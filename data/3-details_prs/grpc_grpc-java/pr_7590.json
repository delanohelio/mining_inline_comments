{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1MTQzMzU5", "number": 7590, "title": "xds: add File-watcher certificate provider", "bodyText": "", "createdAt": "2020-11-04T05:30:27Z", "url": "https://github.com/grpc/grpc-java/pull/7590", "merged": true, "mergeCommit": {"oid": "cffc07f5d88dbe149ff3e3da60cae94d0f2558fa"}, "closed": true, "closedAt": "2020-11-09T17:52:43Z", "author": {"login": "sanjaypujare"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZG6IYAH2gAyNTE1MTQzMzU5OmQ1NDFhZjBmM2M3YzA3OGE0YjUxYTJmNmVhNGFiZDEzNDQ2OWU4OGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABda4fmeAFqTUyNjUwNDE1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d541af0f3c7c078a4b51a2f6ea4abd134469e88f", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/d541af0f3c7c078a4b51a2f6ea4abd134469e88f", "committedDate": "2020-11-04T05:28:16Z", "message": "xds: add File-watcher certificate provider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85c9667bf6368f299c1c241895b9b3126b53d447", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/85c9667bf6368f299c1c241895b9b3126b53d447", "committedDate": "2020-11-05T17:40:52Z", "message": "changes dashes to underscores to conform to styleguide"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/e093fb1e7667d41f57dbe6614e6b1454b153581b", "committedDate": "2020-11-05T18:15:38Z", "message": "changes dashes to underscores to conform to styleguide-2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NjE3NjQ3", "url": "https://github.com/grpc/grpc-java/pull/7590#pullrequestreview-524617647", "createdAt": "2020-11-05T19:55:07Z", "commit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTo1NTowN1rOHuUJ3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDoxMToyMVrOHuUstA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMyNjc1MA==", "bodyText": "DynamicReloadingCertificateProvider is passing a directory, why this one is not?", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518326750", "createdAt": "2020-11-05T19:55:07Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileTime;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for file watching cert provider. */\n+final class FileWatcherCertificateProvider extends CertificateProvider {\n+  private static final Logger logger =\n+      Logger.getLogger(FileWatcherCertificateProvider.class.getName());\n+\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final TimeProvider timeProvider;\n+  private final Path certFile;\n+  private final Path keyFile;\n+  private final Path trustFile;\n+  private final long refreshIntervalInSeconds;\n+  @VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle;\n+  private FileTime lastModifiedTimeCert;\n+  private FileTime lastModifiedTimeKey;\n+  private FileTime lastModifiedTimeRoot;\n+\n+  FileWatcherCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String certFile,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzMTYwNg==", "bodyText": "I wonder if we can have an intermediate class AbstractCertProvider that provides createSynchronizationContext() and generateErrorIfCurrentCertExpired() etc.", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518331606", "createdAt": "2020-11-05T20:03:58Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileTime;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for file watching cert provider. */\n+final class FileWatcherCertificateProvider extends CertificateProvider {\n+  private static final Logger logger =\n+      Logger.getLogger(FileWatcherCertificateProvider.class.getName());\n+\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final TimeProvider timeProvider;\n+  private final Path certFile;\n+  private final Path keyFile;\n+  private final Path trustFile;\n+  private final long refreshIntervalInSeconds;\n+  @VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle;\n+  private FileTime lastModifiedTimeCert;\n+  private FileTime lastModifiedTimeKey;\n+  private FileTime lastModifiedTimeRoot;\n+\n+  FileWatcherCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String certFile,\n+      String keyFile,\n+      String trustFile,\n+      long refreshIntervalInSeconds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider) {\n+    super(watcher, notifyCertUpdates);\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.certFile = Paths.get(checkNotNull(certFile, \"certFile\"));\n+    this.keyFile = Paths.get(checkNotNull(keyFile, \"keyFile\"));\n+    this.trustFile = Paths.get(checkNotNull(trustFile, \"trustFile\"));\n+    this.refreshIntervalInSeconds = refreshIntervalInSeconds;\n+    this.syncContext = createSynchronizationContext(certFile);\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzNTY2OA==", "bodyText": "I'm not wild about calling an essentially private attribute in tests. This does not look like a real usecase. Why calling cancel() followed by checkAndReloadCertificates()?", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518335668", "createdAt": "2020-11-05T20:11:21Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.scheduledHandle.cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "originalPosition": 144}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de5063efe524f6f7079ef220f7e6914b22ef5cc9", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/de5063efe524f6f7079ef220f7e6914b22ef5cc9", "committedDate": "2020-11-05T21:23:51Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60af22e1b1d105c8a733aaeb23c5dd03c165d8bd", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/60af22e1b1d105c8a733aaeb23c5dd03c165d8bd", "committedDate": "2020-11-06T01:29:29Z", "message": "use Duration parsing for parsing duration with suffix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1NTM0Mjc5", "url": "https://github.com/grpc/grpc-java/pull/7590#pullrequestreview-525534279", "createdAt": "2020-11-06T22:29:38Z", "commit": {"oid": "60af22e1b1d105c8a733aaeb23c5dd03c165d8bd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjoyOTozOFrOHu_gkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjoyOTozOFrOHu_gkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNzA3Mw==", "bodyText": "The test might take a little too long, 5s. Is it possible to make use of FakeClock for scheduler like other tests are doing?", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r519037073", "createdAt": "2020-11-06T22:29:38Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherErrorUpdates(null, null, 0, 0, (String[]) null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(null, null, SERVER_1_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(null, SERVER_1_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(SERVER_0_PEM_FILE, SERVER_0_KEY_FILE, null, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(SERVER_0_PEM_FILE, null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60af22e1b1d105c8a733aaeb23c5dd03c165d8bd"}, "originalPosition": 172}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0018d090cb0bfd5101bb49d33ed7b5d9ad0167b5", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/0018d090cb0bfd5101bb49d33ed7b5d9ad0167b5", "committedDate": "2020-11-09T01:41:53Z", "message": "address review comments-2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NTA0MTU0", "url": "https://github.com/grpc/grpc-java/pull/7590#pullrequestreview-526504154", "createdAt": "2020-11-09T17:48:28Z", "commit": {"oid": "0018d090cb0bfd5101bb49d33ed7b5d9ad0167b5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3970, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}