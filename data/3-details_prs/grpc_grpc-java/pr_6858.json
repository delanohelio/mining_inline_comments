{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNzg2NjQw", "number": 6858, "title": "xds: implement LRS LB policy", "bodyText": "", "createdAt": "2020-03-25T19:33:58Z", "url": "https://github.com/grpc/grpc-java/pull/6858", "merged": true, "mergeCommit": {"oid": "d88f0f19ec128fb4ee3550f221949aee3fc9cbd9"}, "closed": true, "closedAt": "2020-04-07T18:44:37Z", "author": {"login": "voidzcy"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRMttdgH2gAyMzkzNzg2NjQwOjY0YTcyNWFhYjg0MTk3NTRlNzQzMDNiYTZkNWQ1ODI3NzBmODlkODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVElV7AFqTM4ODU4NTYyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "64a725aab8419754e74303ba6d5d582770f89d81", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/64a725aab8419754e74303ba6d5d582770f89d81", "committedDate": "2020-03-25T19:31:35Z", "message": "Add attributes for passing LoadStatsStore to LB policy tree."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75e501fa0a8d430a26e4fcfb6283a7c42fcda663", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/75e501fa0a8d430a26e4fcfb6283a7c42fcda663", "committedDate": "2020-03-25T19:32:49Z", "message": "Implement LRS config parser."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cccbba912134e21251af9e065ac0e95f056b44a0", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/cccbba912134e21251af9e065ac0e95f056b44a0", "committedDate": "2020-03-25T19:33:01Z", "message": "Implement LRS Lb policy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a7023a9f265ac5bcf5b2508b16034969c9abaf2a", "committedDate": "2020-03-25T20:13:40Z", "message": "Rename subzone to subZone."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MzE2OTY3", "url": "https://github.com/grpc/grpc-java/pull/6858#pullrequestreview-384316967", "createdAt": "2020-03-31T00:07:31Z", "commit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDowNzozMVrOF-AqlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDozOTozMlrOF-BOYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjkzMw==", "bodyText": "Why android? No android module should depend on grpc-xds.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400566933", "createdAt": "2020-03-31T00:07:31Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3MDIzMg==", "bodyText": "Since LrsLoadBalancerProvider is completely internal, and the config is NOT coming from any resolver, so LrsConfig is totally internal and constructed directly, there is no code path to parse a rawConfig to LrsConfig.  This parser is dead code. Simply throw UnsupportedOperationException would be sufficient.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400570232", "createdAt": "2020-03-31T00:18:37Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provider for lrs load balancing policy.\n+ */\n+@Internal\n+public class LrsLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  private static final String LRS_POLICY_NAME = \"lrs_experimental\";\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(LoadBalancer.Helper helper) {\n+    return new LrsLoadBalancer(helper);\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return LRS_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NTI2MA==", "bodyText": "Do you want to check if store is null?", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400575260", "createdAt": "2020-03-31T00:36:35Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Objects;\n+\n+/**\n+ * Load balancer for lrs policy.\n+ */\n+final class LrsLoadBalancer extends LoadBalancer {\n+  private final LoadBalancer.Helper helper;\n+  private GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private LoadStatsStore loadStatsStore;\n+  private String clusterName;\n+  private String edsServiceName;\n+  private Locality locality;\n+  private String childPolicyName;\n+\n+  LrsLoadBalancer(LoadBalancer.Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    LrsConfig config = (LrsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    LoadStatsStore store =\n+        resolvedAddresses.getAttributes().get(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE);\n+    checkAndSetUp(config, store);\n+\n+    if (switchingLoadBalancer == null) {\n+      loadStatsStore.addLocality(config.locality);\n+      final ClientLoadCounter counter = loadStatsStore.getLocalityCounter(config.locality);\n+      LoadBalancer.Helper loadRecordingHelper = new ForwardingLoadBalancerHelper() {\n+        @Override\n+        protected Helper delegate() {\n+          return helper;\n+        }\n+\n+        @Override\n+        public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+          @SuppressLint(\"VisibleForTests\")\n+          SubchannelPicker loadRecordingPicker =\n+              new LoadRecordingSubchannelPicker(counter, newPicker);\n+          super.updateBalancingState(newState, loadRecordingPicker);\n+        }\n+      };\n+      switchingLoadBalancer = new GracefulSwitchLoadBalancer(loadRecordingHelper);\n+    }\n+    String updatedChildPolicyName = config.childPolicy.getProvider().getPolicyName();\n+    if (!Objects.equals(childPolicyName, updatedChildPolicyName)) {\n+      switchingLoadBalancer.switchTo(config.childPolicy.getProvider());\n+      childPolicyName = updatedChildPolicyName;\n+    }\n+    ResolvedAddresses downStreamResult =\n+        resolvedAddresses.toBuilder()\n+            .setLoadBalancingPolicyConfig(config.childPolicy.getConfig())\n+            .build();\n+    switchingLoadBalancer.handleResolvedAddresses(downStreamResult);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    if (switchingLoadBalancer != null) {\n+      switchingLoadBalancer.handleNameResolutionError(error);\n+    } else {\n+      helper.updateBalancingState(ConnectivityState.TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    if (switchingLoadBalancer != null) {\n+      loadStatsStore.removeLocality(locality);\n+      switchingLoadBalancer.shutdown();\n+    }\n+  }\n+\n+  private void checkAndSetUp(LrsConfig config, LoadStatsStore store) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NjA5OA==", "bodyText": "@Nullable", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400576098", "createdAt": "2020-03-31T00:39:32Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Objects;\n+\n+/**\n+ * Load balancer for lrs policy.\n+ */\n+final class LrsLoadBalancer extends LoadBalancer {\n+  private final LoadBalancer.Helper helper;\n+  private GracefulSwitchLoadBalancer switchingLoadBalancer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff89d73c61cd46f0ae84f7c126e7247adeba93e3", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ff89d73c61cd46f0ae84f7c126e7247adeba93e3", "committedDate": "2020-03-31T01:06:06Z", "message": "Remove wrong annotation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b4c117f42da685e76bf640f525d4213a63f24f2", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/9b4c117f42da685e76bf640f525d4213a63f24f2", "committedDate": "2020-03-31T01:06:46Z", "message": "Deleted code for parsing raw LrsConfig."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e89a0e6db138e55a2ff5494bf104db448a5f2e12", "committedDate": "2020-04-01T19:04:28Z", "message": "Enhance null checks."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1OTYwNjgz", "url": "https://github.com/grpc/grpc-java/pull/6858#pullrequestreview-385960683", "createdAt": "2020-04-01T21:25:36Z", "commit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToyNTozNlrOF_TMqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjowODoyN1rOF_UZpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxOTE0NQ==", "bodyText": "nit: final", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401919145", "createdAt": "2020-04-01T21:25:36Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provider for lrs load balancing policy.\n+ */\n+@Internal\n+public class LrsLoadBalancerProvider extends LoadBalancerProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxOTQ0Mg==", "bodyText": "nit: final", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401919442", "createdAt": "2020-04-01T21:26:07Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provider for lrs load balancing policy.\n+ */\n+@Internal\n+public class LrsLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  private static final String LRS_POLICY_NAME = \"lrs_experimental\";\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(LoadBalancer.Helper helper) {\n+    return new LrsLoadBalancer(helper);\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return LRS_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  static class LrsConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzMzIyNw==", "bodyText": "Also assert all childBalancers are shutdown. You might use peekLast() not removing them in the tests.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401933227", "createdAt": "2020-04-01T21:55:01Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNjM0NA==", "bodyText": "You can use TestUtils.StandardLoadBalancerProvider after pulling master.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401936344", "createdAt": "2020-04-01T22:02:20Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNzQ0NQ==", "bodyText": "This is just testing test implementation. The subchannel of the picker and the action of calling childHelper.updateBalancingState() should be considered as test input instead of test implementation.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401937445", "createdAt": "2020-04-01T22:04:47Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      final Subchannel subchannel = new NoopSubchannel(resolvedAddresses.getAddresses());\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          return PickResult.withSubchannel(subchannel);\n+        }\n+      };\n+      helper.updateBalancingState(ConnectivityState.READY, picker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzODg1Mw==", "bodyText": "This line is just testing test implementation and nothing else is tested. Use mock subchannel with childHelper.updateBalancingState() as test input, and verify result.getSubchannel() is expected.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401938853", "createdAt": "2020-04-01T22:08:27Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94eb6f44e9f9f89167f58b551e7e52a9cff7fec6", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/94eb6f44e9f9f89167f58b551e7e52a9cff7fec6", "committedDate": "2020-04-02T18:28:39Z", "message": "Delete redundant verifications."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d08271331e1b24a8ea0c9962d61c4e3fb25218e", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/4d08271331e1b24a8ea0c9962d61c4e3fb25218e", "committedDate": "2020-04-02T18:39:40Z", "message": "Just use mock for Subchannel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4eab7c75cb739486cc36b8469e63ee5d52dcd9c6", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/4eab7c75cb739486cc36b8469e63ee5d52dcd9c6", "committedDate": "2020-04-02T18:39:45Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/add_lrs_lb_policy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab8f1b7133679ee455df503c13b976b70a46d117", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ab8f1b7133679ee455df503c13b976b70a46d117", "committedDate": "2020-04-02T18:48:17Z", "message": "Add missing final modifier."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c87cedb8040c2d971f8ea6fa120077d394e7af4", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3c87cedb8040c2d971f8ea6fa120077d394e7af4", "committedDate": "2020-04-06T19:03:14Z", "message": "Improve test, separate delivering subchannel state."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6db4a90225aff55bc737da47f0a0332bd70fa5ba", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/6db4a90225aff55bc737da47f0a0332bd70fa5ba", "committedDate": "2020-04-06T19:02:32Z", "message": "Improve test, separate delivering subchannel state."}, "afterCommit": {"oid": "3c87cedb8040c2d971f8ea6fa120077d394e7af4", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3c87cedb8040c2d971f8ea6fa120077d394e7af4", "committedDate": "2020-04-06T19:03:14Z", "message": "Improve test, separate delivering subchannel state."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NTg1NjI4", "url": "https://github.com/grpc/grpc-java/pull/6858#pullrequestreview-388585628", "createdAt": "2020-04-06T20:18:50Z", "commit": {"oid": "3c87cedb8040c2d971f8ea6fa120077d394e7af4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDoxODo1MFrOGBoUOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDoxODo1MFrOGBoUOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2MjI5Nw==", "bodyText": "This and NoopSubchannel  seem to be a lot implementation. We don't really care the original resolved EADs (in general there's no relation between original EAG and subchannel, the EGAs could even be empty), and the subchannel can totally be mocked as long as we know childBalancer.helper. But this is fine.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r404362297", "createdAt": "2020-04-06T20:18:50Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    NoopSubchannel subchannel = childBalancer.subchannels.values().iterator().next();\n+    deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    // Error after child policy is created.\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private static void deliverSubchannelState(\n+      final NoopSubchannel subchannel, ConnectivityState state) {\n+    SubchannelPicker picker = new SubchannelPicker() {\n+      @Override\n+      public PickResult pickSubchannel(PickSubchannelArgs args) {\n+        return PickResult.withSubchannel(subchannel);\n+      }\n+    };\n+    subchannel.helper.updateBalancingState(state, picker);\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+    private final Map<EquivalentAddressGroup, NoopSubchannel> subchannels = new HashMap<>();\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      List<EquivalentAddressGroup> addresses = resolvedAddresses.getAddresses();\n+      for (EquivalentAddressGroup eag : addresses) {\n+        subchannels.put(eag, new NoopSubchannel(helper));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c87cedb8040c2d971f8ea6fa120077d394e7af4"}, "originalPosition": 234}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4486, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}