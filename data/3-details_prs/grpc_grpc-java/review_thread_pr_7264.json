{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NjE5MDc3", "number": 7264, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo0NDo1MVrOEVJL8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMDoxNjo0MlrOEVJzQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjA2MDY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo0NDo1MVrOG7u_mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjoyNjo1N1rOG7zomg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4OTExNA==", "bodyText": "This is quite a bit directly in the constructor. Could this all be moved into a function so that it'd become:\nthis.initialDeadlineMonitor = scheduleDeadlineIfNeeded(scheduler, deadline, context);", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465289114", "createdAt": "2020-08-04T19:44:51Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTE0Ng==", "bodyText": "Done. Not passing context as an argument because scheduleDeadlineIfNeeded can not be static method anyway.", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465365146", "createdAt": "2020-08-04T22:26:57Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4OTExNA=="}, "originalCommit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjE2MTI5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMDoxNjo0MlrOG7v-aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjoyNzoxOVrOG7zpEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNTE5Mg==", "bodyText": "It's unclear to me how much this does. What would happen if we didn't have this check?\nI feel like we either don't need this check, or we need to pass a boolean to cancel(Status) saying not to cancel if realCall is set, in a non-racy way.", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465305192", "createdAt": "2020-08-04T20:16:42Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();\n+    if (deadline == null && contextDeadline == null) {\n+      this.initialDeadlineMonitor = null;\n+      return;\n+    }\n+    long remainingNanos = Long.MAX_VALUE;\n+    if (deadline != null) {\n+      remainingNanos = Math.min(remainingNanos, deadline.timeRemaining(NANOSECONDS));\n+    }\n+    if (contextDeadline != null && contextDeadline.timeRemaining(NANOSECONDS) < remainingNanos) {\n+      remainingNanos = contextDeadline.timeRemaining(NANOSECONDS);\n+      if (logger.isLoggable(Level.FINE)) {\n+        StringBuilder builder =\n+            new StringBuilder(\n+                String.format(\n+                    \"Call timeout set to '%d' ns, due to context deadline.\", remainingNanos));\n+        if (deadline == null) {\n+          builder.append(\" Explicit call timeout was not set.\");\n+        } else {\n+          long callTimeout = deadline.timeRemaining(TimeUnit.NANOSECONDS);\n+          builder.append(String.format(\" Explicit call timeout was '%d' ns.\", callTimeout));\n+        }\n+        logger.fine(builder.toString());\n+      }\n+    }\n+    long seconds = Math.abs(remainingNanos) / TimeUnit.SECONDS.toNanos(1);\n+    long nanos = Math.abs(remainingNanos) % TimeUnit.SECONDS.toNanos(1);\n+    final StringBuilder buf = new StringBuilder();\n+    if (remainingNanos < 0) {\n+      buf.append(\"ClientCall started after deadline exceeded. Deadline exceeded after -\");\n+    } else {\n+      buf.append(\"Deadline exceeded after \");\n+    }\n+    buf.append(seconds);\n+    buf.append(String.format(\".%09d\", nanos));\n+    buf.append(\"s. \");\n+    /** Cancels the call if deadline exceeded prior to the real call being set. */\n+    class DeadlineExceededRunnable implements Runnable {\n+      @Override\n+      public void run() {\n+        synchronized (DelayedClientCall.this) {\n+          if (realCall != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMTcxOQ==", "bodyText": "The interop test (AbstractInteropTest.deadlineInPast()) was very flaky without it. So I guessed it was due to racy cancellation. Adding it just fixed the flakiness. Let me check if this is the right fix...", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465311719", "createdAt": "2020-08-04T20:29:40Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();\n+    if (deadline == null && contextDeadline == null) {\n+      this.initialDeadlineMonitor = null;\n+      return;\n+    }\n+    long remainingNanos = Long.MAX_VALUE;\n+    if (deadline != null) {\n+      remainingNanos = Math.min(remainingNanos, deadline.timeRemaining(NANOSECONDS));\n+    }\n+    if (contextDeadline != null && contextDeadline.timeRemaining(NANOSECONDS) < remainingNanos) {\n+      remainingNanos = contextDeadline.timeRemaining(NANOSECONDS);\n+      if (logger.isLoggable(Level.FINE)) {\n+        StringBuilder builder =\n+            new StringBuilder(\n+                String.format(\n+                    \"Call timeout set to '%d' ns, due to context deadline.\", remainingNanos));\n+        if (deadline == null) {\n+          builder.append(\" Explicit call timeout was not set.\");\n+        } else {\n+          long callTimeout = deadline.timeRemaining(TimeUnit.NANOSECONDS);\n+          builder.append(String.format(\" Explicit call timeout was '%d' ns.\", callTimeout));\n+        }\n+        logger.fine(builder.toString());\n+      }\n+    }\n+    long seconds = Math.abs(remainingNanos) / TimeUnit.SECONDS.toNanos(1);\n+    long nanos = Math.abs(remainingNanos) % TimeUnit.SECONDS.toNanos(1);\n+    final StringBuilder buf = new StringBuilder();\n+    if (remainingNanos < 0) {\n+      buf.append(\"ClientCall started after deadline exceeded. Deadline exceeded after -\");\n+    } else {\n+      buf.append(\"Deadline exceeded after \");\n+    }\n+    buf.append(seconds);\n+    buf.append(String.format(\".%09d\", nanos));\n+    buf.append(\"s. \");\n+    /** Cancels the call if deadline exceeded prior to the real call being set. */\n+    class DeadlineExceededRunnable implements Runnable {\n+      @Override\n+      public void run() {\n+        synchronized (DelayedClientCall.this) {\n+          if (realCall != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNTE5Mg=="}, "originalCommit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1MTI1NQ==", "bodyText": "Discussed \"offline.\" This is legitimate because ClientCall.cancel() is non-thread-safe and will cause exceptions if you try to send after it. That is different from in the stream where cancel() is thread-safe and wouldn't trigger any checkState()s. But as-is it isn't atomic; we need to move the realCall != null check into the private cancel() function to make it atomic.", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465351255", "createdAt": "2020-08-04T21:52:34Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();\n+    if (deadline == null && contextDeadline == null) {\n+      this.initialDeadlineMonitor = null;\n+      return;\n+    }\n+    long remainingNanos = Long.MAX_VALUE;\n+    if (deadline != null) {\n+      remainingNanos = Math.min(remainingNanos, deadline.timeRemaining(NANOSECONDS));\n+    }\n+    if (contextDeadline != null && contextDeadline.timeRemaining(NANOSECONDS) < remainingNanos) {\n+      remainingNanos = contextDeadline.timeRemaining(NANOSECONDS);\n+      if (logger.isLoggable(Level.FINE)) {\n+        StringBuilder builder =\n+            new StringBuilder(\n+                String.format(\n+                    \"Call timeout set to '%d' ns, due to context deadline.\", remainingNanos));\n+        if (deadline == null) {\n+          builder.append(\" Explicit call timeout was not set.\");\n+        } else {\n+          long callTimeout = deadline.timeRemaining(TimeUnit.NANOSECONDS);\n+          builder.append(String.format(\" Explicit call timeout was '%d' ns.\", callTimeout));\n+        }\n+        logger.fine(builder.toString());\n+      }\n+    }\n+    long seconds = Math.abs(remainingNanos) / TimeUnit.SECONDS.toNanos(1);\n+    long nanos = Math.abs(remainingNanos) % TimeUnit.SECONDS.toNanos(1);\n+    final StringBuilder buf = new StringBuilder();\n+    if (remainingNanos < 0) {\n+      buf.append(\"ClientCall started after deadline exceeded. Deadline exceeded after -\");\n+    } else {\n+      buf.append(\"Deadline exceeded after \");\n+    }\n+    buf.append(seconds);\n+    buf.append(String.format(\".%09d\", nanos));\n+    buf.append(\"s. \");\n+    /** Cancels the call if deadline exceeded prior to the real call being set. */\n+    class DeadlineExceededRunnable implements Runnable {\n+      @Override\n+      public void run() {\n+        synchronized (DelayedClientCall.this) {\n+          if (realCall != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNTE5Mg=="}, "originalCommit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTI2NQ==", "bodyText": "Done.", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465365265", "createdAt": "2020-08-04T22:27:19Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();\n+    if (deadline == null && contextDeadline == null) {\n+      this.initialDeadlineMonitor = null;\n+      return;\n+    }\n+    long remainingNanos = Long.MAX_VALUE;\n+    if (deadline != null) {\n+      remainingNanos = Math.min(remainingNanos, deadline.timeRemaining(NANOSECONDS));\n+    }\n+    if (contextDeadline != null && contextDeadline.timeRemaining(NANOSECONDS) < remainingNanos) {\n+      remainingNanos = contextDeadline.timeRemaining(NANOSECONDS);\n+      if (logger.isLoggable(Level.FINE)) {\n+        StringBuilder builder =\n+            new StringBuilder(\n+                String.format(\n+                    \"Call timeout set to '%d' ns, due to context deadline.\", remainingNanos));\n+        if (deadline == null) {\n+          builder.append(\" Explicit call timeout was not set.\");\n+        } else {\n+          long callTimeout = deadline.timeRemaining(TimeUnit.NANOSECONDS);\n+          builder.append(String.format(\" Explicit call timeout was '%d' ns.\", callTimeout));\n+        }\n+        logger.fine(builder.toString());\n+      }\n+    }\n+    long seconds = Math.abs(remainingNanos) / TimeUnit.SECONDS.toNanos(1);\n+    long nanos = Math.abs(remainingNanos) % TimeUnit.SECONDS.toNanos(1);\n+    final StringBuilder buf = new StringBuilder();\n+    if (remainingNanos < 0) {\n+      buf.append(\"ClientCall started after deadline exceeded. Deadline exceeded after -\");\n+    } else {\n+      buf.append(\"Deadline exceeded after \");\n+    }\n+    buf.append(seconds);\n+    buf.append(String.format(\".%09d\", nanos));\n+    buf.append(\"s. \");\n+    /** Cancels the call if deadline exceeded prior to the real call being set. */\n+    class DeadlineExceededRunnable implements Runnable {\n+      @Override\n+      public void run() {\n+        synchronized (DelayedClientCall.this) {\n+          if (realCall != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNTE5Mg=="}, "originalCommit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2421, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}