{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwNjg1NjAy", "number": 6589, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMDoyNzo0OFrODWtXtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQyMzoyNzowMVrODXA2zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTM4NjEzOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/sds/trust/SdsX509TrustManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMDoyNzo0OVrOFbn6PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMDoyNzo0OVrOFbn6PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUwOTc1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  SSLSocket sslSocket = (SSLSocket)socket;\n          \n          \n            \n                  SSLSocket sslSocket = (SSLSocket) socket;", "url": "https://github.com/grpc/grpc-java/pull/6589#discussion_r364509757", "createdAt": "2020-01-09T00:27:49Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/sds/trust/SdsX509TrustManager.java", "diffHunk": "@@ -256,13 +258,26 @@ public void checkClientTrusted(X509Certificate[] chain, String authType)\n   @Override\n   public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket)\n       throws CertificateException {\n+    if (socket instanceof SSLSocket) {\n+      SSLSocket sslSocket = (SSLSocket)socket;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15f717cea47a257dfe1338d7e07965b8978f0532"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTM5NDI0OnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMDozMzoxNlrOFbn_UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMDo0OToyMVrOFboODQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMTA1Nw==", "bodyText": "same for this.", "url": "https://github.com/grpc/grpc-java/pull/6589#discussion_r364511057", "createdAt": "2020-01-09T00:33:16Z", "author": {"login": "creamsoup"}, "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "diffHunk": "@@ -221,14 +244,346 @@ public void oneIpAddressInPeerCertsMismatch() throws CertificateException, IOExc\n             .addVerifySubjectAltName(\"x.foo.com\")\n             .addVerifySubjectAltName(\"192.168.2.3\")\n             .build();\n-    SdsX509TrustManager trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n+    trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n     X509Certificate[] certs =\n         CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n     try {\n       trustManager.verifySubjectAltNameInChain(certs);\n-      Assert.fail(\"no exception thrown\");\n+      fail(\"no exception thrown\");\n     } catch (CertificateException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"Peer certificate SAN check failed\");\n     }\n   }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslEngine);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslEngine);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslSocket);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslSocket);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  private SSLEngine buildTrustManagerAndGetSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLParameters sslParams = buildTrustManagerAndGetSslParameters();\n+    SSLEngine sslEngine =  new SSLEngine() {\n+      @Override\n+      public SSLEngineResult wrap(ByteBuffer[] byteBuffers, int i, int i1, ByteBuffer byteBuffer)\n+          throws SSLException {\n+        return null;\n+      }\n+\n+      @Override\n+      public SSLEngineResult unwrap(ByteBuffer byteBuffer, ByteBuffer[] byteBuffers, int i, int i1)\n+          throws SSLException {\n+        return null;\n+      }\n+\n+      @Override\n+      public Runnable getDelegatedTask() {\n+        return null;\n+      }\n+\n+      @Override\n+      public void closeInbound() throws SSLException {\n+\n+      }\n+\n+      @Override\n+      public boolean isInboundDone() {\n+        return false;\n+      }\n+\n+      @Override\n+      public void closeOutbound() {\n+\n+      }\n+\n+      @Override\n+      public boolean isOutboundDone() {\n+        return false;\n+      }\n+\n+      @Override\n+      public String[] getSupportedCipherSuites() {\n+        return new String[0];\n+      }\n+\n+      @Override\n+      public String[] getEnabledCipherSuites() {\n+        return new String[0];\n+      }\n+\n+      @Override\n+      public void setEnabledCipherSuites(String[] strings) {\n+\n+      }\n+\n+      @Override\n+      public String[] getSupportedProtocols() {\n+        return new String[0];\n+      }\n+\n+      @Override\n+      public String[] getEnabledProtocols() {\n+        return new String[0];\n+      }\n+\n+      @Override\n+      public void setEnabledProtocols(String[] strings) {\n+\n+      }\n+\n+      @Override\n+      public SSLSession getSession() {\n+        return mockSession;\n+      }\n+\n+      @Override\n+      public void beginHandshake() throws SSLException {\n+\n+      }\n+\n+      @Override\n+      public HandshakeStatus getHandshakeStatus() {\n+        return null;\n+      }\n+\n+      @Override\n+      public void setUseClientMode(boolean b) {\n+\n+      }\n+\n+      @Override\n+      public boolean getUseClientMode() {\n+        return false;\n+      }\n+\n+      @Override\n+      public void setNeedClientAuth(boolean b) {\n+\n+      }\n+\n+      @Override\n+      public boolean getNeedClientAuth() {\n+        return false;\n+      }\n+\n+      @Override\n+      public void setWantClientAuth(boolean b) {\n+\n+      }\n+\n+      @Override\n+      public boolean getWantClientAuth() {\n+        return false;\n+      }\n+\n+      @Override\n+      public void setEnableSessionCreation(boolean b) {\n+\n+      }\n+\n+      @Override\n+      public boolean getEnableSessionCreation() {\n+        return false;\n+      }\n+\n+      @Override\n+      public SSLSession getHandshakeSession() {\n+        return mockSession;\n+      }\n+\n+      @Override\n+      public SSLParameters getSSLParameters() {\n+        return sslParameters;\n+      }\n+\n+      @Override\n+      public void setSSLParameters(SSLParameters sslParameters) {\n+        this.sslParameters = sslParameters;\n+      }\n+\n+      private SSLParameters sslParameters;\n+    };\n+    sslEngine.setSSLParameters(sslParams);\n+    return sslEngine;\n+  }\n+\n+  private SSLSocket buildTrustManagerAndGetSslSocket()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLParameters sslParams = buildTrustManagerAndGetSslParameters();\n+\n+    SSLSocket sslSocket = new SSLSocket() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15f717cea47a257dfe1338d7e07965b8978f0532"}, "originalPosition": 411}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxNDgyOQ==", "bodyText": "Mocks won't work here (AFAIK) as stated before.", "url": "https://github.com/grpc/grpc-java/pull/6589#discussion_r364514829", "createdAt": "2020-01-09T00:49:21Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "diffHunk": "@@ -221,14 +244,346 @@ public void oneIpAddressInPeerCertsMismatch() throws CertificateException, IOExc\n             .addVerifySubjectAltName(\"x.foo.com\")\n             .addVerifySubjectAltName(\"192.168.2.3\")\n             .build();\n-    SdsX509TrustManager trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n+    trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n     X509Certificate[] certs =\n         CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n     try {\n       trustManager.verifySubjectAltNameInChain(certs);\n-      Assert.fail(\"no exception thrown\");\n+      fail(\"no exception thrown\");\n     } catch (CertificateException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"Peer certificate SAN check failed\");\n     }\n   }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslEngine);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslEngine);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslSocket);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslSocket);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  private SSLEngine buildTrustManagerAndGetSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLParameters sslParams = buildTrustManagerAndGetSslParameters();\n+    SSLEngine sslEngine =  new SSLEngine() {\n+      @Override\n+      public SSLEngineResult wrap(ByteBuffer[] byteBuffers, int i, int i1, ByteBuffer byteBuffer)\n+          throws SSLException {\n+        return null;\n+      }\n+\n+      @Override\n+      public SSLEngineResult unwrap(ByteBuffer byteBuffer, ByteBuffer[] byteBuffers, int i, int i1)\n+          throws SSLException {\n+        return null;\n+      }\n+\n+      @Override\n+      public Runnable getDelegatedTask() {\n+        return null;\n+      }\n+\n+      @Override\n+      public void closeInbound() throws SSLException {\n+\n+      }\n+\n+      @Override\n+      public boolean isInboundDone() {\n+        return false;\n+      }\n+\n+      @Override\n+      public void closeOutbound() {\n+\n+      }\n+\n+      @Override\n+      public boolean isOutboundDone() {\n+        return false;\n+      }\n+\n+      @Override\n+      public String[] getSupportedCipherSuites() {\n+        return new String[0];\n+      }\n+\n+      @Override\n+      public String[] getEnabledCipherSuites() {\n+        return new String[0];\n+      }\n+\n+      @Override\n+      public void setEnabledCipherSuites(String[] strings) {\n+\n+      }\n+\n+      @Override\n+      public String[] getSupportedProtocols() {\n+        return new String[0];\n+      }\n+\n+      @Override\n+      public String[] getEnabledProtocols() {\n+        return new String[0];\n+      }\n+\n+      @Override\n+      public void setEnabledProtocols(String[] strings) {\n+\n+      }\n+\n+      @Override\n+      public SSLSession getSession() {\n+        return mockSession;\n+      }\n+\n+      @Override\n+      public void beginHandshake() throws SSLException {\n+\n+      }\n+\n+      @Override\n+      public HandshakeStatus getHandshakeStatus() {\n+        return null;\n+      }\n+\n+      @Override\n+      public void setUseClientMode(boolean b) {\n+\n+      }\n+\n+      @Override\n+      public boolean getUseClientMode() {\n+        return false;\n+      }\n+\n+      @Override\n+      public void setNeedClientAuth(boolean b) {\n+\n+      }\n+\n+      @Override\n+      public boolean getNeedClientAuth() {\n+        return false;\n+      }\n+\n+      @Override\n+      public void setWantClientAuth(boolean b) {\n+\n+      }\n+\n+      @Override\n+      public boolean getWantClientAuth() {\n+        return false;\n+      }\n+\n+      @Override\n+      public void setEnableSessionCreation(boolean b) {\n+\n+      }\n+\n+      @Override\n+      public boolean getEnableSessionCreation() {\n+        return false;\n+      }\n+\n+      @Override\n+      public SSLSession getHandshakeSession() {\n+        return mockSession;\n+      }\n+\n+      @Override\n+      public SSLParameters getSSLParameters() {\n+        return sslParameters;\n+      }\n+\n+      @Override\n+      public void setSSLParameters(SSLParameters sslParameters) {\n+        this.sslParameters = sslParameters;\n+      }\n+\n+      private SSLParameters sslParameters;\n+    };\n+    sslEngine.setSSLParameters(sslParams);\n+    return sslEngine;\n+  }\n+\n+  private SSLSocket buildTrustManagerAndGetSslSocket()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLParameters sslParams = buildTrustManagerAndGetSslParameters();\n+\n+    SSLSocket sslSocket = new SSLSocket() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMTA1Nw=="}, "originalCommit": {"oid": "15f717cea47a257dfe1338d7e07965b8978f0532"}, "originalPosition": 411}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTM5OTEzOnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMDozNjoxOVrOFboCLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQyMDoxODo1MFrOFcCQKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMTc5MA==", "bodyText": "can you use mock to get rid of boiler plate? mock should be avoided, but in this case it seems like a better idea.", "url": "https://github.com/grpc/grpc-java/pull/6589#discussion_r364511790", "createdAt": "2020-01-09T00:36:19Z", "author": {"login": "creamsoup"}, "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "diffHunk": "@@ -221,14 +244,346 @@ public void oneIpAddressInPeerCertsMismatch() throws CertificateException, IOExc\n             .addVerifySubjectAltName(\"x.foo.com\")\n             .addVerifySubjectAltName(\"192.168.2.3\")\n             .build();\n-    SdsX509TrustManager trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n+    trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n     X509Certificate[] certs =\n         CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n     try {\n       trustManager.verifySubjectAltNameInChain(certs);\n-      Assert.fail(\"no exception thrown\");\n+      fail(\"no exception thrown\");\n     } catch (CertificateException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"Peer certificate SAN check failed\");\n     }\n   }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslEngine);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslEngine);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslSocket);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslSocket);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  private SSLEngine buildTrustManagerAndGetSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLParameters sslParams = buildTrustManagerAndGetSslParameters();\n+    SSLEngine sslEngine =  new SSLEngine() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15f717cea47a257dfe1338d7e07965b8978f0532"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxNDUxMQ==", "bodyText": "I would have used a mock if it worked. In the actual (new) code it is setting values in the object:\n    if (sslParams != null) {\n      sslParams.setEndpointIdentificationAlgorithm(null);\n      sslEngine.setSSLParameters(sslParams);\n    }\n\nIf sslEngine and sslParams were mocks, the setters will be no-op and the corresponding getters (called in Java/Sun library code) won't return the correct values. Isn't that right?", "url": "https://github.com/grpc/grpc-java/pull/6589#discussion_r364514511", "createdAt": "2020-01-09T00:47:52Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "diffHunk": "@@ -221,14 +244,346 @@ public void oneIpAddressInPeerCertsMismatch() throws CertificateException, IOExc\n             .addVerifySubjectAltName(\"x.foo.com\")\n             .addVerifySubjectAltName(\"192.168.2.3\")\n             .build();\n-    SdsX509TrustManager trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n+    trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n     X509Certificate[] certs =\n         CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n     try {\n       trustManager.verifySubjectAltNameInChain(certs);\n-      Assert.fail(\"no exception thrown\");\n+      fail(\"no exception thrown\");\n     } catch (CertificateException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"Peer certificate SAN check failed\");\n     }\n   }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslEngine);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslEngine);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslSocket);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslSocket);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  private SSLEngine buildTrustManagerAndGetSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLParameters sslParams = buildTrustManagerAndGetSslParameters();\n+    SSLEngine sslEngine =  new SSLEngine() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMTc5MA=="}, "originalCommit": {"oid": "15f717cea47a257dfe1338d7e07965b8978f0532"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxNTM2MQ==", "bodyText": "i think you can create an abstract class with the set/get implemented and use mock with Mockito.CALLS_REAL_METHODS to achieve exact same behavior as current code.", "url": "https://github.com/grpc/grpc-java/pull/6589#discussion_r364515361", "createdAt": "2020-01-09T00:51:53Z", "author": {"login": "creamsoup"}, "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "diffHunk": "@@ -221,14 +244,346 @@ public void oneIpAddressInPeerCertsMismatch() throws CertificateException, IOExc\n             .addVerifySubjectAltName(\"x.foo.com\")\n             .addVerifySubjectAltName(\"192.168.2.3\")\n             .build();\n-    SdsX509TrustManager trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n+    trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n     X509Certificate[] certs =\n         CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n     try {\n       trustManager.verifySubjectAltNameInChain(certs);\n-      Assert.fail(\"no exception thrown\");\n+      fail(\"no exception thrown\");\n     } catch (CertificateException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"Peer certificate SAN check failed\");\n     }\n   }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslEngine);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslEngine);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslSocket);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslSocket);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  private SSLEngine buildTrustManagerAndGetSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLParameters sslParams = buildTrustManagerAndGetSslParameters();\n+    SSLEngine sslEngine =  new SSLEngine() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMTc5MA=="}, "originalCommit": {"oid": "15f717cea47a257dfe1338d7e07965b8978f0532"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk0MTM1NA==", "bodyText": "good suggestion. done.", "url": "https://github.com/grpc/grpc-java/pull/6589#discussion_r364941354", "createdAt": "2020-01-09T20:18:50Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "diffHunk": "@@ -221,14 +244,346 @@ public void oneIpAddressInPeerCertsMismatch() throws CertificateException, IOExc\n             .addVerifySubjectAltName(\"x.foo.com\")\n             .addVerifySubjectAltName(\"192.168.2.3\")\n             .build();\n-    SdsX509TrustManager trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n+    trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n     X509Certificate[] certs =\n         CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n     try {\n       trustManager.verifySubjectAltNameInChain(certs);\n-      Assert.fail(\"no exception thrown\");\n+      fail(\"no exception thrown\");\n     } catch (CertificateException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"Peer certificate SAN check failed\");\n     }\n   }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslEngine);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslEngine);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslSocket);\n+  }\n+\n+  @Test\n+  public void checkServerTrustedSslSocket_untrustedServer_expectException()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLSocket sslSocket = buildTrustManagerAndGetSslSocket();\n+    X509Certificate[] badServerCert =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(BAD_SERVER_PEM_FILE));\n+    try {\n+      trustManager.checkServerTrusted(badServerCert, \"ECDHE_ECDSA\", sslSocket);\n+      fail(\"exception expected\");\n+    } catch (ValidatorException expected) {\n+      assertThat(expected).hasMessageThat()\n+          .endsWith(\"unable to find valid certification path to requested target\");\n+    }\n+  }\n+\n+  private SSLEngine buildTrustManagerAndGetSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    SSLParameters sslParams = buildTrustManagerAndGetSslParameters();\n+    SSLEngine sslEngine =  new SSLEngine() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMTc5MA=="}, "originalCommit": {"oid": "15f717cea47a257dfe1338d7e07965b8978f0532"}, "originalPosition": 263}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NDU3ODcwOnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQyMzoyNzowMVrOFcGamg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQyMzoyNzowMVrOFcGamg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAwOTU2Mg==", "bodyText": "fyi, times(1) can be omitted unless very good reason to emphasize times(1). i am just pointing out because all verify has it.", "url": "https://github.com/grpc/grpc-java/pull/6589#discussion_r365009562", "createdAt": "2020-01-09T23:27:01Z", "author": {"login": "creamsoup"}, "path": "xds/src/test/java/io/grpc/xds/sds/trust/SdsX509TrustManagerTest.java", "diffHunk": "@@ -221,14 +244,132 @@ public void oneIpAddressInPeerCertsMismatch() throws CertificateException, IOExc\n             .addVerifySubjectAltName(\"x.foo.com\")\n             .addVerifySubjectAltName(\"192.168.2.3\")\n             .build();\n-    SdsX509TrustManager trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n+    trustManager = new SdsX509TrustManager(certContext, mockDelegate);\n     X509Certificate[] certs =\n         CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n     try {\n       trustManager.verifySubjectAltNameInChain(certs);\n-      Assert.fail(\"no exception thrown\");\n+      fail(\"no exception thrown\");\n     } catch (CertificateException expected) {\n       assertThat(expected).hasMessageThat().isEqualTo(\"Peer certificate SAN check failed\");\n     }\n   }\n+\n+  @Test\n+  public void checkServerTrustedSslEngine()\n+      throws CertificateException, IOException, CertStoreException {\n+    TestSslEngine sslEngine = buildTrustManagerAndGetSslEngine();\n+    X509Certificate[] serverCerts =\n+        CertificateUtils.toX509Certificates(TestUtils.loadCert(SERVER_1_PEM_FILE));\n+    trustManager.checkServerTrusted(serverCerts, \"ECDHE_ECDSA\", sslEngine);\n+    verify(sslEngine, times(1)).getHandshakeSession();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88b0d01a94287f2e15ea5e96dd6132e62a8ee7c3"}, "originalPosition": 219}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3044, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}