{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2Njk3MTg4", "number": 6883, "title": "rls: lb policy config object & ChildPolicyReportingHelper", "bodyText": "some of them are public because it needs to be accessed from Lb/LbProvider.", "createdAt": "2020-04-01T00:46:16Z", "url": "https://github.com/grpc/grpc-java/pull/6883", "merged": true, "mergeCommit": {"oid": "23bcdb1a09d1c612edbdc5793097fd22a12419b9"}, "closed": true, "closedAt": "2020-04-21T06:04:18Z", "author": {"login": "creamsoup"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTMzPEAH2gAyMzk2Njk3MTg4OmM0NWM0NmNhYWIwZTY3MWNmZmU1YTRjODUxODVhMGQ5MWU0ZWJjYzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZoZVmAH2gAyMzk2Njk3MTg4OjZmNTJiYzNiNzUxYmQzZGE1M2I4NWRlNzE3MmYwZjA0YmIwZjM3NmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/c45c46caab0e671cffe5a4c85185a0d91e4ebcc7", "committedDate": "2020-04-01T00:45:28Z", "message": "rls: lb policy config object"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMTQyMTYw", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-393142160", "createdAt": "2020-04-14T17:26:13Z", "commit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzoyNjoxM1rOGFZOmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzo0NToxMlrOGFZ8WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwOTQwMQ==", "bodyText": "I don't see its entries are used in this class and I don't see any getter of it. How is this map going to be used?", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r408309401", "createdAt": "2020-04-14T17:26:13Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODAzOA==", "bodyText": "Can helper be final? Is there a case it could change?", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r408318038", "createdAt": "2020-04-14T17:40:17Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String childPolicyConfigTargetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          childPolicyConfigTargetFieldName != null && !childPolicyConfigTargetFieldName.isEmpty(),\n+          \"childPolicyConfigTargetFieldName cannot be empty or null\");\n+      this.childPolicyConfigTargetFieldName = childPolicyConfigTargetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(\n+          effectiveChildPolicy.size() == 1,\n+          \"childPolicy should have exactly one loadbalancing policy\");\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(childPolicyConfigTargetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    void addPendingRequest(RouteLookupRequest request, BackoffPolicy backoffPolicy) {\n+      checkNotNull(request, \"request\");\n+      checkNotNull(backoffPolicy, \"backoffPolicy\");\n+      BackoffPolicy existing = pendingRequests.put(request, backoffPolicy);\n+      checkState(\n+          existing == null,\n+          \"This is a bug, there should be at most one outstanding pending request\");\n+    }\n+\n+    void removePendingRequest(RouteLookupRequest request) {\n+      BackoffPolicy policy = pendingRequests.remove(request);\n+      checkState(policy != null, \"This is a bug, untracked pending request found\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(childPolicyConfigTargetFieldName, that.childPolicyConfigTargetFieldName)\n+          && Objects.equals(pendingRequests, that.pendingRequests);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return\n+          Objects\n+              .hash(\n+                  effectiveRawChildPolicy,\n+                  effectiveLbProvider,\n+                  childPolicyConfigTargetFieldName,\n+                  pendingRequests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", childPolicyConfigTargetFieldName)\n+          .add(\"pendingRequests\", pendingRequests)\n+          .toString();\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper implements Closeable {\n+\n+    @VisibleForTesting\n+    static final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final String target;\n+    @Nullable\n+    private ChildLoadBalancingPolicy childPolicy;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+    private Helper helper;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyMTExMg==", "bodyText": "Can this be final? Is there a case it could change?", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r408321112", "createdAt": "2020-04-14T17:45:12Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String childPolicyConfigTargetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          childPolicyConfigTargetFieldName != null && !childPolicyConfigTargetFieldName.isEmpty(),\n+          \"childPolicyConfigTargetFieldName cannot be empty or null\");\n+      this.childPolicyConfigTargetFieldName = childPolicyConfigTargetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(\n+          effectiveChildPolicy.size() == 1,\n+          \"childPolicy should have exactly one loadbalancing policy\");\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(childPolicyConfigTargetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    void addPendingRequest(RouteLookupRequest request, BackoffPolicy backoffPolicy) {\n+      checkNotNull(request, \"request\");\n+      checkNotNull(backoffPolicy, \"backoffPolicy\");\n+      BackoffPolicy existing = pendingRequests.put(request, backoffPolicy);\n+      checkState(\n+          existing == null,\n+          \"This is a bug, there should be at most one outstanding pending request\");\n+    }\n+\n+    void removePendingRequest(RouteLookupRequest request) {\n+      BackoffPolicy policy = pendingRequests.remove(request);\n+      checkState(policy != null, \"This is a bug, untracked pending request found\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(childPolicyConfigTargetFieldName, that.childPolicyConfigTargetFieldName)\n+          && Objects.equals(pendingRequests, that.pendingRequests);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return\n+          Objects\n+              .hash(\n+                  effectiveRawChildPolicy,\n+                  effectiveLbProvider,\n+                  childPolicyConfigTargetFieldName,\n+                  pendingRequests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", childPolicyConfigTargetFieldName)\n+          .add(\"pendingRequests\", pendingRequests)\n+          .toString();\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper implements Closeable {\n+\n+    @VisibleForTesting\n+    static final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final String target;\n+    @Nullable\n+    private ChildLoadBalancingPolicy childPolicy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "originalPosition": 225}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Njg5MzAy", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-395689302", "createdAt": "2020-04-17T18:40:57Z", "commit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODo0MDo1N1rOGHZGQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODo0MDo1N1rOGHZGQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNDQxOQ==", "bodyText": "This map is shared for the whole JVM for all channels to totally different servers. This worries me.  Also the map needs synchronization.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410404419", "createdAt": "2020-04-17T18:40:57Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String childPolicyConfigTargetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          childPolicyConfigTargetFieldName != null && !childPolicyConfigTargetFieldName.isEmpty(),\n+          \"childPolicyConfigTargetFieldName cannot be empty or null\");\n+      this.childPolicyConfigTargetFieldName = childPolicyConfigTargetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(\n+          effectiveChildPolicy.size() == 1,\n+          \"childPolicy should have exactly one loadbalancing policy\");\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(childPolicyConfigTargetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    void addPendingRequest(RouteLookupRequest request, BackoffPolicy backoffPolicy) {\n+      checkNotNull(request, \"request\");\n+      checkNotNull(backoffPolicy, \"backoffPolicy\");\n+      BackoffPolicy existing = pendingRequests.put(request, backoffPolicy);\n+      checkState(\n+          existing == null,\n+          \"This is a bug, there should be at most one outstanding pending request\");\n+    }\n+\n+    void removePendingRequest(RouteLookupRequest request) {\n+      BackoffPolicy policy = pendingRequests.remove(request);\n+      checkState(policy != null, \"This is a bug, untracked pending request found\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(childPolicyConfigTargetFieldName, that.childPolicyConfigTargetFieldName)\n+          && Objects.equals(pendingRequests, that.pendingRequests);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return\n+          Objects\n+              .hash(\n+                  effectiveRawChildPolicy,\n+                  effectiveLbProvider,\n+                  childPolicyConfigTargetFieldName,\n+                  pendingRequests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", childPolicyConfigTargetFieldName)\n+          .add(\"pendingRequests\", pendingRequests)\n+          .toString();\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper implements Closeable {\n+\n+    @VisibleForTesting\n+    static final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "originalPosition": 220}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e921201ca04cda85979dd0fa0b0dfb478a3a4eae", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/e921201ca04cda85979dd0fa0b0dfb478a3a4eae", "committedDate": "2020-04-17T20:21:46Z", "message": "remove pending, rename some variables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Nzc0OTMz", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-395774933", "createdAt": "2020-04-17T21:10:45Z", "commit": {"oid": "e921201ca04cda85979dd0fa0b0dfb478a3a4eae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToxMDo0NVrOGHdNcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToxMDo0NVrOGHdNcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTc5NA==", "bodyText": "Seems you can just implement LrsLoadBalancerProvider.parseLoadBalancingPolicyConfig() by merging master.  Return ConfigOrError instead of throw.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410471794", "createdAt": "2020-04-17T21:10:45Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e921201ca04cda85979dd0fa0b0dfb478a3a4eae"}, "originalPosition": 137}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4b4a9a655f02e092524df8c5dcf1207d99ec2f7", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/e4b4a9a655f02e092524df8c5dcf1207d99ec2f7", "committedDate": "2020-04-17T23:08:10Z", "message": "use checked exception in create"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e278b51935d34805c661a6469b30e6f2fff6fefe", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/e278b51935d34805c661a6469b30e6f2fff6fefe", "committedDate": "2020-04-18T00:21:24Z", "message": "Merge branch 'master' into rls_objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c9f7462b2f026de9b7a90ffe524556263a08f4c", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/5c9f7462b2f026de9b7a90ffe524556263a08f4c", "committedDate": "2020-04-18T00:21:31Z", "message": "Merge remote-tracking branch 'upstream/master' into rls_objects"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjUzMjIw", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-395653220", "createdAt": "2020-04-17T17:45:49Z", "commit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzo0NTo1MFrOGHXXMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMzowNjoyOVrOGHfd4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3NTk4Nw==", "bodyText": "the helper won't be changed once it is set. if we want to make it final, the caller may need to create a delegating helper (this will be next PR depends on this change) even if it will use the cached version.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410375987", "createdAt": "2020-04-17T17:45:50Z", "author": {"login": "creamsoup"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String childPolicyConfigTargetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          childPolicyConfigTargetFieldName != null && !childPolicyConfigTargetFieldName.isEmpty(),\n+          \"childPolicyConfigTargetFieldName cannot be empty or null\");\n+      this.childPolicyConfigTargetFieldName = childPolicyConfigTargetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(\n+          effectiveChildPolicy.size() == 1,\n+          \"childPolicy should have exactly one loadbalancing policy\");\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(childPolicyConfigTargetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    void addPendingRequest(RouteLookupRequest request, BackoffPolicy backoffPolicy) {\n+      checkNotNull(request, \"request\");\n+      checkNotNull(backoffPolicy, \"backoffPolicy\");\n+      BackoffPolicy existing = pendingRequests.put(request, backoffPolicy);\n+      checkState(\n+          existing == null,\n+          \"This is a bug, there should be at most one outstanding pending request\");\n+    }\n+\n+    void removePendingRequest(RouteLookupRequest request) {\n+      BackoffPolicy policy = pendingRequests.remove(request);\n+      checkState(policy != null, \"This is a bug, untracked pending request found\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(childPolicyConfigTargetFieldName, that.childPolicyConfigTargetFieldName)\n+          && Objects.equals(pendingRequests, that.pendingRequests);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return\n+          Objects\n+              .hash(\n+                  effectiveRawChildPolicy,\n+                  effectiveLbProvider,\n+                  childPolicyConfigTargetFieldName,\n+                  pendingRequests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", childPolicyConfigTargetFieldName)\n+          .add(\"pendingRequests\", pendingRequests)\n+          .toString();\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper implements Closeable {\n+\n+    @VisibleForTesting\n+    static final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final String target;\n+    @Nullable\n+    private ChildLoadBalancingPolicy childPolicy;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+    private Helper helper;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxODAzOA=="}, "originalCommit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NTgwMQ==", "bodyText": "same as helper, it is used like final but it will be set after the caller find out that it is a brand new ChildPolicyWrapper. unlike helper it doesn't create extra object. do you think it is better to pass helper and childPolicy to the factory method to make it final?", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410385801", "createdAt": "2020-04-17T18:04:18Z", "author": {"login": "creamsoup"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String childPolicyConfigTargetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          childPolicyConfigTargetFieldName != null && !childPolicyConfigTargetFieldName.isEmpty(),\n+          \"childPolicyConfigTargetFieldName cannot be empty or null\");\n+      this.childPolicyConfigTargetFieldName = childPolicyConfigTargetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(\n+          effectiveChildPolicy.size() == 1,\n+          \"childPolicy should have exactly one loadbalancing policy\");\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(childPolicyConfigTargetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    void addPendingRequest(RouteLookupRequest request, BackoffPolicy backoffPolicy) {\n+      checkNotNull(request, \"request\");\n+      checkNotNull(backoffPolicy, \"backoffPolicy\");\n+      BackoffPolicy existing = pendingRequests.put(request, backoffPolicy);\n+      checkState(\n+          existing == null,\n+          \"This is a bug, there should be at most one outstanding pending request\");\n+    }\n+\n+    void removePendingRequest(RouteLookupRequest request) {\n+      BackoffPolicy policy = pendingRequests.remove(request);\n+      checkState(policy != null, \"This is a bug, untracked pending request found\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(childPolicyConfigTargetFieldName, that.childPolicyConfigTargetFieldName)\n+          && Objects.equals(pendingRequests, that.pendingRequests);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return\n+          Objects\n+              .hash(\n+                  effectiveRawChildPolicy,\n+                  effectiveLbProvider,\n+                  childPolicyConfigTargetFieldName,\n+                  pendingRequests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", childPolicyConfigTargetFieldName)\n+          .add(\"pendingRequests\", pendingRequests)\n+          .toString();\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper implements Closeable {\n+\n+    @VisibleForTesting\n+    static final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final String target;\n+    @Nullable\n+    private ChildLoadBalancingPolicy childPolicy;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyMTExMg=="}, "originalCommit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NDcyNA==", "bodyText": "oops, yes this is no longer used (moved to PendingCacheEntry which contains BackoffPolicy so we don't need to maintain a map). removed.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410394724", "createdAt": "2020-04-17T18:21:36Z", "author": {"login": "creamsoup"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMwOTQwMQ=="}, "originalCommit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwODYzOQ==", "bodyText": "discussed offline, the RlsLbProvider.parseLoadBalancingPolicyConfig() has more logic than just parsing ChildLoadBalancingPolicy. to imply the parsing can be fail, it will throw checked exception.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410508639", "createdAt": "2020-04-17T23:05:55Z", "author": {"login": "creamsoup"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTc5NA=="}, "originalCommit": {"oid": "e921201ca04cda85979dd0fa0b0dfb478a3a4eae"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwODc3MQ==", "bodyText": "yes target can be same. good catch. i refactored out this factory part. it is not globally shared, i didn't add any synchronization. future implementation always call it with lock if this can justify it.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410508771", "createdAt": "2020-04-17T23:06:29Z", "author": {"login": "creamsoup"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Iterables;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.io.Closeable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String childPolicyConfigTargetFieldName;\n+    private final Map<RouteLookupRequest, BackoffPolicy> pendingRequests = new HashMap<>();\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String childPolicyConfigTargetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          childPolicyConfigTargetFieldName != null && !childPolicyConfigTargetFieldName.isEmpty(),\n+          \"childPolicyConfigTargetFieldName cannot be empty or null\");\n+      this.childPolicyConfigTargetFieldName = childPolicyConfigTargetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName,\n+        List<Map<String, ?>> childPolicies) {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        String policyName = Iterables.getOnlyElement(childPolicy.keySet());\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      checkState(\n+          effectiveChildPolicy != null,\n+          \"no valid childPolicy found, policy tried: %s\", policyTried);\n+      checkArgument(\n+          effectiveChildPolicy.size() == 1,\n+          \"childPolicy should have exactly one loadbalancing policy\");\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(childPolicyConfigTargetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    void addPendingRequest(RouteLookupRequest request, BackoffPolicy backoffPolicy) {\n+      checkNotNull(request, \"request\");\n+      checkNotNull(backoffPolicy, \"backoffPolicy\");\n+      BackoffPolicy existing = pendingRequests.put(request, backoffPolicy);\n+      checkState(\n+          existing == null,\n+          \"This is a bug, there should be at most one outstanding pending request\");\n+    }\n+\n+    void removePendingRequest(RouteLookupRequest request) {\n+      BackoffPolicy policy = pendingRequests.remove(request);\n+      checkState(policy != null, \"This is a bug, untracked pending request found\");\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(childPolicyConfigTargetFieldName, that.childPolicyConfigTargetFieldName)\n+          && Objects.equals(pendingRequests, that.pendingRequests);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return\n+          Objects\n+              .hash(\n+                  effectiveRawChildPolicy,\n+                  effectiveLbProvider,\n+                  childPolicyConfigTargetFieldName,\n+                  pendingRequests);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", childPolicyConfigTargetFieldName)\n+          .add(\"pendingRequests\", pendingRequests)\n+          .toString();\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper implements Closeable {\n+\n+    @VisibleForTesting\n+    static final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNDQxOQ=="}, "originalCommit": {"oid": "c45c46caab0e671cffe5a4c85185a0d91e4ebcc7"}, "originalPosition": 220}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "937c8bb0f876813c07ce75ef5d14717d90e6c52e", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/937c8bb0f876813c07ce75ef5d14717d90e6c52e", "committedDate": "2020-04-18T00:26:44Z", "message": "move factory method out of ChildPolicyWrapper"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODM4NTQ3", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-395838547", "createdAt": "2020-04-18T00:47:22Z", "commit": {"oid": "e4b4a9a655f02e092524df8c5dcf1207d99ec2f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDo0NzoyM1rOGHglIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDo0NzoyM1rOGHglIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNzAxMQ==", "bodyText": "Maybe you can turn off writableStackTrace.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r410527011", "createdAt": "2020-04-18T00:47:23Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -344,4 +348,14 @@ public String toString() {\n           .toString();\n     }\n   }\n+\n+  /** Exception thrown when attempting to parse child policy encountered parsing issue. */\n+  public static final class InvalidChildPolicyConfigException extends Exception {\n+\n+    private static final long serialVersionUID = 0L;\n+\n+    public InvalidChildPolicyConfigException(String message) {\n+      super(message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4b4a9a655f02e092524df8c5dcf1207d99ec2f7"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1a50f36daf6410adb94bdfb36224265696407fa", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/e1a50f36daf6410adb94bdfb36224265696407fa", "committedDate": "2020-04-20T01:50:30Z", "message": "make exception stackless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "527cd1198e09f7c85b524e266120ce574f040843", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/527cd1198e09f7c85b524e266120ce574f040843", "committedDate": "2020-04-20T17:54:15Z", "message": "move helper creation to factory"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODQyOTg2", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-396842986", "createdAt": "2020-04-20T21:58:42Z", "commit": {"oid": "527cd1198e09f7c85b524e266120ce574f040843"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo1ODo0M1rOGIpa6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo1ODo0M1rOGIpa6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDQyNw==", "bodyText": "What's the expected usecase here? getObject() once and returnObject() twice()?", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411720427", "createdAt": "2020-04-20T21:58:43Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.ChildPolicyReportingHelper.ChildLbStatusListener;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName, List<Map<String, ?>> childPolicies)\n+        throws InvalidChildPolicyConfigException {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        if (childPolicy.size() != 1) {\n+          throw\n+              new InvalidChildPolicyConfigException(\n+                  \"childPolicy should have exactly one loadbalancing policy\");\n+        }\n+        String policyName = childPolicy.keySet().iterator().next();\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      if (effectiveChildPolicy == null) {\n+        throw\n+            new InvalidChildPolicyConfigException(\n+                String.format(\"no valid childPolicy found, policy tried: %s\", policyTried));\n+      }\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(targetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(targetFieldName, that.targetFieldName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(effectiveRawChildPolicy, effectiveLbProvider, targetFieldName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", targetFieldName)\n+          .toString();\n+    }\n+  }\n+\n+  /** Factory for {@link ChildPolicyWrapper}. */\n+  static final class RefCountedChildPolicyWrapperFactory {\n+    @VisibleForTesting\n+    final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final ChildLoadBalancerHelperProvider childLbHelperProvider;\n+    @Nullable\n+    private final ChildLbStatusListener childLbStatusListener;\n+\n+    public RefCountedChildPolicyWrapperFactory(\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable ChildLbStatusListener childLbStatusListener) {\n+      this.childLbHelperProvider = checkNotNull(childLbHelperProvider, \"childLbHelperProvider\");\n+      this.childLbStatusListener = childLbStatusListener;\n+    }\n+\n+    ChildPolicyWrapper createOrGet(String target) {\n+      // TODO(creamsoup) check if the target is valid or not\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      if (existing != null) {\n+        return existing.getObject();\n+      }\n+      ChildPolicyWrapper childPolicyWrapper =\n+          new ChildPolicyWrapper(target, childLbHelperProvider, childLbStatusListener);\n+      RefCountedChildPolicyWrapper wrapper = RefCountedChildPolicyWrapper.of(childPolicyWrapper);\n+      childPolicyMap.put(target, wrapper);\n+      return childPolicyWrapper;\n+    }\n+\n+    void release(ChildPolicyWrapper childPolicyWrapper) {\n+      checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+      String target = childPolicyWrapper.getTarget();\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      checkState(existing != null, \"Cannot access already released object\");\n+      if (existing.returnObject(childPolicyWrapper) == null) {\n+        childPolicyMap.remove(target);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper {\n+\n+    private final String target;\n+    private final ChildPolicyReportingHelper helper;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+\n+    public ChildPolicyWrapper(\n+        String target,\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable  ChildLbStatusListener childLbStatusListener) {\n+      this.target = target;\n+      this.helper =\n+          new ChildPolicyReportingHelper(childLbHelperProvider, this, childLbStatusListener);\n+    }\n+\n+    String getTarget() {\n+      return target;\n+    }\n+\n+    void setPicker(SubchannelPicker picker) {\n+      this.picker = checkNotNull(picker, \"picker\");\n+    }\n+\n+    SubchannelPicker getPicker() {\n+      return picker;\n+    }\n+\n+    ChildPolicyReportingHelper getHelper() {\n+      return helper;\n+    }\n+\n+    void setConnectivityStateInfo(ConnectivityStateInfo connectivityStateInfo) {\n+      this.connectivityStateInfo = connectivityStateInfo;\n+    }\n+\n+    ConnectivityStateInfo getConnectivityStateInfo() {\n+      return connectivityStateInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildPolicyWrapper that = (ChildPolicyWrapper) o;\n+      return Objects.equals(target, that.target)\n+          && Objects.equals(helper, that.helper)\n+          && Objects.equals(connectivityStateInfo, that.connectivityStateInfo)\n+          && Objects.equals(picker, that.picker);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(target, helper, connectivityStateInfo, picker);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"target\", target)\n+          .add(\"helper\", helper)\n+          .add(\"connectivityStateInfo\", connectivityStateInfo)\n+          .add(\"picker\", picker)\n+          .toString();\n+    }\n+  }\n+\n+  private static final class RefCountedChildPolicyWrapper\n+      implements ObjectPool<ChildPolicyWrapper> {\n+\n+    private final AtomicLong refCnt = new AtomicLong(1);\n+    @Nullable\n+    private ChildPolicyWrapper childPolicyWrapper;\n+\n+    private RefCountedChildPolicyWrapper(ChildPolicyWrapper childPolicyWrapper) {\n+      this.childPolicyWrapper = checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+    }\n+\n+    @Override\n+    public ChildPolicyWrapper getObject() {\n+      long curr = refCnt.getAndIncrement();\n+      if (curr <= 0) {\n+        throw new IllegalStateException(\"ChildPolicyWrapper is already released\");\n+      }\n+      return childPolicyWrapper;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ChildPolicyWrapper returnObject(Object object) {\n+      checkState(\n+          childPolicyWrapper == object,\n+          \"returned object doesn't match the pooled childPolicyWrapper\");\n+      long newCnt = refCnt.decrementAndGet();\n+      if (newCnt == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "527cd1198e09f7c85b524e266120ce574f040843"}, "originalPosition": 335}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODQzMDQ2", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-396843046", "createdAt": "2020-04-20T21:58:51Z", "commit": {"oid": "527cd1198e09f7c85b524e266120ce574f040843"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo1ODo1MVrOGIpbQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo1ODo1MVrOGIpbQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDUxMw==", "bodyText": "This circular dependency looks weird, because ChildPolicyWrapper is consumed by new ChildPolicyReportingHelper() before instantiation is complete.\nThe two classes are tightly coupled. Making ChildPolicyReportingHelper an inner (non-static) class of ChildPolicyWrapper might be more natural.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411720513", "createdAt": "2020-04-20T21:58:51Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.ChildPolicyReportingHelper.ChildLbStatusListener;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName, List<Map<String, ?>> childPolicies)\n+        throws InvalidChildPolicyConfigException {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        if (childPolicy.size() != 1) {\n+          throw\n+              new InvalidChildPolicyConfigException(\n+                  \"childPolicy should have exactly one loadbalancing policy\");\n+        }\n+        String policyName = childPolicy.keySet().iterator().next();\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      if (effectiveChildPolicy == null) {\n+        throw\n+            new InvalidChildPolicyConfigException(\n+                String.format(\"no valid childPolicy found, policy tried: %s\", policyTried));\n+      }\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(targetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(targetFieldName, that.targetFieldName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(effectiveRawChildPolicy, effectiveLbProvider, targetFieldName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", targetFieldName)\n+          .toString();\n+    }\n+  }\n+\n+  /** Factory for {@link ChildPolicyWrapper}. */\n+  static final class RefCountedChildPolicyWrapperFactory {\n+    @VisibleForTesting\n+    final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final ChildLoadBalancerHelperProvider childLbHelperProvider;\n+    @Nullable\n+    private final ChildLbStatusListener childLbStatusListener;\n+\n+    public RefCountedChildPolicyWrapperFactory(\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable ChildLbStatusListener childLbStatusListener) {\n+      this.childLbHelperProvider = checkNotNull(childLbHelperProvider, \"childLbHelperProvider\");\n+      this.childLbStatusListener = childLbStatusListener;\n+    }\n+\n+    ChildPolicyWrapper createOrGet(String target) {\n+      // TODO(creamsoup) check if the target is valid or not\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      if (existing != null) {\n+        return existing.getObject();\n+      }\n+      ChildPolicyWrapper childPolicyWrapper =\n+          new ChildPolicyWrapper(target, childLbHelperProvider, childLbStatusListener);\n+      RefCountedChildPolicyWrapper wrapper = RefCountedChildPolicyWrapper.of(childPolicyWrapper);\n+      childPolicyMap.put(target, wrapper);\n+      return childPolicyWrapper;\n+    }\n+\n+    void release(ChildPolicyWrapper childPolicyWrapper) {\n+      checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+      String target = childPolicyWrapper.getTarget();\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      checkState(existing != null, \"Cannot access already released object\");\n+      if (existing.returnObject(childPolicyWrapper) == null) {\n+        childPolicyMap.remove(target);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper {\n+\n+    private final String target;\n+    private final ChildPolicyReportingHelper helper;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+\n+    public ChildPolicyWrapper(\n+        String target,\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable  ChildLbStatusListener childLbStatusListener) {\n+      this.target = target;\n+      this.helper =\n+          new ChildPolicyReportingHelper(childLbHelperProvider, this, childLbStatusListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "527cd1198e09f7c85b524e266120ce574f040843"}, "originalPosition": 250}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODQzMzI5", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-396843329", "createdAt": "2020-04-20T21:59:25Z", "commit": {"oid": "527cd1198e09f7c85b524e266120ce574f040843"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo1OToyNVrOGIpcMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo1OToyNVrOGIpcMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDc1Mw==", "bodyText": "Not used?", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411720753", "createdAt": "2020-04-20T21:59:25Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/ChildPolicyReportingHelper.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.LbPolicyConfiguration.ChildPolicyWrapper;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.ForwardingSubchannel;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A delegating {@link io.grpc.LoadBalancer.Helper} maintains status of {@link ChildPolicyWrapper}\n+ * when {@link Subchannel} status changed. This helper is used between child policy and parent\n+ * load-balancer where each picker in child policy is governed by a governing picker (RlsPicker).\n+ * The governing picker will be reported back to the parent load-balancer.\n+ */\n+final class ChildPolicyReportingHelper extends ForwardingLoadBalancerHelper {\n+\n+  private final ChildLoadBalancerHelper delegate;\n+  private final ChildPolicyWrapper childPolicyWrapper;\n+  @Nullable\n+  private final ChildLbStatusListener listener;\n+\n+  ChildPolicyReportingHelper(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "527cd1198e09f7c85b524e266120ce574f040843"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "988839c19922127432e00466f8c391d5347f9b56", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/988839c19922127432e00466f8c391d5347f9b56", "committedDate": "2020-04-20T23:00:15Z", "message": "make helper inner class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd6e862613e19424fc5f02597ae5d7e2acefa4c1", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/cd6e862613e19424fc5f02597ae5d7e2acefa4c1", "committedDate": "2020-04-20T23:11:44Z", "message": "add check already released"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2ODc2MjMx", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-396876231", "createdAt": "2020-04-20T23:16:03Z", "commit": {"oid": "cd6e862613e19424fc5f02597ae5d7e2acefa4c1"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzoxNjowM1rOGIreag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMzoyMTo1NFrOGIrmmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDA5MA==", "bodyText": "There is extra space.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411754090", "createdAt": "2020-04-20T23:16:03Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.LbPolicyConfiguration.ChildPolicyWrapper.ChildLbStatusListener;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.ForwardingSubchannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName, List<Map<String, ?>> childPolicies)\n+        throws InvalidChildPolicyConfigException {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        if (childPolicy.size() != 1) {\n+          throw\n+              new InvalidChildPolicyConfigException(\n+                  \"childPolicy should have exactly one loadbalancing policy\");\n+        }\n+        String policyName = childPolicy.keySet().iterator().next();\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      if (effectiveChildPolicy == null) {\n+        throw\n+            new InvalidChildPolicyConfigException(\n+                String.format(\"no valid childPolicy found, policy tried: %s\", policyTried));\n+      }\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(targetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(targetFieldName, that.targetFieldName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(effectiveRawChildPolicy, effectiveLbProvider, targetFieldName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", targetFieldName)\n+          .toString();\n+    }\n+  }\n+\n+  /** Factory for {@link ChildPolicyWrapper}. */\n+  static final class RefCountedChildPolicyWrapperFactory {\n+    @VisibleForTesting\n+    final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final ChildLoadBalancerHelperProvider childLbHelperProvider;\n+    @Nullable\n+    private final ChildLbStatusListener childLbStatusListener;\n+\n+    public RefCountedChildPolicyWrapperFactory(\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable ChildLbStatusListener childLbStatusListener) {\n+      this.childLbHelperProvider = checkNotNull(childLbHelperProvider, \"childLbHelperProvider\");\n+      this.childLbStatusListener = childLbStatusListener;\n+    }\n+\n+    ChildPolicyWrapper createOrGet(String target) {\n+      // TODO(creamsoup) check if the target is valid or not\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      if (existing != null) {\n+        return existing.getObject();\n+      }\n+      ChildPolicyWrapper childPolicyWrapper =\n+          new ChildPolicyWrapper(target, childLbHelperProvider, childLbStatusListener);\n+      RefCountedChildPolicyWrapper wrapper = RefCountedChildPolicyWrapper.of(childPolicyWrapper);\n+      childPolicyMap.put(target, wrapper);\n+      return childPolicyWrapper;\n+    }\n+\n+    void release(ChildPolicyWrapper childPolicyWrapper) {\n+      checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+      String target = childPolicyWrapper.getTarget();\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      checkState(existing != null, \"Cannot access already released object\");\n+      if (existing.returnObject(childPolicyWrapper) == null) {\n+        childPolicyMap.remove(target);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper {\n+\n+    private final String target;\n+    private final ChildPolicyReportingHelper helper;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+\n+    public ChildPolicyWrapper(\n+        String target,\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable  ChildLbStatusListener childLbStatusListener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd6e862613e19424fc5f02597ae5d7e2acefa4c1"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NDMwNA==", "bodyText": "nit: The listener interface is nested too deep. Can be one level up.", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411754304", "createdAt": "2020-04-20T23:16:37Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.LbPolicyConfiguration.ChildPolicyWrapper.ChildLbStatusListener;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd6e862613e19424fc5f02597ae5d7e2acefa4c1"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1NjE4Nw==", "bodyText": "This API should always return null.\nhttps://github.com/grpc/grpc-java/blob/v1.28.1/core/src/main/java/io/grpc/internal/ObjectPool.java#L32-L36", "url": "https://github.com/grpc/grpc-java/pull/6883#discussion_r411756187", "createdAt": "2020-04-20T23:21:54Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LbPolicyConfiguration.java", "diffHunk": "@@ -0,0 +1,446 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ConnectivityStateInfo;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancer.SubchannelStateListener;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.rls.internal.ChildLoadBalancerHelper.ChildLoadBalancerHelperProvider;\n+import io.grpc.rls.internal.LbPolicyConfiguration.ChildPolicyWrapper.ChildLbStatusListener;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.ForwardingSubchannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nullable;\n+\n+/** Configuration for RLS load balancing policy. */\n+public final class LbPolicyConfiguration {\n+\n+  private final RouteLookupConfig routeLookupConfig;\n+  private final ChildLoadBalancingPolicy policy;\n+\n+  public LbPolicyConfiguration(\n+      RouteLookupConfig routeLookupConfig, ChildLoadBalancingPolicy policy) {\n+    this.routeLookupConfig = checkNotNull(routeLookupConfig, \"routeLookupConfig\");\n+    this.policy = checkNotNull(policy, \"policy\");\n+  }\n+\n+  public RouteLookupConfig getRouteLookupConfig() {\n+    return routeLookupConfig;\n+  }\n+\n+  public ChildLoadBalancingPolicy getLoadBalancingPolicy() {\n+    return policy;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    LbPolicyConfiguration that = (LbPolicyConfiguration) o;\n+    return Objects.equals(routeLookupConfig, that.routeLookupConfig)\n+        && Objects.equals(policy, that.policy);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(routeLookupConfig, policy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"routeLookupConfig\", routeLookupConfig)\n+        .add(\"policy\", policy)\n+        .toString();\n+  }\n+\n+  /** ChildLoadBalancingPolicy is an elected child policy to delegate requests. */\n+  public static final class ChildLoadBalancingPolicy {\n+\n+    private final Map<String, Object> effectiveRawChildPolicy;\n+    private final LoadBalancerProvider effectiveLbProvider;\n+    private final String targetFieldName;\n+\n+    @VisibleForTesting\n+    ChildLoadBalancingPolicy(\n+        String targetFieldName,\n+        Map<String, Object> effectiveRawChildPolicy,\n+        LoadBalancerProvider effectiveLbProvider) {\n+      checkArgument(\n+          targetFieldName != null && !targetFieldName.isEmpty(),\n+          \"targetFieldName cannot be empty or null\");\n+      this.targetFieldName = targetFieldName;\n+      this.effectiveRawChildPolicy =\n+          checkNotNull(effectiveRawChildPolicy, \"effectiveRawChildPolicy\");\n+      this.effectiveLbProvider = checkNotNull(effectiveLbProvider, \"effectiveLbProvider\");\n+    }\n+\n+    /** Creates ChildLoadBalancingPolicy. */\n+    @SuppressWarnings(\"unchecked\")\n+    public static ChildLoadBalancingPolicy create(\n+        String childPolicyConfigTargetFieldName, List<Map<String, ?>> childPolicies)\n+        throws InvalidChildPolicyConfigException {\n+      Map<String, Object> effectiveChildPolicy = null;\n+      LoadBalancerProvider effectiveLbProvider = null;\n+      List<String> policyTried = new ArrayList<>();\n+\n+      LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+      for (Map<String, ?> childPolicy : childPolicies) {\n+        if (childPolicy.isEmpty()) {\n+          continue;\n+        }\n+        if (childPolicy.size() != 1) {\n+          throw\n+              new InvalidChildPolicyConfigException(\n+                  \"childPolicy should have exactly one loadbalancing policy\");\n+        }\n+        String policyName = childPolicy.keySet().iterator().next();\n+        LoadBalancerProvider provider = lbRegistry.getProvider(policyName);\n+        if (provider != null) {\n+          effectiveLbProvider = provider;\n+          effectiveChildPolicy = Collections.unmodifiableMap(childPolicy);\n+          break;\n+        }\n+        policyTried.add(policyName);\n+      }\n+      if (effectiveChildPolicy == null) {\n+        throw\n+            new InvalidChildPolicyConfigException(\n+                String.format(\"no valid childPolicy found, policy tried: %s\", policyTried));\n+      }\n+      return\n+          new ChildLoadBalancingPolicy(\n+              childPolicyConfigTargetFieldName,\n+              (Map<String, Object>) effectiveChildPolicy.values().iterator().next(),\n+              effectiveLbProvider);\n+    }\n+\n+    /** Creates a child load balancer config for given target from elected raw child policy. */\n+    public Map<String, ?> getEffectiveChildPolicy(String target) {\n+      Map<String, Object> childPolicy = new HashMap<>(effectiveRawChildPolicy);\n+      childPolicy.put(targetFieldName, target);\n+      return childPolicy;\n+    }\n+\n+    /** Returns the elected child {@link LoadBalancerProvider}. */\n+    public LoadBalancerProvider getEffectiveLbProvider() {\n+      return effectiveLbProvider;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildLoadBalancingPolicy that = (ChildLoadBalancingPolicy) o;\n+      return Objects.equals(effectiveRawChildPolicy, that.effectiveRawChildPolicy)\n+          && Objects.equals(effectiveLbProvider, that.effectiveLbProvider)\n+          && Objects.equals(targetFieldName, that.targetFieldName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(effectiveRawChildPolicy, effectiveLbProvider, targetFieldName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"effectiveRawChildPolicy\", effectiveRawChildPolicy)\n+          .add(\"effectiveLbProvider\", effectiveLbProvider)\n+          .add(\"childPolicyConfigTargetFieldName\", targetFieldName)\n+          .toString();\n+    }\n+  }\n+\n+  /** Factory for {@link ChildPolicyWrapper}. */\n+  static final class RefCountedChildPolicyWrapperFactory {\n+    @VisibleForTesting\n+    final Map<String /* target */, RefCountedChildPolicyWrapper> childPolicyMap =\n+        new HashMap<>();\n+\n+    private final ChildLoadBalancerHelperProvider childLbHelperProvider;\n+    @Nullable\n+    private final ChildLbStatusListener childLbStatusListener;\n+\n+    public RefCountedChildPolicyWrapperFactory(\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable ChildLbStatusListener childLbStatusListener) {\n+      this.childLbHelperProvider = checkNotNull(childLbHelperProvider, \"childLbHelperProvider\");\n+      this.childLbStatusListener = childLbStatusListener;\n+    }\n+\n+    ChildPolicyWrapper createOrGet(String target) {\n+      // TODO(creamsoup) check if the target is valid or not\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      if (existing != null) {\n+        return existing.getObject();\n+      }\n+      ChildPolicyWrapper childPolicyWrapper =\n+          new ChildPolicyWrapper(target, childLbHelperProvider, childLbStatusListener);\n+      RefCountedChildPolicyWrapper wrapper = RefCountedChildPolicyWrapper.of(childPolicyWrapper);\n+      childPolicyMap.put(target, wrapper);\n+      return childPolicyWrapper;\n+    }\n+\n+    void release(ChildPolicyWrapper childPolicyWrapper) {\n+      checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+      String target = childPolicyWrapper.getTarget();\n+      ObjectPool<ChildPolicyWrapper> existing = childPolicyMap.get(target);\n+      checkState(existing != null, \"Cannot access already released object\");\n+      if (existing.returnObject(childPolicyWrapper) == null) {\n+        childPolicyMap.remove(target);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * ChildPolicyWrapper is a wrapper class for child load balancing policy with associated helper /\n+   * utility classes to manage the child policy.\n+   */\n+  static final class ChildPolicyWrapper {\n+\n+    private final String target;\n+    private final ChildPolicyReportingHelper helper;\n+    private ConnectivityStateInfo connectivityStateInfo =\n+        ConnectivityStateInfo.forNonError(ConnectivityState.IDLE);\n+    private SubchannelPicker picker;\n+\n+    public ChildPolicyWrapper(\n+        String target,\n+        ChildLoadBalancerHelperProvider childLbHelperProvider,\n+        @Nullable  ChildLbStatusListener childLbStatusListener) {\n+      this.target = target;\n+      this.helper =\n+          new ChildPolicyReportingHelper(childLbHelperProvider, childLbStatusListener);\n+    }\n+\n+    String getTarget() {\n+      return target;\n+    }\n+\n+    void setPicker(SubchannelPicker picker) {\n+      this.picker = checkNotNull(picker, \"picker\");\n+    }\n+\n+    SubchannelPicker getPicker() {\n+      return picker;\n+    }\n+\n+    ChildPolicyReportingHelper getHelper() {\n+      return helper;\n+    }\n+\n+    void setConnectivityStateInfo(ConnectivityStateInfo connectivityStateInfo) {\n+      this.connectivityStateInfo = connectivityStateInfo;\n+    }\n+\n+    ConnectivityStateInfo getConnectivityStateInfo() {\n+      return connectivityStateInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      ChildPolicyWrapper that = (ChildPolicyWrapper) o;\n+      return Objects.equals(target, that.target)\n+          && Objects.equals(helper, that.helper)\n+          && Objects.equals(connectivityStateInfo, that.connectivityStateInfo)\n+          && Objects.equals(picker, that.picker);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(target, helper, connectivityStateInfo, picker);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"target\", target)\n+          .add(\"helper\", helper)\n+          .add(\"connectivityStateInfo\", connectivityStateInfo)\n+          .add(\"picker\", picker)\n+          .toString();\n+    }\n+\n+    /**\n+     * A delegating {@link io.grpc.LoadBalancer.Helper} maintains status of {@link\n+     * ChildPolicyWrapper} when {@link Subchannel} status changed. This helper is used between child\n+     * policy and parent load-balancer where each picker in child policy is governed by a governing\n+     * picker (RlsPicker). The governing picker will be reported back to the parent load-balancer.\n+     */\n+    final class ChildPolicyReportingHelper extends ForwardingLoadBalancerHelper {\n+\n+      private final ChildLoadBalancerHelper delegate;\n+      @Nullable\n+      private final ChildLbStatusListener listener;\n+\n+      ChildPolicyReportingHelper(ChildLoadBalancerHelperProvider childHelperProvider) {\n+        this(childHelperProvider, null);\n+      }\n+\n+      ChildPolicyReportingHelper(\n+          ChildLoadBalancerHelperProvider childHelperProvider,\n+          @Nullable ChildLbStatusListener listener) {\n+        checkNotNull(childHelperProvider, \"childHelperProvider\");\n+        this.delegate = childHelperProvider.forTarget(getTarget());\n+        this.listener = listener;\n+      }\n+\n+      @Override\n+      protected Helper delegate() {\n+        return delegate;\n+      }\n+\n+      @Override\n+      public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+        setPicker(newPicker);\n+        super.updateBalancingState(newState, newPicker);\n+        if (listener != null) {\n+          listener.onStatusChanged(newState);\n+        }\n+      }\n+\n+      @Override\n+      public Subchannel createSubchannel(CreateSubchannelArgs args) {\n+        final Subchannel subchannel = super.createSubchannel(args);\n+        return new ForwardingSubchannel() {\n+          @Override\n+          protected Subchannel delegate() {\n+            return subchannel;\n+          }\n+\n+          @Override\n+          public void start(final SubchannelStateListener listener) {\n+            super.start(new SubchannelStateListener() {\n+              @Override\n+              public void onSubchannelState(ConnectivityStateInfo newState) {\n+                setConnectivityStateInfo(newState);\n+                listener.onSubchannelState(newState);\n+              }\n+            });\n+          }\n+        };\n+      }\n+    }\n+\n+    /** Listener for child lb status change events. */\n+    interface ChildLbStatusListener {\n+\n+      /** Notifies when child lb status changes. */\n+      void onStatusChanged(ConnectivityState newState);\n+    }\n+  }\n+\n+  private static final class RefCountedChildPolicyWrapper\n+      implements ObjectPool<ChildPolicyWrapper> {\n+\n+    private final AtomicLong refCnt = new AtomicLong(1);\n+    @Nullable\n+    private ChildPolicyWrapper childPolicyWrapper;\n+\n+    private RefCountedChildPolicyWrapper(ChildPolicyWrapper childPolicyWrapper) {\n+      this.childPolicyWrapper = checkNotNull(childPolicyWrapper, \"childPolicyWrapper\");\n+    }\n+\n+    @Override\n+    public ChildPolicyWrapper getObject() {\n+      long curr = refCnt.getAndIncrement();\n+      if (curr <= 0) {\n+        throw new IllegalStateException(\"ChildPolicyWrapper is already released\");\n+      }\n+      return childPolicyWrapper;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ChildPolicyWrapper returnObject(Object object) {\n+      checkState(\n+          childPolicyWrapper != null,\n+          \"cannot return already released ChildPolicyWrapper, this is possibly a bug.\");\n+      checkState(\n+          childPolicyWrapper == object,\n+          \"returned object doesn't match the pooled childPolicyWrapper\");\n+      long newCnt = refCnt.decrementAndGet();\n+      if (newCnt == 0) {\n+        childPolicyWrapper = null;\n+      }\n+      return childPolicyWrapper;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd6e862613e19424fc5f02597ae5d7e2acefa4c1"}, "originalPosition": 415}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2b4040d78dfaa64869e23f84d8332104812a985", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/a2b4040d78dfaa64869e23f84d8332104812a985", "committedDate": "2020-04-20T23:52:26Z", "message": "ref count start from 0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d31b8b0ac9551c4d0d45d4571c881b0eab22d08", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/9d31b8b0ac9551c4d0d45d4571c881b0eab22d08", "committedDate": "2020-04-20T23:56:55Z", "message": "remove space, move listener up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e170906d94f7c5a23d9a67421458e0c7163e1794", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/e170906d94f7c5a23d9a67421458e0c7163e1794", "committedDate": "2020-04-21T00:06:15Z", "message": "make objectpool non static, make returnObject returns null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09363bcf45674856772d344fe429ff77a0272d0b", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/09363bcf45674856772d344fe429ff77a0272d0b", "committedDate": "2020-04-21T00:14:39Z", "message": "Revert \"make objectpool non static, make returnObject returns null\"\n\nThis reverts commit e170906d94f7c5a23d9a67421458e0c7163e1794."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTA0NzQ4", "url": "https://github.com/grpc/grpc-java/pull/6883#pullrequestreview-396904748", "createdAt": "2020-04-21T00:16:31Z", "commit": {"oid": "6f52bc3b751bd3da53b85de7172f0f04bb0f376e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f52bc3b751bd3da53b85de7172f0f04bb0f376e", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/6f52bc3b751bd3da53b85de7172f0f04bb0f376e", "committedDate": "2020-04-21T00:18:04Z", "message": "add isReleased to pool"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4496, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}