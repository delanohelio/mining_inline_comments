{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NDg3ODQw", "number": 6731, "title": "xds: implement WeightedTargetLoadBalancer", "bodyText": "Implement weighted_target lb part of go/grpc-xds-traffic-splitting-and-path-matching\nRefactor InterLocalityPicker to reuse the RandomWeightedPicker.", "createdAt": "2020-02-20T00:45:39Z", "url": "https://github.com/grpc/grpc-java/pull/6731", "merged": true, "mergeCommit": {"oid": "5e7b8c672fab7d67d642fc5d718b2b5c571f5429"}, "closed": true, "closedAt": "2020-03-11T22:35:32Z", "author": {"login": "dapengzhang0"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGQfvtgBqjMwNTc5MDUyMzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMGwMvgFqTM3MTU5ODQ4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "993c3177eba067657eb5a15a525c7bbbcf51ce46", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/993c3177eba067657eb5a15a525c7bbbcf51ce46", "committedDate": "2020-02-20T00:44:19Z", "message": "xds: implement WeightedTargetLoadBalancer"}, "afterCommit": {"oid": "ea1fe7f32746b6b9a613f2461f09da87f7af0ee1", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/ea1fe7f32746b6b9a613f2461f09da87f7af0ee1", "committedDate": "2020-02-20T19:42:27Z", "message": "xds: implement WeightedTargetLoadBalancer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ea1fe7f32746b6b9a613f2461f09da87f7af0ee1", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/ea1fe7f32746b6b9a613f2461f09da87f7af0ee1", "committedDate": "2020-02-20T19:42:27Z", "message": "xds: implement WeightedTargetLoadBalancer"}, "afterCommit": {"oid": "dc8da345ee361836c1697529e64bc222170d4696", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/dc8da345ee361836c1697529e64bc222170d4696", "committedDate": "2020-02-20T21:35:33Z", "message": "xds: implement WeightedTargetLoadBalancer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dc8da345ee361836c1697529e64bc222170d4696", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/dc8da345ee361836c1697529e64bc222170d4696", "committedDate": "2020-02-20T21:35:33Z", "message": "xds: implement WeightedTargetLoadBalancer"}, "afterCommit": {"oid": "829babcd2bf7b2c89d632d9111b9b261bd27db3d", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/829babcd2bf7b2c89d632d9111b9b261bd27db3d", "committedDate": "2020-02-20T21:37:17Z", "message": "xds: implement WeightedTargetLoadBalancer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cf623ebb58ff8fa93ef4350596f202125dbc4d9", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/2cf623ebb58ff8fa93ef4350596f202125dbc4d9", "committedDate": "2020-02-20T23:25:27Z", "message": "xds: implement WeightedTargetLoadBalancer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "829babcd2bf7b2c89d632d9111b9b261bd27db3d", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/829babcd2bf7b2c89d632d9111b9b261bd27db3d", "committedDate": "2020-02-20T21:37:17Z", "message": "xds: implement WeightedTargetLoadBalancer"}, "afterCommit": {"oid": "2cf623ebb58ff8fa93ef4350596f202125dbc4d9", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/2cf623ebb58ff8fa93ef4350596f202125dbc4d9", "committedDate": "2020-02-20T23:25:27Z", "message": "xds: implement WeightedTargetLoadBalancer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94ca8f4544a99a0900893bca2fb75eaaab289bba", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/94ca8f4544a99a0900893bca2fb75eaaab289bba", "committedDate": "2020-02-26T18:28:04Z", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java into weighted-target-2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/40d402a0d2aed77afe16fa9cdd9cf23819c78474", "committedDate": "2020-02-26T18:35:12Z", "message": "use the new Logger"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzQ1NTQ4", "url": "https://github.com/grpc/grpc-java/pull/6731#pullrequestreview-366745548", "createdAt": "2020-02-28T23:40:08Z", "commit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzo0MDowOFrOFwFxZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOTozMTowOVrOFwsZ7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3MDUzMg==", "bodyText": "Why this is \"cds-lb\"? You can just use normal logger if things have not been finalized.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r385970532", "createdAt": "2020-02-28T23:40:08Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.\n+   * The list must not be empty and must not contain duplicate lb configs.\n+   */\n+  WeightedTargetLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        checkNotNull(lbRegistry, \"lbRegistry\"),\n+        WeightedPickerFactory.RANDOM_PICKER_FACTORY);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancer(\n+      Helper helper, LoadBalancerRegistry lbRegistry, WeightedPickerFactory weightedPickerFactory) {\n+    this.helper = helper;\n+    this.lbRegistry = lbRegistry;\n+    this.weightedPickerFactory = weightedPickerFactory;\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NTUyMQ==", "bodyText": "nit: delete one empty line.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r385985521", "createdAt": "2020-02-29T01:06:33Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(WeightedTargetLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and WeightedTargetLoadBalancerProvider.\n+  public WeightedTargetLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return WEIGHTED_TARGET_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new WeightedTargetLoadBalancer(helper, loadBalancerRegistry());\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> targets = JsonUtil.getObject(rawConfig, \"targets\");\n+      if (targets == null || targets.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No targets provided for weighted_target LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, WeightedChildLbConfig> parsedChildConfigs = new LinkedHashMap<>();\n+      for (String name : targets.keySet()) {\n+        Map<String, ?> rawWeightedTarget = JsonUtil.getObject(targets, name);\n+        if (rawWeightedTarget == null || rawWeightedTarget.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        Double weightD = JsonUtil.getNumber(rawWeightedTarget, \"weight\");\n+        if (weightD == null || weightD < 1) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Wrong weight for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawWeightedTarget, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        int weight = weightD.intValue();\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in weighted_target Lb policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedChildConfigs.put(\n+                name,\n+                new WeightedChildLbConfig(weight, policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+      return ConfigOrError.fromConfig(new WeightedTargetConfig(parsedChildConfigs));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse weighted_target LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  /** Child lb config with weight. */\n+  static final class WeightedChildLbConfig {\n+\n+    final int weight;\n+    final String policyName;\n+    final Object config; // Parsed config.\n+\n+    @VisibleForTesting\n+    WeightedChildLbConfig(int weight, String policyName, Object config) {\n+      this.weight = weight;\n+      this.policyName = policyName;\n+      this.config = config;\n+    }\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2MDU5Ng==", "bodyText": "For any reason this needs to be non-private? I just found all load balancer provider in xds packages seem to have the same issue.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386560596", "createdAt": "2020-03-02T18:11:33Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2Njg5NA==", "bodyText": "Same as mentioned in XdsRoutingLoadbalancerProvider, do not use \"child\" as a type name.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386566894", "createdAt": "2020-03-02T18:24:01Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(WeightedTargetLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and WeightedTargetLoadBalancerProvider.\n+  public WeightedTargetLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return WEIGHTED_TARGET_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new WeightedTargetLoadBalancer(helper, loadBalancerRegistry());\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> targets = JsonUtil.getObject(rawConfig, \"targets\");\n+      if (targets == null || targets.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No targets provided for weighted_target LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, WeightedChildLbConfig> parsedChildConfigs = new LinkedHashMap<>();\n+      for (String name : targets.keySet()) {\n+        Map<String, ?> rawWeightedTarget = JsonUtil.getObject(targets, name);\n+        if (rawWeightedTarget == null || rawWeightedTarget.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        Double weightD = JsonUtil.getNumber(rawWeightedTarget, \"weight\");\n+        if (weightD == null || weightD < 1) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Wrong weight for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawWeightedTarget, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        int weight = weightD.intValue();\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in weighted_target Lb policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedChildConfigs.put(\n+                name,\n+                new WeightedChildLbConfig(weight, policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+      return ConfigOrError.fromConfig(new WeightedTargetConfig(parsedChildConfigs));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse weighted_target LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  /** Child lb config with weight. */\n+  static final class WeightedChildLbConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU2NzU1NA==", "bodyText": "nit: comment is redundant.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386567554", "createdAt": "2020-03-02T18:25:23Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(WeightedTargetLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and WeightedTargetLoadBalancerProvider.\n+  public WeightedTargetLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return WEIGHTED_TARGET_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new WeightedTargetLoadBalancer(helper, loadBalancerRegistry());\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> targets = JsonUtil.getObject(rawConfig, \"targets\");\n+      if (targets == null || targets.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No targets provided for weighted_target LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, WeightedChildLbConfig> parsedChildConfigs = new LinkedHashMap<>();\n+      for (String name : targets.keySet()) {\n+        Map<String, ?> rawWeightedTarget = JsonUtil.getObject(targets, name);\n+        if (rawWeightedTarget == null || rawWeightedTarget.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        Double weightD = JsonUtil.getNumber(rawWeightedTarget, \"weight\");\n+        if (weightD == null || weightD < 1) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Wrong weight for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawWeightedTarget, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        int weight = weightD.intValue();\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in weighted_target Lb policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedChildConfigs.put(\n+                name,\n+                new WeightedChildLbConfig(weight, policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+      return ConfigOrError.fromConfig(new WeightedTargetConfig(parsedChildConfigs));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse weighted_target LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  /** Child lb config with weight. */\n+  static final class WeightedChildLbConfig {\n+\n+    final int weight;\n+    final String policyName;\n+    final Object config; // Parsed config.\n+\n+    @VisibleForTesting\n+    WeightedChildLbConfig(int weight, String policyName, Object config) {\n+      this.weight = weight;\n+      this.policyName = policyName;\n+      this.config = config;\n+    }\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      WeightedChildLbConfig that = (WeightedChildLbConfig) o;\n+      return weight == that.weight\n+          && Objects.equals(policyName, that.policyName)\n+          && Objects.equals(config, that.config);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(weight, policyName, config);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"weight\", weight)\n+          .add(\"policyName\", policyName)\n+          .add(\"config\", config)\n+          .toString();\n+    }\n+  }\n+\n+  /** The lb config for WeightedTargetLoadBalancer. */\n+  static final class WeightedTargetConfig {\n+\n+    final Map<String, WeightedChildLbConfig> targets;\n+\n+    /** Constructs a deeply parsed weighted_target config with the given non-empty targets map. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU3MDMwOQ==", "bodyText": "Wrong comment (commenting is redundant).", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386570309", "createdAt": "2020-03-02T18:30:19Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU4MzY2OA==", "bodyText": "Although not wrong, I feel like there isn't a strong reason to make a copy.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386583668", "createdAt": "2020-03-02T18:55:08Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the weighted_target balancing policy.  This class should not be\n+ * directly referenced in code.  The policy should be accessed through {@link\n+ * LoadBalancerRegistry#getProvider} with the name \"weighted_target_experimental\".\n+ */\n+@Internal\n+public final class WeightedTargetLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String WEIGHTED_TARGET_POLICY_NAME = \"weighted_target_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(WeightedTargetLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and WeightedTargetLoadBalancerProvider.\n+  public WeightedTargetLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return WEIGHTED_TARGET_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new WeightedTargetLoadBalancer(helper, loadBalancerRegistry());\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> targets = JsonUtil.getObject(rawConfig, \"targets\");\n+      if (targets == null || targets.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No targets provided for weighted_target LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, WeightedChildLbConfig> parsedChildConfigs = new LinkedHashMap<>();\n+      for (String name : targets.keySet()) {\n+        Map<String, ?> rawWeightedTarget = JsonUtil.getObject(targets, name);\n+        if (rawWeightedTarget == null || rawWeightedTarget.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        Double weightD = JsonUtil.getNumber(rawWeightedTarget, \"weight\");\n+        if (weightD == null || weightD < 1) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Wrong weight for target \" + name + \" in weighted_target LB policy:\\n \" + rawConfig));\n+        }\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawWeightedTarget, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        int weight = weightD.intValue();\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in weighted_target Lb policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedChildConfigs.put(\n+                name,\n+                new WeightedChildLbConfig(weight, policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for target \" + name + \" in weighted_target LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+      return ConfigOrError.fromConfig(new WeightedTargetConfig(parsedChildConfigs));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse weighted_target LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  /** Child lb config with weight. */\n+  static final class WeightedChildLbConfig {\n+\n+    final int weight;\n+    final String policyName;\n+    final Object config; // Parsed config.\n+\n+    @VisibleForTesting\n+    WeightedChildLbConfig(int weight, String policyName, Object config) {\n+      this.weight = weight;\n+      this.policyName = policyName;\n+      this.config = config;\n+    }\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      WeightedChildLbConfig that = (WeightedChildLbConfig) o;\n+      return weight == that.weight\n+          && Objects.equals(policyName, that.policyName)\n+          && Objects.equals(config, that.config);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(weight, policyName, config);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"weight\", weight)\n+          .add(\"policyName\", policyName)\n+          .add(\"config\", config)\n+          .toString();\n+    }\n+  }\n+\n+  /** The lb config for WeightedTargetLoadBalancer. */\n+  static final class WeightedTargetConfig {\n+\n+    final Map<String, WeightedChildLbConfig> targets;\n+\n+    /** Constructs a deeply parsed weighted_target config with the given non-empty targets map. */\n+    @VisibleForTesting\n+    WeightedTargetConfig(Map<String, WeightedChildLbConfig> targets) {\n+      this.targets = ImmutableMap.copyOf(targets);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU4NjczOA==", "bodyText": "nit: commenting is redundant. Same for above and below. Code is already clearly saying what it is doing.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386586738", "createdAt": "2020-03-02T19:00:29Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.\n+   * The list must not be empty and must not contain duplicate lb configs.\n+   */\n+  WeightedTargetLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        checkNotNull(lbRegistry, \"lbRegistry\"),\n+        WeightedPickerFactory.RANDOM_PICKER_FACTORY);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancer(\n+      Helper helper, LoadBalancerRegistry lbRegistry, WeightedPickerFactory weightedPickerFactory) {\n+    this.helper = helper;\n+    this.lbRegistry = lbRegistry;\n+    this.weightedPickerFactory = weightedPickerFactory;\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    Object lbConfig = resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(lbConfig, \"missing weighted_target lb config\");\n+\n+    WeightedTargetConfig weightedTargetConfig = (WeightedTargetConfig) lbConfig;\n+    Map<String, WeightedChildLbConfig> newTargets = weightedTargetConfig.targets;\n+\n+    for (String targetName : newTargets.keySet()) {\n+      WeightedChildLbConfig weightedChildLbConfig = newTargets.get(targetName);\n+      if (!targets.containsKey(targetName)) {\n+        // Create child balancers for new names.\n+        ChildHelper childHelper = new ChildHelper();\n+        GracefulSwitchLoadBalancer childBalancer = new GracefulSwitchLoadBalancer(childHelper);\n+        childBalancer.switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+        childHelpers.put(targetName, childHelper);\n+        childBalancers.put(targetName, childBalancer);\n+      } else if (!weightedChildLbConfig.policyName.equals(targets.get(targetName).policyName)) {\n+        // Policy name change for the same target is not a typical usecase, but we should support", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MDIwOA==", "bodyText": "We may want to make a utility method for this, as it is used in a couple of places (for any load balancers that contain a bunch of child balancers).", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386590208", "createdAt": "2020-03-02T19:07:09Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.\n+   * The list must not be empty and must not contain duplicate lb configs.\n+   */\n+  WeightedTargetLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        checkNotNull(lbRegistry, \"lbRegistry\"),\n+        WeightedPickerFactory.RANDOM_PICKER_FACTORY);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancer(\n+      Helper helper, LoadBalancerRegistry lbRegistry, WeightedPickerFactory weightedPickerFactory) {\n+    this.helper = helper;\n+    this.lbRegistry = lbRegistry;\n+    this.weightedPickerFactory = weightedPickerFactory;\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    Object lbConfig = resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(lbConfig, \"missing weighted_target lb config\");\n+\n+    WeightedTargetConfig weightedTargetConfig = (WeightedTargetConfig) lbConfig;\n+    Map<String, WeightedChildLbConfig> newTargets = weightedTargetConfig.targets;\n+\n+    for (String targetName : newTargets.keySet()) {\n+      WeightedChildLbConfig weightedChildLbConfig = newTargets.get(targetName);\n+      if (!targets.containsKey(targetName)) {\n+        // Create child balancers for new names.\n+        ChildHelper childHelper = new ChildHelper();\n+        GracefulSwitchLoadBalancer childBalancer = new GracefulSwitchLoadBalancer(childHelper);\n+        childBalancer.switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+        childHelpers.put(targetName, childHelper);\n+        childBalancers.put(targetName, childBalancer);\n+      } else if (!weightedChildLbConfig.policyName.equals(targets.get(targetName).policyName)) {\n+        // Policy name change for the same target is not a typical usecase, but we should support\n+        // it. Switch child policy.\n+        childBalancers.get(targetName)\n+            .switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+      }\n+    }\n+\n+    // Update new config map.\n+    targets = newTargets;\n+\n+    // Call handleResolvedAddresses() for each child balancer.\n+    for (String targetName : targets.keySet()) {\n+      childBalancers.get(targetName).handleResolvedAddresses(\n+          resolvedAddresses.toBuilder()\n+              .setLoadBalancingPolicyConfig(targets.get(targetName).config)\n+              .build());\n+    }\n+\n+    // Cleanup removed targets.\n+    // TODO(zdapeng): cache removed target for 15 minutes.\n+    for (String targetName : childBalancers.keySet()) {\n+      if (!targets.containsKey(targetName)) {\n+        childBalancers.get(targetName).shutdown();\n+      }\n+    }\n+    childBalancers.keySet().retainAll(targets.keySet());\n+    childHelpers.keySet().retainAll(targets.keySet());\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (childBalancers.isEmpty()) {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (LoadBalancer childBalancer : childBalancers.values()) {\n+      childBalancer.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (LoadBalancer childBalancer : childBalancers.values()) {\n+      childBalancer.shutdown();\n+    }\n+  }\n+\n+  private void updateBalancingState() {\n+    List<WeightedChildPicker> childPickers = new ArrayList<>();\n+\n+    ConnectivityState overallState = null;\n+    for (String name : targets.keySet()) {\n+      ChildHelper childHelper = childHelpers.get(name);\n+      ConnectivityState childState = childHelper.currentState;\n+      overallState = aggregateState(overallState, childState);\n+      if (READY == childState) {\n+        int weight = targets.get(name).weight;\n+        childPickers.add(new WeightedChildPicker(weight, childHelper.currentPicker));\n+      }\n+    }\n+\n+    SubchannelPicker picker;\n+    if (childPickers.isEmpty()) {\n+      if (overallState == TRANSIENT_FAILURE) {\n+        picker = new ErrorPicker(Status.UNAVAILABLE); // TODO: more details in status\n+      } else {\n+        picker = XdsSubchannelPickers.BUFFER_PICKER;\n+      }\n+    } else {\n+      picker = weightedPickerFactory.picker(childPickers);\n+    }\n+\n+    if (overallState != null) {\n+      helper.updateBalancingState(overallState, picker);\n+    }\n+  }\n+\n+  @Nullable\n+  private ConnectivityState aggregateState(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5Njc3MA==", "bodyText": "WeightedRandomPicker sounds better.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386596770", "createdAt": "2020-03-02T19:19:07Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/RandomWeightedPicker.java", "diffHunk": "@@ -27,7 +27,7 @@\n import io.grpc.LoadBalancer.SubchannelPicker;\n import java.util.List;\n \n-final class InterLocalityPicker extends SubchannelPicker {\n+final class RandomWeightedPicker extends SubchannelPicker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwMzUwMg==", "bodyText": "Maybe we do not need both RandomWeightedPicker and WeightedPickerFactory (I feel like we are introducing many classes/interfaces that do not seem to be necessary).\nfinal class WeightedRamdomPicker {  // or some better class name\n   private final Random rand;\n   WeightedRamdonPicker(Random rand) {\n      this.rand = rand;\n   }\n   SubchannelPicker picker(List<WeightedChildPicker> childPickers) {  // or some better method name\n      // compute total weight for the list of child pickers, randomly choose one.\n   }\n}", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386603502", "createdAt": "2020-03-02T19:31:09Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/RandomWeightedPicker.java", "diffHunk": "@@ -116,4 +116,17 @@ public String toString() {\n         .add(\"totalWeight\", totalWeight)\n         .toString();\n   }\n+\n+  /** Factory that creates a SubchannelPicker for a given list of weighted child pickers. */\n+  interface WeightedPickerFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDc1ODk0", "url": "https://github.com/grpc/grpc-java/pull/6731#pullrequestreview-367475894", "createdAt": "2020-03-02T19:43:55Z", "commit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOTo0Mzo1NVrOFwsyug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOTo0Mzo1NVrOFwsyug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwOTg1MA==", "bodyText": "nit: you don't need WeightedTargetLoadBalancer.this (may need to change the method name updateBalancingState()).", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r386609850", "createdAt": "2020-03-02T19:43:55Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.RandomWeightedPicker.WeightedChildPicker;\n+import io.grpc.xds.RandomWeightedPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedChildLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedChildLbConfig> targets = ImmutableMap.of();\n+\n+  /**\n+   * Constructs a WeightedTargetLoadBalancer with the given weighted list of child balancer configs.\n+   * The list must not be empty and must not contain duplicate lb configs.\n+   */\n+  WeightedTargetLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        checkNotNull(lbRegistry, \"lbRegistry\"),\n+        WeightedPickerFactory.RANDOM_PICKER_FACTORY);\n+  }\n+\n+  @VisibleForTesting\n+  WeightedTargetLoadBalancer(\n+      Helper helper, LoadBalancerRegistry lbRegistry, WeightedPickerFactory weightedPickerFactory) {\n+    this.helper = helper;\n+    this.lbRegistry = lbRegistry;\n+    this.weightedPickerFactory = weightedPickerFactory;\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    Object lbConfig = resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(lbConfig, \"missing weighted_target lb config\");\n+\n+    WeightedTargetConfig weightedTargetConfig = (WeightedTargetConfig) lbConfig;\n+    Map<String, WeightedChildLbConfig> newTargets = weightedTargetConfig.targets;\n+\n+    for (String targetName : newTargets.keySet()) {\n+      WeightedChildLbConfig weightedChildLbConfig = newTargets.get(targetName);\n+      if (!targets.containsKey(targetName)) {\n+        // Create child balancers for new names.\n+        ChildHelper childHelper = new ChildHelper();\n+        GracefulSwitchLoadBalancer childBalancer = new GracefulSwitchLoadBalancer(childHelper);\n+        childBalancer.switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+        childHelpers.put(targetName, childHelper);\n+        childBalancers.put(targetName, childBalancer);\n+      } else if (!weightedChildLbConfig.policyName.equals(targets.get(targetName).policyName)) {\n+        // Policy name change for the same target is not a typical usecase, but we should support\n+        // it. Switch child policy.\n+        childBalancers.get(targetName)\n+            .switchTo(lbRegistry.getProvider(weightedChildLbConfig.policyName));\n+      }\n+    }\n+\n+    // Update new config map.\n+    targets = newTargets;\n+\n+    // Call handleResolvedAddresses() for each child balancer.\n+    for (String targetName : targets.keySet()) {\n+      childBalancers.get(targetName).handleResolvedAddresses(\n+          resolvedAddresses.toBuilder()\n+              .setLoadBalancingPolicyConfig(targets.get(targetName).config)\n+              .build());\n+    }\n+\n+    // Cleanup removed targets.\n+    // TODO(zdapeng): cache removed target for 15 minutes.\n+    for (String targetName : childBalancers.keySet()) {\n+      if (!targets.containsKey(targetName)) {\n+        childBalancers.get(targetName).shutdown();\n+      }\n+    }\n+    childBalancers.keySet().retainAll(targets.keySet());\n+    childHelpers.keySet().retainAll(targets.keySet());\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (childBalancers.isEmpty()) {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (LoadBalancer childBalancer : childBalancers.values()) {\n+      childBalancer.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (LoadBalancer childBalancer : childBalancers.values()) {\n+      childBalancer.shutdown();\n+    }\n+  }\n+\n+  private void updateBalancingState() {\n+    List<WeightedChildPicker> childPickers = new ArrayList<>();\n+\n+    ConnectivityState overallState = null;\n+    for (String name : targets.keySet()) {\n+      ChildHelper childHelper = childHelpers.get(name);\n+      ConnectivityState childState = childHelper.currentState;\n+      overallState = aggregateState(overallState, childState);\n+      if (READY == childState) {\n+        int weight = targets.get(name).weight;\n+        childPickers.add(new WeightedChildPicker(weight, childHelper.currentPicker));\n+      }\n+    }\n+\n+    SubchannelPicker picker;\n+    if (childPickers.isEmpty()) {\n+      if (overallState == TRANSIENT_FAILURE) {\n+        picker = new ErrorPicker(Status.UNAVAILABLE); // TODO: more details in status\n+      } else {\n+        picker = XdsSubchannelPickers.BUFFER_PICKER;\n+      }\n+    } else {\n+      picker = weightedPickerFactory.picker(childPickers);\n+    }\n+\n+    if (overallState != null) {\n+      helper.updateBalancingState(overallState, picker);\n+    }\n+  }\n+\n+  @Nullable\n+  private ConnectivityState aggregateState(\n+      @Nullable ConnectivityState overallState, ConnectivityState childState) {\n+    if (overallState == null) {\n+      return childState;\n+    }\n+    if (overallState == READY || childState == READY) {\n+      return READY;\n+    }\n+    if (overallState == CONNECTING || childState == CONNECTING) {\n+      return CONNECTING;\n+    }\n+    if (overallState == IDLE || childState == IDLE) {\n+      return IDLE;\n+    }\n+    return overallState;\n+  }\n+\n+  private final class ChildHelper extends ForwardingLoadBalancerHelper {\n+    ConnectivityState currentState = CONNECTING;\n+    SubchannelPicker currentPicker = BUFFER_PICKER;\n+\n+    @Override\n+    public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+      currentState = newState;\n+      currentPicker = newPicker;\n+      WeightedTargetLoadBalancer.this.updateBalancingState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d402a0d2aed77afe16fa9cdd9cf23819c78474"}, "originalPosition": 208}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5014be7307fd6605dc6f9c8988214efac86d0b32", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/5014be7307fd6605dc6f9c8988214efac86d0b32", "committedDate": "2020-03-03T01:21:46Z", "message": "fix nits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c847c313d26a65027f5a76a773a38aaf964e712d", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/c847c313d26a65027f5a76a773a38aaf964e712d", "committedDate": "2020-03-03T18:25:13Z", "message": "move RANDOM_PICKER_FACTORY out of factory interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfa75cb6e21119d15ff554ffb4bd008437704152", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/dfa75cb6e21119d15ff554ffb4bd008437704152", "committedDate": "2020-03-03T19:25:49Z", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java into weighted-target-2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca6c100598a78dcd400a7d51a396e5f7870bbfaa", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/ca6c100598a78dcd400a7d51a396e5f7870bbfaa", "committedDate": "2020-03-03T19:57:17Z", "message": "use refactored PolicySelection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c33dac834452f0b7a1fb3a5a32073334f4157ef", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/3c33dac834452f0b7a1fb3a5a32073334f4157ef", "committedDate": "2020-03-04T18:36:04Z", "message": "fix build"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzEyNTI3", "url": "https://github.com/grpc/grpc-java/pull/6731#pullrequestreview-370712527", "createdAt": "2020-03-07T01:55:15Z", "commit": {"oid": "3c33dac834452f0b7a1fb3a5a32073334f4157ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo1NToxNVrOFzL4vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMTo1NToxNVrOFzL4vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNjQ0NQ==", "bodyText": "This class structure does not help with testing at all, as in order to provide your own random number generator in test, you have to implement a fake WeightedPickerFactory instance whose picker(...) method creates a fake SubchannelPicker. So everything about picking is fake. This tests nothing.\nInstead, a better strategy is to not have this constructor at all. You implementation code should always call the constructor with injectable random number generator. In that way, your test code is  still executing the real WeightedRandomPicker but only with the random number generator being faked out.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r389216445", "createdAt": "2020-03-07T01:55:15Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedRandomPicker.java", "diffHunk": "@@ -62,12 +62,12 @@ public String toString() {\n     }\n   }\n \n-  InterLocalityPicker(List<WeightedChildPicker> weightedChildPickers) {\n+  WeightedRandomPicker(List<WeightedChildPicker> weightedChildPickers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c33dac834452f0b7a1fb3a5a32073334f4157ef"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzE0MTc3", "url": "https://github.com/grpc/grpc-java/pull/6731#pullrequestreview-370714177", "createdAt": "2020-03-07T02:12:40Z", "commit": {"oid": "3c33dac834452f0b7a1fb3a5a32073334f4157ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMjoxMjo0MFrOFzL_aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwMjoxMjo0MFrOFzL_aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxODE1Mg==", "bodyText": "This looks bad... You should rather call constructor to create a factory or call the factory class to get the instance. At least, not something that is not the factory itself.", "url": "https://github.com/grpc/grpc-java/pull/6731#discussion_r389218152", "createdAt": "2020-03-07T02:12:40Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/WeightedTargetLoadBalancer.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.WeightedRandomPicker.WeightedChildPicker;\n+import io.grpc.xds.WeightedRandomPicker.WeightedPickerFactory;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for weighted_target policy. */\n+final class WeightedTargetLoadBalancer extends LoadBalancer {\n+\n+  private final XdsLogger logger;\n+  private final Map<String, GracefulSwitchLoadBalancer> childBalancers = new HashMap<>();\n+  private final Map<String, ChildHelper> childHelpers = new HashMap<>();\n+  private final Helper helper;\n+  private final WeightedPickerFactory weightedPickerFactory;\n+\n+  private Map<String, WeightedPolicySelection> targets = ImmutableMap.of();\n+\n+  WeightedTargetLoadBalancer(Helper helper) {\n+    this(\n+        checkNotNull(helper, \"helper\"),\n+        WeightedRandomPicker.RANDOM_PICKER_FACTORY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c33dac834452f0b7a1fb3a5a32073334f4157ef"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c22b8239f19047b3037e2ce4321055fb64d8b0a0", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/c22b8239f19047b3037e2ce4321055fb64d8b0a0", "committedDate": "2020-03-09T17:40:25Z", "message": "call factory.INSTANCE"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "365f33dc4ccdee08c741cc18125fb12f8b5d29b2", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/365f33dc4ccdee08c741cc18125fb12f8b5d29b2", "committedDate": "2020-03-09T19:19:14Z", "message": "revise tests"}, "afterCommit": {"oid": "5a7e7325e7f7c333b5ec2fcca197d71994c37bca", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/5a7e7325e7f7c333b5ec2fcca197d71994c37bca", "committedDate": "2020-03-09T19:42:38Z", "message": "revise tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a7e7325e7f7c333b5ec2fcca197d71994c37bca", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/5a7e7325e7f7c333b5ec2fcca197d71994c37bca", "committedDate": "2020-03-09T19:42:38Z", "message": "revise tests"}, "afterCommit": {"oid": "ca310f12b1ef2b2cdb3236c872f5810c5871469c", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/ca310f12b1ef2b2cdb3236c872f5810c5871469c", "committedDate": "2020-03-09T19:45:55Z", "message": "revise tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b4ed3ded00cd4004b23d28498b1b179762b137a", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/9b4ed3ded00cd4004b23d28498b1b179762b137a", "committedDate": "2020-03-09T19:57:43Z", "message": "revise tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ca310f12b1ef2b2cdb3236c872f5810c5871469c", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/ca310f12b1ef2b2cdb3236c872f5810c5871469c", "committedDate": "2020-03-09T19:45:55Z", "message": "revise tests"}, "afterCommit": {"oid": "9b4ed3ded00cd4004b23d28498b1b179762b137a", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/9b4ed3ded00cd4004b23d28498b1b179762b137a", "committedDate": "2020-03-09T19:57:43Z", "message": "revise tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecc6042103b875d13142c346e79737d1ad8afc4c", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/ecc6042103b875d13142c346e79737d1ad8afc4c", "committedDate": "2020-03-09T22:37:42Z", "message": "not using immutable copy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTk4NDg2", "url": "https://github.com/grpc/grpc-java/pull/6731#pullrequestreview-371598486", "createdAt": "2020-03-09T23:45:15Z", "commit": {"oid": "ecc6042103b875d13142c346e79737d1ad8afc4c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4588, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}