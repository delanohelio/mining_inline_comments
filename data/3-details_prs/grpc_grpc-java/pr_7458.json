{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyODM5MDcz", "number": 7458, "title": "xds: refactor resource subscription implementation in XdsClient", "bodyText": "This would be a great maintainability improvement for XdsClientImpl.\nShould have no behavior change.\nCurrently for each type of resources, there are multiple pieces: watchers, cached entries, initial fetch timer, etc. Every time newly subscribing to a new resource or receiving a response, these pieces of state need to be updated individually. This is complicated to maintain and there is a lot of duplicated code. This PR groups status of a subscribed resource into ResourceSubscriber. You can think of it for tracking the state of a single resource.\nEvery time newly subscribing to some resource, a corresponding ResourceSubscriber is created. Note it does not control the resource discovery RPCs. It is still the XdsClient that sends RPCs for with all subscribed resource names for each type. A ResourceSubscriber can have the following states:\n\n\nWhen the initial resource fetch timer (respTimer) is pending, the resource is under discovery, the resource data is unknown. Even if the XdsClient receives a response not containing the corresponding resource, it does not mean the resource is absent. We still need to wait until a response containing the resource data coming or the timer being fired. The timer is scheduled when the ResourceSubscriber is created. So the XdsClient should always create the corresponding ResourceSubscriber when it starts to subscribe a new resource.\n\n\nIf the resource fetch timer is not pending, we must know the existence of the resource data. If data field is set, it is the most recently received resource data (aka, cached entry). Otherwise, absent field is set to true, indicating the resource does not exist.\n\n\nThe exceptional case is when the ADS stream is closed and in the retry backoff period. During that period, respTimer is cancelled and the resource existence may or may not be known. Once the backoff finishes, the XdsClient will reschedule the respTimer when it recreates the ADS stream and re-request all the resources.\n\nTODO: need to check with Mark do we really want to reschedule the initial resource fetch timer for recreated ADS stream. As now the xDS version_info is persistent across ADS streams and the management server is allowed to not send resources that previously sent after the ADS stream is recreated.\nUpdate: the initial resource fetch timer should only be scheduled when sending requests for a resource that its existence is not known. Will address this issue in a later PR. This PR will keep the existing behavior.\n\n\n\nWatchers can be added to existing ResourceSubscribers. At the time the watcher is added, its callback will be invoked if we've already known the existence of the resource. Otherwise, the watcher will just sit there and wait data or absence to come in the future.\nEvery time after processing the xDS response, the extracted and validated resource data (or absence) will be put into each corresponding ResourceSubscribe. Then watchers may be invoked.\n\nWill do the same for LDS/RDS in next PR and replace the existing ConfigWatcher.", "createdAt": "2020-09-25T05:17:57Z", "url": "https://github.com/grpc/grpc-java/pull/7458", "merged": true, "mergeCommit": {"oid": "2adeff56fe64e36e75f5f299a957666266c02ff3"}, "closed": true, "closedAt": "2020-09-28T20:43:42Z", "author": {"login": "voidzcy"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMOtv5AH2gAyNDkyODM5MDczOjk3MmZmYjJmNmU4NmIzZTRmZTc3ZjEwMmJlZWNjZDY1NDEyZjhmYzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNZU5RAFqTQ5Nzg1ODQyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "972ffb2f6e86b3e4fe77f102beeccd65412f8fc6", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/972ffb2f6e86b3e4fe77f102beeccd65412f8fc6", "committedDate": "2020-09-25T05:12:58Z", "message": "Create a ResourceUpdate facade to tracking all types of resources under subscription."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "465c176e0e011a1efbfb1be454957559abcc33a3", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/465c176e0e011a1efbfb1be454957559abcc33a3", "committedDate": "2020-09-25T05:15:17Z", "message": "Introduce ResourceSubscriber, which encapsulates the whole tracking logic (initial subscription timeout, data cache, watchers, etc) for a single subscribed resource."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d4ef905430b72f809e614914e9284d345986af0", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/2d4ef905430b72f809e614914e9284d345986af0", "committedDate": "2020-09-25T05:15:55Z", "message": "Fixed the way of verifying scheduled resource fetching timer in tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/78aaf2b2aa348bd6b5ad36ee180f087f563f9508", "committedDate": "2020-09-28T17:02:45Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into refactor/encapsulate_resource_subscription_logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzY1NzE4", "url": "https://github.com/grpc/grpc-java/pull/7458#pullrequestreview-497765718", "createdAt": "2020-09-28T17:52:43Z", "commit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo1Mjo0M1rOHZJb8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTowMDoxM1rOHZLr7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzMTA1Nw==", "bodyText": "nit: Move this line inside the if block blow.", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496131057", "createdAt": "2020-09-28T17:52:43Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1025,63 +891,26 @@ private void handleCdsResponse(DiscoveryResponseData cdsResponse) {\n     if (errorMessage != null) {\n       adsStream.sendNackRequest(\n           ResourceType.CDS,\n-          cdsWatchers.keySet(),\n+          cdsResourceSubscribers.keySet(),\n           cdsResponse.getVersionInfo(),\n           errorMessage);\n       return;\n     }\n-    adsStream.sendAckRequest(ResourceType.CDS, cdsWatchers.keySet(),\n+    adsStream.sendAckRequest(ResourceType.CDS, cdsResourceSubscribers.keySet(),\n         cdsResponse.getVersionInfo());\n \n-    // Update local CDS cache with data in this response.\n-    absentCdsResources.removeAll(cdsUpdates.keySet());\n-    for (Map.Entry<String, CdsUpdate> entry : clusterNamesToCdsUpdates.entrySet()) {\n-      if (!cdsUpdates.containsKey(entry.getKey())) {\n-        // Some previously existing resource no longer exists.\n-        absentCdsResources.add(entry.getKey());\n-      } else if (cdsUpdates.get(entry.getKey()).equals(entry.getValue())) {\n-        cdsUpdates.remove(entry.getKey());\n-      }\n-    }\n-    clusterNamesToCdsUpdates.keySet().removeAll(absentCdsResources);\n-    clusterNamesToCdsUpdates.putAll(cdsUpdates);\n-\n-    // Remove EDS cache entries for ClusterLoadAssignments not referenced by this CDS response.\n-    for (String clusterName : clusterNamesToEdsUpdates.keySet()) {\n-      if (!edsServices.contains(clusterName)) {\n-        absentEdsResources.add(clusterName);\n-        // Notify EDS resource removal to watchers.\n-        if (edsWatchers.containsKey(clusterName)) {\n-          Set<EdsResourceWatcher> watchers = edsWatchers.get(clusterName);\n-          for (EdsResourceWatcher watcher : watchers) {\n-            watcher.onResourceDoesNotExist(clusterName);\n-          }\n-        }\n-      }\n-    }\n-    clusterNamesToEdsUpdates.keySet().retainAll(edsServices);\n-\n-    for (String clusterName : cdsUpdates.keySet()) {\n-      if (cdsRespTimers.containsKey(clusterName)) {\n-        cdsRespTimers.get(clusterName).cancel();\n-        cdsRespTimers.remove(clusterName);\n+    for (String resource : cdsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = cdsResourceSubscribers.get(resource);\n+      if (cdsUpdates.containsKey(resource)) {\n+        subscriber.onData(cdsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n       }\n     }\n-\n-    // Notify watchers if clusters interested in present in this CDS response.\n-    for (Map.Entry<String, Set<CdsResourceWatcher>> entry : cdsWatchers.entrySet()) {\n-      String clusterName = entry.getKey();\n-      if (cdsUpdates.containsKey(entry.getKey())) {\n-        CdsUpdate cdsUpdate = cdsUpdates.get(clusterName);\n-        for (CdsResourceWatcher watcher : entry.getValue()) {\n-          watcher.onChanged(cdsUpdate);\n-        }\n-      } else if (!clusterNamesToCdsUpdates.containsKey(entry.getKey())\n-          && !cdsRespTimers.containsKey(clusterName)) {\n-        // Update for previously present resource being removed.\n-        for (CdsResourceWatcher watcher : entry.getValue()) {\n-          watcher.onResourceDoesNotExist(entry.getKey());\n-        }\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTk1Mg==", "bodyText": "Need override equals() for LdsUpdate and RdsUpdate.", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496145952", "createdAt": "2020-09-28T18:19:56Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1333,6 +1150,131 @@ static ResourceType fromTypeUrl(String typeUrl) {\n     }\n   }\n \n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 559}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE2NzkxNw==", "bodyText": "Is it equivalent to\nif (!absent) {\n  absent = true;\n  data = null;\n  for (ResourceWatcher watcher : watchers) {\n    watcher.onResourceDoesNotExist(resource);\n  }\n}\n?", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496167917", "createdAt": "2020-09-28T19:00:13Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1333,6 +1150,131 @@ static ResourceType fromTypeUrl(String typeUrl) {\n     }\n   }\n \n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {\n+        for (ResourceWatcher watcher : watchers) {\n+          notifyWatcher(watcher, data);\n+        }\n+      }\n+    }\n+\n+    void onAbsent() {\n+      if (respTimer != null && respTimer.isPending()) {  // too early to conclude absence\n+        return;\n+      }\n+      boolean oldAbsent = absent;\n+      data = null;\n+      absent = true;\n+      if (!oldAbsent) {\n+        for (ResourceWatcher watcher : watchers) {\n+          watcher.onResourceDoesNotExist(resource);\n+        }\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 577}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76711e165cbe3b92ac52de33ce3b40d2337126a6", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/76711e165cbe3b92ac52de33ce3b40d2337126a6", "committedDate": "2020-09-28T19:14:59Z", "message": "Implement equality methods for LdsUpdate."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaebd947dc114e2ac4fe2400bfb93154f4853793", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/aaebd947dc114e2ac4fe2400bfb93154f4853793", "committedDate": "2020-09-28T19:34:11Z", "message": "Fix minor style issues."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODU4NDI0", "url": "https://github.com/grpc/grpc-java/pull/7458#pullrequestreview-497858424", "createdAt": "2020-09-28T20:08:42Z", "commit": {"oid": "aaebd947dc114e2ac4fe2400bfb93154f4853793"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4058, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}