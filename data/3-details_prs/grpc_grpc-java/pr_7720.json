{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM2MzU5NDc2", "number": 7720, "title": " check pending stream completion at delayed transport lifecycle", "bodyText": "To fix #6283\nProblem\nThe issue was that delayedClientTransport reprocess() schedules work createRealStream() but does not track whether it is committed, i.e. the real stream done set to the delayed stream which completes the delegation. Because it does not track the completion, shutdown prematurely goes through and then executor was destroyed.\nThe inflight work that has been scheduled happen to use the same executor, causing RejectedExecutionException\n t1-Thread0:delayedTransport.reprocess()                            t3-Thread1:createRealStream()`RejectedExecutionException`        \n                                          t2-Thread0:shutdownNow() \n\nReproduce\nThe problem can be reproduced by putting a pause at createRealStream(), and then run a client call.\n\n  \n    \n      grpc-java/core/src/main/java/io/grpc/internal/DelayedStream.java\n    \n    \n         Line 140\n      in\n      ddaf1c8\n    \n    \n    \n    \n\n        \n          \n           private void drainPendingCalls() { \n        \n    \n  \n\n\n  private void drainPendingCalls() {\n      Thread.sleep(3000);\n ...", "createdAt": "2020-12-11T00:20:14Z", "url": "https://github.com/grpc/grpc-java/pull/7720", "merged": true, "mergeCommit": {"oid": "90850128a60dcb45282063ff6de98603e02d4de7"}, "closed": true, "closedAt": "2020-12-21T19:56:52Z", "author": {"login": "YifeiZhuang"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdk5TGzAH2gAyNTM2MzU5NDc2OmFjOTk5NzI0Yjk2MTAyNjZhMThkMTYyODMwYWFmZjdlNmJlZjVkNzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdoa-lnAFqTU1NjYwODcxNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ac999724b9610266a18d162830aaff7e6bef5d72", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/ac999724b9610266a18d162830aaff7e6bef5d72", "committedDate": "2020-12-10T20:23:58Z", "message": "check pending stream completion at delayed transport lifecycle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fe3bcea1d62dba739e36ac730caad1a78769c97", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/1fe3bcea1d62dba739e36ac730caad1a78769c97", "committedDate": "2020-12-10T22:40:40Z", "message": "rename"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTM1MDg0", "url": "https://github.com/grpc/grpc-java/pull/7720#pullrequestreview-550535084", "createdAt": "2020-12-11T19:56:25Z", "commit": {"oid": "1fe3bcea1d62dba739e36ac730caad1a78769c97"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTo1NjoyNVrOIEJmkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQyMDo0NDoyNFrOIEMexQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyMjU0Ng==", "bodyText": "You don't need the check, can always count down.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541222546", "createdAt": "2020-12-11T19:56:25Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/DelayedStream.java", "diffHunk": "@@ -302,7 +325,11 @@ public void run() {\n         listenerToClose.closed(reason, new Metadata());\n       }\n       drainPendingCalls();\n+      if (!isStreamTransferCompleted()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fe3bcea1d62dba739e36ac730caad1a78769c97"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNDQ4NQ==", "bodyText": "Where is this signal checked? Why interrupting the cancellation thread works?", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541224485", "createdAt": "2020-12-11T19:58:38Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/DelayedStream.java", "diffHunk": "@@ -132,6 +135,24 @@ final void setStream(ClientStream stream) {\n     drainPendingCalls();\n   }\n \n+  protected boolean isStreamTransferCompleted() {\n+    return realStreamStarted.getCount() == 0;\n+  }\n+\n+  protected void awaitStreamTransferCompletion() {\n+    // Wait until accepted RPCs transfer to the real stream so that we can properly cancel or\n+    // shutdown. Not waiting for transfer completion may cause pending calls orphaned. #636.\n+    boolean delegationComplete;\n+    try {\n+      delegationComplete = realStreamStarted.await(5, TimeUnit.SECONDS);\n+    } catch (InterruptedException ex) {\n+      delegationComplete = false;\n+    }\n+    if (!delegationComplete) {\n+      Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fe3bcea1d62dba739e36ac730caad1a78769c97"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1MDY5OA==", "bodyText": "The wait seems useless here. If it is delegating to realStream, all pending calls should have already been drained (the delayOrExecute for realStream.cancel() several lines above might be misleading, it's actually always executed inline). So at this point, the transfer is guaranteed to be done.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541250698", "createdAt": "2020-12-11T20:24:21Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/DelayedStream.java", "diffHunk": "@@ -302,7 +325,11 @@ public void run() {\n         listenerToClose.closed(reason, new Metadata());\n       }\n       drainPendingCalls();\n+      if (!isStreamTransferCompleted()) {\n+        realStreamStarted.countDown();\n+      }\n     }\n+    awaitStreamTransferCompletion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fe3bcea1d62dba739e36ac730caad1a78769c97"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI1NzIyMQ==", "bodyText": "nit: public is redundant and this should be @VisibleForTesting .\nBut since there is already a getUncommittedStreamsCount() for testing, I don't think this method is useful anymore. All invocations to this method are already holding the lock and calling !toCheckCompletionStreams.isEmpty() is equally concise as calling this method.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541257221", "createdAt": "2020-12-11T20:31:07Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -252,13 +277,26 @@ public final boolean hasPendingStreams() {\n     }\n   }\n \n+  public final boolean hasUncommittedStreams() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fe3bcea1d62dba739e36ac730caad1a78769c97"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTI2OTcwMQ==", "bodyText": "May not want to make excessive changes.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r541269701", "createdAt": "2020-12-11T20:44:24Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -322,9 +373,10 @@ public void run() {\n         // transport starting streams and setting in-use state.  During the gap the whole channel's\n         // in-use state may be false. However, it shouldn't cause spurious switching to idleness\n         // (which would shutdown the transports and LoadBalancer) because the gap should be shorter\n-        // than IDLE_MODE_DEFAULT_TIMEOUT_MILLIS (1 second).\n+        // than IDLE_MODE_DEFAULT_TIMEOUT_MILLIS (30 millis).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fe3bcea1d62dba739e36ac730caad1a78769c97"}, "originalPosition": 179}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91", "committedDate": "2020-12-14T05:37:31Z", "message": "fix travis test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxNzcwOTU1", "url": "https://github.com/grpc/grpc-java/pull/7720#pullrequestreview-551770955", "createdAt": "2020-12-14T18:21:35Z", "commit": {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODoyMTozNlrOIFeEwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOToxNDowNFrOIFhtIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYwNjUyOQ==", "bodyText": "Make it final?", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542606529", "createdAt": "2020-12-14T18:21:36Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -66,6 +66,23 @@\n   @Nonnull\n   @GuardedBy(\"lock\")\n   private Collection<PendingStream> pendingStreams = new LinkedHashSet<>();\n+  @GuardedBy(\"lock\")\n+  private Collection<PendingStream> toCheckCompletionStreams = new LinkedHashSet<>();\n+  private Runnable pollForStreamTransferCompletion = new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzMzcwMg==", "bodyText": "Note that getCount() is typically used for debugging and testing purposes. https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CountDownLatch.html#getCount()\nBetter avoid it in the main source if possible.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542633702", "createdAt": "2020-12-14T18:46:12Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedStream.java", "diffHunk": "@@ -132,6 +135,24 @@ final void setStream(ClientStream stream) {\n     drainPendingCalls();\n   }\n \n+  protected boolean isStreamTransferCompleted() {\n+    return realStreamStarted.getCount() == 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY1NzA3Mg==", "bodyText": "I would prefer making toCheckCompletionStreams be either 'non-final and immutable' or 'final and mutable', but not 'non-final' and 'mutable'.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542657072", "createdAt": "2020-12-14T19:05:57Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -270,48 +308,61 @@ final int getPendingStreamsCount() {\n    * <p>This method <strong>must not</strong> be called concurrently with itself.\n    */\n   final void reprocess(@Nullable SubchannelPicker picker) {\n-    ArrayList<PendingStream> toProcess;\n+    ArrayList<PendingStream> toCreateRealStream;\n+    ArrayList<PendingStream> toCheckCompletion;\n     synchronized (lock) {\n       lastPicker = picker;\n       lastPickerVersion++;\n-      if (picker == null || !hasPendingStreams()) {\n+      if ((picker == null || !hasPendingStreams()) && !hasUncommittedStreams()) {\n         return;\n       }\n-      toProcess = new ArrayList<>(pendingStreams);\n+      toCreateRealStream = new ArrayList<>(pendingStreams);\n+      toCheckCompletion = new ArrayList<>(toCheckCompletionStreams);\n     }\n-    ArrayList<PendingStream> toRemove = new ArrayList<>();\n+    ArrayList<PendingStream> newlyCreated = new ArrayList<>();\n \n-    for (final PendingStream stream : toProcess) {\n-      PickResult pickResult = picker.pickSubchannel(stream.args);\n-      CallOptions callOptions = stream.args.getCallOptions();\n-      final ClientTransport transport = GrpcUtil.getTransportFromPickResult(pickResult,\n-          callOptions.isWaitForReady());\n-      if (transport != null) {\n-        Executor executor = defaultAppExecutor;\n-        // createRealStream may be expensive. It will start real streams on the transport. If\n-        // there are pending requests, they will be serialized too, which may be expensive. Since\n-        // we are now on transport thread, we need to offload the work to an executor.\n-        if (callOptions.getExecutor() != null) {\n-          executor = callOptions.getExecutor();\n-        }\n-        executor.execute(new Runnable() {\n+\n+    if (picker != null) {\n+      for (final PendingStream stream : toCreateRealStream) {\n+        PickResult pickResult = picker.pickSubchannel(stream.args);\n+        CallOptions callOptions = stream.args.getCallOptions();\n+        final ClientTransport transport = GrpcUtil.getTransportFromPickResult(pickResult,\n+            callOptions.isWaitForReady());\n+        if (transport != null) {\n+          Executor executor = defaultAppExecutor;\n+          // createRealStream may be expensive. It will start real streams on the transport. If\n+          // there are pending requests, they will be serialized too, which may be expensive. Since\n+          // we are now on transport thread, we need to offload the work to an executor.\n+          if (callOptions.getExecutor() != null) {\n+            executor = callOptions.getExecutor();\n+          }\n+          executor.execute(new Runnable() {\n             @Override\n             public void run() {\n               stream.createRealStream(transport);\n             }\n           });\n-        toRemove.add(stream);\n-      }  // else: stay pending\n+          newlyCreated.add(stream);\n+        }  // else: stay pending\n+      }\n+    }\n+    toCheckCompletion.addAll(newlyCreated);\n+    ArrayList<PendingStream> completed = new ArrayList<>();\n+    for (final PendingStream stream : toCheckCompletion) {\n+      if (stream.isStreamTransferCompleted()) {\n+        completed.add(stream);\n+      }\n     }\n-\n     synchronized (lock) {\n       // Between this synchronized and the previous one:\n       //   - Streams may have been cancelled, which may turn pendingStreams into emptiness.\n-      //   - shutdown() may be called, which may turn pendingStreams into null.\n-      if (!hasPendingStreams()) {\n+      //   - shutdownNow() may be called, which may turn pendingStreams into emptiness.\n+      if (!hasPendingStreams() && !hasUncommittedStreams()) {\n         return;\n       }\n-      pendingStreams.removeAll(toRemove);\n+      pendingStreams.removeAll(newlyCreated);\n+      toCheckCompletionStreams.addAll(newlyCreated);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY2MjgxMQ==", "bodyText": "What about using the same name for toCheckCompletionStreams and uncommittedStreams?", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542662811", "createdAt": "2020-12-14T19:11:11Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -252,13 +277,26 @@ public final boolean hasPendingStreams() {\n     }\n   }\n \n+  public final boolean hasUncommittedStreams() {\n+    synchronized (lock) {\n+      return !toCheckCompletionStreams.isEmpty();\n+    }\n+  }\n+\n   @VisibleForTesting\n   final int getPendingStreamsCount() {\n     synchronized (lock) {\n       return pendingStreams.size();\n     }\n   }\n \n+  @VisibleForTesting\n+  final int getUncommittedStreamsCount() {\n+    synchronized (lock) {\n+      return toCheckCompletionStreams.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY2NjAxOQ==", "bodyText": "You don't need copy the list, just saving the reference should be sufficient.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542666019", "createdAt": "2020-12-14T19:14:04Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -66,6 +66,23 @@\n   @Nonnull\n   @GuardedBy(\"lock\")\n   private Collection<PendingStream> pendingStreams = new LinkedHashSet<>();\n+  @GuardedBy(\"lock\")\n+  private Collection<PendingStream> toCheckCompletionStreams = new LinkedHashSet<>();\n+  private Runnable pollForStreamTransferCompletion = new Runnable() {\n+    @Override\n+    public void run() {\n+      ArrayList<PendingStream> savedToCheckCompletionStreams;\n+      synchronized (lock) {\n+        savedToCheckCompletionStreams = new ArrayList<>(toCheckCompletionStreams);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxODY0NDA1", "url": "https://github.com/grpc/grpc-java/pull/7720#pullrequestreview-551864405", "createdAt": "2020-12-14T20:25:38Z", "commit": {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMDoyNTozOVrOIFmbjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMDoyNTozOVrOIFmbjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0MzQzOA==", "bodyText": "I think changing this line is not necessary. Regardless of hasUncommittedStreams, if return then stream.createRealStream() or drain() will not be called and will not cause trouble.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r542743438", "createdAt": "2020-12-14T20:25:39Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -270,48 +308,61 @@ final int getPendingStreamsCount() {\n    * <p>This method <strong>must not</strong> be called concurrently with itself.\n    */\n   final void reprocess(@Nullable SubchannelPicker picker) {\n-    ArrayList<PendingStream> toProcess;\n+    ArrayList<PendingStream> toCreateRealStream;\n+    ArrayList<PendingStream> toCheckCompletion;\n     synchronized (lock) {\n       lastPicker = picker;\n       lastPickerVersion++;\n-      if (picker == null || !hasPendingStreams()) {\n+      if ((picker == null || !hasPendingStreams()) && !hasUncommittedStreams()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1f553a81385a5b5a61033302305a84cc03f6f46", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/b1f553a81385a5b5a61033302305a84cc03f6f46", "committedDate": "2020-12-14T21:06:32Z", "message": "Fix syntax: immutability and started flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81ab463a3acfb4ef193d83dce8f22afabd24490c", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/81ab463a3acfb4ef193d83dce8f22afabd24490c", "committedDate": "2020-12-16T05:06:22Z", "message": "Revert \"Fix syntax: immutability and started flag\"\n\nThis reverts commit b1f553a81385a5b5a61033302305a84cc03f6f46."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "193eb481ed3e82257355ef1569a3bc8758d7dbe3", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/193eb481ed3e82257355ef1569a3bc8758d7dbe3", "committedDate": "2020-12-16T05:06:26Z", "message": "Revert \"fix travis test\"\n\nThis reverts commit eb188611d789c2fc0cdb7a6caa7dfbc4a6010e91."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "930437585c0d98b228173973f15b9a0ff4e5dfc9", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/930437585c0d98b228173973f15b9a0ff4e5dfc9", "committedDate": "2020-12-16T05:06:28Z", "message": "Revert \"rename\"\n\nThis reverts commit 1fe3bcea1d62dba739e36ac730caad1a78769c97."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56374ddb865ca87986ab76f26b53013cfb59980c", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/56374ddb865ca87986ab76f26b53013cfb59980c", "committedDate": "2020-12-16T05:06:29Z", "message": "Revert \"check pending stream completion at delayed transport lifecycle\"\n\nThis reverts commit ac999724b9610266a18d162830aaff7e6bef5d72."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "502429067108066fcb2840b9daa31fc3de7cf7a4", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/502429067108066fcb2840b9daa31fc3de7cf7a4", "committedDate": "2020-12-16T05:33:28Z", "message": "transfer complete abstract class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzOTk2MDU2", "url": "https://github.com/grpc/grpc-java/pull/7720#pullrequestreview-553996056", "createdAt": "2020-12-16T19:03:39Z", "commit": {"oid": "502429067108066fcb2840b9daa31fc3de7cf7a4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOTowMzo0MFrOIHUqUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOTowMzo0MFrOIHUqUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU0OTQ1Ng==", "bodyText": "nit: public redundant.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r544549456", "createdAt": "2020-12-16T19:03:40Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/TransferableClientStream.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+/**\n+ * A logical {@link ClientStream} that does internal transfer processing of the clint requests.\n+ */\n+abstract class TransferableClientStream implements ClientStream {\n+\n+  /**\n+   * Provides the place to define actions at the point when transfer is done.\n+   * Call this method to trigger those transfer completion activities. No-op by default.\n+   */\n+  public void onTransferComplete() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "502429067108066fcb2840b9daa31fc3de7cf7a4"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MzM1MTgz", "url": "https://github.com/grpc/grpc-java/pull/7720#pullrequestreview-554335183", "createdAt": "2020-12-17T07:24:20Z", "commit": {"oid": "502429067108066fcb2840b9daa31fc3de7cf7a4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzoyNDoyMFrOIHn7Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwNzo0OTo0OVrOIHosNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2NTAyNg==", "bodyText": "Why introduce yet another class? I would just add onTransferComplete() to DelayedStream (making DelayedStream abstract).", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r544865026", "createdAt": "2020-12-17T07:24:20Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/TransferableClientStream.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+/**\n+ * A logical {@link ClientStream} that does internal transfer processing of the clint requests.\n+ */\n+abstract class TransferableClientStream implements ClientStream {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "502429067108066fcb2840b9daa31fc3de7cf7a4"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2ODUwMQ==", "bodyText": "The operations should be atomic otherwise not thread-safe. Use AtomicBoolean.compareAndSet() or AtomicReferenceFieldUpdater.compareAndSet(), or check it inside lock.\nAn alternative is to guarantee onTransferComplete() is only called once per lifecycle of stream, then transferCompleted is not needed. (Currently, there is one case that cancel() and start() are in a race to call onTransferComplete(). This case can be excluded.)", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r544868501", "createdAt": "2020-12-17T07:31:53Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -362,15 +361,25 @@ private void createRealStream(ClientTransport transport) {\n     public void cancel(Status reason) {\n       super.cancel(reason);\n       synchronized (lock) {\n-        if (reportTransportTerminated != null) {\n-          boolean justRemovedAnElement = pendingStreams.remove(this);\n-          if (!hasPendingStreams() && justRemovedAnElement) {\n-            syncContext.executeLater(reportTransportNotInUse);\n-            if (shutdownStatus != null) {\n-              syncContext.executeLater(reportTransportTerminated);\n-              reportTransportTerminated = null;\n-            }\n-          }\n+        boolean justRemovedAnElement = pendingStreams.remove(this);\n+        if (!hasPendingStreams() && justRemovedAnElement && reportTransportTerminated != null) {\n+          syncContext.executeLater(reportTransportNotInUse);\n+        }\n+      }\n+      syncContext.drain();\n+    }\n+\n+    @Override\n+    public void onTransferComplete() {\n+      if (transferCompleted) {\n+        return;\n+      }\n+      transferCompleted = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "502429067108066fcb2840b9daa31fc3de7cf7a4"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3NzYyMw==", "bodyText": "No need to check reportTransportTerminated != null after the change. Previously if reportTransportTerminated == null, pendingStream is guaranteed reset to empty and justRemovedAnElement will never happen.", "url": "https://github.com/grpc/grpc-java/pull/7720#discussion_r544877623", "createdAt": "2020-12-17T07:49:49Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientTransport.java", "diffHunk": "@@ -362,15 +361,25 @@ private void createRealStream(ClientTransport transport) {\n     public void cancel(Status reason) {\n       super.cancel(reason);\n       synchronized (lock) {\n-        if (reportTransportTerminated != null) {\n-          boolean justRemovedAnElement = pendingStreams.remove(this);\n-          if (!hasPendingStreams() && justRemovedAnElement) {\n-            syncContext.executeLater(reportTransportNotInUse);\n-            if (shutdownStatus != null) {\n-              syncContext.executeLater(reportTransportTerminated);\n-              reportTransportTerminated = null;\n-            }\n-          }\n+        boolean justRemovedAnElement = pendingStreams.remove(this);\n+        if (!hasPendingStreams() && justRemovedAnElement && reportTransportTerminated != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "502429067108066fcb2840b9daa31fc3de7cf7a4"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7022f5e10c71b739443d54835736822218d533a7", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/7022f5e10c71b739443d54835736822218d533a7", "committedDate": "2020-12-17T18:07:26Z", "message": "make delayedStream abstract class and fix thread safetiness"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf2d51bfea41772bda8f7b335ce23ea2c4d10f22", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/cf2d51bfea41772bda8f7b335ce23ea2c4d10f22", "committedDate": "2020-12-17T18:26:43Z", "message": "non-final ApplierDelayedStream inner class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NjA4NzE2", "url": "https://github.com/grpc/grpc-java/pull/7720#pullrequestreview-556608716", "createdAt": "2020-12-21T19:20:06Z", "commit": {"oid": "cf2d51bfea41772bda8f7b335ce23ea2c4d10f22"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4758, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}