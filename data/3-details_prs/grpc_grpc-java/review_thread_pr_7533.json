{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MzA4NDM1", "number": 7533, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODoxMDoxOFrOEv6ibg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMTozODoyNVrOEw9Ezg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njc3NjE0OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODoxMDoxOFrOHlKyrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODoxMjozNFrOHlK4Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczNjE3NQ==", "bodyText": "This does not seem to be used anywhere. Does it mean there will be another PR for the server side to actually start using ServerXdsClient from the current XdsClientImpl2?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508736175", "createdAt": "2020-10-20T18:10:18Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86af29df1dcb2c01e2d99b013e41e7cb665cf75e"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczNzYzNQ==", "bodyText": "Yes, exactly.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508737635", "createdAt": "2020-10-20T18:12:34Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczNjE3NQ=="}, "originalCommit": {"oid": "86af29df1dcb2c01e2d99b013e41e7cb665cf75e"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjkzNTI4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo0Nzo1MlrOHlMWwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTowNTozNFrOHlM-YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTc5NA==", "bodyText": "Few comments about this sequence of actions:\n\nif adjustResourceSubscription decided to not issue a request because it's in backoffMode do you still need to set the timer?\nwhy updateNodeMetadataForListenerRequest if you are in backoffMode and not going to issue the request?\ncan the INFO log statement be issued only if a request is issued (and the timer set)?\nif the ServerXdsClient is going to be shared among multiple server instances then updating the common node instance is going to be problematic. Hopefully with the new server side API, modifying Node will not be needed. So we can ignore this problem for now\n\nI understand some of the above was existing code but I understand one of the goals is to fix whatever issues we can fix.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508761794", "createdAt": "2020-10-20T18:47:52Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatch);\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    ldsRespTimer =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86af29df1dcb2c01e2d99b013e41e7cb665cf75e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MTkzNw==", "bodyText": "if adjustResourceSubscription decided to not issue a request because it's in backoffMode do you still need to set the timer?\n\n\nYeah, this is something missed. It should check before scheduling the timer. It should call isInBackoff() to check before scheduling the timer. Good catch. Fixed it.\n\n\nwhy updateNodeMetadataForListenerRequest if you are in backoffMode and not going to issue the request?\n\n\nI think in the existing XdsClientImpl2 this is wrong. It should indeed update the Node even if currently in backoff and no request is being sent. Currently in backoff just means we should not send the request now, the retry task will send the request once the timer fires. So even if the retry timer is pending, we should set up the Node properly so that once the timer fires it picks up the latest updated Node for sending the request.\n\n\ncan the INFO log statement be issued only if a request is issued (and the timer set)?\n\n\nI think it is ok as the log just says it starts watching, which means the watcher is added, not necessarily the resource is requested. It's just for business logic level (the caller of this API does not care about how XdsClient subscribe to the resources, it just need to know that its watcher is added and will be notified later). There are other logs for requests being sent.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508771937", "createdAt": "2020-10-20T19:05:34Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatch);\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    ldsRespTimer =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTc5NA=="}, "originalCommit": {"oid": "86af29df1dcb2c01e2d99b013e41e7cb665cf75e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njk2NzMyOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1NjozMlrOHlMqCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOToxMToxMlrOHlNKww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2NjczMQ==", "bodyText": "This can be made abstract instead of returning null as I don't see any advantage of providing a default implementation.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508766731", "createdAt": "2020-10-20T18:56:32Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,762 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  Collection<String> getSubscribedResources(ResourceType type) {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9060990ca6cbcd95c5ba409bb415a9a4f1e063ba"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3NTEwNw==", "bodyText": "Sure. Made it abstract.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508775107", "createdAt": "2020-10-20T19:11:12Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,762 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  Collection<String> getSubscribedResources(ResourceType type) {\n+    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2NjczMQ=="}, "originalCommit": {"oid": "9060990ca6cbcd95c5ba409bb415a9a4f1e063ba"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njk3NzM2OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1OToxNlrOHlMwQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTozMToxNlrOHlN1DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2ODMyMw==", "bodyText": "Should it be if (!isInBackoff()) ?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508768323", "createdAt": "2020-10-20T18:59:16Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (isInBackoff()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3Mjc0MA==", "bodyText": "Oops. Sorry, my bad. Fixed.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508772740", "createdAt": "2020-10-20T19:06:55Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (isInBackoff()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2ODMyMw=="}, "originalCommit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3NTU2Nw==", "bodyText": "I highly recommend having a  unit test that checks that ldsRespTimer is not created/set if the client is in backoffMode to catch such things.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508775567", "createdAt": "2020-10-20T19:12:05Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (isInBackoff()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2ODMyMw=="}, "originalCommit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc4NTkzMg==", "bodyText": "That needs to be done for client and server side respectively. On the client side we have streamClosedAndRetryRaceWithAddRemoveWatchers. But it doesn't verify the resource subscribe timers. It can be added easily into that test case. But maybe not now. This is an existing behavior, so we should not expect anything related to it to be changed even though it is missing some tests. Also, can you take care of the server side if you want make server side test more robust?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508785932", "createdAt": "2020-10-20T19:31:16Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (isInBackoff()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2ODMyMw=="}, "originalCommit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njk4ODU3OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/ClientXdsClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTowMjowN1rOHlM3BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTowOTo0MFrOHlNHdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MDA1Mg==", "bodyText": "ServerXdsClient will also start using resources so I was thinking this can be moved up into AbstractXdsClient but we can hold off on it.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508770052", "createdAt": "2020-10-20T19:02:07Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ClientXdsClient.java", "diffHunk": "@@ -0,0 +1,840 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.grpc.xds.EnvoyProtoData.TRANSPORT_SOCKET_NAME_TLS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.util.Durations;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for client side usages.\n+ */\n+final class ClientXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+\n+  private final Object lock = new Object();\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3NDI2Mw==", "bodyText": "No, resource subscription should belong to the business logic layer. So they should be kept here. Basically, the abstract layer should only abstract away the logic of how it send/receive xDS requests/responses.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508774263", "createdAt": "2020-10-20T19:09:40Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/ClientXdsClient.java", "diffHunk": "@@ -0,0 +1,840 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.grpc.xds.EnvoyProtoData.TRANSPORT_SOCKET_NAME_TLS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.util.Durations;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for client side usages.\n+ */\n+final class ClientXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+\n+  private final Object lock = new Object();\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MDA1Mg=="}, "originalCommit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI3Mzk4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyMzozMFrOHlPlYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTozODozMlrOHlSGxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDY5MQ==", "bodyText": "Behavior of getSubscribedResources as I have understood is:\n\nthe one in ServerXdsClient returns null if no watcher set else emptyList\nthe one in ClientXdsClient returns null instead of emptyList\nover here if it is null you change it back to emptyList\n\nWhy can't we then have getSubscribedResources return emptyList instead of null? So null should never be returned unless I am missing something", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508814691", "createdAt": "2020-10-20T20:23:30Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MDE0Ng==", "bodyText": "The problem really comes from the ServerXdsClient's implementation. As you mentioned, returning null and empty list means different things for ServerXdsClient: null indicates nothing is being subscribed to and when the ADS stream is recreated, no request should be sent. While empty list does mean it is currently subscribing to the wildcard Listener resource, and a request need to be sent when the ADS stream is recreated.\nClientXdsClient's implementation will always return null if nothing being subscribed to, or a non-empty list. It has to be consistent with ServerXdsClient's semantics. It cannot return an empty list as its semantics has alreayd been taken. The abstract layer does not know if the real implementation is a ServerXdsClient or a ClientXdsClient.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508850146", "createdAt": "2020-10-20T21:27:02Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDY5MQ=="}, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NjAwNQ==", "bodyText": "Okay, thanks for the clarification. I thought the client side (ClientXdsClient) also uses wildcard queries (since they are supported for clusters and listeners) but it looks like our client-side never needs to issue wild-card queries because of the specific use-case of proxyless gRPC (unlike Envoy which uses wildcard queries to get all the clusters and listeners in the mesh).\nThe server side will also now use specific resources (assuming TD implements the new API) so the emptyList case should never happen and this code can then be cleaned up.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508856005", "createdAt": "2020-10-20T21:38:32Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDY5MQ=="}, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzU5MTY3OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1NTozNFrOHlSmvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjoxMDo1OVrOHlTAUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NDE4OA==", "bodyText": "Can you just call handleStreamRestarted() to eliminate code duplication? because you are using constants etc it will be helpful in eliminating trivial errors.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508864188", "createdAt": "2020-10-20T21:55:34Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (!isInBackoff()) {\n+      ldsRespTimer =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg3MDczNw==", "bodyText": "No, that's wrong. handleStreamRestarted() should be effectively abstract, only the abstract layer should call it. Concrete layers should only provides the implementation to the abstract layer.\nAlso, upon stream recreated, it should only schedule the timer if the resource has not been resolved (as the management server can choose to not send resources already sent in the previous stream). This is a pending change/bugfix.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508870737", "createdAt": "2020-10-20T22:10:59Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (!isInBackoff()) {\n+      ldsRespTimer =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NDE4OA=="}, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzYxMDg3OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowMjoyN1rOHlSy0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowNjowNFrOHlS4lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NzI4MA==", "bodyText": "ClientXdsClient has cleanUpResourceTimers. We can combine the 2 into 1 abstract method cleanUpResourceTimers in AbstractXdsClient which might also simplify the code at call sites.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508867280", "createdAt": "2020-10-20T22:02:27Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (!isInBackoff()) {\n+      ldsRespTimer =\n+          syncContext\n+              .schedule(\n+                  new ListenerResourceFetchTimeoutTask(\":\" + port),\n+                  INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, getTimeService());\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  Collection<String> getSubscribedResources(ResourceType type) {\n+    if (listenerWatcher == null) {\n+      return null;\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  /** In case of Listener watcher metadata to be updated to include port. */\n+  private void updateNodeMetadataForListenerRequest(int port) {\n+    Map<String, Object> newMetadata = new HashMap<>();\n+    if (node.getMetadata() != null) {\n+      newMetadata.putAll(node.getMetadata());\n+    }\n+    newMetadata.put(\"TRAFFICDIRECTOR_PROXYLESS\", \"1\");\n+    // TODO(sanjaypujare): eliminate usage of listening_addresses.\n+    EnvoyProtoData.Address listeningAddress =\n+        new EnvoyProtoData.Address(\"0.0.0.0\", port);\n+    node =\n+        node.toBuilder().setMetadata(newMetadata).addListeningAddresses(listeningAddress).build();\n+  }\n+\n+  @Override\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+    // Unpack Listener messages.\n+    Listener requestedListener = null;\n+    getLogger().log(XdsLogLevel.DEBUG, \"Listener count: {0}\", resources.size());\n+    try {\n+      for (com.google.protobuf.Any res : resources) {\n+        if (res.getTypeUrl().equals(ResourceType.LDS.typeUrlV2())) {\n+          res = res.toBuilder().setTypeUrl(ResourceType.LDS.typeUrl()).build();\n+        }\n+        Listener listener = res.unpack(Listener.class);\n+        getLogger().log(XdsLogLevel.DEBUG, \"Found listener {0}\", listener.toString());\n+        if (isRequestedListener(listener)) {\n+          requestedListener = listener;\n+          getLogger().log(XdsLogLevel.DEBUG, \"Requested listener found: {0}\", listener.getName());\n+        }\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      getLogger().log(XdsLogLevel.WARNING, \"Failed to unpack Listeners in LDS response {0}\", e);\n+      nackResponse(ResourceType.LDS, nonce, \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+    ListenerUpdate listenerUpdate = null;\n+    if (requestedListener != null) {\n+      if (ldsRespTimer != null) {\n+        ldsRespTimer.cancel();\n+        ldsRespTimer = null;\n+      }\n+      try {\n+        listenerUpdate = ListenerUpdate.newBuilder()\n+            .setListener(EnvoyServerProtoData.Listener.fromEnvoyProtoListener(requestedListener))\n+            .build();\n+      } catch (InvalidProtocolBufferException e) {\n+        getLogger().log(XdsLogLevel.WARNING, \"Failed to unpack Listener in LDS response {0}\", e);\n+        nackResponse(ResourceType.LDS, nonce, \"Malformed LDS response: \" + e);\n+        return;\n+      }\n+    } else {\n+      if (ldsRespTimer == null) {\n+        listenerWatcher.onResourceDoesNotExist(\":\" + listenerPort);\n+      }\n+    }\n+    ackResponse(ResourceType.LDS, versionInfo, nonce);\n+    if (listenerUpdate != null) {\n+      listenerWatcher.onListenerChanged(listenerUpdate);\n+    }\n+  }\n+\n+  private boolean isRequestedListener(Listener listener) {\n+    // TODO(sanjaypujare): check listener.getName() once we know what xDS server returns\n+    return isAddressMatching(listener.getAddress())\n+        && hasMatchingFilter(listener.getFilterChainsList());\n+  }\n+\n+  private boolean isAddressMatching(Address address) {\n+    // TODO(sanjaypujare): check IP address once we know xDS server will include it\n+    return address.hasSocketAddress()\n+        && (address.getSocketAddress().getPortValue() == listenerPort);\n+  }\n+\n+  private boolean hasMatchingFilter(List<FilterChain> filterChainsList) {\n+    // TODO(sanjaypujare): if myIp to be checked against filterChainMatch.getPrefixRangesList()\n+    for (FilterChain filterChain : filterChainsList) {\n+      FilterChainMatch filterChainMatch = filterChain.getFilterChainMatch();\n+\n+      if (listenerPort == filterChainMatch.getDestinationPort().getValue()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  protected void handleStreamClosed(Status error) {\n+    cleanUpResourceTimer();\n+    if (listenerWatcher != null) {\n+      listenerWatcher.onError(error);\n+    }\n+  }\n+\n+  @Override\n+  protected void handleStreamRestarted() {\n+    if (listenerWatcher != null) {\n+      ldsRespTimer =\n+          syncContext\n+              .schedule(\n+                  new ListenerResourceFetchTimeoutTask(\":\" + listenerPort),\n+                  INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, getTimeService());\n+    }\n+  }\n+\n+  @Override\n+  protected void handleShutdown() {\n+    cleanUpResourceTimer();\n+  }\n+\n+  @Override\n+  protected void runWithSynchronized(Runnable runnable) {\n+    syncContext.execute(runnable);\n+  }\n+\n+  private void cleanUpResourceTimer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2ODc1Nw==", "bodyText": "No, cleanUpResourceTimers should be concrete implantation's own logic. The abstract layer does not aware how concrete implementations subscribing to resources. This cleanUpResourceTimer method is just a helper method in the concrete implementation, it's used for both XdsClient shutdown and handleStreamClosed callback.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508868757", "createdAt": "2020-10-20T22:06:04Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (!isInBackoff()) {\n+      ldsRespTimer =\n+          syncContext\n+              .schedule(\n+                  new ListenerResourceFetchTimeoutTask(\":\" + port),\n+                  INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, getTimeService());\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  Collection<String> getSubscribedResources(ResourceType type) {\n+    if (listenerWatcher == null) {\n+      return null;\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  /** In case of Listener watcher metadata to be updated to include port. */\n+  private void updateNodeMetadataForListenerRequest(int port) {\n+    Map<String, Object> newMetadata = new HashMap<>();\n+    if (node.getMetadata() != null) {\n+      newMetadata.putAll(node.getMetadata());\n+    }\n+    newMetadata.put(\"TRAFFICDIRECTOR_PROXYLESS\", \"1\");\n+    // TODO(sanjaypujare): eliminate usage of listening_addresses.\n+    EnvoyProtoData.Address listeningAddress =\n+        new EnvoyProtoData.Address(\"0.0.0.0\", port);\n+    node =\n+        node.toBuilder().setMetadata(newMetadata).addListeningAddresses(listeningAddress).build();\n+  }\n+\n+  @Override\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+    // Unpack Listener messages.\n+    Listener requestedListener = null;\n+    getLogger().log(XdsLogLevel.DEBUG, \"Listener count: {0}\", resources.size());\n+    try {\n+      for (com.google.protobuf.Any res : resources) {\n+        if (res.getTypeUrl().equals(ResourceType.LDS.typeUrlV2())) {\n+          res = res.toBuilder().setTypeUrl(ResourceType.LDS.typeUrl()).build();\n+        }\n+        Listener listener = res.unpack(Listener.class);\n+        getLogger().log(XdsLogLevel.DEBUG, \"Found listener {0}\", listener.toString());\n+        if (isRequestedListener(listener)) {\n+          requestedListener = listener;\n+          getLogger().log(XdsLogLevel.DEBUG, \"Requested listener found: {0}\", listener.getName());\n+        }\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      getLogger().log(XdsLogLevel.WARNING, \"Failed to unpack Listeners in LDS response {0}\", e);\n+      nackResponse(ResourceType.LDS, nonce, \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+    ListenerUpdate listenerUpdate = null;\n+    if (requestedListener != null) {\n+      if (ldsRespTimer != null) {\n+        ldsRespTimer.cancel();\n+        ldsRespTimer = null;\n+      }\n+      try {\n+        listenerUpdate = ListenerUpdate.newBuilder()\n+            .setListener(EnvoyServerProtoData.Listener.fromEnvoyProtoListener(requestedListener))\n+            .build();\n+      } catch (InvalidProtocolBufferException e) {\n+        getLogger().log(XdsLogLevel.WARNING, \"Failed to unpack Listener in LDS response {0}\", e);\n+        nackResponse(ResourceType.LDS, nonce, \"Malformed LDS response: \" + e);\n+        return;\n+      }\n+    } else {\n+      if (ldsRespTimer == null) {\n+        listenerWatcher.onResourceDoesNotExist(\":\" + listenerPort);\n+      }\n+    }\n+    ackResponse(ResourceType.LDS, versionInfo, nonce);\n+    if (listenerUpdate != null) {\n+      listenerWatcher.onListenerChanged(listenerUpdate);\n+    }\n+  }\n+\n+  private boolean isRequestedListener(Listener listener) {\n+    // TODO(sanjaypujare): check listener.getName() once we know what xDS server returns\n+    return isAddressMatching(listener.getAddress())\n+        && hasMatchingFilter(listener.getFilterChainsList());\n+  }\n+\n+  private boolean isAddressMatching(Address address) {\n+    // TODO(sanjaypujare): check IP address once we know xDS server will include it\n+    return address.hasSocketAddress()\n+        && (address.getSocketAddress().getPortValue() == listenerPort);\n+  }\n+\n+  private boolean hasMatchingFilter(List<FilterChain> filterChainsList) {\n+    // TODO(sanjaypujare): if myIp to be checked against filterChainMatch.getPrefixRangesList()\n+    for (FilterChain filterChain : filterChainsList) {\n+      FilterChainMatch filterChainMatch = filterChain.getFilterChainMatch();\n+\n+      if (listenerPort == filterChainMatch.getDestinationPort().getValue()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  protected void handleStreamClosed(Status error) {\n+    cleanUpResourceTimer();\n+    if (listenerWatcher != null) {\n+      listenerWatcher.onError(error);\n+    }\n+  }\n+\n+  @Override\n+  protected void handleStreamRestarted() {\n+    if (listenerWatcher != null) {\n+      ldsRespTimer =\n+          syncContext\n+              .schedule(\n+                  new ListenerResourceFetchTimeoutTask(\":\" + listenerPort),\n+                  INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, getTimeService());\n+    }\n+  }\n+\n+  @Override\n+  protected void handleShutdown() {\n+    cleanUpResourceTimer();\n+  }\n+\n+  @Override\n+  protected void runWithSynchronized(Runnable runnable) {\n+    syncContext.execute(runnable);\n+  }\n+\n+  private void cleanUpResourceTimer() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NzI4MA=="}, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzcwMzcwOnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/AbstractXdsClientTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjozODo1MVrOHlTqlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMzowOTowOFrOHlUUZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4MTU1Nw==", "bodyText": "This has only MessagePrinter tests and MessagePrinter is only used in log messages and not for any functionality. So these tests don't test any functionality, is that correct?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508881557", "createdAt": "2020-10-20T22:38:51Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/AbstractXdsClientTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientTestHelper.buildCluster;\n+import static io.grpc.xds.XdsClientTestHelper.buildClusterLoadAssignment;\n+import static io.grpc.xds.XdsClientTestHelper.buildDiscoveryResponse;\n+import static io.grpc.xds.XdsClientTestHelper.buildDropOverload;\n+import static io.grpc.xds.XdsClientTestHelper.buildLbEndpoint;\n+import static io.grpc.xds.XdsClientTestHelper.buildListener;\n+import static io.grpc.xds.XdsClientTestHelper.buildLocalityLbEndpoints;\n+import static io.grpc.xds.XdsClientTestHelper.buildRouteConfiguration;\n+import static io.grpc.xds.XdsClientTestHelper.buildVirtualHost;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Any;\n+import io.envoyproxy.envoy.config.core.v3.HealthStatus;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.xds.AbstractXdsClient.MessagePrinter;\n+import io.grpc.xds.AbstractXdsClient.ResourceType;\n+import java.util.List;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Tests for {@link AbstractXdsClient}.\n+ */\n+@RunWith(JUnit4.class)\n+public class AbstractXdsClientTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg5MjI2MQ==", "bodyText": "The XdsClient's behaviors (including functionalities such as ADS stream closed and retry implemented in the abstract layer) are tested in each of the concrete implementations (see ClientXdsClientTest and ServerXdsClientTest). In high-level, it's more like a blackbox test.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508892261", "createdAt": "2020-10-20T23:09:08Z", "author": {"login": "voidzcy"}, "path": "xds/src/test/java/io/grpc/xds/AbstractXdsClientTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientTestHelper.buildCluster;\n+import static io.grpc.xds.XdsClientTestHelper.buildClusterLoadAssignment;\n+import static io.grpc.xds.XdsClientTestHelper.buildDiscoveryResponse;\n+import static io.grpc.xds.XdsClientTestHelper.buildDropOverload;\n+import static io.grpc.xds.XdsClientTestHelper.buildLbEndpoint;\n+import static io.grpc.xds.XdsClientTestHelper.buildListener;\n+import static io.grpc.xds.XdsClientTestHelper.buildLocalityLbEndpoints;\n+import static io.grpc.xds.XdsClientTestHelper.buildRouteConfiguration;\n+import static io.grpc.xds.XdsClientTestHelper.buildVirtualHost;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Any;\n+import io.envoyproxy.envoy.config.core.v3.HealthStatus;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.xds.AbstractXdsClient.MessagePrinter;\n+import io.grpc.xds.AbstractXdsClient.ResourceType;\n+import java.util.List;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Tests for {@link AbstractXdsClient}.\n+ */\n+@RunWith(JUnit4.class)\n+public class AbstractXdsClientTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4MTU1Nw=="}, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI4NDY4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/ClientXdsClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowOToyNlrOHmK40g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMDoxMjowOFrOHmMFuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NjMyMg==", "bodyText": "You can delete now, otherwise it will fail to build.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r509786322", "createdAt": "2020-10-21T23:09:26Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/ClientXdsClient.java", "diffHunk": "@@ -0,0 +1,840 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.grpc.xds.EnvoyProtoData.TRANSPORT_SOCKET_NAME_TLS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.util.Durations;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for client side usages.\n+ */\n+final class ClientXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+\n+  private final Object lock = new Object();\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> rdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> cdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> edsResourceSubscribers = new HashMap<>();\n+  private final LoadStatsManager loadStatsManager = new LoadStatsManager();\n+  private final LoadReportClient lrsClient;\n+  private boolean reportingLoad;\n+\n+  ClientXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    // TODO(chengyuanzhang): delete me after https://github.com/grpc/grpc-java/pull/7528.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgwNjAwOQ==", "bodyText": "Sure. Updated.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r509806009", "createdAt": "2020-10-22T00:12:08Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/ClientXdsClient.java", "diffHunk": "@@ -0,0 +1,840 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.grpc.xds.EnvoyProtoData.TRANSPORT_SOCKET_NAME_TLS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.util.Durations;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for client side usages.\n+ */\n+final class ClientXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+\n+  private final Object lock = new Object();\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> rdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> cdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> edsResourceSubscribers = new HashMap<>();\n+  private final LoadStatsManager loadStatsManager = new LoadStatsManager();\n+  private final LoadReportClient lrsClient;\n+  private boolean reportingLoad;\n+\n+  ClientXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    // TODO(chengyuanzhang): delete me after https://github.com/grpc/grpc-java/pull/7528.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NjMyMg=="}, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5MzI5ODgyOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxNjowNFrOHmLBVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMzo0NTo0OFrOHm3g6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4ODUwMw==", "bodyText": "Pass in Supplier<Stopwatch> as discussed before.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r509788503", "createdAt": "2020-10-21T23:16:04Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUxNzQ4Mg==", "bodyText": "Okay, changed, although this constructor is called by super() with a new stopwatch gotten from the supplier in concrete classes.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510517482", "createdAt": "2020-10-22T23:45:48Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4ODUwMw=="}, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzUwMjExOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDo0NjowOVrOHmzKgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMzo0NTo1NFrOHm3hBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0NjIxMQ==", "bodyText": "s/a/an/", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510446211", "createdAt": "2020-10-22T20:46:09Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUxNzUxMQ==", "bodyText": "Fixed, thanks.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510517511", "createdAt": "2020-10-22T23:45:54Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0NjIxMQ=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzUwNzMwOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDo0Nzo0M1rOHmzNuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMzo0NjoxNVrOHm3hWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0NzAzMw==", "bodyText": "If type is not LDS should also return null?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510447033", "createdAt": "2020-10-22T20:47:43Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (!isInBackoff()) {\n+      ldsRespTimer =\n+          syncContext\n+              .schedule(\n+                  new ListenerResourceFetchTimeoutTask(\":\" + port),\n+                  INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, getTimeService());\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  Collection<String> getSubscribedResources(ResourceType type) {\n+    if (listenerWatcher == null) {\n+      return null;\n+    }\n+    return Collections.emptyList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUxNzU5NQ==", "bodyText": "Yeah, that's better. Updated.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510517595", "createdAt": "2020-10-22T23:46:15Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (!isInBackoff()) {\n+      ldsRespTimer =\n+          syncContext\n+              .schedule(\n+                  new ListenerResourceFetchTimeoutTask(\":\" + port),\n+                  INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, getTimeService());\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  Collection<String> getSubscribedResources(ResourceType type) {\n+    if (listenerWatcher == null) {\n+      return null;\n+    }\n+    return Collections.emptyList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0NzAzMw=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzU3MjY0OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMTowNjoxM1rOHmz1Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMzo0NjozNFrOHm3hqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1NzExNQ==", "bodyText": "Add an INFO level log for sending discovery type request for resources? Just as the INFO levels log in NACK and ACK.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510457115", "createdAt": "2020-10-22T21:06:13Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUxNzY3NA==", "bodyText": "Sure, added a log message.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510517674", "createdAt": "2020-10-22T23:46:34Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1NzExNQ=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 450}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzU4NjMxOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMToxMDoxMFrOHmz9KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDowNTozNFrOHm4DCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1OTE3Nw==", "bodyText": "Provide the type name?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510459177", "createdAt": "2020-10-22T21:10:10Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 500}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUxODQ3MA==", "bodyText": "Hmm, the enum value doesn't carry the raw type name (aka, typeUrl), this method is already using abstracted information. The real type URL should have been logged in the raw message, so it should be good enough to just warn with the the unknownness.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510518470", "createdAt": "2020-10-22T23:49:47Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1OTE3Nw=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 500}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUyNjIxOA==", "bodyText": "Yeah, we can't print the actual type name.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510526218", "createdAt": "2020-10-23T00:05:34Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1OTE3Nw=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 500}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzYxNDI4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMToxODoyMVrOHm0ODw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDowODozN1rOHm4GGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2MzUwMw==", "bodyText": "The method has almost identical name as handleRpcStreamClosed().\nSo propagateStreamError() might be a better name, as it's propagating error to the watchers.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510463503", "createdAt": "2020-10-22T21:18:21Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");\n+      }\n+    }\n+\n+    final void handleRpcError(Throwable t) {\n+      handleRpcStreamClosed(Status.fromThrowable(t));\n+    }\n+\n+    final void handleRpcCompleted() {\n+      handleRpcStreamClosed(Status.UNAVAILABLE.withDescription(\"Closed by server\"));\n+    }\n+\n+    private void handleRpcStreamClosed(Status error) {\n+      checkArgument(!error.isOk(), \"unexpected OK status\");\n+      if (closed) {\n+        return;\n+      }\n+      logger.log(\n+          XdsLogLevel.ERROR,\n+          \"ADS stream closed with status {0}: {1}. Cause: {2}\",\n+          error.getCode(), error.getDescription(), error.getCause());\n+      closed = true;\n+      handleStreamClosed(error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 522}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUxOTgyNg==", "bodyText": "Hmm, I think handleStreamClosed() is better aligned with other \"abstract\" methods. Calling it \"propagate\" may not be that appropriate as this is actually how inheritance works. It is not directly calling another classes' method,  it is calling itself's method.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510519826", "createdAt": "2020-10-22T23:54:23Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");\n+      }\n+    }\n+\n+    final void handleRpcError(Throwable t) {\n+      handleRpcStreamClosed(Status.fromThrowable(t));\n+    }\n+\n+    final void handleRpcCompleted() {\n+      handleRpcStreamClosed(Status.UNAVAILABLE.withDescription(\"Closed by server\"));\n+    }\n+\n+    private void handleRpcStreamClosed(Status error) {\n+      checkArgument(!error.isOk(), \"unexpected OK status\");\n+      if (closed) {\n+        return;\n+      }\n+      logger.log(\n+          XdsLogLevel.ERROR,\n+          \"ADS stream closed with status {0}: {1}. Cause: {2}\",\n+          error.getCode(), error.getDescription(), error.getCause());\n+      closed = true;\n+      handleStreamClosed(error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2MzUwMw=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 522}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUyNzAwMg==", "bodyText": "Not a big deal. Just felt names are too closed.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510527002", "createdAt": "2020-10-23T00:08:37Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");\n+      }\n+    }\n+\n+    final void handleRpcError(Throwable t) {\n+      handleRpcStreamClosed(Status.fromThrowable(t));\n+    }\n+\n+    final void handleRpcCompleted() {\n+      handleRpcStreamClosed(Status.UNAVAILABLE.withDescription(\"Closed by server\"));\n+    }\n+\n+    private void handleRpcStreamClosed(Status error) {\n+      checkArgument(!error.isOk(), \"unexpected OK status\");\n+      if (closed) {\n+        return;\n+      }\n+      logger.log(\n+          XdsLogLevel.ERROR,\n+          \"ADS stream closed with status {0}: {1}. Cause: {2}\",\n+          error.getCode(), error.getDescription(), error.getCause());\n+      closed = true;\n+      handleStreamClosed(error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2MzUwMw=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 522}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzYyMjI4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMToyMDo1MFrOHm0Syw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMzo1NTo0MlrOHm3t6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2NDcxNQ==", "bodyText": "stubV2 can be moved into start() as a local variable.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510464715", "createdAt": "2020-10-22T21:20:50Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");\n+      }\n+    }\n+\n+    final void handleRpcError(Throwable t) {\n+      handleRpcStreamClosed(Status.fromThrowable(t));\n+    }\n+\n+    final void handleRpcCompleted() {\n+      handleRpcStreamClosed(Status.UNAVAILABLE.withDescription(\"Closed by server\"));\n+    }\n+\n+    private void handleRpcStreamClosed(Status error) {\n+      checkArgument(!error.isOk(), \"unexpected OK status\");\n+      if (closed) {\n+        return;\n+      }\n+      logger.log(\n+          XdsLogLevel.ERROR,\n+          \"ADS stream closed with status {0}: {1}. Cause: {2}\",\n+          error.getCode(), error.getDescription(), error.getCause());\n+      closed = true;\n+      handleStreamClosed(error);\n+      cleanUp();\n+      if (responseReceived || retryBackoffPolicy == null) {\n+        // Reset the backoff sequence if had received a response, or backoff sequence\n+        // has never been initialized.\n+        retryBackoffPolicy = backoffPolicyProvider.get();\n+      }\n+      long delayNanos = 0;\n+      if (!responseReceived) {\n+        delayNanos =\n+            Math.max(\n+                0,\n+                retryBackoffPolicy.nextBackoffNanos()\n+                    - stopwatch.elapsed(TimeUnit.NANOSECONDS));\n+      }\n+      logger.log(XdsLogLevel.INFO, \"Retry ADS stream in {0} ns\", delayNanos);\n+      rpcRetryTimer = timeService.schedule(new RpcRetryTask(), delayNanos, TimeUnit.NANOSECONDS);\n+    }\n+\n+    private void close(Exception error) {\n+      if (closed) {\n+        return;\n+      }\n+      closed = true;\n+      cleanUp();\n+      sendError(error);\n+    }\n+\n+    private void cleanUp() {\n+      if (adsStream == this) {\n+        adsStream = null;\n+      }\n+    }\n+  }\n+\n+  private final class AdsStreamV2 extends AbstractAdsStream {\n+    private final io.envoyproxy.envoy.service.discovery.v2.AggregatedDiscoveryServiceGrpc\n+        .AggregatedDiscoveryServiceStub stubV2;\n+    private StreamObserver<io.envoyproxy.envoy.api.v2.DiscoveryRequest> requestWriterV2;\n+\n+    AdsStreamV2() {\n+      stubV2 = io.envoyproxy.envoy.service.discovery.v2.AggregatedDiscoveryServiceGrpc.newStub(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 563}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUyMDgxMA==", "bodyText": "Sure. Cleaned up the AdsStreamV2 and AdsStreamV3 naming as well, made the class itself more descriptive.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510520810", "createdAt": "2020-10-22T23:55:42Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");\n+      }\n+    }\n+\n+    final void handleRpcError(Throwable t) {\n+      handleRpcStreamClosed(Status.fromThrowable(t));\n+    }\n+\n+    final void handleRpcCompleted() {\n+      handleRpcStreamClosed(Status.UNAVAILABLE.withDescription(\"Closed by server\"));\n+    }\n+\n+    private void handleRpcStreamClosed(Status error) {\n+      checkArgument(!error.isOk(), \"unexpected OK status\");\n+      if (closed) {\n+        return;\n+      }\n+      logger.log(\n+          XdsLogLevel.ERROR,\n+          \"ADS stream closed with status {0}: {1}. Cause: {2}\",\n+          error.getCode(), error.getDescription(), error.getCause());\n+      closed = true;\n+      handleStreamClosed(error);\n+      cleanUp();\n+      if (responseReceived || retryBackoffPolicy == null) {\n+        // Reset the backoff sequence if had received a response, or backoff sequence\n+        // has never been initialized.\n+        retryBackoffPolicy = backoffPolicyProvider.get();\n+      }\n+      long delayNanos = 0;\n+      if (!responseReceived) {\n+        delayNanos =\n+            Math.max(\n+                0,\n+                retryBackoffPolicy.nextBackoffNanos()\n+                    - stopwatch.elapsed(TimeUnit.NANOSECONDS));\n+      }\n+      logger.log(XdsLogLevel.INFO, \"Retry ADS stream in {0} ns\", delayNanos);\n+      rpcRetryTimer = timeService.schedule(new RpcRetryTask(), delayNanos, TimeUnit.NANOSECONDS);\n+    }\n+\n+    private void close(Exception error) {\n+      if (closed) {\n+        return;\n+      }\n+      closed = true;\n+      cleanUp();\n+      sendError(error);\n+    }\n+\n+    private void cleanUp() {\n+      if (adsStream == this) {\n+        adsStream = null;\n+      }\n+    }\n+  }\n+\n+  private final class AdsStreamV2 extends AbstractAdsStream {\n+    private final io.envoyproxy.envoy.service.discovery.v2.AggregatedDiscoveryServiceGrpc\n+        .AggregatedDiscoveryServiceStub stubV2;\n+    private StreamObserver<io.envoyproxy.envoy.api.v2.DiscoveryRequest> requestWriterV2;\n+\n+    AdsStreamV2() {\n+      stubV2 = io.envoyproxy.envoy.service.discovery.v2.AggregatedDiscoveryServiceGrpc.newStub(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2NDcxNQ=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 563}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NzY3NzU4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMTozODoyNVrOHm00PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDowOToxNFrOHm4GvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3MzI3Ng==", "bodyText": "Usages of adjustResourceSubscription  seem not synchronized in the sense of runWithSynchronized().", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510473276", "createdAt": "2020-10-22T21:38:25Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUxNTc1Mw==", "bodyText": "Which usage specifically? All of its invocations should have been holding the lock.\nBut, btw, I am highly suspecting the server side SynchronizationContext is wrong. It is already wrong in XdsClientWrapperForServerSds. It doesn't synchronize anything, because only tasks from the XdsClient's channel thread are scheduled into it.\n/cc @sanjaypujare You probably do not understand how those threads work.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510515753", "createdAt": "2020-10-22T23:39:15Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3MzI3Ng=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUyNjQ2NA==", "bodyText": "Basically, calling into XdsClient's API (e.g., XdsClient.watchListenerData()) should also be from inside the SynchronizationContext. Even the existing server side usage is wrong.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510526464", "createdAt": "2020-10-23T00:06:28Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3MzI3Ng=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUyNzE2NQ==", "bodyText": "Oh, sorry, I forgot they were inside lock and misunderstood the code.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510527165", "createdAt": "2020-10-23T00:09:14Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3MzI3Ng=="}, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 212}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2229, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}