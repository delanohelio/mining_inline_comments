{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNzg2NjQw", "number": 6858, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDowNzozMVrODs5efQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDoxODo1MFrODvSiIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDA1NjI5OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDowNzozMVrOF-AqlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDo1NzozN1rOF-Bicg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjkzMw==", "bodyText": "Why android? No android module should depend on grpc-xds.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400566933", "createdAt": "2020-03-31T00:07:31Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MTIzNA==", "bodyText": "Oops. Auto-imported by IDE.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400581234", "createdAt": "2020-03-31T00:57:37Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjkzMw=="}, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDA3NzE3OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDoxODozN1rOF-A3eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDo1NzowNVrOF-Bh7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3MDIzMg==", "bodyText": "Since LrsLoadBalancerProvider is completely internal, and the config is NOT coming from any resolver, so LrsConfig is totally internal and constructed directly, there is no code path to parse a rawConfig to LrsConfig.  This parser is dead code. Simply throw UnsupportedOperationException would be sufficient.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400570232", "createdAt": "2020-03-31T00:18:37Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provider for lrs load balancing policy.\n+ */\n+@Internal\n+public class LrsLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  private static final String LRS_POLICY_NAME = \"lrs_experimental\";\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(LoadBalancer.Helper helper) {\n+    return new LrsLoadBalancer(helper);\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return LRS_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4MTEwMA==", "bodyText": "Yep, I agree.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400581100", "createdAt": "2020-03-31T00:57:05Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provider for lrs load balancing policy.\n+ */\n+@Internal\n+public class LrsLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  private static final String LRS_POLICY_NAME = \"lrs_experimental\";\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(LoadBalancer.Helper helper) {\n+    return new LrsLoadBalancer(helper);\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return LRS_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3MDIzMg=="}, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDExMDQ2OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDozNjozNVrOF-BLHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNzoxOTowMFrOF_KwFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NTI2MA==", "bodyText": "Do you want to check if store is null?", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400575260", "createdAt": "2020-03-31T00:36:35Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Objects;\n+\n+/**\n+ * Load balancer for lrs policy.\n+ */\n+final class LrsLoadBalancer extends LoadBalancer {\n+  private final LoadBalancer.Helper helper;\n+  private GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private LoadStatsStore loadStatsStore;\n+  private String clusterName;\n+  private String edsServiceName;\n+  private Locality locality;\n+  private String childPolicyName;\n+\n+  LrsLoadBalancer(LoadBalancer.Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    LrsConfig config = (LrsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    LoadStatsStore store =\n+        resolvedAddresses.getAttributes().get(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE);\n+    checkAndSetUp(config, store);\n+\n+    if (switchingLoadBalancer == null) {\n+      loadStatsStore.addLocality(config.locality);\n+      final ClientLoadCounter counter = loadStatsStore.getLocalityCounter(config.locality);\n+      LoadBalancer.Helper loadRecordingHelper = new ForwardingLoadBalancerHelper() {\n+        @Override\n+        protected Helper delegate() {\n+          return helper;\n+        }\n+\n+        @Override\n+        public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+          @SuppressLint(\"VisibleForTests\")\n+          SubchannelPicker loadRecordingPicker =\n+              new LoadRecordingSubchannelPicker(counter, newPicker);\n+          super.updateBalancingState(newState, loadRecordingPicker);\n+        }\n+      };\n+      switchingLoadBalancer = new GracefulSwitchLoadBalancer(loadRecordingHelper);\n+    }\n+    String updatedChildPolicyName = config.childPolicy.getProvider().getPolicyName();\n+    if (!Objects.equals(childPolicyName, updatedChildPolicyName)) {\n+      switchingLoadBalancer.switchTo(config.childPolicy.getProvider());\n+      childPolicyName = updatedChildPolicyName;\n+    }\n+    ResolvedAddresses downStreamResult =\n+        resolvedAddresses.toBuilder()\n+            .setLoadBalancingPolicyConfig(config.childPolicy.getConfig())\n+            .build();\n+    switchingLoadBalancer.handleResolvedAddresses(downStreamResult);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    if (switchingLoadBalancer != null) {\n+      switchingLoadBalancer.handleNameResolutionError(error);\n+    } else {\n+      helper.updateBalancingState(ConnectivityState.TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    if (switchingLoadBalancer != null) {\n+      loadStatsStore.removeLocality(locality);\n+      switchingLoadBalancer.shutdown();\n+    }\n+  }\n+\n+  private void checkAndSetUp(LrsConfig config, LoadStatsStore store) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4NDAwNg==", "bodyText": "checkState( loadStatsStore == null || loadStatsStore.equals(store), \"loadStatsStore should not change\");\nshould have covered it.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400584006", "createdAt": "2020-03-31T01:07:45Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Objects;\n+\n+/**\n+ * Load balancer for lrs policy.\n+ */\n+final class LrsLoadBalancer extends LoadBalancer {\n+  private final LoadBalancer.Helper helper;\n+  private GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private LoadStatsStore loadStatsStore;\n+  private String clusterName;\n+  private String edsServiceName;\n+  private Locality locality;\n+  private String childPolicyName;\n+\n+  LrsLoadBalancer(LoadBalancer.Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    LrsConfig config = (LrsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    LoadStatsStore store =\n+        resolvedAddresses.getAttributes().get(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE);\n+    checkAndSetUp(config, store);\n+\n+    if (switchingLoadBalancer == null) {\n+      loadStatsStore.addLocality(config.locality);\n+      final ClientLoadCounter counter = loadStatsStore.getLocalityCounter(config.locality);\n+      LoadBalancer.Helper loadRecordingHelper = new ForwardingLoadBalancerHelper() {\n+        @Override\n+        protected Helper delegate() {\n+          return helper;\n+        }\n+\n+        @Override\n+        public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+          @SuppressLint(\"VisibleForTests\")\n+          SubchannelPicker loadRecordingPicker =\n+              new LoadRecordingSubchannelPicker(counter, newPicker);\n+          super.updateBalancingState(newState, loadRecordingPicker);\n+        }\n+      };\n+      switchingLoadBalancer = new GracefulSwitchLoadBalancer(loadRecordingHelper);\n+    }\n+    String updatedChildPolicyName = config.childPolicy.getProvider().getPolicyName();\n+    if (!Objects.equals(childPolicyName, updatedChildPolicyName)) {\n+      switchingLoadBalancer.switchTo(config.childPolicy.getProvider());\n+      childPolicyName = updatedChildPolicyName;\n+    }\n+    ResolvedAddresses downStreamResult =\n+        resolvedAddresses.toBuilder()\n+            .setLoadBalancingPolicyConfig(config.childPolicy.getConfig())\n+            .build();\n+    switchingLoadBalancer.handleResolvedAddresses(downStreamResult);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    if (switchingLoadBalancer != null) {\n+      switchingLoadBalancer.handleNameResolutionError(error);\n+    } else {\n+      helper.updateBalancingState(ConnectivityState.TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    if (switchingLoadBalancer != null) {\n+      loadStatsStore.removeLocality(locality);\n+      switchingLoadBalancer.shutdown();\n+    }\n+  }\n+\n+  private void checkAndSetUp(LrsConfig config, LoadStatsStore store) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NTI2MA=="}, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc4MDc1Ng==", "bodyText": "Are you allowing the store argument to be nullable?", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401780756", "createdAt": "2020-04-01T17:19:00Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Objects;\n+\n+/**\n+ * Load balancer for lrs policy.\n+ */\n+final class LrsLoadBalancer extends LoadBalancer {\n+  private final LoadBalancer.Helper helper;\n+  private GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private LoadStatsStore loadStatsStore;\n+  private String clusterName;\n+  private String edsServiceName;\n+  private Locality locality;\n+  private String childPolicyName;\n+\n+  LrsLoadBalancer(LoadBalancer.Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    LrsConfig config = (LrsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    LoadStatsStore store =\n+        resolvedAddresses.getAttributes().get(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE);\n+    checkAndSetUp(config, store);\n+\n+    if (switchingLoadBalancer == null) {\n+      loadStatsStore.addLocality(config.locality);\n+      final ClientLoadCounter counter = loadStatsStore.getLocalityCounter(config.locality);\n+      LoadBalancer.Helper loadRecordingHelper = new ForwardingLoadBalancerHelper() {\n+        @Override\n+        protected Helper delegate() {\n+          return helper;\n+        }\n+\n+        @Override\n+        public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+          @SuppressLint(\"VisibleForTests\")\n+          SubchannelPicker loadRecordingPicker =\n+              new LoadRecordingSubchannelPicker(counter, newPicker);\n+          super.updateBalancingState(newState, loadRecordingPicker);\n+        }\n+      };\n+      switchingLoadBalancer = new GracefulSwitchLoadBalancer(loadRecordingHelper);\n+    }\n+    String updatedChildPolicyName = config.childPolicy.getProvider().getPolicyName();\n+    if (!Objects.equals(childPolicyName, updatedChildPolicyName)) {\n+      switchingLoadBalancer.switchTo(config.childPolicy.getProvider());\n+      childPolicyName = updatedChildPolicyName;\n+    }\n+    ResolvedAddresses downStreamResult =\n+        resolvedAddresses.toBuilder()\n+            .setLoadBalancingPolicyConfig(config.childPolicy.getConfig())\n+            .build();\n+    switchingLoadBalancer.handleResolvedAddresses(downStreamResult);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    if (switchingLoadBalancer != null) {\n+      switchingLoadBalancer.handleNameResolutionError(error);\n+    } else {\n+      helper.updateBalancingState(ConnectivityState.TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    if (switchingLoadBalancer != null) {\n+      loadStatsStore.removeLocality(locality);\n+      switchingLoadBalancer.shutdown();\n+    }\n+  }\n+\n+  private void checkAndSetUp(LrsConfig config, LoadStatsStore store) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NTI2MA=="}, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDExNTg3OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMDozOTozMlrOF-BOYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNzoyMzo0N1rOF_K7Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NjA5OA==", "bodyText": "@Nullable", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400576098", "createdAt": "2020-03-31T00:39:32Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Objects;\n+\n+/**\n+ * Load balancer for lrs policy.\n+ */\n+final class LrsLoadBalancer extends LoadBalancer {\n+  private final LoadBalancer.Helper helper;\n+  private GracefulSwitchLoadBalancer switchingLoadBalancer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4NjQ3Mw==", "bodyText": "Ah. Strictly speaking all the following fields are nullable as they are only initiated after the first invocation of handleResolvedAddresses(...). But in the context of our design and how LB policy instances are structured, we use handleResolvedAddresses(...) as the entry point instead of constructor (we cannot). handleResolvedAddresses(...) is always called immediately after an instance is created. This is unfortunate, feature development does not perfectly fit into our existing LoadBalancer APIs. I am feeling better to not have them being annotated with @Nullable.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r400586473", "createdAt": "2020-03-31T01:16:16Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Objects;\n+\n+/**\n+ * Load balancer for lrs policy.\n+ */\n+final class LrsLoadBalancer extends LoadBalancer {\n+  private final LoadBalancer.Helper helper;\n+  private GracefulSwitchLoadBalancer switchingLoadBalancer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NjA5OA=="}, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc4MzU4Nw==", "bodyText": "Then maybe @CheckForNull might be more suitable. After all,  we can not guarantee handleResolvedAddresses is always the first method to be called for the instance.\nI don't care too much about the other fields, because they are only used in one method.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401783587", "createdAt": "2020-04-01T17:23:47Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import android.annotation.SuppressLint;\n+import io.grpc.ConnectivityState;\n+import io.grpc.LoadBalancer;\n+import io.grpc.Status;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Objects;\n+\n+/**\n+ * Load balancer for lrs policy.\n+ */\n+final class LrsLoadBalancer extends LoadBalancer {\n+  private final LoadBalancer.Helper helper;\n+  private GracefulSwitchLoadBalancer switchingLoadBalancer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3NjA5OA=="}, "originalCommit": {"oid": "a7023a9f265ac5bcf5b2508b16034969c9abaf2a"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjU4ODgzOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToyNTozNlrOF_TMqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToyNTozNlrOF_TMqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxOTE0NQ==", "bodyText": "nit: final", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401919145", "createdAt": "2020-04-01T21:25:36Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provider for lrs load balancing policy.\n+ */\n+@Internal\n+public class LrsLoadBalancerProvider extends LoadBalancerProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjU5MDc3OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToyNjowN1rOF_TN0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToyNjowN1rOF_TN0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxOTQ0Mg==", "bodyText": "nit: final", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401919442", "createdAt": "2020-04-01T21:26:07Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/LrsLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provider for lrs load balancing policy.\n+ */\n+@Internal\n+public class LrsLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  private static final String LRS_POLICY_NAME = \"lrs_experimental\";\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(LoadBalancer.Helper helper) {\n+    return new LrsLoadBalancer(helper);\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return LRS_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  static class LrsConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjY4MDc0OnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMTo1NTowMVrOF_UDqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMzozODo1NlrOGAAOEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzMzIyNw==", "bodyText": "Also assert all childBalancers are shutdown. You might use peekLast() not removing them in the tests.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401933227", "createdAt": "2020-04-01T21:55:01Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1Njc4Nw==", "bodyText": "See test case updateChildPolicy()", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r402656787", "createdAt": "2020-04-02T23:38:56Z", "author": {"login": "voidzcy"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzMzIyNw=="}, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjcwMDQ4OnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjowMjoyMFrOF_UP2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxODoxMDowOVrOF_3gDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNjM0NA==", "bodyText": "You can use TestUtils.StandardLoadBalancerProvider after pulling master.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401936344", "createdAt": "2020-04-01T22:02:20Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxMzkzNQ==", "bodyText": "No, I do not like that. I am going to avoid using it, in case some day it gets deleted.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r402513935", "createdAt": "2020-04-02T18:10:09Z", "author": {"login": "voidzcy"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNjM0NA=="}, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjcwNzA0OnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjowNDo0N1rOF_UUJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxOTowMzo1OVrOGBl0ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNzQ0NQ==", "bodyText": "This is just testing test implementation. The subchannel of the picker and the action of calling childHelper.updateBalancingState() should be considered as test input instead of test implementation.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401937445", "createdAt": "2020-04-01T22:04:47Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      final Subchannel subchannel = new NoopSubchannel(resolvedAddresses.getAddresses());\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          return PickResult.withSubchannel(subchannel);\n+        }\n+      };\n+      helper.updateBalancingState(ConnectivityState.READY, picker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNzQ1Mw==", "bodyText": "This is the implicitly an \"input\", by my implementation choice: calling LrsLoadBalancer's handleResolvedAddresses(...) immediately triggers a subchannel become READY. This merges two steps into one: deliver addresses + deliver subchannel state. We do not care about how subchannels are created, so it's completely up to the fake balancer's implementation.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r402517453", "createdAt": "2020-04-02T18:16:13Z", "author": {"login": "voidzcy"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      final Subchannel subchannel = new NoopSubchannel(resolvedAddresses.getAddresses());\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          return PickResult.withSubchannel(subchannel);\n+        }\n+      };\n+      helper.updateBalancingState(ConnectivityState.READY, picker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNzQ0NQ=="}, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwOTg2Ng==", "bodyText": "Hiding implicit \"input\" in fake lb's handleResolvedAddresses() implementation makes the tests very difficult to read and surprises readers: you are testing against a very very special child balancer implementation.\nYou can make the input explicit by adding a method FakeLoadBalancer.deliverBalancingState()and call it explicitly in the test method - if you don't want to cache the childHelper and call childHelper. updateBalancingState() explicitly.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r402609866", "createdAt": "2020-04-02T21:35:21Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      final Subchannel subchannel = new NoopSubchannel(resolvedAddresses.getAddresses());\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          return PickResult.withSubchannel(subchannel);\n+        }\n+      };\n+      helper.updateBalancingState(ConnectivityState.READY, picker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNzQ0NQ=="}, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2MTAxNg==", "bodyText": "How downstream balancer/helper propagate subchannel state/picker up to parent balancer is completely downstream balancer's logic. In this test, its choice is to immediately propagate a READY subchannel when it receives ResolvedAddresses.\n\nmakes the tests very difficult to read and surprises readers\n\nWhy this would surprise readers? Readers need to know how downstream balancer propagates subchannel state/picker to parent balancer, so it needs to read how this fake downstream balancer is implemented.\n\nyou are testing against a very very special child balancer implementation.\n\nDoes this matter to what is being tested and verified? It does not. From LrsLoadBalancer's perspective, downstream balancer is opaque, it's just a LoadBalancer.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r402661016", "createdAt": "2020-04-02T23:53:27Z", "author": {"login": "voidzcy"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      final Subchannel subchannel = new NoopSubchannel(resolvedAddresses.getAddresses());\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          return PickResult.withSubchannel(subchannel);\n+        }\n+      };\n+      helper.updateBalancingState(ConnectivityState.READY, picker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNzQ0NQ=="}, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMDEwNg==", "bodyText": "Why this would surprise readers?\n\nA couple of reasons:\n\n\nA fake object should normally have a trivial implementation, such as recording the input arguments and constructing a dummy return value. Fake object should normally not implement the overriding methods with any behaviors. Otherwise you should not name it fake object (sometimes I made the same mistake), but give them a meaningful name like ImmediateReadyLoadBalancer,  ImmediateReadyLbProvider, and immediate-ready-policy-foo, and optionally provide javadoc for the behavior. Otherwise readers reading the test methods will ignore/overlook there is a behavior in the fake object implementation.\n\n\nSubchannel turning to READY state is triggered by external event: the transport is connected and notifies the subchannel state listener.  Lb itself can not control when the event is fired.\nCalling childHelper.updateBalancingState(READY, picker)explicitly on demand in test methods as a test input is a sound way to simulate that the external event is happening. On the contrary, overriding handleResolvedAddresses() to call childHelper. updateBalancingState(READY, picker) is a weird behavior as if the lb itself fires the external event automatically.\n\n\n\nDoes this matter to what is being tested and verified?\n\nOverriding handleResolvedAddresses() this way is technically equivalent to calling a dummy handleResolvedAddresses() and immediately calling childHelper.updateBalancingState(READY, picker) after it. If all the test methods only need to call the two together, technically there is no difference, but looks all the tests and future tests are relying on this special behavior. Two approaches can technically achieve the same thing but one is hacky.\nJust my 2 cents.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r403400106", "createdAt": "2020-04-04T00:55:34Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      final Subchannel subchannel = new NoopSubchannel(resolvedAddresses.getAddresses());\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          return PickResult.withSubchannel(subchannel);\n+        }\n+      };\n+      helper.updateBalancingState(ConnectivityState.READY, picker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNzQ0NQ=="}, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyMTQzOA==", "bodyText": "Sure, sounds solid. Thanks. Updated.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r404321438", "createdAt": "2020-04-06T19:03:59Z", "author": {"login": "voidzcy"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      final Subchannel subchannel = new NoopSubchannel(resolvedAddresses.getAddresses());\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          return PickResult.withSubchannel(subchannel);\n+        }\n+      };\n+      helper.updateBalancingState(ConnectivityState.READY, picker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzNzQ0NQ=="}, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjcxNTY3OnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjowODoyN1rOF_UZpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxODo1MDozNFrOF_47uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzODg1Mw==", "bodyText": "This line is just testing test implementation and nothing else is tested. Use mock subchannel with childHelper.updateBalancingState() as test input, and verify result.getSubchannel() is expected.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r401938853", "createdAt": "2020-04-01T22:08:27Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUzNzQwMw==", "bodyText": "Deleted. We only care about the picker, how subchannel are created with respect to addresses are completely up to child balancer/helper's implementation. Not interested by LrsLoadBalancer's behavior.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r402537403", "createdAt": "2020-04-02T18:50:34Z", "author": {"login": "voidzcy"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    assertThat(result.getSubchannel().getAllAddresses()).isEqualTo(backendAddrs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzODg1Mw=="}, "originalCommit": {"oid": "e89a0e6db138e55a2ff5494bf104db448a5f2e12"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTEzMzEyOnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDoxODo1MFrOGBoUOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDo1MDowMVrOGBpWeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2MjI5Nw==", "bodyText": "This and NoopSubchannel  seem to be a lot implementation. We don't really care the original resolved EADs (in general there's no relation between original EAG and subchannel, the EGAs could even be empty), and the subchannel can totally be mocked as long as we know childBalancer.helper. But this is fine.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r404362297", "createdAt": "2020-04-06T20:18:50Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    NoopSubchannel subchannel = childBalancer.subchannels.values().iterator().next();\n+    deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    // Error after child policy is created.\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private static void deliverSubchannelState(\n+      final NoopSubchannel subchannel, ConnectivityState state) {\n+    SubchannelPicker picker = new SubchannelPicker() {\n+      @Override\n+      public PickResult pickSubchannel(PickSubchannelArgs args) {\n+        return PickResult.withSubchannel(subchannel);\n+      }\n+    };\n+    subchannel.helper.updateBalancingState(state, picker);\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+    private final Map<EquivalentAddressGroup, NoopSubchannel> subchannels = new HashMap<>();\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      List<EquivalentAddressGroup> addresses = resolvedAddresses.getAddresses();\n+      for (EquivalentAddressGroup eag : addresses) {\n+        subchannels.put(eag, new NoopSubchannel(helper));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c87cedb8040c2d971f8ea6fa120077d394e7af4"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3OTI1Nw==", "bodyText": "Yep, you are right. NoopSubchannel is mainly introduced for holding the reference to the Helper that creates it, which would be the instance that updateBalancingState(...) is invoked on. It's fine, all the required overridden methods are just no-op. Addresses are just used for a cleaner way of organizing/look up subchannels, to which states will be delivered. I agree, slightly overkill, but the way objects are organized looks pretty comfortable to me.", "url": "https://github.com/grpc/grpc-java/pull/6858#discussion_r404379257", "createdAt": "2020-04-06T20:50:01Z", "author": {"login": "voidzcy"}, "path": "xds/src/test/java/io/grpc/xds/LrsLoadBalancerTest.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import io.envoyproxy.envoy.api.v2.endpoint.ClusterStats;\n+import io.grpc.Attributes;\n+import io.grpc.ClientStreamTracer;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingStreamTracerFactory;\n+import io.grpc.xds.ClientLoadCounter.LoadRecordingSubchannelPicker;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/**\n+ * Unit tests for {@link LrsLoadBalancer}.\n+ */\n+@RunWith(JUnit4.class)\n+public class LrsLoadBalancerTest {\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  private static final String CLUSTER_NAME = \"cluster-foo.googleapis.com\";\n+  private static final String EDS_SERVICE_NAME = \"cluster-foo:service-blade\";\n+  private static final String LRS_SERVER_NAME = \"trafficdirector.googleapis.com\";\n+  private static final Locality TEST_LOCALITY =\n+      new Locality(\"test-region\", \"test-zone\", \"test-subzone\");\n+\n+  private final ClientLoadCounter counter = new ClientLoadCounter();\n+  private final LoadRecorder loadRecorder = new LoadRecorder();\n+  private final Queue<LoadBalancer> childBalancers = new ArrayDeque<>();\n+\n+  @Mock\n+  private Helper helper;\n+  private LrsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    loadBalancer = new LrsLoadBalancer(helper);\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+  }\n+\n+  @Test\n+  public void subchannelPickerInterceptedWithLoadRecording() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    NoopSubchannel subchannel = childBalancer.subchannels.values().iterator().next();\n+    deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    assertThat(loadRecorder.recording).isTrue();\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper).updateBalancingState(eq(ConnectivityState.READY), pickerCaptor.capture());\n+    SubchannelPicker picker = pickerCaptor.getValue();\n+    assertThat(picker).isInstanceOf(LoadRecordingSubchannelPicker.class);\n+    PickResult result = picker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    ClientStreamTracer.Factory tracerFactory = result.getStreamTracerFactory();\n+    assertThat(((LoadRecordingStreamTracerFactory) tracerFactory).getCounter())\n+        .isSameInstanceAs(counter);\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(loadRecorder.recording).isFalse();\n+  }\n+\n+  @Test\n+  public void updateChildPolicy() {\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    FakeLoadBalancer childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"round_robin\");\n+    deliverResolvedAddresses(backendAddrs, \"pick_first\");\n+    assertThat(childBalancer.shutdown).isTrue();\n+    childBalancer = (FakeLoadBalancer) childBalancers.poll();\n+    assertThat(childBalancer.name).isEqualTo(\"pick_first\");\n+    loadBalancer.shutdown();\n+    assertThat(childBalancer.shutdown).isTrue();\n+  }\n+\n+  @Test\n+  public void errorPropagation() {\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    ArgumentCaptor<SubchannelPicker> pickerCaptor = ArgumentCaptor.forClass(null);\n+    verify(helper)\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    Status status =\n+        pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+\n+    List<EquivalentAddressGroup> backendAddrs = createResolvedBackendAddresses(2);\n+    deliverResolvedAddresses(backendAddrs, \"round_robin\");\n+    // Error after child policy is created.\n+    loadBalancer.handleNameResolutionError(Status.UNKNOWN.withDescription(\"I failed\"));\n+    verify(helper, times(2))\n+        .updateBalancingState(eq(ConnectivityState.TRANSIENT_FAILURE), pickerCaptor.capture());\n+    status = pickerCaptor.getValue().pickSubchannel(mock(PickSubchannelArgs.class)).getStatus();\n+    assertThat(status.getDescription()).contains(\"I failed\");\n+    assertThat(status.getDescription()).contains(\"handled by downstream balancer\");\n+  }\n+\n+  private void deliverResolvedAddresses(\n+      List<EquivalentAddressGroup> addresses, String childPolicy) {\n+    PolicySelection childPolicyConfig =\n+        new PolicySelection(new FakeLoadBalancerProvider(childPolicy), null, null);\n+    LrsConfig config =\n+        new LrsConfig(\n+            CLUSTER_NAME, EDS_SERVICE_NAME, LRS_SERVER_NAME, TEST_LOCALITY, childPolicyConfig);\n+    ResolvedAddresses resolvedAddresses =\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(addresses)\n+            .setAttributes(\n+                Attributes.newBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadRecorder)\n+                    .build())\n+            .setLoadBalancingPolicyConfig(config)\n+            .build();\n+    loadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  private static List<EquivalentAddressGroup> createResolvedBackendAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      SocketAddress addr = new FakeSocketAddress(\"fake-address-\" + i);\n+      list.add(new EquivalentAddressGroup(addr));\n+    }\n+    return list;\n+  }\n+\n+  private static void deliverSubchannelState(\n+      final NoopSubchannel subchannel, ConnectivityState state) {\n+    SubchannelPicker picker = new SubchannelPicker() {\n+      @Override\n+      public PickResult pickSubchannel(PickSubchannelArgs args) {\n+        return PickResult.withSubchannel(subchannel);\n+      }\n+    };\n+    subchannel.helper.updateBalancingState(state, picker);\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      LoadBalancer balancer = new FakeLoadBalancer(helper, policyName);\n+      childBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private static final class FakeLoadBalancer extends LoadBalancer {\n+    private final Helper helper;\n+    private final String name;\n+    private boolean shutdown;\n+    private final Map<EquivalentAddressGroup, NoopSubchannel> subchannels = new HashMap<>();\n+\n+    FakeLoadBalancer(Helper helper, String name) {\n+      this.helper = helper;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      List<EquivalentAddressGroup> addresses = resolvedAddresses.getAddresses();\n+      for (EquivalentAddressGroup eag : addresses) {\n+        subchannels.put(eag, new NoopSubchannel(helper));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2MjI5Nw=="}, "originalCommit": {"oid": "3c87cedb8040c2d971f8ea6fa120077d394e7af4"}, "originalPosition": 234}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2750, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}