{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MDk4NTI1", "number": 7259, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMjo0OToxM1rOEVpZgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzowNDowOVrOEbCpTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTMzODI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMjo0OToxM1rOG8hWNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzoyMjoyM1rOHEWbqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjExNDEwMw==", "bodyText": "Is it better to offload this to the executor?\nfinal List<Runnable> runnables = pendingCalls;\npendingCalls = null;\nexecutor.execute(()-> {\n    for (Runnable pendingCall : runnables) {\n      pendingCall.run();\n    }});", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r466114103", "createdAt": "2020-08-06T02:49:13Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1511,6 +1588,15 @@ private void handleErrorInSyncContext(Status error) {\n       scheduleExponentialBackOffInSyncContext();\n     }\n \n+    private void drainPendingCalls() {\n+      if (pendingCalls != null) {\n+        for (Runnable pendingCall : pendingCalls) {\n+          pendingCall.run();\n+        }\n+        pendingCalls = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIyODAxOQ==", "bodyText": "Yes, I think we need to. We should really follow DelayedClientSteram's approach: schedule each call separately in the executor and if the CallOptions had an executor, we should use it.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467228019", "createdAt": "2020-08-07T19:24:31Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1511,6 +1588,15 @@ private void handleErrorInSyncContext(Status error) {\n       scheduleExponentialBackOffInSyncContext();\n     }\n \n+    private void drainPendingCalls() {\n+      if (pendingCalls != null) {\n+        for (Runnable pendingCall : pendingCalls) {\n+          pendingCall.run();\n+        }\n+        pendingCalls = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjExNDEwMw=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkyNzgwNw==", "bodyText": "Using callExecutor io.grpc.stub.ClientCallsTest.test blockingUnaryCall2_interruptedWaitsForOnClose is failing. Because the callExecutor is ClientCalls.ThreadlessExecutor and it throws with interrupted exception before assigning inprocess server response observer.  I think the failure is legitimate.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r468927807", "createdAt": "2020-08-11T23:53:46Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1511,6 +1588,15 @@ private void handleErrorInSyncContext(Status error) {\n       scheduleExponentialBackOffInSyncContext();\n     }\n \n+    private void drainPendingCalls() {\n+      if (pendingCalls != null) {\n+        for (Runnable pendingCall : pendingCalls) {\n+          pendingCall.run();\n+        }\n+        pendingCalls = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjExNDEwMw=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMzg4MA==", "bodyText": "Using callExecutor io.grpc.stub.ClientCallsTest.test blockingUnaryCall2_interruptedWaitsForOnClose is failing. Because the callExecutor is ClientCalls.ThreadlessExecutor and it throws with interrupted exception before assigning inprocess server response observer. I think the failure is legitimate.\n\nAs per offline discussion, we want to keep the tests behavior because exiting users' tests may also be relying on the currrent behavior. So we decide to make a hack/optimization at the beginning of newCall().", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r474323880", "createdAt": "2020-08-20T23:22:23Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1511,6 +1588,15 @@ private void handleErrorInSyncContext(Status error) {\n       scheduleExponentialBackOffInSyncContext();\n     }\n \n+    private void drainPendingCalls() {\n+      if (pendingCalls != null) {\n+        for (Runnable pendingCall : pendingCalls) {\n+          pendingCall.run();\n+        }\n+        pendingCalls = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjExNDEwMw=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDIxNjAzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzoyMTo1MlrOG89BpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzoyMTo1MlrOG89BpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2NzU4OQ==", "bodyText": "nit: get rid of the else and just reduce the indentation of the rest of this method's code?", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r466567589", "createdAt": "2020-08-06T17:21:52Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,18 +907,39 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n-      return new ClientCallImpl<>(\n-          method,\n-          getCallExecutor(callOptions),\n-          callOptions,\n-          transportProvider,\n-          terminated ? null : transportFactory.getScheduledExecutorService(),\n-          channelCallTracer)\n-          .setFullStreamDecompression(fullStreamDecompression)\n-          .setDecompressorRegistry(decompressorRegistry)\n-          .setCompressorRegistry(compressorRegistry);\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDIyMzY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzoyMzoxNFrOG89GQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNjozNDowNFrOHCFPCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2ODc2OA==", "bodyText": "I don't think the OobChannel should have any service config. It certainly wouldn't share the service config with the parent, right, since it is to some other random server?", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r466568768", "createdAt": "2020-08-06T17:23:14Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1204,7 +1258,8 @@ public ManagedChannel createOobChannel(EquivalentAddressGroup addressGroup, Stri\n               \"OobChannel for \" + addressGroup);\n       final OobChannel oobChannel = new OobChannel(\n           authority, balancerRpcExecutorPool, transportFactory.getScheduledExecutorService(),\n-          syncContext, callTracerFactory.create(), oobChannelTracer, channelz, timeProvider);\n+          syncContext, callTracerFactory.create(), oobChannelTracer, channelz, timeProvider,\n+          configSelector);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3MDAyOQ==", "bodyText": "Right. I thought the OobChannel uses the same lb policy as the parent channel, so it need the same config selector. After a second look, it does not uses any lb policy, just makes use of a given subchannelImpl", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467270029", "createdAt": "2020-08-07T21:09:51Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1204,7 +1258,8 @@ public ManagedChannel createOobChannel(EquivalentAddressGroup addressGroup, Stri\n               \"OobChannel for \" + addressGroup);\n       final OobChannel oobChannel = new OobChannel(\n           authority, balancerRpcExecutorPool, transportFactory.getScheduledExecutorService(),\n-          syncContext, callTracerFactory.create(), oobChannelTracer, channelz, timeProvider);\n+          syncContext, callTracerFactory.create(), oobChannelTracer, channelz, timeProvider,\n+          configSelector);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2ODc2OA=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0NDk2OA==", "bodyText": "Fixed", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r471944968", "createdAt": "2020-08-18T06:34:04Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1204,7 +1258,8 @@ public ManagedChannel createOobChannel(EquivalentAddressGroup addressGroup, Stri\n               \"OobChannel for \" + addressGroup);\n       final OobChannel oobChannel = new OobChannel(\n           authority, balancerRpcExecutorPool, transportFactory.getScheduledExecutorService(),\n-          syncContext, callTracerFactory.create(), oobChannelTracer, channelz, timeProvider);\n+          syncContext, callTracerFactory.create(), oobChannelTracer, channelz, timeProvider,\n+          configSelector);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2ODc2OA=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzk4MDM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjozNDo1M1rOG9gbCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMjoxNjo1M1rOG9qTug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NzUzMA==", "bodyText": "I don't think we should log at info level. This could be FINE, but we should not log at a default log level when everything is fine, and even when something is broken we try hard not to log.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467147530", "createdAt": "2020-08-07T16:34:53Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1408,13 +1465,21 @@ public void run() {\n             }\n             effectiveServiceConfig =\n                 defaultServiceConfig == null ? EMPTY_SERVICE_CONFIG : defaultServiceConfig;\n+            if (resolvedConfigSelector != null) {\n+              channelLogger.log(\n+                  ChannelLogLevel.INFO,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2Nzg1OQ==", "bodyText": "ChannelLogLevel.INFO is java.util.Logger.LogLevel.FINEST, there is no ChannelLogLevel.FINE available.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467267859", "createdAt": "2020-08-07T21:04:00Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1408,13 +1465,21 @@ public void run() {\n             }\n             effectiveServiceConfig =\n                 defaultServiceConfig == null ? EMPTY_SERVICE_CONFIG : defaultServiceConfig;\n+            if (resolvedConfigSelector != null) {\n+              channelLogger.log(\n+                  ChannelLogLevel.INFO,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NzUzMA=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMwOTQ5OA==", "bodyText": "That burns me every time.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467309498", "createdAt": "2020-08-07T22:16:53Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1408,13 +1465,21 @@ public void run() {\n             }\n             effectiveServiceConfig =\n                 defaultServiceConfig == null ? EMPTY_SERVICE_CONFIG : defaultServiceConfig;\n+            if (resolvedConfigSelector != null) {\n+              channelLogger.log(\n+                  ChannelLogLevel.INFO,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0NzUzMA=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNzk4NzIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjozNjo1OFrOG9gfQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMTowMTo1NFrOG9nuBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0ODYwOQ==", "bodyText": "I don't understand why you are assuming the config selector will only exist if there is a service config. Why can't we use the config selector here?\nReally, it seems like we can use the configSelector independent of how the service config validated; the name resolver could be fully aware of the failure, after all, and we have decided we want to allow the name resolver to allow communicating things failing independently. The only time we'd avoid applying the config selector is if lookUpServiceConfig == true, although even in that case it could make sense to call the config selector but throw away the service config result (that could be done easily by wrapping resolvedConfigSelector).", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467148609", "createdAt": "2020-08-07T16:36:58Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1408,13 +1465,21 @@ public void run() {\n             }\n             effectiveServiceConfig =\n                 defaultServiceConfig == null ? EMPTY_SERVICE_CONFIG : defaultServiceConfig;\n+            if (resolvedConfigSelector != null) {\n+              channelLogger.log(\n+                  ChannelLogLevel.INFO,\n+                  \"Config selector from name resolver discarded by channel settings\");\n+            }\n+            configSelector.set(null);\n           } else {\n             // Try to use config if returned from name resolver\n             // Otherwise, try to use the default config if available\n             if (validServiceConfig != null) {\n               effectiveServiceConfig = validServiceConfig;\n+              configSelector.set(resolvedConfigSelector);\n             } else if (defaultServiceConfig != null) {\n               effectiveServiceConfig = defaultServiceConfig;\n+              configSelector.set(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2NzA3Nw==", "bodyText": "The config selector should only work with the service config returned together by the resolver. It shouldn't work with an arbitrarily provided defaultServiceConfig. In the case we choose defaultServiceConfig, we should ignore the config selector.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467267077", "createdAt": "2020-08-07T21:01:54Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1408,13 +1465,21 @@ public void run() {\n             }\n             effectiveServiceConfig =\n                 defaultServiceConfig == null ? EMPTY_SERVICE_CONFIG : defaultServiceConfig;\n+            if (resolvedConfigSelector != null) {\n+              channelLogger.log(\n+                  ChannelLogLevel.INFO,\n+                  \"Config selector from name resolver discarded by channel settings\");\n+            }\n+            configSelector.set(null);\n           } else {\n             // Try to use config if returned from name resolver\n             // Otherwise, try to use the default config if available\n             if (validServiceConfig != null) {\n               effectiveServiceConfig = validServiceConfig;\n+              configSelector.set(resolvedConfigSelector);\n             } else if (defaultServiceConfig != null) {\n               effectiveServiceConfig = defaultServiceConfig;\n+              configSelector.set(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0ODYwOQ=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODI5NjEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODoxNjoxNFrOG9jdFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNjozNDo1OVrOHCFQjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5NzIwNw==", "bodyText": "Could we always discard this key?", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467197207", "createdAt": "2020-08-07T18:16:14Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1452,22 +1518,29 @@ public void run() {\n                   re);\n             }\n           }\n+          drainPendingCalls();\n \n           Attributes effectiveAttrs = resolutionResult.getAttributes();\n           // Call LB only if it's not shutdown.  If LB is shutdown, lbHelper won't match.\n           if (NameResolverListener.this.helper == ManagedChannelImpl.this.lbHelper) {\n+            Attributes.Builder attrBuilder = effectiveAttrs.toBuilder();\n+            if (configSelector.get() == null) {\n+              attrBuilder.discard(InternalConfigSelector.KEY);\n+            } else {\n+              attrBuilder.set(InternalConfigSelector.KEY, configSelector.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0NTM1Nw==", "bodyText": "Yes, you're right.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r471945357", "createdAt": "2020-08-18T06:34:59Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1452,22 +1518,29 @@ public void run() {\n                   re);\n             }\n           }\n+          drainPendingCalls();\n \n           Attributes effectiveAttrs = resolutionResult.getAttributes();\n           // Call LB only if it's not shutdown.  If LB is shutdown, lbHelper won't match.\n           if (NameResolverListener.this.helper == ManagedChannelImpl.this.lbHelper) {\n+            Attributes.Builder attrBuilder = effectiveAttrs.toBuilder();\n+            if (configSelector.get() == null) {\n+              attrBuilder.discard(InternalConfigSelector.KEY);\n+            } else {\n+              attrBuilder.set(InternalConfigSelector.KEY, configSelector.get());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5NzIwNw=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODMyMjcwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODoyNTo0NlrOG9juTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNjozNToyMFrOHCFRNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwMTYxNQ==", "bodyText": "Are we assuming that the NameResolver will return before we will go idle? We may want a check in enterIdleMode() to wake things up again if configSelector.get() == INITIAL_PENDING_SELECTOR, like where we check inUseStateAggregator. It would probably be good to just update inUseStateAggregator appropriately; that will also handle this exitIdleMode().", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467201615", "createdAt": "2020-08-07T18:25:46Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,18 +907,39 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n-      return new ClientCallImpl<>(\n-          method,\n-          getCallExecutor(callOptions),\n-          callOptions,\n-          transportProvider,\n-          terminated ? null : transportFactory.getScheduledExecutorService(),\n-          channelCallTracer)\n-          .setFullStreamDecompression(fullStreamDecompression)\n-          .setDecompressorRegistry(decompressorRegistry)\n-          .setCompressorRegistry(compressorRegistry);\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      } else {\n+        final DelayedClientCall<ReqT, RespT> delayedClientCall = new DelayedClientCall<>(\n+            getCallExecutor(callOptions), scheduledExecutor, callOptions.getDeadline());\n+        final Context context = Context.current();\n+        class TransitionRunnable extends ContextRunnable {\n+          TransitionRunnable() {\n+            super(context);\n+          }\n+\n+          @Override\n+          public void runInContext() {\n+            delayedClientCall.setCall(newClientCall(method, callOptions));\n+          }\n+        }\n+\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            exitIdleMode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI4MDgxMQ==", "bodyText": "The purpose of exitIdleMode() here is to start the name resolver. Why should we care if NameResolver returns after channel going idle?", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467280811", "createdAt": "2020-08-07T21:30:40Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,18 +907,39 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n-      return new ClientCallImpl<>(\n-          method,\n-          getCallExecutor(callOptions),\n-          callOptions,\n-          transportProvider,\n-          terminated ? null : transportFactory.getScheduledExecutorService(),\n-          channelCallTracer)\n-          .setFullStreamDecompression(fullStreamDecompression)\n-          .setDecompressorRegistry(decompressorRegistry)\n-          .setCompressorRegistry(compressorRegistry);\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      } else {\n+        final DelayedClientCall<ReqT, RespT> delayedClientCall = new DelayedClientCall<>(\n+            getCallExecutor(callOptions), scheduledExecutor, callOptions.getDeadline());\n+        final Context context = Context.current();\n+        class TransitionRunnable extends ContextRunnable {\n+          TransitionRunnable() {\n+            super(context);\n+          }\n+\n+          @Override\n+          public void runInContext() {\n+            delayedClientCall.setCall(newClientCall(method, callOptions));\n+          }\n+        }\n+\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            exitIdleMode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwMTYxNQ=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMDgxMg==", "bodyText": "The code buffers calls until the name resolver returns for the first time. We must not let the channel go idle while calls are buffered, as they will be \"stuck\"; the channel would not be trying to connect yet there are outstanding RPCs to service.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467310812", "createdAt": "2020-08-07T22:22:11Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,18 +907,39 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n-      return new ClientCallImpl<>(\n-          method,\n-          getCallExecutor(callOptions),\n-          callOptions,\n-          transportProvider,\n-          terminated ? null : transportFactory.getScheduledExecutorService(),\n-          channelCallTracer)\n-          .setFullStreamDecompression(fullStreamDecompression)\n-          .setDecompressorRegistry(decompressorRegistry)\n-          .setCompressorRegistry(compressorRegistry);\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      } else {\n+        final DelayedClientCall<ReqT, RespT> delayedClientCall = new DelayedClientCall<>(\n+            getCallExecutor(callOptions), scheduledExecutor, callOptions.getDeadline());\n+        final Context context = Context.current();\n+        class TransitionRunnable extends ContextRunnable {\n+          TransitionRunnable() {\n+            super(context);\n+          }\n+\n+          @Override\n+          public void runInContext() {\n+            delayedClientCall.setCall(newClientCall(method, callOptions));\n+          }\n+        }\n+\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            exitIdleMode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwMTYxNQ=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0NTUyNA==", "bodyText": "Fixed.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r471945524", "createdAt": "2020-08-18T06:35:20Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,18 +907,39 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n-      return new ClientCallImpl<>(\n-          method,\n-          getCallExecutor(callOptions),\n-          callOptions,\n-          transportProvider,\n-          terminated ? null : transportFactory.getScheduledExecutorService(),\n-          channelCallTracer)\n-          .setFullStreamDecompression(fullStreamDecompression)\n-          .setDecompressorRegistry(decompressorRegistry)\n-          .setCompressorRegistry(compressorRegistry);\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      } else {\n+        final DelayedClientCall<ReqT, RespT> delayedClientCall = new DelayedClientCall<>(\n+            getCallExecutor(callOptions), scheduledExecutor, callOptions.getDeadline());\n+        final Context context = Context.current();\n+        class TransitionRunnable extends ContextRunnable {\n+          TransitionRunnable() {\n+            super(context);\n+          }\n+\n+          @Override\n+          public void runInContext() {\n+            delayedClientCall.setCall(newClientCall(method, callOptions));\n+          }\n+        }\n+\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            exitIdleMode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwMTYxNQ=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODM3MTcyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo0MzozMVrOG9kNLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNjozMDo0M1rOHCFKEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTUxNg==", "bodyText": "How much do we care about this holding onto cancelled RPCs during startup? It seems we should remove items for RPC cancellation, right?", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467209516", "createdAt": "2020-08-07T18:43:31Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -207,6 +216,10 @@ public void uncaughtException(Thread t, Throwable e) {\n   // switch to a ConcurrentHashMap.\n   private final Set<InternalSubchannel> subchannels = new HashSet<>(16, .75f);\n \n+  // Must be accessed from syncContext\n+  @Nullable\n+  private Collection<Runnable> pendingCalls = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3MzY5Nw==", "bodyText": "Hmm, it might be hard to remove an item when it's cancelled.\nBut at least we should avoid setCall(newClientCall(method, callOptions)) when resolver returns after cancellation. That is easier, we can just check\nfor (Runnable pendingCall : pendingCalls) {\n  if (!peddingCall.isCancelled()) {\n    executor.execute(() -> pendingCall.run());\n  }\n}", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467273697", "createdAt": "2020-08-07T21:20:29Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -207,6 +216,10 @@ public void uncaughtException(Thread t, Throwable e) {\n   // switch to a ConcurrentHashMap.\n   private final Set<InternalSubchannel> subchannels = new HashSet<>(16, .75f);\n \n+  // Must be accessed from syncContext\n+  @Nullable\n+  private Collection<Runnable> pendingCalls = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTUxNg=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTc2MA==", "bodyText": "DelayedClientTransport keeps a LinkedHashSet for the instances to be able to remove them. It doesn't seem that hard to me, although it'd be harder if you keep the collection containing Runnables.\nI don't think setCall(newClientCall(method, callOptions)) is any problem; ClientCallImpl can be safely thrown away and not started. And setCall() does nothing if the call was already.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467311760", "createdAt": "2020-08-07T22:25:40Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -207,6 +216,10 @@ public void uncaughtException(Thread t, Throwable e) {\n   // switch to a ConcurrentHashMap.\n   private final Set<InternalSubchannel> subchannels = new HashSet<>(16, .75f);\n \n+  // Must be accessed from syncContext\n+  @Nullable\n+  private Collection<Runnable> pendingCalls = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTUxNg=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxNzIzNQ==", "bodyText": "DelayedClientTransport keeps a LinkedHashSet for the instances to be able to remove them. It doesn't seem that hard to me, although it'd be harder if you keep the collection containing Runnables.\n\nI could use a LinkedHashMap instead. But I might need to copy the pattern from DelayedClientTransport as well.\nclass PendingStream extends DelayedStream {\n  @Override\n  public void cancel(Status reason) {}\n}\n\nI don't think setCall(newClientCall(method, callOptions)) is any problem\n\nMy concern was instantiation of ClientCallImpl objects just waiting for garbage collection.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467317235", "createdAt": "2020-08-07T22:47:34Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -207,6 +216,10 @@ public void uncaughtException(Thread t, Throwable e) {\n   // switch to a ConcurrentHashMap.\n   private final Set<InternalSubchannel> subchannels = new HashSet<>(16, .75f);\n \n+  // Must be accessed from syncContext\n+  @Nullable\n+  private Collection<Runnable> pendingCalls = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTUxNg=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0MzY5OA==", "bodyText": "Doing removal for cancelled calls now.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r471943698", "createdAt": "2020-08-18T06:30:43Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -207,6 +216,10 @@ public void uncaughtException(Thread t, Throwable e) {\n   // switch to a ConcurrentHashMap.\n   private final Set<InternalSubchannel> subchannels = new HashSet<>(16, .75f);\n \n+  // Must be accessed from syncContext\n+  @Nullable\n+  private Collection<Runnable> pendingCalls = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTUxNg=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODQ5OTMwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxOToyNzozN1rOG9la3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwNjozMTo1MVrOHCFLsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIyOTQwNg==", "bodyText": "I don't see us making an InternalConfigSelector for the provided service config anywhere. The \"normal\" approach is the name resolver will not provide an InternalConfigSelector, and it isn't clear how that is supposed to be handled.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467229406", "createdAt": "2020-08-07T19:27:37Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1393,9 +1448,11 @@ public void run() {\n \n           nameResolverBackoffPolicy = null;\n           ConfigOrError configOrError = resolutionResult.getServiceConfig();\n+          InternalConfigSelector resolvedConfigSelector =\n+              resolutionResult.getAttributes().get(InternalConfigSelector.KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2MjQzNw==", "bodyText": "I don't understand. What does \"normal\" approach do?", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467262437", "createdAt": "2020-08-07T20:50:08Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1393,9 +1448,11 @@ public void run() {\n \n           nameResolverBackoffPolicy = null;\n           ConfigOrError configOrError = resolutionResult.getServiceConfig();\n+          InternalConfigSelector resolvedConfigSelector =\n+              resolutionResult.getAttributes().get(InternalConfigSelector.KEY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIyOTQwNg=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMzMxMA==", "bodyText": "If a service config provides per-method configuration, right now ServiceConfigInterceptor processes the configuration and applies it to the call via CallOptions. This is quite a different flow. I would have expected the two data flows to be more similar.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r467313310", "createdAt": "2020-08-07T22:31:50Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1393,9 +1448,11 @@ public void run() {\n \n           nameResolverBackoffPolicy = null;\n           ConfigOrError configOrError = resolutionResult.getServiceConfig();\n+          InternalConfigSelector resolvedConfigSelector =\n+              resolutionResult.getAttributes().get(InternalConfigSelector.KEY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIyOTQwNg=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk0NDExMw==", "bodyText": "Will be doing that in a separate PR.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r471944113", "createdAt": "2020-08-18T06:31:51Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1393,9 +1448,11 @@ public void run() {\n \n           nameResolverBackoffPolicy = null;\n           ConfigOrError configOrError = resolutionResult.getServiceConfig();\n+          InternalConfigSelector resolvedConfigSelector =\n+              resolutionResult.getAttributes().get(InternalConfigSelector.KEY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIyOTQwNg=="}, "originalCommit": {"oid": "17a301e8daabc08d1965fd9899589661c82444d6"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTkzNzg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNDo0ODoxN1rOHCYK3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxOTowODo0NFrOHCiLRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1NTE5Ng==", "bodyText": "This is only called from the PendingCallRunnable. cancel() calls setRealCall(), not this method.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472255196", "createdAt": "2020-08-18T14:48:17Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,24 +914,90 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      }\n+      final Context context = Context.current();\n+      final PendingCall<ReqT, RespT> pendingCall = new PendingCall<>(context, method, callOptions);\n+\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          exitIdleMode();\n+          if (configSelector.get() == INITIAL_PENDING_SELECTOR) {\n+            if (pendingCalls.isEmpty()) {\n+              inUseStateAggregator.updateObjectInUse(RealChannel.this, true);\n+            }\n+            pendingCalls.add(pendingCall);\n+          } else {\n+            pendingCall.pendingCallRunnable.run();\n+          }\n+        }\n+      });\n+      return pendingCall;\n+    }\n+\n+    @Override\n+    public String authority() {\n+      return authority;\n+    }\n+\n+    private final class PendingCall<ReqT, RespT> extends DelayedClientCall<ReqT, RespT> {\n+      final Runnable pendingCallRunnable;\n+\n+      PendingCall(\n+          final Context context, final MethodDescriptor<ReqT, RespT> method,\n+          final CallOptions callOptions) {\n+        super(getCallExecutor(callOptions), scheduledExecutor, callOptions.getDeadline());\n+        class PendingCallRunnable implements Runnable {\n+          @Override\n+          public void run() {\n+            getCallExecutor(callOptions).execute(\n+                new ContextRunnable(context) {\n+                  @Override\n+                  public void runInContext() {\n+                    setCall(newClientCall(method, callOptions));\n+                  }\n+                }\n+            );\n+          }\n+        }\n+\n+        pendingCallRunnable = new PendingCallRunnable();\n+      }\n+\n+      @Override\n+      void setCall(ClientCall<ReqT, RespT> call) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d9449cda2858319e3ff34ba0cca857956ff1332"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMwMjkwNg==", "bodyText": "Should I override setRealCall() or cancel(final Status status, boolean onlyCancelPendingCall)?", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472302906", "createdAt": "2020-08-18T15:53:53Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,24 +914,90 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      }\n+      final Context context = Context.current();\n+      final PendingCall<ReqT, RespT> pendingCall = new PendingCall<>(context, method, callOptions);\n+\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          exitIdleMode();\n+          if (configSelector.get() == INITIAL_PENDING_SELECTOR) {\n+            if (pendingCalls.isEmpty()) {\n+              inUseStateAggregator.updateObjectInUse(RealChannel.this, true);\n+            }\n+            pendingCalls.add(pendingCall);\n+          } else {\n+            pendingCall.pendingCallRunnable.run();\n+          }\n+        }\n+      });\n+      return pendingCall;\n+    }\n+\n+    @Override\n+    public String authority() {\n+      return authority;\n+    }\n+\n+    private final class PendingCall<ReqT, RespT> extends DelayedClientCall<ReqT, RespT> {\n+      final Runnable pendingCallRunnable;\n+\n+      PendingCall(\n+          final Context context, final MethodDescriptor<ReqT, RespT> method,\n+          final CallOptions callOptions) {\n+        super(getCallExecutor(callOptions), scheduledExecutor, callOptions.getDeadline());\n+        class PendingCallRunnable implements Runnable {\n+          @Override\n+          public void run() {\n+            getCallExecutor(callOptions).execute(\n+                new ContextRunnable(context) {\n+                  @Override\n+                  public void runInContext() {\n+                    setCall(newClientCall(method, callOptions));\n+                  }\n+                }\n+            );\n+          }\n+        }\n+\n+        pendingCallRunnable = new PendingCallRunnable();\n+      }\n+\n+      @Override\n+      void setCall(ClientCall<ReqT, RespT> call) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1NTE5Ng=="}, "originalCommit": {"oid": "0d9449cda2858319e3ff34ba0cca857956ff1332"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM2NTE5OA==", "bodyText": "Cancel would be ideal, but I don't think it currently makes sense because it might not actually cancel. setRealCall() is called under a lock, so that's no good. I think it may be good to have a new protected void callCancelled() {} noop method for overriding, that is called during cancel(Status, boolean) only if it cancels.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472365198", "createdAt": "2020-08-18T17:31:52Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,24 +914,90 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      }\n+      final Context context = Context.current();\n+      final PendingCall<ReqT, RespT> pendingCall = new PendingCall<>(context, method, callOptions);\n+\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          exitIdleMode();\n+          if (configSelector.get() == INITIAL_PENDING_SELECTOR) {\n+            if (pendingCalls.isEmpty()) {\n+              inUseStateAggregator.updateObjectInUse(RealChannel.this, true);\n+            }\n+            pendingCalls.add(pendingCall);\n+          } else {\n+            pendingCall.pendingCallRunnable.run();\n+          }\n+        }\n+      });\n+      return pendingCall;\n+    }\n+\n+    @Override\n+    public String authority() {\n+      return authority;\n+    }\n+\n+    private final class PendingCall<ReqT, RespT> extends DelayedClientCall<ReqT, RespT> {\n+      final Runnable pendingCallRunnable;\n+\n+      PendingCall(\n+          final Context context, final MethodDescriptor<ReqT, RespT> method,\n+          final CallOptions callOptions) {\n+        super(getCallExecutor(callOptions), scheduledExecutor, callOptions.getDeadline());\n+        class PendingCallRunnable implements Runnable {\n+          @Override\n+          public void run() {\n+            getCallExecutor(callOptions).execute(\n+                new ContextRunnable(context) {\n+                  @Override\n+                  public void runInContext() {\n+                    setCall(newClientCall(method, callOptions));\n+                  }\n+                }\n+            );\n+          }\n+        }\n+\n+        pendingCallRunnable = new PendingCallRunnable();\n+      }\n+\n+      @Override\n+      void setCall(ClientCall<ReqT, RespT> call) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1NTE5Ng=="}, "originalCommit": {"oid": "0d9449cda2858319e3ff34ba0cca857956ff1332"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQxOTE0Mw==", "bodyText": "Good idea. Done.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472419143", "createdAt": "2020-08-18T19:08:44Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,24 +914,90 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        final MethodDescriptor<ReqT, RespT> method, final CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      }\n+      final Context context = Context.current();\n+      final PendingCall<ReqT, RespT> pendingCall = new PendingCall<>(context, method, callOptions);\n+\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          exitIdleMode();\n+          if (configSelector.get() == INITIAL_PENDING_SELECTOR) {\n+            if (pendingCalls.isEmpty()) {\n+              inUseStateAggregator.updateObjectInUse(RealChannel.this, true);\n+            }\n+            pendingCalls.add(pendingCall);\n+          } else {\n+            pendingCall.pendingCallRunnable.run();\n+          }\n+        }\n+      });\n+      return pendingCall;\n+    }\n+\n+    @Override\n+    public String authority() {\n+      return authority;\n+    }\n+\n+    private final class PendingCall<ReqT, RespT> extends DelayedClientCall<ReqT, RespT> {\n+      final Runnable pendingCallRunnable;\n+\n+      PendingCall(\n+          final Context context, final MethodDescriptor<ReqT, RespT> method,\n+          final CallOptions callOptions) {\n+        super(getCallExecutor(callOptions), scheduledExecutor, callOptions.getDeadline());\n+        class PendingCallRunnable implements Runnable {\n+          @Override\n+          public void run() {\n+            getCallExecutor(callOptions).execute(\n+                new ContextRunnable(context) {\n+                  @Override\n+                  public void runInContext() {\n+                    setCall(newClientCall(method, callOptions));\n+                  }\n+                }\n+            );\n+          }\n+        }\n+\n+        pendingCallRunnable = new PendingCallRunnable();\n+      }\n+\n+      @Override\n+      void setCall(ClientCall<ReqT, RespT> call) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1NTE5Ng=="}, "originalCommit": {"oid": "0d9449cda2858319e3ff34ba0cca857956ff1332"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTk0OTA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNDo1MDo0MFrOHCYSAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxOTowOTowMVrOHCiL5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1NzAyNQ==", "bodyText": "This may be large. We don't want to keep it around after we are no longer queuing calls.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472257025", "createdAt": "2020-08-18T14:50:40Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -207,6 +217,9 @@ public void uncaughtException(Thread t, Throwable e) {\n   // switch to a ConcurrentHashMap.\n   private final Set<InternalSubchannel> subchannels = new HashSet<>(16, .75f);\n \n+  // Must be accessed from syncContext\n+  private final Collection<RealChannel.PendingCall<?, ?>> pendingCalls = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d9449cda2858319e3ff34ba0cca857956ff1332"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMwMDQ4Mg==", "bodyText": "Yeah, I was trying to clear it but I had NPE 0d9449c. Seems I need introduce a flag.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472300482", "createdAt": "2020-08-18T15:50:42Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -207,6 +217,9 @@ public void uncaughtException(Thread t, Throwable e) {\n   // switch to a ConcurrentHashMap.\n   private final Set<InternalSubchannel> subchannels = new HashSet<>(16, .75f);\n \n+  // Must be accessed from syncContext\n+  private final Collection<RealChannel.PendingCall<?, ?>> pendingCalls = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1NzAyNQ=="}, "originalCommit": {"oid": "0d9449cda2858319e3ff34ba0cca857956ff1332"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM1Nzc1Nw==", "bodyText": "After each remove(), if the set is now empty check the config selector to see if buffering is still occurring. If not, set it to null.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472357757", "createdAt": "2020-08-18T17:19:21Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -207,6 +217,9 @@ public void uncaughtException(Thread t, Throwable e) {\n   // switch to a ConcurrentHashMap.\n   private final Set<InternalSubchannel> subchannels = new HashSet<>(16, .75f);\n \n+  // Must be accessed from syncContext\n+  private final Collection<RealChannel.PendingCall<?, ?>> pendingCalls = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1NzAyNQ=="}, "originalCommit": {"oid": "0d9449cda2858319e3ff34ba0cca857956ff1332"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQxOTMwMw==", "bodyText": "Done.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472419303", "createdAt": "2020-08-18T19:09:01Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -207,6 +217,9 @@ public void uncaughtException(Thread t, Throwable e) {\n   // switch to a ConcurrentHashMap.\n   private final Set<InternalSubchannel> subchannels = new HashSet<>(16, .75f);\n \n+  // Must be accessed from syncContext\n+  private final Collection<RealChannel.PendingCall<?, ?>> pendingCalls = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1NzAyNQ=="}, "originalCommit": {"oid": "0d9449cda2858319e3ff34ba0cca857956ff1332"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Mjk3OTA1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxOToxNTo0NlrOHCiZ8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMToyODoyOVrOHCnVXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQyMjg5OQ==", "bodyText": "I think you actually had this correct before. We need to wait until the calls are drained (at least the newCall and start() for each call) until we consider this no longer used, as otherwise that opens up a race window where it appears there are no RPCs in progress.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472422899", "createdAt": "2020-08-18T19:15:46Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1511,6 +1626,18 @@ private void handleErrorInSyncContext(Status error) {\n       scheduleExponentialBackOffInSyncContext();\n     }\n \n+    // Must run in SynchronizationContext.\n+    private void drainPendingCalls() {\n+      if (pendingCalls == null) {\n+        return;\n+      }\n+      for (RealChannel.PendingCall<?, ?> pendingCall : pendingCalls) {\n+        pendingCall.pendingCallRunnable.run();\n+      }\n+      inUseStateAggregator.updateObjectInUse(pendingCallsInUseObject, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df5eb253af6a1de65217b2dc76be38a9c7d8411e"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMzY0NA==", "bodyText": "Yeah, that's subtle. Fixed.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472503644", "createdAt": "2020-08-18T21:28:29Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1511,6 +1626,18 @@ private void handleErrorInSyncContext(Status error) {\n       scheduleExponentialBackOffInSyncContext();\n     }\n \n+    // Must run in SynchronizationContext.\n+    private void drainPendingCalls() {\n+      if (pendingCalls == null) {\n+        return;\n+      }\n+      for (RealChannel.PendingCall<?, ?> pendingCall : pendingCalls) {\n+        pendingCall.pendingCallRunnable.run();\n+      }\n+      inUseStateAggregator.updateObjectInUse(pendingCallsInUseObject, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQyMjg5OQ=="}, "originalCommit": {"oid": "df5eb253af6a1de65217b2dc76be38a9c7d8411e"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzQ4NjE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMToyODo1OFrOHCnWOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMDowMjowMFrOHDXFVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMzg2Nw==", "bodyText": "Every call to executeLater must be followed by a drain() call. I don't see such a call here or in callCancelled()", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472503867", "createdAt": "2020-08-18T21:28:58Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -962,6 +962,18 @@ public void run() {\n                   @Override\n                   public void runInContext() {\n                     setCall(newClientCall(method, callOptions));\n+                    syncContext.executeLater(new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47d0f4a0050541e1ac2e60d7fda0908601bb3cb1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMjc3OQ==", "bodyText": "The IdleTimer or cancelIdleTimer() will drain it. It only need be drained any time before IdleTimer is called.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472512779", "createdAt": "2020-08-18T21:48:53Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -962,6 +962,18 @@ public void run() {\n                   @Override\n                   public void runInContext() {\n                     setCall(newClientCall(method, callOptions));\n+                    syncContext.executeLater(new Runnable() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMzg2Nw=="}, "originalCommit": {"oid": "47d0f4a0050541e1ac2e60d7fda0908601bb3cb1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxNzEwOA==", "bodyText": "isInUse() is accessed in syncContext. So whenever you check isInUse(), it is drained. Otherwise it will eventually be drained by IdleTimer or cancelIdleTimer()", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r472517108", "createdAt": "2020-08-18T21:58:56Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -962,6 +962,18 @@ public void run() {\n                   @Override\n                   public void runInContext() {\n                     setCall(newClientCall(method, callOptions));\n+                    syncContext.executeLater(new Runnable() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMzg2Nw=="}, "originalCommit": {"oid": "47d0f4a0050541e1ac2e60d7fda0908601bb3cb1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE3NTAzNQ==", "bodyText": "IdleTimer: you are saying you are willing to wait for minutes, to hours, or maybe even forever (idle time could be infinite)? No, that's a bad idea.\nisInUse(): That seems neither here nor there. It is called from idle mode logic, and we won't call exitIdleMode() unless we are in idle mode.\nEven if those weren't broken, they are far too hard to verify and audit. Every call to executeLater needs to have a call to drain(). We use executeLater when we are processing within a lock, and then we call drain outside of the lock. I don't understand why we are using executeLater here.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r473175035", "createdAt": "2020-08-19T16:46:19Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -962,6 +962,18 @@ public void run() {\n                   @Override\n                   public void runInContext() {\n                     setCall(newClientCall(method, callOptions));\n+                    syncContext.executeLater(new Runnable() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMzg2Nw=="}, "originalCommit": {"oid": "47d0f4a0050541e1ac2e60d7fda0908601bb3cb1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIwOTcxNA==", "bodyText": "I don't understand why we are using executeLater here.\n\nMy purpose of using executeLater() is to offload channel's tasks in syncCtx (could be a ton of them) from callExecutor thread. If it's not necessary performance wise, I will revert to execute().", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r473209714", "createdAt": "2020-08-19T17:38:32Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -962,6 +962,18 @@ public void run() {\n                   @Override\n                   public void runInContext() {\n                     setCall(newClientCall(method, callOptions));\n+                    syncContext.executeLater(new Runnable() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMzg2Nw=="}, "originalCommit": {"oid": "47d0f4a0050541e1ac2e60d7fda0908601bb3cb1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1MTg5NQ==", "bodyText": "The amount of processing in the Runnable is very small. I don't think we should be too concerned. In any case, we should favor correctness over performance so if this was important we'd need to figure out some other approach (which I do see some options available, but given the current inexpensive runnable it would be very hard to show significant improvements).", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r473251895", "createdAt": "2020-08-19T18:56:17Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -962,6 +962,18 @@ public void run() {\n                   @Override\n                   public void runInContext() {\n                     setCall(newClientCall(method, callOptions));\n+                    syncContext.executeLater(new Runnable() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMzg2Nw=="}, "originalCommit": {"oid": "47d0f4a0050541e1ac2e60d7fda0908601bb3cb1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI4NTk3Mg==", "bodyText": "Reverted.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r473285972", "createdAt": "2020-08-19T20:02:00Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -962,6 +962,18 @@ public void run() {\n                   @Override\n                   public void runInContext() {\n                     setCall(newClientCall(method, callOptions));\n+                    syncContext.executeLater(new Runnable() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMzg2Nw=="}, "originalCommit": {"oid": "47d0f4a0050541e1ac2e60d7fda0908601bb3cb1"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Mzc2MTEyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzo1OTowOFrOHENJpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzozNjoyMFrOHEWrsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MTgxNA==", "bodyText": "I think for the moment this also needs to avoid inheriting the config selector. Yes, it is on a connection to a legit backend, but there's actually no LB policy in place. That means it would break xDS reference counting. It doesn't look like this previously used service config, so I think we should leave it config-less for now.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r474171814", "createdAt": "2020-08-20T17:59:08Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1737,7 +1864,8 @@ public Channel asChannel() {\n       return new SubchannelChannel(\n           subchannel, balancerRpcExecutorHolder.getExecutor(),\n           transportFactory.getScheduledExecutorService(),\n-          callTracerFactory.create());\n+          callTracerFactory.create(),\n+          configSelector);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a9f07609430fb9a810b12b1360b8635f0157d5e"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyNzk4NQ==", "bodyText": "Fixed.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r474327985", "createdAt": "2020-08-20T23:36:20Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1737,7 +1864,8 @@ public Channel asChannel() {\n       return new SubchannelChannel(\n           subchannel, balancerRpcExecutorHolder.getExecutor(),\n           transportFactory.getScheduledExecutorService(),\n-          callTracerFactory.create());\n+          callTracerFactory.create(),\n+          configSelector);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MTgxNA=="}, "originalCommit": {"oid": "3a9f07609430fb9a810b12b1360b8635f0157d5e"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2Nzg2Mzk4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNjo1MTo0MVrOHE0U7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzo0Nzo1M1rOHE1-1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMzY3Ng==", "bodyText": "Why added these lines? It doesn't do anything.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r474813676", "createdAt": "2020-08-21T16:51:41Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -231,6 +231,10 @@ public void run() {\n       }\n       drainPendingCalls();\n     }\n+    callCancelled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3962b7ea4919f14235aedb0cdc0e894bf2a18e42"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzNjkwOQ==", "bodyText": "Its extension ManagedChannelImpl.PendingCall is overriding it. See the thread #7259 (comment)", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r474836909", "createdAt": "2020-08-21T17:39:36Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -231,6 +231,10 @@ public void run() {\n       }\n       drainPendingCalls();\n     }\n+    callCancelled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMzY3Ng=="}, "originalCommit": {"oid": "3962b7ea4919f14235aedb0cdc0e894bf2a18e42"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0MDc5MQ==", "bodyText": "Oh, I see.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r474840791", "createdAt": "2020-08-21T17:47:53Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -231,6 +231,10 @@ public void run() {\n       }\n       drainPendingCalls();\n     }\n+    callCancelled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMzY3Ng=="}, "originalCommit": {"oid": "3962b7ea4919f14235aedb0cdc0e894bf2a18e42"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NzkwMzQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzowNDowOVrOHE0s5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNzo0NjowM1rOHE17kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxOTgxNA==", "bodyText": "nit: this doesn't need to be a Runnable, it could just be a method for PendingCall.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r474819814", "createdAt": "2020-08-21T17:04:09Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,24 +916,113 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        MethodDescriptor<ReqT, RespT> method, CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      }\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          exitIdleMode();\n+        }\n+      });\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        // This is an optimization for the case (typically with InProcessTransport) when name\n+        // resolution result is immediately available at this point. Otherwise, some users'\n+        // tests might observe slight behavior difference from earlier grpc versions.\n+        return newClientCall(method, callOptions);\n+      }\n+      Context context = Context.current();\n+      final PendingCall<ReqT, RespT> pendingCall = new PendingCall<>(context, method, callOptions);\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (configSelector.get() == INITIAL_PENDING_SELECTOR) {\n+            if (pendingCalls == null) {\n+              pendingCalls = new LinkedHashSet<>();\n+              inUseStateAggregator.updateObjectInUse(pendingCallsInUseObject, true);\n+            }\n+            pendingCalls.add(pendingCall);\n+          } else {\n+            pendingCall.pendingCallRunnable.run();\n+          }\n+        }\n+      });\n+      return pendingCall;\n+    }\n+\n+    @Override\n+    public String authority() {\n+      return authority;\n+    }\n+\n+    private final class PendingCall<ReqT, RespT> extends DelayedClientCall<ReqT, RespT> {\n+      final Runnable pendingCallRunnable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3962b7ea4919f14235aedb0cdc0e894bf2a18e42"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgzOTk1NA==", "bodyText": "Yes. It was used to be stored in a list of runnables, now it's no longer needed.", "url": "https://github.com/grpc/grpc-java/pull/7259#discussion_r474839954", "createdAt": "2020-08-21T17:46:03Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -889,24 +916,113 @@ private RealChannel(String authority) {\n     }\n \n     @Override\n-    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(MethodDescriptor<ReqT, RespT> method,\n-        CallOptions callOptions) {\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        MethodDescriptor<ReqT, RespT> method, CallOptions callOptions) {\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        return newClientCall(method, callOptions);\n+      }\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          exitIdleMode();\n+        }\n+      });\n+      if (configSelector.get() != INITIAL_PENDING_SELECTOR) {\n+        // This is an optimization for the case (typically with InProcessTransport) when name\n+        // resolution result is immediately available at this point. Otherwise, some users'\n+        // tests might observe slight behavior difference from earlier grpc versions.\n+        return newClientCall(method, callOptions);\n+      }\n+      Context context = Context.current();\n+      final PendingCall<ReqT, RespT> pendingCall = new PendingCall<>(context, method, callOptions);\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (configSelector.get() == INITIAL_PENDING_SELECTOR) {\n+            if (pendingCalls == null) {\n+              pendingCalls = new LinkedHashSet<>();\n+              inUseStateAggregator.updateObjectInUse(pendingCallsInUseObject, true);\n+            }\n+            pendingCalls.add(pendingCall);\n+          } else {\n+            pendingCall.pendingCallRunnable.run();\n+          }\n+        }\n+      });\n+      return pendingCall;\n+    }\n+\n+    @Override\n+    public String authority() {\n+      return authority;\n+    }\n+\n+    private final class PendingCall<ReqT, RespT> extends DelayedClientCall<ReqT, RespT> {\n+      final Runnable pendingCallRunnable;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxOTgxNA=="}, "originalCommit": {"oid": "3962b7ea4919f14235aedb0cdc0e894bf2a18e42"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2417, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}