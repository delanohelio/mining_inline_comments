{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNTY4MzU4", "number": 6838, "title": "xds: integration of XdsClientImpl with XdsServerBuilder to deliver Listener updates", "bodyText": "", "createdAt": "2020-03-18T17:25:41Z", "url": "https://github.com/grpc/grpc-java/pull/6838", "merged": true, "mergeCommit": {"oid": "a2896051b880b91da677558ff2ae98a2cb6f51a2"}, "closed": true, "closedAt": "2020-03-25T17:14:30Z", "author": {"login": "sanjaypujare"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcO6sDZAH2gAyMzkwNTY4MzU4OjI3YTc4MjI4OThlOWMxY2ZjYWJhZGVmM2M2NTJlNWE3YzU3MDdmZGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRKqBugFqTM4MTM1NzUzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/27a7822898e9c1cfcabadef3c652e5a7c5707fde", "committedDate": "2020-03-18T17:23:38Z", "message": "xds: integration of XdsClientImpl with XdsServerBuilder to deliver Listener updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MjkwNzM2", "url": "https://github.com/grpc/grpc-java/pull/6838#pullrequestreview-378290736", "createdAt": "2020-03-20T08:15:50Z", "commit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwODoxNTo1MFrOF5KmyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwODo0MzozN1rOF5LU9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4NjkyMA==", "bodyText": "Why you use an object pool? You are just creating an XdsClient instance in-place without sharing with other classes.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395486920", "createdAt": "2020-03-20T08:15:50Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);\n+      return;\n+    }\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    final Node node = bootstrapInfo.getNode();\n+    if (serverList.isEmpty()) {\n+      logger.log(Level.SEVERE, \"No traffic director provided by bootstrap\");\n+      return;\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+\n+    XdsClient.XdsClientFactory xdsClientFactory =\n+        new XdsClient.XdsClientFactory() {\n+          @Override\n+          XdsClient createXdsClient() {\n+            return new XdsClientImpl(\n+                \"\",\n+                serverList,\n+                XdsClient.XdsChannelFactory.getInstance(),\n+                node,\n+                syncContext,\n+                timeService,\n+                new ExponentialBackoffPolicy.Provider(),\n+                GrpcUtil.STOPWATCH_SUPPLIER);\n+          }\n+        };\n+    xdsClientPool = new XdsClient.RefCountedXdsClientObjectPool(xdsClientFactory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4OTExMQ==", "bodyText": "I don't see any value of using a logId for this class.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395489111", "createdAt": "2020-03-20T08:21:02Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5MDA3NA==", "bodyText": "The exception goes into nowhere except a log message. And this is a constructor. This pattern is bad.\nSame for other places, error handling/propagation in this class is in appropriate.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395490074", "createdAt": "2020-03-20T08:23:22Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5MjczNQ==", "bodyText": "If nothing to do, just don't implement it.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395492735", "createdAt": "2020-03-20T08:29:11Z", "author": {"login": "voidzcy"}, "path": "xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.internal.verification.VerificationModeFactory.times;\n+\n+import com.google.common.base.Strings;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import io.netty.channel.Channel;\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Tests for {@link XdsClientWrapperForServerSds}. */\n+@RunWith(JUnit4.class)\n+public class XdsClientWrapperForServerSdsTest {\n+\n+  private static final int PORT = 7000;\n+\n+  @Mock private XdsClient xdsClient;\n+  @Mock private Channel channel;\n+\n+  private XdsClientWrapperForServerSds xdsClientWrapperForServerSds;\n+  private DownstreamTlsContext tlsContext1;\n+  private DownstreamTlsContext tlsContext2;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+    xdsClientWrapperForServerSds = new XdsClientWrapperForServerSds(PORT, xdsClient);\n+    tlsContext1 = CommonTlsContextTestsUtil.buildTestDownstreamTlsContext(\"CERT1\", \"VA1\");\n+    tlsContext2 = CommonTlsContextTestsUtil.buildTestDownstreamTlsContext(\"CERT2\", \"VA2\");\n+  }\n+\n+  @Test\n+  public void verifyListenerWatcherRegistered() {\n+    verify(xdsClient, times(1)).watchListenerData(eq(PORT), any(XdsClient.ListenerWatcher.class));\n+  }\n+\n+  @Test\n+  public void listener_nullFilterChainMatch1() throws UnknownHostException {\n+    // filterChainMatch missing for filter1, so it matches and returns tlsContext1\n+    commonFilterChainMatchTest(-1, null, null, \"192.168.10.1\", \"192.168.10.2\", tlsContext1);\n+  }\n+\n+  @Test\n+  public void listener_destPortMatchNoAddressPrefix() throws UnknownHostException {\n+    // destPort matches for filter2 even if no cidrRange, so it returns tlsContext2\n+    commonFilterChainMatchTest(PORT + 1, \"192.168.10.1\", \"192.168.10.2\", null, null, tlsContext2);\n+  }\n+\n+  @Test\n+  public void listener_destPortAndAddressPrefixMatch() throws UnknownHostException {\n+    // destPort and cidrRange exact match for filter1, so it returns tlsContext1\n+    commonFilterChainMatchTest(\n+        PORT, \"168.20.20.2\", \"10.1.2.3\", \"192.168.10.1\", \"192.168.10.2\", tlsContext1);\n+  }\n+\n+  @Test\n+  public void listener_emptyAddressRangeOverEmptyFilterChainMatch() throws UnknownHostException {\n+    // existing filterChain with empty address preferred over empty filterChain\n+    commonFilterChainMatchTest(-1, null, null, null, null, tlsContext2);\n+  }\n+\n+  @Test\n+  public void listener_cidrRangeIpAnyOverEmptyAddressRange() throws UnknownHostException {\n+    // IPANY (0.0.0.0) preferred over empty address range\n+    commonFilterChainMatchTest(\n+        PORT,\n+        null,\n+        null,\n+        \"192.168.1.4\",\n+        \"0.0.0.0\",\n+        tlsContext2); // IPANY to make second filterChain selected\n+  }\n+\n+  @Test\n+  public void listener_CidrRangeIpExactOverCidrRangeIpAny() throws UnknownHostException {\n+    // exact address match preferred over IPANY (0.0.0.0)\n+    commonFilterChainMatchTest(\n+        PORT,\n+        \"192.168.1.4\",\n+        \"0.0.0.0\",\n+        \"168.154.4.7\",\n+        \"10.1.2.3\",\n+        tlsContext2); // Matching IP to make second filterChain selected\n+  }\n+\n+  @Test\n+  public void listener_destPortAndAddressPrefixNoMatch() throws UnknownHostException {\n+    // when none matches it should return null\n+    commonFilterChainMatchTest(\n+        PORT, \"168.20.20.2\", \"10.1.2.4\", \"192.168.10.1\", \"192.168.10.2\", null);\n+  }\n+\n+  /**\n+   * Common method called by most tests. Creates 2 filterChains each with 2 addresses. First\n+   * filterChain's destPort is always PORT.\n+   *\n+   * @param destPort1 dest port of 1st filterChain\n+   * @param addressPrefix11 1st address of 1st filter\n+   * @param addressPrefix12 2nd address of 1st filter\n+   * @param addressPrefix21 1st address of 2nd filter\n+   * @param addressPrefix22 2nd address of 2nd filter\n+   * @param expectedTlsContext expected DownstreamTlsContext for the test\n+   */\n+  private void commonFilterChainMatchTest(\n+      int destPort1,\n+      String addressPrefix11,\n+      String addressPrefix12,\n+      String addressPrefix21,\n+      String addressPrefix22,\n+      DownstreamTlsContext expectedTlsContext)\n+      throws UnknownHostException {\n+    ArgumentCaptor<XdsClient.ListenerWatcher> listenerWatcherCaptor = ArgumentCaptor.forClass(null);\n+    verify(xdsClient).watchListenerData(eq(PORT), listenerWatcherCaptor.capture());\n+    XdsClient.ListenerWatcher registeredWatcher = listenerWatcherCaptor.getValue();\n+    InetAddress ipLocalAddress = Inet4Address.getByName(\"10.1.2.3\");\n+    InetSocketAddress localAddress = new InetSocketAddress(ipLocalAddress, PORT);\n+    when(channel.localAddress()).thenReturn(localAddress);\n+    EnvoyServerProtoData.Listener listener =\n+        buildTestListener(\n+            \"listener1\",\n+            \"10.1.2.3\",\n+            destPort1,\n+            PORT,\n+            addressPrefix11,\n+            addressPrefix12,\n+            addressPrefix21,\n+            addressPrefix22);\n+    XdsClient.ListenerUpdate listenerUpdate =\n+        XdsClient.ListenerUpdate.newBuilder().setListener(listener).build();\n+    registeredWatcher.onListenerChanged(listenerUpdate);\n+    DownstreamTlsContext downstreamTlsContext =\n+        xdsClientWrapperForServerSds.getDownstreamTlsContext(channel);\n+    assertThat(downstreamTlsContext).isSameInstanceAs(expectedTlsContext);\n+  }\n+\n+  @After\n+  public void tearDown() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODQ4Mg==", "bodyText": "Not sure if creating a sync context here is appropriate. The whole control plane workflow should use a single sync context, it should not be something to be created just because you need it. You need to consider the whole server side flow.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395498482", "createdAt": "2020-03-20T08:42:57Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODc0Mw==", "bodyText": "It's usually a bad practice to do so much in constructor.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395498743", "createdAt": "2020-03-20T08:43:37Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4Njc2MTAw", "url": "https://github.com/grpc/grpc-java/pull/6838#pullrequestreview-378676100", "createdAt": "2020-03-20T17:24:18Z", "commit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzoyNDoxOFrOF5czBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDoxNDozOFrOF5h6qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4NDk2NQ==", "bodyText": "imo init is worse. can you move some of the prep work to the caller side or factory?", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395784965", "createdAt": "2020-03-20T17:24:18Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5ODc0Mw=="}, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc4ODIyOQ==", "bodyText": "can you handle the exception on the caller side? it may behave same, but there won't be any surprise.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395788229", "createdAt": "2020-03-20T17:30:09Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ5MDA3NA=="}, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjE3NQ==", "bodyText": "passing channel around doesn't seem like a good idea. can you change to local address?", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395812175", "createdAt": "2020-03-20T18:14:09Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);\n+      return;\n+    }\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    final Node node = bootstrapInfo.getNode();\n+    if (serverList.isEmpty()) {\n+      logger.log(Level.SEVERE, \"No traffic director provided by bootstrap\");\n+      return;\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+\n+    XdsClient.XdsClientFactory xdsClientFactory =\n+        new XdsClient.XdsClientFactory() {\n+          @Override\n+          XdsClient createXdsClient() {\n+            return new XdsClientImpl(\n+                \"\",\n+                serverList,\n+                XdsClient.XdsChannelFactory.getInstance(),\n+                node,\n+                syncContext,\n+                timeService,\n+                new ExponentialBackoffPolicy.Provider(),\n+                GrpcUtil.STOPWATCH_SUPPLIER);\n+          }\n+        };\n+    xdsClientPool = new XdsClient.RefCountedXdsClientObjectPool(xdsClientFactory);\n+    xdsClient = xdsClientPool.getObject();\n+    setClientAndWatcher(port);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    this.xdsClient = xdsClient;\n+    setClientAndWatcher(port);\n+  }\n+\n+  private void setClientAndWatcher(int port) {\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), channel);\n+        if (curScore > 0 && curScore > highestScore) {\n+          bestMatch = filterChain;\n+          highestScore = curScore;\n+        }\n+      }\n+      if (bestMatch != null) {\n+        return bestMatch.getDownstreamTlsContext();\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Computes a score for a match of filterChainMatch with channel.\n+   *\n+   * <p>-1 => mismatch (of port or IP address etc)\n+   *\n+   * <p>0 => unimplemented (types or logic etc)\n+   *\n+   * <p>1 => filterChainMatch is null, so nothing to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getFilterChainMatchScore(FilterChainMatch filterChainMatch, Channel channel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMDQ4OQ==", "bodyText": "score based sort error prone. can you use Collections.max with comparator?", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395820489", "createdAt": "2020-03-20T18:30:30Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);\n+      return;\n+    }\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    final Node node = bootstrapInfo.getNode();\n+    if (serverList.isEmpty()) {\n+      logger.log(Level.SEVERE, \"No traffic director provided by bootstrap\");\n+      return;\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+\n+    XdsClient.XdsClientFactory xdsClientFactory =\n+        new XdsClient.XdsClientFactory() {\n+          @Override\n+          XdsClient createXdsClient() {\n+            return new XdsClientImpl(\n+                \"\",\n+                serverList,\n+                XdsClient.XdsChannelFactory.getInstance(),\n+                node,\n+                syncContext,\n+                timeService,\n+                new ExponentialBackoffPolicy.Provider(),\n+                GrpcUtil.STOPWATCH_SUPPLIER);\n+          }\n+        };\n+    xdsClientPool = new XdsClient.RefCountedXdsClientObjectPool(xdsClientFactory);\n+    xdsClient = xdsClientPool.getObject();\n+    setClientAndWatcher(port);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    this.xdsClient = xdsClient;\n+    setClientAndWatcher(port);\n+  }\n+\n+  private void setClientAndWatcher(int port) {\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), channel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMzIxMg==", "bodyText": "eventLoopGroupResource can be null, it should be handled.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395823212", "createdAt": "2020-03-20T18:35:58Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+  private final InternalLogId logId;\n+  // Must be accessed from the syncContext\n+  private boolean panicMode;\n+  final SynchronizationContext syncContext =\n+      new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                  \"[\" + getLogId() + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                  e);\n+            panic(e);\n+          }\n+        });\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  @Nullable private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable private XdsClient xdsClient;\n+\n+  /** Wraps the XdsClientImpl for use by SdsProtocolNegotiators. */\n+  public XdsClientWrapperForServerSds(int port, Bootstrapper bootstrapper) {\n+    this.logId = InternalLogId.allocate(\"GrpcServer\", Integer.toString(port));\n+    Bootstrapper.BootstrapInfo bootstrapInfo = null;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (IOException e) {\n+      logger.log(Level.SEVERE, \"Error from readBootstrap\", e);\n+      return;\n+    }\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    final Node node = bootstrapInfo.getNode();\n+    if (serverList.isEmpty()) {\n+      logger.log(Level.SEVERE, \"No traffic director provided by bootstrap\");\n+      return;\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNDU4Nw==", "bodyText": "the argument name is not changed?", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395824587", "createdAt": "2020-03-20T18:38:42Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -63,12 +65,12 @@ public static ProtocolNegotiatorFactory clientProtocolNegotiatorFactory(\n \n   /**\n    * Creates an SDS based {@link ProtocolNegotiator} for a {@link io.grpc.netty.NettyServerBuilder}.\n-   * Passing {@code null} for downstreamTlsContext will fall back to plaintext.\n+   * Passing {@code null} for downstreamTlsContextFromBuilder will fall back to plaintext.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNDc3Mw==", "bodyText": "what is the port for? need some documentation.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395824773", "createdAt": "2020-03-20T18:39:06Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -63,12 +65,12 @@ public static ProtocolNegotiatorFactory clientProtocolNegotiatorFactory(\n \n   /**\n    * Creates an SDS based {@link ProtocolNegotiator} for a {@link io.grpc.netty.NettyServerBuilder}.\n-   * Passing {@code null} for downstreamTlsContext will fall back to plaintext.\n+   * Passing {@code null} for downstreamTlsContextFromBuilder will fall back to plaintext.\n    */\n   // TODO (sanjaypujare) integrate with xDS client to get LDS\n   public static ProtocolNegotiator serverProtocolNegotiator(\n-      @Nullable DownstreamTlsContext downstreamTlsContext) {\n-    return new ServerSdsProtocolNegotiator(downstreamTlsContext);\n+      @Nullable DownstreamTlsContext downstreamTlsContext, int port) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2MzE5Ng==", "bodyText": "can you add doc for the new behavior (fall back to plaintext)?", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395863196", "createdAt": "2020-03-20T20:01:08Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -63,12 +65,12 @@ public static ProtocolNegotiatorFactory clientProtocolNegotiatorFactory(\n \n   /**\n    * Creates an SDS based {@link ProtocolNegotiator} for a {@link io.grpc.netty.NettyServerBuilder}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2MzM4Mw==", "bodyText": "can you add logging if it falls back to plaintext", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395863383", "createdAt": "2020-03-20T20:01:36Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -294,11 +293,29 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n           });\n       checkNotNull(grpcHandler, \"grpcHandler\");\n       this.grpcHandler = grpcHandler;\n-      this.downstreamTlsContext = downstreamTlsContext;\n+      this.downstreamTlsContextFromBuilder = downstreamTlsContext;\n+      this.xdsClientWrapperForServerSds = xdsClientWrapperForServerSds;\n+    }\n+\n+    private static boolean isTlsContextEmpty(DownstreamTlsContext downstreamTlsContext) {\n+      return downstreamTlsContext == null || !downstreamTlsContext.hasCommonTlsContext();\n     }\n \n     @Override\n     protected void handlerAdded0(final ChannelHandlerContext ctx) {\n+      DownstreamTlsContext downstreamTlsContext =\n+          xdsClientWrapperForServerSds == null\n+              ? null\n+              : xdsClientWrapperForServerSds.getDownstreamTlsContext(ctx.channel());\n+      if (isTlsContextEmpty(downstreamTlsContext)) {\n+        downstreamTlsContext = downstreamTlsContextFromBuilder;\n+      }\n+      if (isTlsContextEmpty(downstreamTlsContext)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2NTM2Nw==", "bodyText": "we would love to make ProtocolNegotiationHandler as small as possible. can you make a new handler that decides which negotiator to use (plaintext/sds)?", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395865367", "createdAt": "2020-03-20T20:06:12Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -294,11 +293,29 @@ public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n           });\n       checkNotNull(grpcHandler, \"grpcHandler\");\n       this.grpcHandler = grpcHandler;\n-      this.downstreamTlsContext = downstreamTlsContext;\n+      this.downstreamTlsContextFromBuilder = downstreamTlsContext;\n+      this.xdsClientWrapperForServerSds = xdsClientWrapperForServerSds;\n+    }\n+\n+    private static boolean isTlsContextEmpty(DownstreamTlsContext downstreamTlsContext) {\n+      return downstreamTlsContext == null || !downstreamTlsContext.hasCommonTlsContext();\n     }\n \n     @Override\n     protected void handlerAdded0(final ChannelHandlerContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2ODg0Mw==", "bodyText": "this is harder to read. consider parameterized test.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r395868843", "createdAt": "2020-03-20T20:14:38Z", "author": {"login": "creamsoup"}, "path": "xds/src/test/java/io/grpc/xds/XdsClientWrapperForServerSdsTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.internal.verification.VerificationModeFactory.times;\n+\n+import com.google.common.base.Strings;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import io.netty.channel.Channel;\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Tests for {@link XdsClientWrapperForServerSds}. */\n+@RunWith(JUnit4.class)\n+public class XdsClientWrapperForServerSdsTest {\n+\n+  private static final int PORT = 7000;\n+\n+  @Mock private XdsClient xdsClient;\n+  @Mock private Channel channel;\n+\n+  private XdsClientWrapperForServerSds xdsClientWrapperForServerSds;\n+  private DownstreamTlsContext tlsContext1;\n+  private DownstreamTlsContext tlsContext2;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+    xdsClientWrapperForServerSds = new XdsClientWrapperForServerSds(PORT, xdsClient);\n+    tlsContext1 = CommonTlsContextTestsUtil.buildTestDownstreamTlsContext(\"CERT1\", \"VA1\");\n+    tlsContext2 = CommonTlsContextTestsUtil.buildTestDownstreamTlsContext(\"CERT2\", \"VA2\");\n+  }\n+\n+  @Test\n+  public void verifyListenerWatcherRegistered() {\n+    verify(xdsClient, times(1)).watchListenerData(eq(PORT), any(XdsClient.ListenerWatcher.class));\n+  }\n+\n+  @Test\n+  public void listener_nullFilterChainMatch1() throws UnknownHostException {\n+    // filterChainMatch missing for filter1, so it matches and returns tlsContext1\n+    commonFilterChainMatchTest(-1, null, null, \"192.168.10.1\", \"192.168.10.2\", tlsContext1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27a7822898e9c1cfcabadef3c652e5a7c5707fde"}, "originalPosition": 75}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/3929209c69c9982d73bc0728ac8844cbc66e9181", "committedDate": "2020-03-23T00:48:23Z", "message": "address review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72fe917caf20211f296759ff65f7a7564de1a226", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/72fe917caf20211f296759ff65f7a7564de1a226", "committedDate": "2020-03-23T00:40:23Z", "message": "address review comments"}, "afterCommit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/3929209c69c9982d73bc0728ac8844cbc66e9181", "committedDate": "2020-03-23T00:48:23Z", "message": "address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjgyNTcy", "url": "https://github.com/grpc/grpc-java/pull/6838#pullrequestreview-379682572", "createdAt": "2020-03-23T17:57:28Z", "commit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1NzoyOVrOF6RZGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1NzoyOVrOF6RZGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjY4MA==", "bodyText": "I doubt the usage of NoSuchElementException here and IllegalStateException below. Error handling still looks a bit abrupt, basically it would panic immediately when encountering those cases. @creamsoup Does server side have any error propagation APIs?", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396646680", "createdAt": "2020-03-23T17:57:29Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NjU2ODgw", "url": "https://github.com/grpc/grpc-java/pull/6838#pullrequestreview-379656880", "createdAt": "2020-03-23T17:26:25Z", "commit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzoyNjoyNVrOF6QHSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNzo1NDowNFrOF6RP8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNTczNw==", "bodyText": "this basically means, it will only work on linux. this is expected?\nalso, XdsClientImpl expects ScheduledExecutorService, eventloop is good but with those limitation i am not sure why we want to use eventloop here?", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396625737", "createdAt": "2020-03-23T17:26:25Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    if (eventLoopGroupResource == null) {\n+      throw new IllegalStateException(Epoll.unavailabilityCause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzMjUxOA==", "bodyText": "mark it @Nullable", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396632518", "createdAt": "2020-03-23T17:36:11Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    if (eventLoopGroupResource == null) {\n+      throw new IllegalStateException(Epoll.unavailabilityCause());\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzNTcwNg==", "bodyText": "can simplify with checkState(predicate, msg);", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396635706", "createdAt": "2020-03-23T17:41:13Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    if (eventLoopGroupResource == null) {\n+      throw new IllegalStateException(Epoll.unavailabilityCause());\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      if (!(localAddress instanceof InetSocketAddress)) {\n+        return null;\n+      }\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      if (port != localInetAddr.getPort()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzNzEyNQ==", "bodyText": "this is still score based. i thought you will use Comparable?", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396637125", "createdAt": "2020-03-23T17:43:13Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final EventLoopGroupResource eventLoopGroupResource =\n+      Epoll.isAvailable() ? new EventLoopGroupResource(\"GrpcServerXdsClient\") : null;\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    if (eventLoopGroupResource == null) {\n+      throw new IllegalStateException(Epoll.unavailabilityCause());\n+    }\n+    final EventLoopGroup timeService = SharedResourceHolder.get(eventLoopGroupResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and returns the\n+   * DownstreamTlsContext from that FilterChain.\n+   */\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      if (!(localAddress instanceof InetSocketAddress)) {\n+        return null;\n+      }\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      if (port != localInetAddr.getPort()) {\n+        throw new IllegalStateException(\n+            \"Channel localAddress port does not match requested listener port\");\n+      }\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), localInetAddr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NDMzOA==", "bodyText": "protocol negotiation is event based. the ServerSdsHandler doesn't follow the pattern because of its unique requirement. the HandlerPickerHanlder should follow the general structure using ProtocolNegotiationEvent see alts/tls protocol negotiator for more detail.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r396644338", "createdAt": "2020-03-23T17:54:04Z", "author": {"login": "creamsoup"}, "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -260,28 +276,79 @@ public AsciiString scheme() {\n \n     @Override\n     public ChannelHandler newHandler(GrpcHttp2ConnectionHandler grpcHandler) {\n-      if (isTlsContextEmpty(downstreamTlsContext)) {\n-        return InternalProtocolNegotiators.serverPlaintext().newHandler(grpcHandler);\n-      }\n-      return new ServerSdsHandler(grpcHandler, downstreamTlsContext);\n+      return new HandlerPickerHandler(grpcHandler, downstreamTlsContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3929209c69c9982d73bc0728ac8844cbc66e9181"}, "originalPosition": 92}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/8c7d196ef0567309f6f3a65bce7f44ca3231b77b", "committedDate": "2020-03-24T01:50:12Z", "message": "address review comment: second set"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNTI0MjA1", "url": "https://github.com/grpc/grpc-java/pull/6838#pullrequestreview-380524205", "createdAt": "2020-03-24T17:10:45Z", "commit": {"oid": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzoxMDo0NVrOF66nQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzoyNjoyN1rOF67SAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyMjA0OA==", "bodyText": "nit: rephrase the error message. This is above-DEBUG-level logging, so it should be semantically meaningful to readers. It should be something like \"Failed to ...\". Also, \"SEVER\" means something is very broken and the system is probably panic. But it turns out we are still able to proceed by falling back to plaintext. I think if something required is missing and we have nothing to do, we just let it panic and halt. But if we do have alternative to recover, it may just be a warning.\nSame thing may apply for other log messages.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397322048", "createdAt": "2020-03-24T17:10:45Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/internal/sds/SdsProtocolNegotiators.java", "diffHunk": "@@ -245,12 +253,21 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)\n \n   private static final class ServerSdsProtocolNegotiator implements ProtocolNegotiator {\n \n-    // TODO (sanjaypujare) integrate with xDS client to get LDS. LDS watcher will\n-    // inject/update the downstreamTlsContext from LDS\n     private DownstreamTlsContext downstreamTlsContext;\n+    private final XdsClientWrapperForServerSds xdsClientWrapperForServerSds;\n \n-    ServerSdsProtocolNegotiator(DownstreamTlsContext downstreamTlsContext) {\n+    ServerSdsProtocolNegotiator(\n+        DownstreamTlsContext downstreamTlsContext, int port, SynchronizationContext syncContext) {\n       this.downstreamTlsContext = downstreamTlsContext;\n+      XdsClientWrapperForServerSds localXdsClientWrapperForServerSds;\n+      try {\n+        localXdsClientWrapperForServerSds =\n+            XdsClientWrapperForServerSds.newInstance(port, Bootstrapper.getInstance(), syncContext);\n+      } catch (Exception e) {\n+        logger.log(Level.SEVERE, \"XdsClientWrapperForServerSds constructor\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyOTcyMQ==", "bodyText": "nit: this will be printed as just \"Shutdown\", without anything else. It doesn't give any useful information.\nAlso, I doubt there should be any log messages above INFO level as anything above (or equal) INFO level will be printed out by default.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397329721", "createdAt": "2020-03-24T17:21:41Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    ScheduledExecutorService timeService = SharedResourceHolder.get(timeServiceResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl, timeService);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient,\n+      ScheduledExecutorService timeService) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    this.timeService = timeService;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and if found\n+   * returns the DownstreamTlsContext from that FilterChain, else null.\n+   */\n+  @Nullable\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      checkState(\n+          localAddress instanceof InetSocketAddress,\n+          \"Channel localAddress is expected to be InetSocketAddress\");\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      checkState(\n+          port == localInetAddr.getPort(),\n+          \"Channel localAddress port does not match requested listener port\");\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), localInetAddr);\n+        if (curScore > 0 && curScore > highestScore) {\n+          bestMatch = filterChain;\n+          highestScore = curScore;\n+        }\n+      }\n+      if (bestMatch != null) {\n+        return bestMatch.getDownstreamTlsContext();\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Computes a score for a match of filterChainMatch with channel.\n+   *\n+   * <p>-1 => mismatch (of port or IP address etc)\n+   *\n+   * <p>0 => unimplemented (types or logic etc)\n+   *\n+   * <p>1 => filterChainMatch is null, so nothing to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getFilterChainMatchScore(\n+      FilterChainMatch filterChainMatch, InetSocketAddress localInetAddr) {\n+    if (filterChainMatch == null) {\n+      return 1;\n+    }\n+    if (filterChainMatch.getDestinationPort() != localInetAddr.getPort()) {\n+      return -1;\n+    }\n+    return getIpAddressAndRangesMatchScore(\n+        localInetAddr.getAddress(), filterChainMatch.getPrefixRanges());\n+  }\n+\n+  /**\n+   * Computes a score for IP address match against a list of CidrRange called only after ports have\n+   * matched, so a minimum score of 2 is returned to indicate a match or else -1 for a mismatch.\n+   *\n+   * <p>-1 => mismatch.\n+   *\n+   * <p>2 => prefixRanges is null/empty, so no IP address to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getIpAddressAndRangesMatchScore(\n+      InetAddress localAddress, List<CidrRange> prefixRanges) {\n+    if (prefixRanges == null || prefixRanges.isEmpty()) {\n+      return 2;\n+    }\n+    int highestScore = -1;\n+    for (CidrRange cidrRange : prefixRanges) {\n+      int curScore = getIpAddressMatchScore(localAddress, cidrRange);\n+      if (curScore > highestScore) {\n+        highestScore = curScore;\n+      }\n+    }\n+    return highestScore;\n+  }\n+\n+  /**\n+   * Computes a score for IP address to CidrRange match.\n+   *\n+   * <p>-1 => mismatch\n+   *\n+   * <p>0 => unimplemented (prefixLen < 32 logic)\n+   *\n+   * <p>4 => match because cidrRange is IPANY_ADDRESS (0.0.0.0)\n+   *\n+   * <p>8 => exact match\n+   */\n+  private static int getIpAddressMatchScore(InetAddress localAddress, CidrRange cidrRange) {\n+    if (cidrRange.getPrefixLen() == 32) {\n+      try {\n+        InetAddress cidrAddr = InetAddress.getByName(cidrRange.getAddressPrefix());\n+        if (cidrAddr.isAnyLocalAddress()) {\n+          return 4;\n+        }\n+        if (cidrAddr.equals(localAddress)) {\n+          return 8;\n+        }\n+        return -1;\n+      } catch (UnknownHostException e) {\n+        logger.log(Level.SEVERE, \"cidrRange address parsing\", e);\n+      }\n+    }\n+    // TODO(sanjaypujare): implement CIDR logic to match prefixes if needed\n+    return 0;\n+  }\n+\n+  /** Shutdown this instance and release resources. */\n+  public void shutdown() {\n+    logger.log(Level.INFO, \"Shutdown\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMDg1Mw==", "bodyText": "nit: delete your personal note.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397330853", "createdAt": "2020-03-24T17:23:19Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    ScheduledExecutorService timeService = SharedResourceHolder.get(timeServiceResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl, timeService);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient,\n+      ScheduledExecutorService timeService) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    this.timeService = timeService;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and if found\n+   * returns the DownstreamTlsContext from that FilterChain, else null.\n+   */\n+  @Nullable\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      checkState(\n+          localAddress instanceof InetSocketAddress,\n+          \"Channel localAddress is expected to be InetSocketAddress\");\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      checkState(\n+          port == localInetAddr.getPort(),\n+          \"Channel localAddress port does not match requested listener port\");\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), localInetAddr);\n+        if (curScore > 0 && curScore > highestScore) {\n+          bestMatch = filterChain;\n+          highestScore = curScore;\n+        }\n+      }\n+      if (bestMatch != null) {\n+        return bestMatch.getDownstreamTlsContext();\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Computes a score for a match of filterChainMatch with channel.\n+   *\n+   * <p>-1 => mismatch (of port or IP address etc)\n+   *\n+   * <p>0 => unimplemented (types or logic etc)\n+   *\n+   * <p>1 => filterChainMatch is null, so nothing to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getFilterChainMatchScore(\n+      FilterChainMatch filterChainMatch, InetSocketAddress localInetAddr) {\n+    if (filterChainMatch == null) {\n+      return 1;\n+    }\n+    if (filterChainMatch.getDestinationPort() != localInetAddr.getPort()) {\n+      return -1;\n+    }\n+    return getIpAddressAndRangesMatchScore(\n+        localInetAddr.getAddress(), filterChainMatch.getPrefixRanges());\n+  }\n+\n+  /**\n+   * Computes a score for IP address match against a list of CidrRange called only after ports have\n+   * matched, so a minimum score of 2 is returned to indicate a match or else -1 for a mismatch.\n+   *\n+   * <p>-1 => mismatch.\n+   *\n+   * <p>2 => prefixRanges is null/empty, so no IP address to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getIpAddressAndRangesMatchScore(\n+      InetAddress localAddress, List<CidrRange> prefixRanges) {\n+    if (prefixRanges == null || prefixRanges.isEmpty()) {\n+      return 2;\n+    }\n+    int highestScore = -1;\n+    for (CidrRange cidrRange : prefixRanges) {\n+      int curScore = getIpAddressMatchScore(localAddress, cidrRange);\n+      if (curScore > highestScore) {\n+        highestScore = curScore;\n+      }\n+    }\n+    return highestScore;\n+  }\n+\n+  /**\n+   * Computes a score for IP address to CidrRange match.\n+   *\n+   * <p>-1 => mismatch\n+   *\n+   * <p>0 => unimplemented (prefixLen < 32 logic)\n+   *\n+   * <p>4 => match because cidrRange is IPANY_ADDRESS (0.0.0.0)\n+   *\n+   * <p>8 => exact match\n+   */\n+  private static int getIpAddressMatchScore(InetAddress localAddress, CidrRange cidrRange) {\n+    if (cidrRange.getPrefixLen() == 32) {\n+      try {\n+        InetAddress cidrAddr = InetAddress.getByName(cidrRange.getAddressPrefix());\n+        if (cidrAddr.isAnyLocalAddress()) {\n+          return 4;\n+        }\n+        if (cidrAddr.equals(localAddress)) {\n+          return 8;\n+        }\n+        return -1;\n+      } catch (UnknownHostException e) {\n+        logger.log(Level.SEVERE, \"cidrRange address parsing\", e);\n+      }\n+    }\n+    // TODO(sanjaypujare): implement CIDR logic to match prefixes if needed\n+    return 0;\n+  }\n+\n+  /** Shutdown this instance and release resources. */\n+  public void shutdown() {\n+    logger.log(Level.INFO, \"Shutdown\");\n+    if (xdsClient != null) {\n+      xdsClient.shutdown();\n+    }\n+    if (timeService != null) {\n+      timeServiceResource.close(timeService);\n+    }\n+  }\n+\n+  private static final class TimeServiceResource\n+          implements SharedResourceHolder.Resource<ScheduledExecutorService> {\n+\n+    private final String name;\n+\n+    TimeServiceResource(String name) {\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public ScheduledExecutorService create() {\n+      // Use Netty's DefaultThreadFactory in order to get the benefit of FastThreadLocal.\n+      ThreadFactory threadFactory = new DefaultThreadFactory(name, /* daemon= */ true);\n+      if (Epoll.isAvailable()) {\n+        return new EpollEventLoopGroup(1, threadFactory);\n+      } else {\n+        return Executors.newSingleThreadScheduledExecutor(threadFactory);\n+      }\n+    }\n+\n+    @SuppressWarnings(\"FutureReturnValueIgnored\")\n+    @Override\n+    public void close(ScheduledExecutorService instance) {\n+      try {\n+        if (instance instanceof EpollEventLoopGroup) {\n+          ((EpollEventLoopGroup)instance).shutdownGracefully(0, 0, TimeUnit.SECONDS).sync();\n+        } else {\n+          instance.shutdown();\n+        }\n+      } catch (InterruptedException e) {\n+        logger.log(Level.SEVERE, \"from EventLoopGroup.shutdownGracefully\", e);\n+        Thread.currentThread().interrupt(); // to not \"swallow\" the exception...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMTQyOQ==", "bodyText": "nit: redundant comment, should delete.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397331429", "createdAt": "2020-03-24T17:24:09Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /** Creates a new instance. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzMjk5NQ==", "bodyText": "IMO, if syncContext comes from the caller side, this should also come from the caller side.", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397332995", "createdAt": "2020-03-24T17:26:27Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /** Creates a new instance. */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    ScheduledExecutorService timeService = SharedResourceHolder.get(timeServiceResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl, timeService);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient,\n+      ScheduledExecutorService timeService) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    this.timeService = timeService;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and if found\n+   * returns the DownstreamTlsContext from that FilterChain, else null.\n+   */\n+  @Nullable\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {\n+    if (curListener != null && channel != null) {\n+      SocketAddress localAddress = channel.localAddress();\n+      checkState(\n+          localAddress instanceof InetSocketAddress,\n+          \"Channel localAddress is expected to be InetSocketAddress\");\n+      InetSocketAddress localInetAddr = (InetSocketAddress) localAddress;\n+      checkState(\n+          port == localInetAddr.getPort(),\n+          \"Channel localAddress port does not match requested listener port\");\n+      List<FilterChain> filterChains = curListener.getFilterChains();\n+      int highestScore = -1;\n+      FilterChain bestMatch = null;\n+      for (FilterChain filterChain : filterChains) {\n+        int curScore = getFilterChainMatchScore(filterChain.getFilterChainMatch(), localInetAddr);\n+        if (curScore > 0 && curScore > highestScore) {\n+          bestMatch = filterChain;\n+          highestScore = curScore;\n+        }\n+      }\n+      if (bestMatch != null) {\n+        return bestMatch.getDownstreamTlsContext();\n+      }\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Computes a score for a match of filterChainMatch with channel.\n+   *\n+   * <p>-1 => mismatch (of port or IP address etc)\n+   *\n+   * <p>0 => unimplemented (types or logic etc)\n+   *\n+   * <p>1 => filterChainMatch is null, so nothing to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getFilterChainMatchScore(\n+      FilterChainMatch filterChainMatch, InetSocketAddress localInetAddr) {\n+    if (filterChainMatch == null) {\n+      return 1;\n+    }\n+    if (filterChainMatch.getDestinationPort() != localInetAddr.getPort()) {\n+      return -1;\n+    }\n+    return getIpAddressAndRangesMatchScore(\n+        localInetAddr.getAddress(), filterChainMatch.getPrefixRanges());\n+  }\n+\n+  /**\n+   * Computes a score for IP address match against a list of CidrRange called only after ports have\n+   * matched, so a minimum score of 2 is returned to indicate a match or else -1 for a mismatch.\n+   *\n+   * <p>-1 => mismatch.\n+   *\n+   * <p>2 => prefixRanges is null/empty, so no IP address to match.\n+   *\n+   * <p>value > 2 indicates some kind of IP address match.\n+   */\n+  private static int getIpAddressAndRangesMatchScore(\n+      InetAddress localAddress, List<CidrRange> prefixRanges) {\n+    if (prefixRanges == null || prefixRanges.isEmpty()) {\n+      return 2;\n+    }\n+    int highestScore = -1;\n+    for (CidrRange cidrRange : prefixRanges) {\n+      int curScore = getIpAddressMatchScore(localAddress, cidrRange);\n+      if (curScore > highestScore) {\n+        highestScore = curScore;\n+      }\n+    }\n+    return highestScore;\n+  }\n+\n+  /**\n+   * Computes a score for IP address to CidrRange match.\n+   *\n+   * <p>-1 => mismatch\n+   *\n+   * <p>0 => unimplemented (prefixLen < 32 logic)\n+   *\n+   * <p>4 => match because cidrRange is IPANY_ADDRESS (0.0.0.0)\n+   *\n+   * <p>8 => exact match\n+   */\n+  private static int getIpAddressMatchScore(InetAddress localAddress, CidrRange cidrRange) {\n+    if (cidrRange.getPrefixLen() == 32) {\n+      try {\n+        InetAddress cidrAddr = InetAddress.getByName(cidrRange.getAddressPrefix());\n+        if (cidrAddr.isAnyLocalAddress()) {\n+          return 4;\n+        }\n+        if (cidrAddr.equals(localAddress)) {\n+          return 8;\n+        }\n+        return -1;\n+      } catch (UnknownHostException e) {\n+        logger.log(Level.SEVERE, \"cidrRange address parsing\", e);\n+      }\n+    }\n+    // TODO(sanjaypujare): implement CIDR logic to match prefixes if needed\n+    return 0;\n+  }\n+\n+  /** Shutdown this instance and release resources. */\n+  public void shutdown() {\n+    logger.log(Level.INFO, \"Shutdown\");\n+    if (xdsClient != null) {\n+      xdsClient.shutdown();\n+    }\n+    if (timeService != null) {\n+      timeServiceResource.close(timeService);\n+    }\n+  }\n+\n+  private static final class TimeServiceResource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c7d196ef0567309f6f3a65bce7f44ca3231b77b"}, "originalPosition": 246}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f628d36689675fc7c40fa082373f9e0fa33b6548", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/f628d36689675fc7c40fa082373f9e0fa33b6548", "committedDate": "2020-03-25T06:55:55Z", "message": "address review comment: 3rd set"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwOTI2MDgy", "url": "https://github.com/grpc/grpc-java/pull/6838#pullrequestreview-380926082", "createdAt": "2020-03-25T08:09:13Z", "commit": {"oid": "f628d36689675fc7c40fa082373f9e0fa33b6548"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwODowOToxNFrOF7Pxuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwODowOToxNFrOF7Pxuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2ODc5NQ==", "bodyText": "A better API would be to take in an InetSocketAddress as the argument instead of a Channel, which makes the method specification stronger (i.e., weaker precondition, the method requires less information).", "url": "https://github.com/grpc/grpc-java/pull/6838#discussion_r397668795", "createdAt": "2020-03-25T08:09:14Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientWrapperForServerSds.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.envoyproxy.envoy.api.v2.auth.DownstreamTlsContext;\n+import io.envoyproxy.envoy.api.v2.core.Node;\n+import io.grpc.Internal;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ExponentialBackoffPolicy;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.SharedResourceHolder;\n+import io.grpc.xds.EnvoyServerProtoData.CidrRange;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChain;\n+import io.grpc.xds.EnvoyServerProtoData.FilterChainMatch;\n+import io.netty.channel.Channel;\n+import io.netty.channel.epoll.Epoll;\n+import io.netty.channel.epoll.EpollEventLoopGroup;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Serves as a wrapper for {@link XdsClientImpl} used on the server side by {@link\n+ * io.grpc.xds.internal.sds.XdsServerBuilder}.\n+ */\n+@Internal\n+public final class XdsClientWrapperForServerSds {\n+  private static final Logger logger =\n+      Logger.getLogger(XdsClientWrapperForServerSds.class.getName());\n+\n+  private static final TimeServiceResource timeServiceResource =\n+      new TimeServiceResource(\"GrpcServerXdsClient\");\n+\n+  private EnvoyServerProtoData.Listener curListener;\n+  // TODO(sanjaypujare): implement shutting down XdsServer which will need xdsClient reference\n+  @SuppressWarnings(\"unused\")\n+  @Nullable private XdsClient xdsClient;\n+  private final int port;\n+  private final ScheduledExecutorService timeService;\n+\n+  /**\n+   * Factory method for creating a {@link XdsClientWrapperForServerSds}.\n+   *\n+   * @param port server's port for which listener config is needed.\n+   * @param bootstrapper {@link Bootstrapper} instance to load bootstrap config.\n+   * @param syncContext {@link SynchronizationContext} needed by {@link XdsClient}.\n+   */\n+  public static XdsClientWrapperForServerSds newInstance(\n+      int port, Bootstrapper bootstrapper, SynchronizationContext syncContext) throws IOException {\n+    Bootstrapper.BootstrapInfo bootstrapInfo = bootstrapper.readBootstrap();\n+    final List<Bootstrapper.ServerInfo> serverList = bootstrapInfo.getServers();\n+    if (serverList.isEmpty()) {\n+      throw new NoSuchElementException(\"No management server provided by bootstrap\");\n+    }\n+    final Node node = bootstrapInfo.getNode();\n+    ScheduledExecutorService timeService = SharedResourceHolder.get(timeServiceResource);\n+    XdsClientImpl xdsClientImpl =\n+        new XdsClientImpl(\n+            \"\",\n+            serverList,\n+            XdsClient.XdsChannelFactory.getInstance(),\n+            node,\n+            syncContext,\n+            timeService,\n+            new ExponentialBackoffPolicy.Provider(),\n+            GrpcUtil.STOPWATCH_SUPPLIER);\n+    return new XdsClientWrapperForServerSds(port, xdsClientImpl, timeService);\n+  }\n+\n+  @VisibleForTesting\n+  XdsClientWrapperForServerSds(int port, XdsClient xdsClient,\n+      ScheduledExecutorService timeService) {\n+    this.port = port;\n+    this.xdsClient = xdsClient;\n+    this.timeService = timeService;\n+    xdsClient.watchListenerData(\n+        port,\n+        new XdsClient.ListenerWatcher() {\n+          @Override\n+          public void onListenerChanged(XdsClient.ListenerUpdate update) {\n+            logger.log(\n+                Level.INFO,\n+                \"Setting myListener from ConfigUpdate listener :{0}\",\n+                update.getListener().toString());\n+            curListener = update.getListener();\n+          }\n+\n+          @Override\n+          public void onError(Status error) {\n+            // In order to distinguish between IO error and resource not found, set curListener\n+            // to null in case of NOT_FOUND\n+            if (error.getCode().equals(Status.Code.NOT_FOUND)) {\n+              curListener = null;\n+            }\n+            // TODO(sanjaypujare): Implement logic for other cases based on final design.\n+            logger.log(Level.SEVERE, \"ListenerWatcher in XdsClientWrapperForServerSds:{0}\", error);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Locates the best matching FilterChain to the channel from the current listener and if found\n+   * returns the DownstreamTlsContext from that FilterChain, else null.\n+   */\n+  @Nullable\n+  public DownstreamTlsContext getDownstreamTlsContext(Channel channel) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f628d36689675fc7c40fa082373f9e0fa33b6548"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMzU3NTM1", "url": "https://github.com/grpc/grpc-java/pull/6838#pullrequestreview-381357535", "createdAt": "2020-03-25T17:07:46Z", "commit": {"oid": "f628d36689675fc7c40fa082373f9e0fa33b6548"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4476, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}