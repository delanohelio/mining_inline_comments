{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczMDgwNjkx", "number": 7356, "title": "xds: eliminate cluster name change logic in CDS LB policy and reimplement tests", "bodyText": "Reviewer may just want to read the whole file instead of diffs.", "createdAt": "2020-08-25T09:48:29Z", "url": "https://github.com/grpc/grpc-java/pull/7356", "merged": true, "mergeCommit": {"oid": "1260db3305074e9537513be48e275bd880e0277a"}, "closed": true, "closedAt": "2020-08-29T01:08:15Z", "author": {"login": "voidzcy"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCUC6bAH2gAyNDczMDgwNjkxOmVjMTQyMmVhM2YzOTcwOGQ1MGVmOTVjZTYzZmVlYmFlMmYyNTFiNzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDZCLkgH2gAyNDczMDgwNjkxOmE5YTJjNGM0ODgyMjI0YTk1NmE1YzUxMjRiODAzMTk4YWM5ZDc2YjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ec1422ea3f39708d50ef95ce63feebae2f251b76", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ec1422ea3f39708d50ef95ce63feebae2f251b76", "committedDate": "2020-08-25T09:46:22Z", "message": "Eliminate logic for receiving updated CDS config with cluster name changed. This should never be the use case."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5abb04088d48b4fd8c9a9fa72465eef692ffdf1", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/f5abb04088d48b4fd8c9a9fa72465eef692ffdf1", "committedDate": "2020-08-25T09:46:39Z", "message": "Reimplement tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTQzMDk3", "url": "https://github.com/grpc/grpc-java/pull/7356#pullrequestreview-474943097", "createdAt": "2020-08-25T22:00:01Z", "commit": {"oid": "f5abb04088d48b4fd8c9a9fa72465eef692ffdf1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMjowMDowMVrOHGsRcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMjowMDowMVrOHGsRcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc3ODg2NA==", "bodyText": "It looks strange to have lb field here, the whole class does not use lb at all. lb should be a field of ChildLbState.", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r476778864", "createdAt": "2020-08-25T22:00:01Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -125,124 +110,35 @@ public boolean canHandleEmptyAddressListFromNameResolution() {\n   @Override\n   public void shutdown() {\n     logger.log(XdsLogLevel.INFO, \"Shutdown\");\n-    switchingLoadBalancer.shutdown();\n+    if (childLbState != null) {\n+      childLbState.shutdown();\n+    }\n     if (xdsClientPool != null) {\n       xdsClientPool.returnObject(xdsClient);\n     }\n   }\n \n-  // TODO(sanjaypujare): remove once xDS security is released\n-  private boolean isXdsSecurityEnabled() {\n-    return enableXdsSecurity || Boolean.valueOf(System.getenv(XDS_SECURITY_ENV_VAR));\n-  }\n-\n-  // TODO(sanjaypujare): remove once xDS security is released\n-  @VisibleForTesting\n-  void setXdsSecurity(boolean enable) {\n-    enableXdsSecurity = enable;\n-  }\n-\n-  /**\n-   * A load balancer factory that provides a load balancer for a given cluster.\n-   */\n-  private final class ClusterBalancerFactory extends LoadBalancer.Factory {\n-\n-    final String clusterName;\n-\n-    ClusterBalancerFactory(String clusterName) {\n-      this.clusterName = clusterName;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-      if (!(o instanceof ClusterBalancerFactory)) {\n-        return false;\n-      }\n-      ClusterBalancerFactory that = (ClusterBalancerFactory) o;\n-      return clusterName.equals(that.clusterName);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return Objects.hash(super.hashCode(), clusterName);\n-    }\n-\n-    @Override\n-    public LoadBalancer newLoadBalancer(final Helper helper) {\n-      return new LoadBalancer() {\n-        // Becomes non-null once handleResolvedAddresses() successfully.\n-        // Assigned at most once.\n-        @Nullable\n-        ClusterWatcherImpl clusterWatcher;\n-\n-        @Override\n-        public void handleNameResolutionError(Status error) {\n-          if (clusterWatcher == null || clusterWatcher.edsBalancer == null) {\n-            // Go into TRANSIENT_FAILURE if we have not yet received any cluster resource.\n-            // Otherwise, we keep running with the data we had previously.\n-            helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n-          }\n-        }\n-\n-        @Override\n-        public boolean canHandleEmptyAddressListFromNameResolution() {\n-          return true;\n-        }\n-\n-        @Override\n-        public void shutdown() {\n-          if (clusterWatcher != null) {\n-            if (clusterWatcher.edsBalancer != null) {\n-              clusterWatcher.edsBalancer.shutdown();\n-            }\n-            xdsClient.cancelClusterDataWatch(clusterName, clusterWatcher);\n-            logger.log(\n-                XdsLogLevel.INFO,\n-                \"Cancelled cluster watcher on {0} with xDS client {1}\",\n-                clusterName, xdsClient);\n-          }\n-        }\n-\n-        @Override\n-        public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n-          if (clusterWatcher == null) {\n-            clusterWatcher = new ClusterWatcherImpl(helper, resolvedAddresses);\n-            logger.log(\n-                XdsLogLevel.INFO,\n-                \"Start cluster watcher on {0} with xDS client {1}\",\n-                clusterName, xdsClient);\n-            xdsClient.watchClusterData(clusterName, clusterWatcher);\n-          }\n-        }\n-      };\n-    }\n-  }\n-\n-  private static final class EdsLoadBalancingHelper extends ForwardingLoadBalancerHelper {\n-    private final Helper delegate;\n-    private final AtomicReference<SslContextProvider> sslContextProvider;\n-\n-    EdsLoadBalancingHelper(Helper helper,\n-        AtomicReference<SslContextProvider> sslContextProvider) {\n-      this.delegate = helper;\n-      this.sslContextProvider = sslContextProvider;\n-    }\n+  private final class ChannelSecurityLbHelper extends ForwardingLoadBalancerHelper {\n+    @Nullable\n+    private SslContextProvider sslContextProvider;\n+    @Nullable\n+    private LoadBalancer lb;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5abb04088d48b4fd8c9a9fa72465eef692ffdf1"}, "originalPosition": 238}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTQ2ODUy", "url": "https://github.com/grpc/grpc-java/pull/7356#pullrequestreview-474946852", "createdAt": "2020-08-25T22:07:13Z", "commit": {"oid": "f5abb04088d48b4fd8c9a9fa72465eef692ffdf1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMjowNzoxM1rOHGsnVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMjowNzoxM1rOHGsnVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njc4NDQ2OQ==", "bodyText": "This can be helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error)) because lbHelper is only for lb. If lb is null, you should use helper directly.", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r476784469", "createdAt": "2020-08-25T22:07:13Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -350,16 +230,33 @@ public void onResourceDoesNotExist(String resourceName) {\n \n     @Override\n     public void onError(Status error) {\n-      logger.log(\n-          XdsLogLevel.WARNING,\n-          \"Received error from xDS client {0}: {1}: {2}\",\n-          xdsClient,\n-          error.getCode(),\n-          error.getDescription());\n-      if (edsBalancer == null) {\n+      logger.log(XdsLogLevel.WARNING, \"Received error from xDS client {0}: {1}\", error);\n+      if (lbHelper.lb == null) {\n         helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n       }\n     }\n-  }\n \n+    void start() {\n+      xdsClient.watchClusterData(clusterName, this);\n+      logger.log(XdsLogLevel.INFO,\n+          \"Started watcher for cluster {0} with xDS client {1}\", clusterName, xdsClient);\n+    }\n+\n+    void shutdown() {\n+      xdsClient.cancelClusterDataWatch(clusterName, this);\n+      logger.log(XdsLogLevel.INFO,\n+          \"Cancelled watcher for cluster {0} with xDS client {1}\", clusterName, xdsClient);\n+      if (lbHelper.lb != null) {\n+        lbHelper.lb.shutdown();\n+      }\n+    }\n+\n+    void propagateError(Status error) {\n+      if (lbHelper.lb != null) {\n+        lbHelper.lb.handleNameResolutionError(error);\n+      } else {\n+        lbHelper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5abb04088d48b4fd8c9a9fa72465eef692ffdf1"}, "originalPosition": 413}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ee2592a72e030458dfd5bb5d1c600a8d851a1cd", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/8ee2592a72e030458dfd5bb5d1c600a8d851a1cd", "committedDate": "2020-08-26T19:42:20Z", "message": "Improve class field composition."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e79c05ca7edb3171943a56d5ce2614a3a6b178d", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3e79c05ca7edb3171943a56d5ce2614a3a6b178d", "committedDate": "2020-08-26T20:35:02Z", "message": "CdsLoadBalancer should be package private."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81e33e2db5c313093817c2efc3be6c4201b21604", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/81e33e2db5c313093817c2efc3be6c4201b21604", "committedDate": "2020-08-26T22:55:29Z", "message": "Revert the year change in file header."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1ODQ2NDI5", "url": "https://github.com/grpc/grpc-java/pull/7356#pullrequestreview-475846429", "createdAt": "2020-08-26T20:46:32Z", "commit": {"oid": "3e79c05ca7edb3171943a56d5ce2614a3a6b178d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDo0NjozMlrOHHdIAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzoyNTo0MlrOHHikvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU3OTI2Ng==", "bodyText": "I think keeping checkNotNull(xdsClientPool, \"missing xDS client pool\"); provides better debug information than a plain NPE.", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477579266", "createdAt": "2020-08-26T20:46:32Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -44,77 +41,65 @@\n import io.grpc.xds.internal.sds.TlsContextManager;\n import io.grpc.xds.internal.sds.TlsContextManagerImpl;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicReference;\n import javax.annotation.Nullable;\n \n /**\n- * Load balancer for cds_experimental LB policy.\n+ * Load balancer for cds_experimental LB policy. One instance per cluster.\n  */\n-public final class CdsLoadBalancer extends LoadBalancer {\n+final class CdsLoadBalancer extends LoadBalancer {\n+  // TODO(sanjaypujare): remove once xds security is released\n+  @VisibleForTesting\n+  static boolean enableSecurity =\n+      Boolean.parseBoolean(System.getenv(\"GRPC_XDS_EXPERIMENTAL_SECURITY_SUPPORT\"));\n   private final XdsLogger logger;\n+  private final LoadBalancer.Helper helper;\n   private final LoadBalancerRegistry lbRegistry;\n-  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n   private final TlsContextManager tlsContextManager;\n-  // TODO(sanjaypujare): remove once xds security is released\n-  private boolean enableXdsSecurity;\n-  private static final String XDS_SECURITY_ENV_VAR = \"GRPC_XDS_EXPERIMENTAL_SECURITY_SUPPORT\";\n-\n-  // The following fields become non-null once handleResolvedAddresses() successfully.\n-\n-  // Most recent cluster name.\n-  @Nullable\n   private String clusterName;\n-  @Nullable\n   private ObjectPool<XdsClient> xdsClientPool;\n-  @Nullable\n   private XdsClient xdsClient;\n+  private ChildLbState childLbState;\n \n-  CdsLoadBalancer(Helper helper) {\n+  CdsLoadBalancer(LoadBalancer.Helper helper) {\n     this(helper, LoadBalancerRegistry.getDefaultRegistry(), TlsContextManagerImpl.getInstance());\n   }\n \n   @VisibleForTesting\n-  CdsLoadBalancer(Helper helper, LoadBalancerRegistry lbRegistry,\n+  CdsLoadBalancer(LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry,\n       TlsContextManager tlsContextManager) {\n-    checkNotNull(helper, \"helper\");\n+    this.helper = checkNotNull(helper, \"helper\");\n     this.lbRegistry = lbRegistry;\n-    this.switchingLoadBalancer = new GracefulSwitchLoadBalancer(helper);\n     this.tlsContextManager = tlsContextManager;\n     logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n     logger.log(XdsLogLevel.INFO, \"Created\");\n   }\n \n   @Override\n   public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n-    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n-    if (xdsClientPool == null) {\n-      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n-      checkNotNull(xdsClientPool, \"missing xDS client pool\");\n-      xdsClient = xdsClientPool.getObject();\n+    if (clusterName != null) {\n+      return;\n     }\n-\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+    xdsClient = xdsClientPool.getObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e79c05ca7edb3171943a56d5ce2614a3a6b178d"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2NTY2OQ==", "bodyText": "Why making this change? Should never remove any unrecognized attributes.", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477665669", "createdAt": "2020-08-26T23:23:06Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -264,83 +158,68 @@ public Subchannel createSubchannel(CreateSubchannelArgs createSubchannelArgs) {\n \n     @Override\n     protected Helper delegate() {\n-      return delegate;\n+      return helper;\n     }\n   }\n \n-  private final class ClusterWatcherImpl implements ClusterWatcher {\n-\n-    final EdsLoadBalancingHelper helper;\n-    final ResolvedAddresses resolvedAddresses;\n-\n+  private final class ChildLbState implements ClusterWatcher {\n+    private final ChannelSecurityLbHelper lbHelper = new ChannelSecurityLbHelper();\n     @Nullable\n-    LoadBalancer edsBalancer;\n-\n-    ClusterWatcherImpl(Helper helper, ResolvedAddresses resolvedAddresses) {\n-      this.helper = new EdsLoadBalancingHelper(helper,\n-          new AtomicReference<SslContextProvider>());\n-      this.resolvedAddresses = resolvedAddresses;\n-    }\n+    private LoadBalancer lb;\n \n     @Override\n-    public void onClusterChanged(ClusterUpdate newUpdate) {\n+    public void onClusterChanged(ClusterUpdate update) {\n       if (logger.isLoggable(XdsLogLevel.INFO)) {\n-        logger.log(\n-            XdsLogLevel.INFO,\n-            \"Received cluster update from xDS client {0}: \"\n+        logger.log(XdsLogLevel.INFO, \"Received cluster update from xDS client {0}: \"\n                 + \"cluster_name={1}, eds_service_name={2}, lb_policy={3}, report_load={4}\",\n-            xdsClient, newUpdate.getClusterName(), newUpdate.getEdsServiceName(),\n-            newUpdate.getLbPolicy(), newUpdate.getLrsServerName() != null);\n+            xdsClient, update.getClusterName(), update.getEdsServiceName(),\n+            update.getLbPolicy(), update.getLrsServerName() != null);\n       }\n-      checkArgument(\n-          newUpdate.getLbPolicy().equals(\"round_robin\"), \"can only support round_robin policy\");\n-\n-      LoadBalancerProvider lbProvider = lbRegistry.getProvider(newUpdate.getLbPolicy());\n-      Object lbConfig =\n-          lbProvider.parseLoadBalancingPolicyConfig(ImmutableMap.<String, Object>of()).getConfig();\n+      LoadBalancerProvider lbProvider = lbRegistry.getProvider(update.getLbPolicy());\n       final EdsConfig edsConfig =\n-          new EdsConfig(\n-              /* clusterName = */ newUpdate.getClusterName(),\n-              /* edsServiceName = */ newUpdate.getEdsServiceName(),\n-              /* lrsServerName = */ newUpdate.getLrsServerName(),\n-              new PolicySelection(lbProvider, ImmutableMap.<String, Object>of(), lbConfig));\n-      if (isXdsSecurityEnabled()) {\n-        updateSslContextProvider(newUpdate.getUpstreamTlsContext());\n+          new EdsConfig(update.getClusterName(), update.getEdsServiceName(),\n+              update.getLrsServerName(), new PolicySelection(lbProvider, null, null));\n+      if (enableSecurity) {\n+        updateSslContextProvider(update.getUpstreamTlsContext());\n       }\n-      if (edsBalancer == null) {\n-        edsBalancer = lbRegistry.getProvider(EDS_POLICY_NAME).newLoadBalancer(helper);\n+      if (lb == null) {\n+        lb = lbRegistry.getProvider(XdsLbPolicies.EDS_POLICY_NAME).newLoadBalancer(lbHelper);\n       }\n-      edsBalancer.handleResolvedAddresses(\n-          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(edsConfig).build());\n+      lb.handleResolvedAddresses(\n+          ResolvedAddresses.newBuilder()\n+              .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+              .setAttributes(\n+                  Attributes.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81e33e2db5c313093817c2efc3be6c4201b21604"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY2ODU0Mg==", "bodyText": "What is {0}?", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477668542", "createdAt": "2020-08-26T23:25:42Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -350,16 +229,33 @@ public void onResourceDoesNotExist(String resourceName) {\n \n     @Override\n     public void onError(Status error) {\n-      logger.log(\n-          XdsLogLevel.WARNING,\n-          \"Received error from xDS client {0}: {1}: {2}\",\n-          xdsClient,\n-          error.getCode(),\n-          error.getDescription());\n-      if (edsBalancer == null) {\n+      logger.log(XdsLogLevel.WARNING, \"Received error from xDS client {0}: {1}\", error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81e33e2db5c313093817c2efc3be6c4201b21604"}, "originalPosition": 386}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MTQ2MjA3", "url": "https://github.com/grpc/grpc-java/pull/7356#pullrequestreview-476146207", "createdAt": "2020-08-26T23:49:39Z", "commit": {"oid": "81e33e2db5c313093817c2efc3be6c4201b21604"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo0OTozOVrOHHktFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo0OTozOVrOHHktFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzcwMzQ0Nw==", "bodyText": "Implementing a TlsContextManager seems simpler and more readable than the boilerplate of implementing new Answer().", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r477703447", "createdAt": "2020-08-26T23:49:39Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java", "diffHunk": "@@ -46,547 +31,485 @@\n import io.grpc.LoadBalancer.PickResult;\n import io.grpc.LoadBalancer.PickSubchannelArgs;\n import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n import io.grpc.LoadBalancer.SubchannelPicker;\n import io.grpc.LoadBalancerProvider;\n import io.grpc.LoadBalancerRegistry;\n-import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n import io.grpc.Status;\n import io.grpc.Status.Code;\n import io.grpc.SynchronizationContext;\n-import io.grpc.internal.FakeClock;\n-import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.internal.ObjectPool;\n import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n-import io.grpc.xds.XdsClient.ClusterUpdate;\n-import io.grpc.xds.XdsClient.ClusterWatcher;\n-import io.grpc.xds.XdsClient.RefCountedXdsClientObjectPool;\n-import io.grpc.xds.XdsClient.XdsClientFactory;\n import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n import io.grpc.xds.internal.sds.SslContextProvider;\n import io.grpc.xds.internal.sds.TlsContextManager;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayDeque;\n+import java.net.SocketAddress;\n import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-import org.mockito.ArgumentCaptor;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n \n /**\n  * Tests for {@link CdsLoadBalancer}.\n  */\n @RunWith(JUnit4.class)\n public class CdsLoadBalancerTest {\n-\n-  private final RefCountedXdsClientObjectPool xdsClientPool = new RefCountedXdsClientObjectPool(\n-      new XdsClientFactory() {\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n         @Override\n-        XdsClient createXdsClient() {\n-          xdsClient = mock(XdsClient.class);\n-          return xdsClient;\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n         }\n+      });\n+  private final List<FakeLoadBalancer> childBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  @Mock\n+  private TlsContextManager tlsContextManager;\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private CdsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+    when(tlsContextManager.findOrCreateClientSslContextProvider(any(UpstreamTlsContext.class)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81e33e2db5c313093817c2efc3be6c4201b21604"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68aab1af647afcd43fa7a072c182c2490d51c2f5", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/68aab1af647afcd43fa7a072c182c2490d51c2f5", "committedDate": "2020-08-27T00:32:46Z", "message": "Fix log typo."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7a5101f73ca29e2b2d3b13d499aed9429a8e4eb", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a7a5101f73ca29e2b2d3b13d499aed9429a8e4eb", "committedDate": "2020-08-27T00:42:32Z", "message": "Use a fake implementation for TlsContextManager for test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d1ee05e4460963f29272bf93287571fb720e65f", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/0d1ee05e4460963f29272bf93287571fb720e65f", "committedDate": "2020-08-27T18:29:24Z", "message": "Eliminated the unnecessary start() method."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6585d3d7cb9afa7bde8f9ac94bf7028d29c49cab", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/6585d3d7cb9afa7bde8f9ac94bf7028d29c49cab", "committedDate": "2020-08-27T18:41:03Z", "message": "Improve logging."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b9af1d4c4b8683bc2252a304e55236b779aaa2d", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/1b9af1d4c4b8683bc2252a304e55236b779aaa2d", "committedDate": "2020-08-27T19:15:56Z", "message": "Pass the ResolvedAddress blob straightly down to the child balancer."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1e3d48f0c8570d246dc8761e9722ec7fdacda70", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/d1e3d48f0c8570d246dc8761e9722ec7fdacda70", "committedDate": "2020-08-27T19:22:09Z", "message": "Pass the whole attributes to child balancer opaquely."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDU2MDU2", "url": "https://github.com/grpc/grpc-java/pull/7356#pullrequestreview-477056056", "createdAt": "2020-08-27T20:27:04Z", "commit": {"oid": "d1e3d48f0c8570d246dc8761e9722ec7fdacda70"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDoyNzowNFrOHIgE6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDoyNzowNFrOHIgE6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3NjIwMg==", "bodyText": "This is also unrelated style change. I also liked @sanjaypujare 's style. Maybe\nreturn enableXdsSecurity || STATIC_VALUE\nfor isXdsSecurityEnabled() could improve it a bit. But the non-static setXdsSecurity() method for testing is better than modifing static value in test, in my opinion.\nAs pointed out by @ejona86 , we should not flip/flop unrelated lines in the PR. Just keeping as-is can make the diff of PR small. If you do want some improvement, make it a separate PR.", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478676202", "createdAt": "2020-08-27T20:27:04Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -125,124 +111,33 @@ public boolean canHandleEmptyAddressListFromNameResolution() {\n   @Override\n   public void shutdown() {\n     logger.log(XdsLogLevel.INFO, \"Shutdown\");\n-    switchingLoadBalancer.shutdown();\n+    if (childLbState != null) {\n+      childLbState.shutdown();\n+    }\n     if (xdsClientPool != null) {\n       xdsClientPool.returnObject(xdsClient);\n     }\n   }\n \n-  // TODO(sanjaypujare): remove once xDS security is released\n-  private boolean isXdsSecurityEnabled() {\n-    return enableXdsSecurity || Boolean.valueOf(System.getenv(XDS_SECURITY_ENV_VAR));\n-  }\n-\n-  // TODO(sanjaypujare): remove once xDS security is released\n-  @VisibleForTesting\n-  void setXdsSecurity(boolean enable) {\n-    enableXdsSecurity = enable;\n-  }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1e3d48f0c8570d246dc8761e9722ec7fdacda70"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c29780907ad4f7997092684304988dcbf04eb7ce", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/c29780907ad4f7997092684304988dcbf04eb7ce", "committedDate": "2020-08-27T20:44:09Z", "message": "Revert \"Pass the whole attributes to child balancer opaquely.\"\n\nThis reverts commit d1e3d48f0c8570d246dc8761e9722ec7fdacda70."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10880ec35423ed9e2c870fae797389bf4f6d2348", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/10880ec35423ed9e2c870fae797389bf4f6d2348", "committedDate": "2020-08-28T00:01:45Z", "message": "Revert non-crutial changes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33b1d93b557f4009c7e31a8630a0507f646a57bf", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/33b1d93b557f4009c7e31a8630a0507f646a57bf", "committedDate": "2020-08-27T23:58:56Z", "message": "Revert non-crutial changes."}, "afterCommit": {"oid": "10880ec35423ed9e2c870fae797389bf4f6d2348", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/10880ec35423ed9e2c870fae797389bf4f6d2348", "committedDate": "2020-08-28T00:01:45Z", "message": "Revert non-crutial changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTU5OTEy", "url": "https://github.com/grpc/grpc-java/pull/7356#pullrequestreview-477159912", "createdAt": "2020-08-28T00:03:24Z", "commit": {"oid": "10880ec35423ed9e2c870fae797389bf4f6d2348"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDowMzoyNVrOHIlKbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDowMzoyNVrOHIlKbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1OTUzNA==", "bodyText": "They are effectively final. Code explains itself, no need to comment.", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r478759534", "createdAt": "2020-08-28T00:03:25Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer.java", "diffHunk": "@@ -45,31 +44,24 @@\n import io.grpc.xds.internal.sds.TlsContextManagerImpl;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.concurrent.atomic.AtomicReference;\n import javax.annotation.Nullable;\n \n /**\n- * Load balancer for cds_experimental LB policy.\n+ * Load balancer for cds_experimental LB policy. One instance per cluster.\n  */\n-public final class CdsLoadBalancer extends LoadBalancer {\n+final class CdsLoadBalancer extends LoadBalancer {\n   private final XdsLogger logger;\n+  private final Helper helper;\n   private final LoadBalancerRegistry lbRegistry;\n-  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n   private final TlsContextManager tlsContextManager;\n   // TODO(sanjaypujare): remove once xds security is released\n   private boolean enableXdsSecurity;\n   private static final String XDS_SECURITY_ENV_VAR = \"GRPC_XDS_EXPERIMENTAL_SECURITY_SUPPORT\";\n-\n-  // The following fields become non-null once handleResolvedAddresses() successfully.\n-\n-  // Most recent cluster name.\n-  @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10880ec35423ed9e2c870fae797389bf4f6d2348"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3ODg2MjQ5", "url": "https://github.com/grpc/grpc-java/pull/7356#pullrequestreview-477886249", "createdAt": "2020-08-28T16:57:02Z", "commit": {"oid": "10880ec35423ed9e2c870fae797389bf4f6d2348"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNjo1NzowMlrOHJN1Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzowNjoxNlrOHJOHjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyNTgxMA==", "bodyText": "an empty line here", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r479425810", "createdAt": "2020-08-28T16:57:02Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java", "diffHunk": "@@ -46,547 +30,498 @@\n import io.grpc.LoadBalancer.PickResult;\n import io.grpc.LoadBalancer.PickSubchannelArgs;\n import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n import io.grpc.LoadBalancer.SubchannelPicker;\n import io.grpc.LoadBalancerProvider;\n import io.grpc.LoadBalancerRegistry;\n-import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n import io.grpc.Status;\n import io.grpc.Status.Code;\n import io.grpc.SynchronizationContext;\n-import io.grpc.internal.FakeClock;\n-import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.internal.ObjectPool;\n import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyServerProtoData.DownstreamTlsContext;\n import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n-import io.grpc.xds.XdsClient.ClusterUpdate;\n-import io.grpc.xds.XdsClient.ClusterWatcher;\n-import io.grpc.xds.XdsClient.RefCountedXdsClientObjectPool;\n-import io.grpc.xds.XdsClient.XdsClientFactory;\n import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n import io.grpc.xds.internal.sds.SslContextProvider;\n import io.grpc.xds.internal.sds.TlsContextManager;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayDeque;\n+import java.net.SocketAddress;\n import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n /**\n  * Tests for {@link CdsLoadBalancer}.\n  */\n @RunWith(JUnit4.class)\n public class CdsLoadBalancerTest {\n-\n-  private final RefCountedXdsClientObjectPool xdsClientPool = new RefCountedXdsClientObjectPool(\n-      new XdsClientFactory() {\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n         @Override\n-        XdsClient createXdsClient() {\n-          xdsClient = mock(XdsClient.class);\n-          return xdsClient;\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n         }\n+      });\n+  private final List<FakeLoadBalancer> childBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  private final TlsContextManager tlsContextManager = new FakeTlsContextManager();\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private CdsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    LoadBalancerRegistry registry = new LoadBalancerRegistry();\n+    registry.register(new FakeLoadBalancerProvider(XdsLbPolicies.EDS_POLICY_NAME));\n+    registry.register(new FakeLoadBalancerProvider(\"round_robin\"));\n+    ObjectPool<XdsClient> xdsClientPool = new ObjectPool<XdsClient>() {\n+      @Override\n+      public XdsClient getObject() {\n+        xdsClientRefs++;\n+        return xdsClient;\n       }\n-  );\n \n-  private final LoadBalancerRegistry lbRegistry = new LoadBalancerRegistry();\n-  private final LoadBalancerProvider fakeEdsLoadBlancerProvider = new LoadBalancerProvider() {\n+      @Override\n+      public XdsClient returnObject(Object object) {\n+        assertThat(xdsClientRefs).isGreaterThan(0);\n+        xdsClientRefs--;\n+        return null;\n+      }\n+    };\n+    loadBalancer = new CdsLoadBalancer(helper, registry, tlsContextManager);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setLoadBalancingPolicyConfig(new CdsConfig(CLUSTER))\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .build());\n+    assertThat(xdsClient.watcher).isNotNull();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(xdsClient.watcher).isNull();\n+    assertThat(xdsClientRefs).isEqualTo(0);\n+  }\n+\n+\n+  @Test\n+  public void receiveFirstClusterResourceInfo() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    assertThat(childBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    assertThat(childBalancer.name).isEqualTo(XdsLbPolicies.EDS_POLICY_NAME);\n+    assertThat(childBalancer.config).isNotNull();\n+    EdsConfig edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isNull();\n+    assertThat(edsConfig.lrsServerName).isNull();\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+  }\n+\n+  @Test\n+  public void clusterResourceNeverExist() {\n+    xdsClient.deliverResourceNotFound();\n+    assertThat(childBalancers).isEmpty();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + CLUSTER + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void clusterResourceRemoved() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    assertThat(childBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    assertThat(childBalancer.shutdown).isFalse();\n+\n+    xdsClient.deliverResourceNotFound();\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + CLUSTER + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void clusterResourceUpdated() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    EdsConfig edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isNull();\n+    assertThat(edsConfig.lrsServerName).isNull();\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+\n+    String edsService = \"service-bar.googleapis.com\";\n+    String loadReportServer = \"lrs-server.googleapis.com\";\n+    xdsClient.deliverClusterInfo(edsService, loadReportServer);\n+    assertThat(childBalancers).containsExactly(childBalancer);\n+    edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isEqualTo(edsService);\n+    assertThat(edsConfig.lrsServerName).isEqualTo(loadReportServer);\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10880ec35423ed9e2c870fae797389bf4f6d2348"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQzMDU0Mg==", "bodyText": "Normally if delivering a picker with a subchannel, the state is READY. If delivering IDLE or TRANSIENT_FAILURE, the picker is buffer picker or error picker.", "url": "https://github.com/grpc/grpc-java/pull/7356#discussion_r479430542", "createdAt": "2020-08-28T17:06:16Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/CdsLoadBalancerTest.java", "diffHunk": "@@ -46,547 +30,498 @@\n import io.grpc.LoadBalancer.PickResult;\n import io.grpc.LoadBalancer.PickSubchannelArgs;\n import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n import io.grpc.LoadBalancer.SubchannelPicker;\n import io.grpc.LoadBalancerProvider;\n import io.grpc.LoadBalancerRegistry;\n-import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n import io.grpc.Status;\n import io.grpc.Status.Code;\n import io.grpc.SynchronizationContext;\n-import io.grpc.internal.FakeClock;\n-import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.internal.ObjectPool;\n import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyServerProtoData.DownstreamTlsContext;\n import io.grpc.xds.EnvoyServerProtoData.UpstreamTlsContext;\n-import io.grpc.xds.XdsClient.ClusterUpdate;\n-import io.grpc.xds.XdsClient.ClusterWatcher;\n-import io.grpc.xds.XdsClient.RefCountedXdsClientObjectPool;\n-import io.grpc.xds.XdsClient.XdsClientFactory;\n import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n import io.grpc.xds.internal.sds.SslContextProvider;\n import io.grpc.xds.internal.sds.TlsContextManager;\n-import java.net.InetSocketAddress;\n-import java.util.ArrayDeque;\n+import java.net.SocketAddress;\n import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n /**\n  * Tests for {@link CdsLoadBalancer}.\n  */\n @RunWith(JUnit4.class)\n public class CdsLoadBalancerTest {\n-\n-  private final RefCountedXdsClientObjectPool xdsClientPool = new RefCountedXdsClientObjectPool(\n-      new XdsClientFactory() {\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n         @Override\n-        XdsClient createXdsClient() {\n-          xdsClient = mock(XdsClient.class);\n-          return xdsClient;\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n         }\n+      });\n+  private final List<FakeLoadBalancer> childBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  private final TlsContextManager tlsContextManager = new FakeTlsContextManager();\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private CdsLoadBalancer loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    LoadBalancerRegistry registry = new LoadBalancerRegistry();\n+    registry.register(new FakeLoadBalancerProvider(XdsLbPolicies.EDS_POLICY_NAME));\n+    registry.register(new FakeLoadBalancerProvider(\"round_robin\"));\n+    ObjectPool<XdsClient> xdsClientPool = new ObjectPool<XdsClient>() {\n+      @Override\n+      public XdsClient getObject() {\n+        xdsClientRefs++;\n+        return xdsClient;\n       }\n-  );\n \n-  private final LoadBalancerRegistry lbRegistry = new LoadBalancerRegistry();\n-  private final LoadBalancerProvider fakeEdsLoadBlancerProvider = new LoadBalancerProvider() {\n+      @Override\n+      public XdsClient returnObject(Object object) {\n+        assertThat(xdsClientRefs).isGreaterThan(0);\n+        xdsClientRefs--;\n+        return null;\n+      }\n+    };\n+    loadBalancer = new CdsLoadBalancer(helper, registry, tlsContextManager);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setLoadBalancingPolicyConfig(new CdsConfig(CLUSTER))\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .build());\n+    assertThat(xdsClient.watcher).isNotNull();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(xdsClient.watcher).isNull();\n+    assertThat(xdsClientRefs).isEqualTo(0);\n+  }\n+\n+\n+  @Test\n+  public void receiveFirstClusterResourceInfo() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    assertThat(childBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    assertThat(childBalancer.name).isEqualTo(XdsLbPolicies.EDS_POLICY_NAME);\n+    assertThat(childBalancer.config).isNotNull();\n+    EdsConfig edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isNull();\n+    assertThat(edsConfig.lrsServerName).isNull();\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+  }\n+\n+  @Test\n+  public void clusterResourceNeverExist() {\n+    xdsClient.deliverResourceNotFound();\n+    assertThat(childBalancers).isEmpty();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + CLUSTER + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void clusterResourceRemoved() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    assertThat(childBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    assertThat(childBalancer.shutdown).isFalse();\n+\n+    xdsClient.deliverResourceNotFound();\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + CLUSTER + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void clusterResourceUpdated() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    EdsConfig edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isNull();\n+    assertThat(edsConfig.lrsServerName).isNull();\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+\n+    String edsService = \"service-bar.googleapis.com\";\n+    String loadReportServer = \"lrs-server.googleapis.com\";\n+    xdsClient.deliverClusterInfo(edsService, loadReportServer);\n+    assertThat(childBalancers).containsExactly(childBalancer);\n+    edsConfig = (EdsConfig) childBalancer.config;\n+    assertThat(edsConfig.clusterName).isEqualTo(CLUSTER);\n+    assertThat(edsConfig.edsServiceName).isEqualTo(edsService);\n+    assertThat(edsConfig.lrsServerName).isEqualTo(loadReportServer);\n+    assertThat(edsConfig.endpointPickingPolicy.getProvider().getPolicyName())\n+        .isEqualTo(\"round_robin\");\n+\n+  }\n+\n+  @Test\n+  public void receiveClusterResourceInfoWithUpstreamTlsContext() {\n+    loadBalancer.setXdsSecurity(true);\n+    UpstreamTlsContext upstreamTlsContext =\n+        CommonTlsContextTestsUtil.buildUpstreamTlsContextFromFilenames(\n+            CommonTlsContextTestsUtil.CLIENT_KEY_FILE,\n+            CommonTlsContextTestsUtil.CLIENT_PEM_FILE,\n+            CommonTlsContextTestsUtil.CA_PEM_FILE);\n+    xdsClient.deliverClusterInfo(null, null, upstreamTlsContext);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    List<EquivalentAddressGroup> addresses = createEndpointAddresses(2);\n+    CreateSubchannelArgs args =\n+        CreateSubchannelArgs.newBuilder()\n+            .setAddresses(addresses)\n+            .build();\n+    Subchannel subchannel = childBalancer.helper.createSubchannel(args);\n+    for (EquivalentAddressGroup eag : subchannel.getAllAddresses()) {\n+      assertThat(eag.getAttributes().get(XdsAttributes.ATTR_UPSTREAM_TLS_CONTEXT))\n+          .isEqualTo(upstreamTlsContext);\n+    }\n+\n+    xdsClient.deliverClusterInfo(null, null);\n+    subchannel = childBalancer.helper.createSubchannel(args);\n+    for (EquivalentAddressGroup eag : subchannel.getAllAddresses()) {\n+      assertThat(eag.getAttributes().get(XdsAttributes.ATTR_UPSTREAM_TLS_CONTEXT)).isNull();\n+    }\n+\n+    upstreamTlsContext =\n+        CommonTlsContextTestsUtil.buildUpstreamTlsContextFromFilenames(\n+            CommonTlsContextTestsUtil.BAD_CLIENT_KEY_FILE,\n+            CommonTlsContextTestsUtil.BAD_CLIENT_PEM_FILE,\n+            CommonTlsContextTestsUtil.CA_PEM_FILE);\n+    xdsClient.deliverClusterInfo(null, null, upstreamTlsContext);\n+    subchannel = childBalancer.helper.createSubchannel(args);\n+    for (EquivalentAddressGroup eag : subchannel.getAllAddresses()) {\n+      assertThat(eag.getAttributes().get(XdsAttributes.ATTR_UPSTREAM_TLS_CONTEXT))\n+          .isEqualTo(upstreamTlsContext);\n+    }\n+  }\n+\n+  @Test\n+  public void subchannelStatePropagateFromDownstreamToUpstream() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    List<EquivalentAddressGroup> addresses = createEndpointAddresses(2);\n+    CreateSubchannelArgs args =\n+        CreateSubchannelArgs.newBuilder()\n+            .setAddresses(addresses)\n+            .build();\n+    Subchannel subchannel = childBalancer.helper.createSubchannel(args);\n+    childBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    assertThat(currentPicker.pickSubchannel(mock(PickSubchannelArgs.class)).getSubchannel())\n+        .isSameInstanceAs(subchannel);\n+  }\n+\n+  @Test\n+  public void clusterDiscoveryError_beforeChildPolicyInstantiated_propagateToUpstream() {\n+    xdsClient.deliverError(Status.UNAUTHENTICATED.withDescription(\"permission denied\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAUTHENTICATED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"permission denied\");\n+  }\n+\n+  @Test\n+  public void clusterDiscoveryError_afterChildPolicyInstantiated_keepUsingCurrentCluster() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    xdsClient.deliverError(Status.UNAVAILABLE.withDescription(\"unreachable\"));\n+    assertThat(currentState).isNull();\n+    assertThat(currentPicker).isNull();\n+    assertThat(childBalancer.shutdown).isFalse();\n+  }\n+\n+  @Test\n+  public void nameResolutionError_beforeChildPolicyInstantiated_returnErrorPickerToUpstream() {\n+    loadBalancer.handleNameResolutionError(\n+        Status.UNIMPLEMENTED.withDescription(\"not found\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNIMPLEMENTED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"not found\");\n+  }\n+\n+  @Test\n+  public void nameResolutionError_afterChildPolicyInstantiated_propagateToDownstream() {\n+    xdsClient.deliverClusterInfo(null, null);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(childBalancers);\n+    loadBalancer.handleNameResolutionError(\n+        Status.UNAVAILABLE.withDescription(\"cannot reach server\"));\n+    assertThat(childBalancer.upstreamError.getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(childBalancer.upstreamError.getDescription())\n+        .isEqualTo(\"cannot reach server\");\n+  }\n+\n+  private static List<EquivalentAddressGroup> createEndpointAddresses(int n) {\n+    List<EquivalentAddressGroup> list = new ArrayList<>();\n+    for (int i = 0; i < n; i++) {\n+      list.add(new EquivalentAddressGroup(mock(SocketAddress.class)));\n+    }\n+    return list;\n+  }\n+\n+  private final class FakeXdsClient extends XdsClient {\n+    private ClusterWatcher watcher;\n+\n     @Override\n-    public boolean isAvailable() {\n-      return true;\n+    void watchClusterData(String clusterName, ClusterWatcher watcher) {\n+      assertThat(clusterName).isEqualTo(CLUSTER);\n+      this.watcher = watcher;\n     }\n \n     @Override\n-    public int getPriority() {\n-      return 5;\n+    void cancelClusterDataWatch(String clusterName, ClusterWatcher watcher) {\n+      assertThat(clusterName).isEqualTo(CLUSTER);\n+      assertThat(watcher).isSameInstanceAs(this.watcher);\n+      this.watcher = null;\n     }\n \n     @Override\n-    public String getPolicyName() {\n-      return EDS_POLICY_NAME;\n+    void shutdown() {\n+      // no-op\n+    }\n+\n+    void deliverClusterInfo(\n+        @Nullable final String edsServiceName, @Nullable final String lrsServerName) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          watcher.onClusterChanged(\n+              ClusterUpdate.newBuilder()\n+                  .setClusterName(CLUSTER)\n+                  .setEdsServiceName(edsServiceName)\n+                  .setLbPolicy(\"round_robin\")  // only supported policy\n+                  .setLrsServerName(lrsServerName)\n+                  .build());\n+        }\n+      });\n+    }\n+\n+    void deliverClusterInfo(\n+        @Nullable final String edsServiceName, @Nullable final String lrsServerName,\n+        final UpstreamTlsContext tlsContext) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          watcher.onClusterChanged(\n+              ClusterUpdate.newBuilder()\n+                  .setClusterName(CLUSTER)\n+                  .setEdsServiceName(edsServiceName)\n+                  .setLbPolicy(\"round_robin\")  // only supported policy\n+                  .setLrsServerName(lrsServerName)\n+                  .setUpstreamTlsContext(tlsContext)\n+                  .build());\n+        }\n+      });\n+    }\n+\n+    void deliverResourceNotFound() {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          watcher.onResourceDoesNotExist(CLUSTER);\n+        }\n+      });\n+    }\n+\n+    void deliverError(final Status error) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          watcher.onError(error);\n+        }\n+      });\n+    }\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n     }\n \n     @Override\n     public LoadBalancer newLoadBalancer(Helper helper) {\n-      edsLbHelpers.add(helper);\n-      LoadBalancer edsLoadBalancer = mock(LoadBalancer.class);\n-      edsLoadBalancers.add(edsLoadBalancer);\n-      return edsLoadBalancer;\n+      FakeLoadBalancer balancer = new FakeLoadBalancer(policyName, helper);\n+      childBalancers.add(balancer);\n+      return balancer;\n     }\n-  };\n \n-  private final LoadBalancerProvider fakeRoundRobinLbProvider = new LoadBalancerProvider() {\n     @Override\n     public boolean isAvailable() {\n       return true;\n     }\n \n     @Override\n     public int getPriority() {\n-      return 5;\n+      return 0;  // doesn't matter\n     }\n \n     @Override\n     public String getPolicyName() {\n-      return \"round_robin\";\n+      return policyName;\n+    }\n+  }\n+\n+  private final class FakeLoadBalancer extends LoadBalancer {\n+    private final String name;\n+    private final Helper helper;\n+    private Object config;\n+    private Status upstreamError;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(String name, Helper helper) {\n+      this.name = name;\n+      this.helper = helper;\n     }\n \n     @Override\n-    public LoadBalancer newLoadBalancer(Helper helper) {\n-      return mock(LoadBalancer.class);\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      config = resolvedAddresses.getLoadBalancingPolicyConfig();\n     }\n \n     @Override\n-    public ConfigOrError parseLoadBalancingPolicyConfig(\n-        Map<String, ?> rawLoadBalancingPolicyConfig) {\n-      return ConfigOrError.fromConfig(\"fake round robin config\");\n+    public void handleNameResolutionError(Status error) {\n+      upstreamError = error;\n     }\n-  };\n \n-  private final SynchronizationContext syncContext = new SynchronizationContext(\n-      new Thread.UncaughtExceptionHandler() {\n+    @Override\n+    public void shutdown() {\n+      shutdown = true;\n+      childBalancers.remove(this);\n+    }\n+\n+    void deliverSubchannelState(final Subchannel subchannel, ConnectivityState state) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "10880ec35423ed9e2c870fae797389bf4f6d2348"}, "originalPosition": 475}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9a2c4c4882224a956a5c5124b803198ac9d76b3", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a9a2c4c4882224a956a5c5124b803198ac9d76b3", "committedDate": "2020-08-28T18:09:01Z", "message": "Delete empty line."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4199, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}