{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAyNzUzMzc0", "number": 7517, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzo1Njo1NFrOEyBYpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzo1Njo1NFrOEyBYpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODg2OTUxOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNzo1Njo1NFrOHobyZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjo1MjoxOFrOHrDGQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MDM1OQ==", "bodyText": "If result is a buffering result, should we drop the request immediately as well?", "url": "https://github.com/grpc/grpc-java/pull/7517#discussion_r512160359", "createdAt": "2020-10-26T17:56:54Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -398,7 +393,97 @@ protected Helper delegate() {\n         private void updateDropPolicies(List<DropOverload> dropOverloads) {\n           dropPolicies = dropOverloads;\n         }\n+\n+        private void updateMaxConcurrentRequests(long maxConcurrentRequests) {\n+          this.maxConcurrentRequests = maxConcurrentRequests;\n+        }\n+\n+        private final class RequestLimitingSubchannelPicker extends SubchannelPicker {\n+          private final SubchannelPicker delegate;\n+          private final List<DropOverload> dropPolicies;\n+          private final long maxConcurrentRequests;\n+\n+          private RequestLimitingSubchannelPicker(SubchannelPicker delegate,\n+              List<DropOverload> dropPolicies, long maxConcurrentRequests) {\n+            this.delegate = delegate;\n+            this.dropPolicies = dropPolicies;\n+            this.maxConcurrentRequests = maxConcurrentRequests;\n+          }\n+\n+          @Override\n+          public PickResult pickSubchannel(PickSubchannelArgs args) {\n+            for (DropOverload dropOverload : dropPolicies) {\n+              int rand = random.nextInt(1_000_000);\n+              if (rand < dropOverload.getDropsPerMillion()) {\n+                logger.log(XdsLogLevel.INFO, \"Drop request with category: {0}\",\n+                    dropOverload.getCategory());\n+                if (loadStatsStore != null) {\n+                  loadStatsStore.recordDroppedRequest(dropOverload.getCategory());\n+                }\n+                return PickResult.withDrop(\n+                    Status.UNAVAILABLE.withDescription(\"Dropped: \" + dropOverload.getCategory()));\n+              }\n+            }\n+            PickResult result = delegate.pickSubchannel(args);\n+            if (result.getStatus().isOk() && result.getSubchannel() != null) {\n+              if (requestCount.get() >= maxConcurrentRequests) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2efcbe05d732c408a031da77fec853f662a741a"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2NTk3Nw==", "bodyText": "result.getSubchannel() != null should be the thing to cover it.", "url": "https://github.com/grpc/grpc-java/pull/7517#discussion_r512165977", "createdAt": "2020-10-26T18:05:55Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -398,7 +393,97 @@ protected Helper delegate() {\n         private void updateDropPolicies(List<DropOverload> dropOverloads) {\n           dropPolicies = dropOverloads;\n         }\n+\n+        private void updateMaxConcurrentRequests(long maxConcurrentRequests) {\n+          this.maxConcurrentRequests = maxConcurrentRequests;\n+        }\n+\n+        private final class RequestLimitingSubchannelPicker extends SubchannelPicker {\n+          private final SubchannelPicker delegate;\n+          private final List<DropOverload> dropPolicies;\n+          private final long maxConcurrentRequests;\n+\n+          private RequestLimitingSubchannelPicker(SubchannelPicker delegate,\n+              List<DropOverload> dropPolicies, long maxConcurrentRequests) {\n+            this.delegate = delegate;\n+            this.dropPolicies = dropPolicies;\n+            this.maxConcurrentRequests = maxConcurrentRequests;\n+          }\n+\n+          @Override\n+          public PickResult pickSubchannel(PickSubchannelArgs args) {\n+            for (DropOverload dropOverload : dropPolicies) {\n+              int rand = random.nextInt(1_000_000);\n+              if (rand < dropOverload.getDropsPerMillion()) {\n+                logger.log(XdsLogLevel.INFO, \"Drop request with category: {0}\",\n+                    dropOverload.getCategory());\n+                if (loadStatsStore != null) {\n+                  loadStatsStore.recordDroppedRequest(dropOverload.getCategory());\n+                }\n+                return PickResult.withDrop(\n+                    Status.UNAVAILABLE.withDescription(\"Dropped: \" + dropOverload.getCategory()));\n+              }\n+            }\n+            PickResult result = delegate.pickSubchannel(args);\n+            if (result.getStatus().isOk() && result.getSubchannel() != null) {\n+              if (requestCount.get() >= maxConcurrentRequests) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MDM1OQ=="}, "originalCommit": {"oid": "d2efcbe05d732c408a031da77fec853f662a741a"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3MTA1OQ==", "bodyText": "I think for buffering result (result.getStatus().isOk() && result.getSubchannel() == null), it should also be dropped immediately.", "url": "https://github.com/grpc/grpc-java/pull/7517#discussion_r512171059", "createdAt": "2020-10-26T18:14:18Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -398,7 +393,97 @@ protected Helper delegate() {\n         private void updateDropPolicies(List<DropOverload> dropOverloads) {\n           dropPolicies = dropOverloads;\n         }\n+\n+        private void updateMaxConcurrentRequests(long maxConcurrentRequests) {\n+          this.maxConcurrentRequests = maxConcurrentRequests;\n+        }\n+\n+        private final class RequestLimitingSubchannelPicker extends SubchannelPicker {\n+          private final SubchannelPicker delegate;\n+          private final List<DropOverload> dropPolicies;\n+          private final long maxConcurrentRequests;\n+\n+          private RequestLimitingSubchannelPicker(SubchannelPicker delegate,\n+              List<DropOverload> dropPolicies, long maxConcurrentRequests) {\n+            this.delegate = delegate;\n+            this.dropPolicies = dropPolicies;\n+            this.maxConcurrentRequests = maxConcurrentRequests;\n+          }\n+\n+          @Override\n+          public PickResult pickSubchannel(PickSubchannelArgs args) {\n+            for (DropOverload dropOverload : dropPolicies) {\n+              int rand = random.nextInt(1_000_000);\n+              if (rand < dropOverload.getDropsPerMillion()) {\n+                logger.log(XdsLogLevel.INFO, \"Drop request with category: {0}\",\n+                    dropOverload.getCategory());\n+                if (loadStatsStore != null) {\n+                  loadStatsStore.recordDroppedRequest(dropOverload.getCategory());\n+                }\n+                return PickResult.withDrop(\n+                    Status.UNAVAILABLE.withDescription(\"Dropped: \" + dropOverload.getCategory()));\n+              }\n+            }\n+            PickResult result = delegate.pickSubchannel(args);\n+            if (result.getStatus().isOk() && result.getSubchannel() != null) {\n+              if (requestCount.get() >= maxConcurrentRequests) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MDM1OQ=="}, "originalCommit": {"oid": "d2efcbe05d732c408a031da77fec853f662a741a"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE4MDkwMg==", "bodyText": "Why? It will cause RPCs to be dropped prematurely. We shouldn't do anything to buffer result. The channel will handle it correctly.", "url": "https://github.com/grpc/grpc-java/pull/7517#discussion_r512180902", "createdAt": "2020-10-26T18:30:38Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -398,7 +393,97 @@ protected Helper delegate() {\n         private void updateDropPolicies(List<DropOverload> dropOverloads) {\n           dropPolicies = dropOverloads;\n         }\n+\n+        private void updateMaxConcurrentRequests(long maxConcurrentRequests) {\n+          this.maxConcurrentRequests = maxConcurrentRequests;\n+        }\n+\n+        private final class RequestLimitingSubchannelPicker extends SubchannelPicker {\n+          private final SubchannelPicker delegate;\n+          private final List<DropOverload> dropPolicies;\n+          private final long maxConcurrentRequests;\n+\n+          private RequestLimitingSubchannelPicker(SubchannelPicker delegate,\n+              List<DropOverload> dropPolicies, long maxConcurrentRequests) {\n+            this.delegate = delegate;\n+            this.dropPolicies = dropPolicies;\n+            this.maxConcurrentRequests = maxConcurrentRequests;\n+          }\n+\n+          @Override\n+          public PickResult pickSubchannel(PickSubchannelArgs args) {\n+            for (DropOverload dropOverload : dropPolicies) {\n+              int rand = random.nextInt(1_000_000);\n+              if (rand < dropOverload.getDropsPerMillion()) {\n+                logger.log(XdsLogLevel.INFO, \"Drop request with category: {0}\",\n+                    dropOverload.getCategory());\n+                if (loadStatsStore != null) {\n+                  loadStatsStore.recordDroppedRequest(dropOverload.getCategory());\n+                }\n+                return PickResult.withDrop(\n+                    Status.UNAVAILABLE.withDescription(\"Dropped: \" + dropOverload.getCategory()));\n+              }\n+            }\n+            PickResult result = delegate.pickSubchannel(args);\n+            if (result.getStatus().isOk() && result.getSubchannel() != null) {\n+              if (requestCount.get() >= maxConcurrentRequests) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MDM1OQ=="}, "originalCommit": {"oid": "d2efcbe05d732c408a031da77fec853f662a741a"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4NjQzNA==", "bodyText": "If requestCount.get() >= maxConcurrentRequest it should drop the RPC regardless of the subchannel's readiness. What's dropped prematurely?", "url": "https://github.com/grpc/grpc-java/pull/7517#discussion_r514886434", "createdAt": "2020-10-30T05:57:24Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -398,7 +393,97 @@ protected Helper delegate() {\n         private void updateDropPolicies(List<DropOverload> dropOverloads) {\n           dropPolicies = dropOverloads;\n         }\n+\n+        private void updateMaxConcurrentRequests(long maxConcurrentRequests) {\n+          this.maxConcurrentRequests = maxConcurrentRequests;\n+        }\n+\n+        private final class RequestLimitingSubchannelPicker extends SubchannelPicker {\n+          private final SubchannelPicker delegate;\n+          private final List<DropOverload> dropPolicies;\n+          private final long maxConcurrentRequests;\n+\n+          private RequestLimitingSubchannelPicker(SubchannelPicker delegate,\n+              List<DropOverload> dropPolicies, long maxConcurrentRequests) {\n+            this.delegate = delegate;\n+            this.dropPolicies = dropPolicies;\n+            this.maxConcurrentRequests = maxConcurrentRequests;\n+          }\n+\n+          @Override\n+          public PickResult pickSubchannel(PickSubchannelArgs args) {\n+            for (DropOverload dropOverload : dropPolicies) {\n+              int rand = random.nextInt(1_000_000);\n+              if (rand < dropOverload.getDropsPerMillion()) {\n+                logger.log(XdsLogLevel.INFO, \"Drop request with category: {0}\",\n+                    dropOverload.getCategory());\n+                if (loadStatsStore != null) {\n+                  loadStatsStore.recordDroppedRequest(dropOverload.getCategory());\n+                }\n+                return PickResult.withDrop(\n+                    Status.UNAVAILABLE.withDescription(\"Dropped: \" + dropOverload.getCategory()));\n+              }\n+            }\n+            PickResult result = delegate.pickSubchannel(args);\n+            if (result.getStatus().isOk() && result.getSubchannel() != null) {\n+              if (requestCount.get() >= maxConcurrentRequests) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MDM1OQ=="}, "originalCommit": {"oid": "d2efcbe05d732c408a031da77fec853f662a741a"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMTU3MA==", "bodyText": "No, that should not count toward the number of dropped requests. Also, it doesn't make sense to override the non-ready picker with a drop picker.", "url": "https://github.com/grpc/grpc-java/pull/7517#discussion_r514901570", "createdAt": "2020-10-30T06:52:18Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -398,7 +393,97 @@ protected Helper delegate() {\n         private void updateDropPolicies(List<DropOverload> dropOverloads) {\n           dropPolicies = dropOverloads;\n         }\n+\n+        private void updateMaxConcurrentRequests(long maxConcurrentRequests) {\n+          this.maxConcurrentRequests = maxConcurrentRequests;\n+        }\n+\n+        private final class RequestLimitingSubchannelPicker extends SubchannelPicker {\n+          private final SubchannelPicker delegate;\n+          private final List<DropOverload> dropPolicies;\n+          private final long maxConcurrentRequests;\n+\n+          private RequestLimitingSubchannelPicker(SubchannelPicker delegate,\n+              List<DropOverload> dropPolicies, long maxConcurrentRequests) {\n+            this.delegate = delegate;\n+            this.dropPolicies = dropPolicies;\n+            this.maxConcurrentRequests = maxConcurrentRequests;\n+          }\n+\n+          @Override\n+          public PickResult pickSubchannel(PickSubchannelArgs args) {\n+            for (DropOverload dropOverload : dropPolicies) {\n+              int rand = random.nextInt(1_000_000);\n+              if (rand < dropOverload.getDropsPerMillion()) {\n+                logger.log(XdsLogLevel.INFO, \"Drop request with category: {0}\",\n+                    dropOverload.getCategory());\n+                if (loadStatsStore != null) {\n+                  loadStatsStore.recordDroppedRequest(dropOverload.getCategory());\n+                }\n+                return PickResult.withDrop(\n+                    Status.UNAVAILABLE.withDescription(\"Dropped: \" + dropOverload.getCategory()));\n+              }\n+            }\n+            PickResult result = delegate.pickSubchannel(args);\n+            if (result.getStatus().isOk() && result.getSubchannel() != null) {\n+              if (requestCount.get() >= maxConcurrentRequests) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MDM1OQ=="}, "originalCommit": {"oid": "d2efcbe05d732c408a031da77fec853f662a741a"}, "originalPosition": 159}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2404, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}