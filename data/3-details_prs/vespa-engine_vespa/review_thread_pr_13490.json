{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTI2MDY4", "number": 13490, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxNzozOFrOEC5l9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDo1MzowM1rOEC6NBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDc2MjE1OnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxNzozOFrOGfo1wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzo0NToxNFrOGgJmKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODE2Mg==", "bodyText": "should also test with inverted vectors", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828162", "createdAt": "2020-06-05T10:17:38Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NDg0MA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436364840", "createdAt": "2020-06-07T13:45:14Z", "author": {"login": "baldersheim"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODE2Mg=="}, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDc2MjU2OnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxNzo0N1rOGfo2Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzo0NTowMlrOGgJmCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODIzNA==", "bodyText": "should also test with inverted vectors", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828234", "createdAt": "2020-06-05T10:17:47Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");\n+                LOG_ABORT(\"should not be reached\");\n+            }\n+        }\n+    }\n+}\n+\n+void\n+verifyAnd64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleAndWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NDgxMA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436364810", "createdAt": "2020-06-07T13:45:02Z", "author": {"login": "baldersheim"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");\n+                LOG_ABORT(\"should not be reached\");\n+            }\n+        }\n+    }\n+}\n+\n+void\n+verifyAnd64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleAndWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODIzNA=="}, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDc2MzU4OnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxODowOVrOGfo2zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMjo0NTo1NVrOGgJSMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQyOA==", "bodyText": "misleading error message", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828428", "createdAt": "2020-06-05T10:18:09Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");\n+                LOG_ABORT(\"should not be reached\");\n+            }\n+        }\n+    }\n+}\n+\n+void\n+verifyAnd64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleAndWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.and64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1OTczMQ==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436359731", "createdAt": "2020-06-07T12:45:55Z", "author": {"login": "baldersheim"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");\n+                LOG_ABORT(\"should not be reached\");\n+            }\n+        }\n+    }\n+}\n+\n+void\n+verifyAnd64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleAndWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.and64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQyOA=="}, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDc2Mzc1OnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxODoxNVrOGfo2-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMjo0NTo0MVrOGgJSEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQ3Mw==", "bodyText": "even more misleading error message", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828473", "createdAt": "2020-06-05T10:18:15Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1OTY5OA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436359698", "createdAt": "2020-06-07T12:45:41Z", "author": {"login": "baldersheim"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQ3Mw=="}, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDgzNjA2OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDo0MzoxOVrOGfpk8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMjo0MjoxMVrOGgJQ_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MDI0Mw==", "bodyText": "should add a static assert somewhere that this value is 64 bytes", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435840243", "createdAt": "2020-06-05T10:43:19Z", "author": {"login": "havardpe"}, "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,90 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(const Children & children) : MultiBitVectorIteratorBase(children) { }\n+    explicit MultiBitVectorIterator(const Children & children)\n+        : MultiBitVectorIteratorBase(children),\n+          _update(),\n+          _lastWords(),\n+          _accel(IAccelrated::getAccelrator())\n+    {\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    Word                _lastWords[8] __attribute__((aligned(32)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1OTQyMA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436359420", "createdAt": "2020-06-07T12:42:11Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,90 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(const Children & children) : MultiBitVectorIteratorBase(children) { }\n+    explicit MultiBitVectorIterator(const Children & children)\n+        : MultiBitVectorIteratorBase(children),\n+          _update(),\n+          _lastWords(),\n+          _accel(IAccelrated::getAccelrator())\n+    {\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    Word                _lastWords[8] __attribute__((aligned(32)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MDI0Mw=="}, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDg2MjE0OnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDo1MzowNFrOGfp1JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxMzo0NjowMlrOGgJmag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NDM4OA==", "bodyText": "these functions are a bit confusing. The length of the operation is specified in bytes while the offset is specified in multiples of uint64_t. It also binds the Word abstraction to be uint64_t, making that abstraction less useful. Also; at glace, the 64 in the function name seems to reflect the fact that we are using 64-bit values, leaving the size of the operation a mystery...\nconsider using byte offset and passing the memory as void*", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435844388", "createdAt": "2020-06-05T10:53:04Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.h", "diffHunk": "@@ -29,6 +30,9 @@ class IAccelrated\n     virtual size_t populationCount(const uint64_t *a, size_t sz) const = 0;\n     virtual double squaredEuclideanDistance(const float * a, const float * b, size_t sz) const = 0;\n     virtual double squaredEuclideanDistance(const double * a, const double * b, size_t sz) const = 0;\n+    // And 64 bytes from multiple sources\n+    virtual void and64(size_t offset, const std::vector<std::pair<const uint64_t *, bool>> &src, uint64_t *dest) const = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NDkwNg==", "bodyText": "Agree, fixed", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r436364906", "createdAt": "2020-06-07T13:46:02Z", "author": {"login": "baldersheim"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.h", "diffHunk": "@@ -29,6 +30,9 @@ class IAccelrated\n     virtual size_t populationCount(const uint64_t *a, size_t sz) const = 0;\n     virtual double squaredEuclideanDistance(const float * a, const float * b, size_t sz) const = 0;\n     virtual double squaredEuclideanDistance(const double * a, const double * b, size_t sz) const = 0;\n+    // And 64 bytes from multiple sources\n+    virtual void and64(size_t offset, const std::vector<std::pair<const uint64_t *, bool>> &src, uint64_t *dest) const = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NDM4OA=="}, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1988, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}