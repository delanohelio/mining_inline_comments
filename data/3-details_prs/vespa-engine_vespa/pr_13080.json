{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5NDY5ODE1", "number": 13080, "title": "Remove batching of messages that has no effect in favor of making asy\u2026", "bodyText": "\u2026nc operations easier to implement.\n@vekterli PR", "createdAt": "2020-04-27T12:30:03Z", "url": "https://github.com/vespa-engine/vespa/pull/13080", "merged": true, "mergeCommit": {"oid": "e2356a51c4c64745d232c02ed142afd42efe5a93"}, "closed": true, "closedAt": "2020-04-27T13:24:27Z", "author": {"login": "baldersheim"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcbucgAAH2gAyNDA5NDY5ODE1OmYwYTdhMTRkNjM5MDU5ZjRkOWRlMzAwMWZjOTZkOTUyMTlmNDk5YjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcbvOIwgH2gAyNDA5NDY5ODE1OjJlMTYwMmQ0NTNkYzQyNzJlN2UxMDQwYTIxZjEyZTM0MzhjOGE1YWE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f0a7a14d639059f4d9de3001fc96d95219f499b2", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/f0a7a14d639059f4d9de3001fc96d95219f499b2", "committedDate": "2020-04-27T12:28:48Z", "message": "Remove batching of messages that has no effect in favor of making async operations easier to implement."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTExNTcw", "url": "https://github.com/vespa-engine/vespa/pull/13080#pullrequestreview-400911570", "createdAt": "2020-04-27T12:41:10Z", "commit": {"oid": "f0a7a14d639059f4d9de3001fc96d95219f499b2"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo0MToxMFrOGMhD1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo1MTowNVrOGMhehQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3Nzc0OQ==", "bodyText": "Consider updating log message to no longer talk about looping", "url": "https://github.com/vespa-engine/vespa/pull/13080#discussion_r415777749", "createdAt": "2020-04-27T12:41:10Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -894,115 +894,24 @@ bool hasBucketInfo(const api::StorageMessage& msg)\n \n }\n \n-void\n-PersistenceThread::flushAllReplies(\n-        const document::Bucket& bucket,\n-        std::vector<std::unique_ptr<MessageTracker> >& replies)\n-{\n-    if (replies.empty()) {\n-        return;\n-    }\n-\n-    try {\n-        if (replies.size() > 1) {\n-            _env._metrics.batchingSize.addValue(replies.size());\n-        }\n-#ifdef ENABLE_BUCKET_OPERATION_LOGGING\n-        {\n-            size_t nputs = 0, nremoves = 0, nother = 0;\n-            for (size_t i = 0; i < replies.size(); ++i) {\n-                if (dynamic_cast<api::PutReply*>(replies[i]->getReply().get()))\n-                {\n-                    ++nputs;\n-                } else if (dynamic_cast<api::RemoveReply*>(\n-                                replies[i]->getReply().get()))\n-                {\n-                    ++nremoves;\n-                } else {\n-                    ++nother;\n-                }\n-            }\n-            LOG_BUCKET_OPERATION(\n-                    bucket.getBucketId(),\n-                    vespalib::make_string(\n-                            \"flushing %zu operations (%zu puts, %zu removes, \"\n-                            \"%zu other)\",\n-                            replies.size(), nputs, nremoves, nother));\n-        }\n-#endif\n-        spi::Bucket b(bucket, spi::PartitionId(_env._partition));\n-        // Flush is not used for anything currentlu, and the context is not correct either when batching is done\n-        // So just faking it here.\n-        spi::Context dummyContext(documentapi::LoadType::DEFAULT, 0, 0);\n-        spi::Result result = _spi.flush(b, dummyContext);\n-        uint32_t errorCode = _env.convertErrorCode(result);\n-        if (errorCode != 0) {\n-            for (uint32_t i = 0; i < replies.size(); ++i) {\n-                replies[i]->getReply()->setResult(api::ReturnCode((api::ReturnCode::Result)errorCode, result.getErrorMessage()));\n-            }\n-        }\n-    } catch (std::exception& e) {\n-        for (uint32_t i = 0; i < replies.size(); ++i) {\n-            replies[i]->getReply()->setResult(api::ReturnCode(api::ReturnCode::INTERNAL_FAILURE, e.what()));\n-        }\n-    }\n-\n-    for (uint32_t i = 0; i < replies.size(); ++i) {\n-        LOG(spam, \"Sending reply up (batched): %s %\" PRIu64,\n-            replies[i]->getReply()->toString().c_str(), replies[i]->getReply()->getMsgId());\n-        _env._fileStorHandler.sendReply(replies[i]->getReply());\n-    }\n-\n-    replies.clear();\n-}\n-\n-void PersistenceThread::processMessages(FileStorHandler::LockedMessage & lock)\n-{\n+void PersistenceThread::processMessages(FileStorHandler::LockedMessage & lock) {\n     std::vector<MessageTracker::UP> trackers;\n     document::Bucket bucket = lock.first->getBucket();\n \n-    while (lock.second) {\n-        LOG(debug, \"Inside while loop %d, nodeIndex %d, ptr=%p\", _env._partition, _env._nodeIndex, lock.second.get());\n-        std::shared_ptr<api::StorageMessage> msg(lock.second);\n-        bool batchable = isBatchable(*msg);\n-\n-        // If the next operation wasn't batchable, we should flush\n-        // everything that came before.\n-        if (!batchable) {\n-            flushAllReplies(bucket, trackers);\n-        }\n-\n-        std::unique_ptr<MessageTracker> tracker = processMessage(*msg);\n-        if (!tracker || !tracker->getReply()) {\n-            // Was a reply\n-            break;\n-        }\n+    LOG(debug, \"Inside while loop %d, nodeIndex %d, ptr=%p\", _env._partition, _env._nodeIndex, lock.second.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a7a14d639059f4d9de3001fc96d95219f499b2"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NDU4MQ==", "bodyText": "Consider updating name to not be plural anymore (probably something like processLockedMessage to avoid colliding with existing processMessage", "url": "https://github.com/vespa-engine/vespa/pull/13080#discussion_r415784581", "createdAt": "2020-04-27T12:51:05Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -894,115 +894,24 @@ bool hasBucketInfo(const api::StorageMessage& msg)\n \n }\n \n-void\n-PersistenceThread::flushAllReplies(\n-        const document::Bucket& bucket,\n-        std::vector<std::unique_ptr<MessageTracker> >& replies)\n-{\n-    if (replies.empty()) {\n-        return;\n-    }\n-\n-    try {\n-        if (replies.size() > 1) {\n-            _env._metrics.batchingSize.addValue(replies.size());\n-        }\n-#ifdef ENABLE_BUCKET_OPERATION_LOGGING\n-        {\n-            size_t nputs = 0, nremoves = 0, nother = 0;\n-            for (size_t i = 0; i < replies.size(); ++i) {\n-                if (dynamic_cast<api::PutReply*>(replies[i]->getReply().get()))\n-                {\n-                    ++nputs;\n-                } else if (dynamic_cast<api::RemoveReply*>(\n-                                replies[i]->getReply().get()))\n-                {\n-                    ++nremoves;\n-                } else {\n-                    ++nother;\n-                }\n-            }\n-            LOG_BUCKET_OPERATION(\n-                    bucket.getBucketId(),\n-                    vespalib::make_string(\n-                            \"flushing %zu operations (%zu puts, %zu removes, \"\n-                            \"%zu other)\",\n-                            replies.size(), nputs, nremoves, nother));\n-        }\n-#endif\n-        spi::Bucket b(bucket, spi::PartitionId(_env._partition));\n-        // Flush is not used for anything currentlu, and the context is not correct either when batching is done\n-        // So just faking it here.\n-        spi::Context dummyContext(documentapi::LoadType::DEFAULT, 0, 0);\n-        spi::Result result = _spi.flush(b, dummyContext);\n-        uint32_t errorCode = _env.convertErrorCode(result);\n-        if (errorCode != 0) {\n-            for (uint32_t i = 0; i < replies.size(); ++i) {\n-                replies[i]->getReply()->setResult(api::ReturnCode((api::ReturnCode::Result)errorCode, result.getErrorMessage()));\n-            }\n-        }\n-    } catch (std::exception& e) {\n-        for (uint32_t i = 0; i < replies.size(); ++i) {\n-            replies[i]->getReply()->setResult(api::ReturnCode(api::ReturnCode::INTERNAL_FAILURE, e.what()));\n-        }\n-    }\n-\n-    for (uint32_t i = 0; i < replies.size(); ++i) {\n-        LOG(spam, \"Sending reply up (batched): %s %\" PRIu64,\n-            replies[i]->getReply()->toString().c_str(), replies[i]->getReply()->getMsgId());\n-        _env._fileStorHandler.sendReply(replies[i]->getReply());\n-    }\n-\n-    replies.clear();\n-}\n-\n-void PersistenceThread::processMessages(FileStorHandler::LockedMessage & lock)\n-{\n+void PersistenceThread::processMessages(FileStorHandler::LockedMessage & lock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0a7a14d639059f4d9de3001fc96d95219f499b2"}, "originalPosition": 68}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e1602d453dc4272e7e1040a21f12e3438c8a5aa", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/2e1602d453dc4272e7e1040a21f12e3438c8a5aa", "committedDate": "2020-04-27T13:23:01Z", "message": "Update comments, and don't copy the shared ptr when not necessary."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3276, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}