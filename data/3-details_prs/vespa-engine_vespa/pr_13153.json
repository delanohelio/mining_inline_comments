{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMzQ4MDc5", "number": 13153, "title": "Balder/async put and remove", "bodyText": "@vekterli PR\nThis is the same as reviewed earlier on + async remove and a guard to only produce reply if it is a command.", "createdAt": "2020-05-05T07:23:22Z", "url": "https://github.com/vespa-engine/vespa/pull/13153", "merged": true, "mergeCommit": {"oid": "02a7dbc6c9dfd39c96eb9d72df92f43592ada2bf"}, "closed": true, "closedAt": "2020-05-05T12:06:34Z", "author": {"login": "baldersheim"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABceHKr2gH2gAyNDEzMzQ4MDc5OjlkNzY5ZGNhNDExNjkxNjgwYzE2ZTczMDk0ZWYyNzk1OGIyNjA5NTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceS5fnAH2gAyNDEzMzQ4MDc5OjExYzdjYTRjMTY0YmVjNGMwYWZiYzJmZWM3MGI2MWZmODc1NWVhN2Q=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9d769dca411691680c16e73094ef27958b260959", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/9d769dca411691680c16e73094ef27958b260959", "committedDate": "2020-05-04T22:24:49Z", "message": "Implement async put\nImplement async remove."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2078bee591af22f091e7e9a9d7c039b0fca2be5c", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/2078bee591af22f091e7e9a9d7c039b0fca2be5c", "committedDate": "2020-05-04T22:24:50Z", "message": "Only generate reply if it is a command."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b83b031718d466df9fc0c4abd89f7fe0bcdbbf8", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/2b83b031718d466df9fc0c4abd89f7fe0bcdbbf8", "committedDate": "2020-05-04T22:24:50Z", "message": "Avoid a race during shutdown that can lead to having to wait 120s extra before completeting shutdown sequence.\nThis would happen because you could lose the signal sent from the stop method. Now you will either notice that is topped, or you will receive the signal."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NTkwNzk1", "url": "https://github.com/vespa-engine/vespa/pull/13153#pullrequestreview-405590795", "createdAt": "2020-05-05T08:35:50Z", "commit": {"oid": "2b83b031718d466df9fc0c4abd89f7fe0bcdbbf8"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODozNTo1MFrOGQflrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODo1ODo0OFrOGQgYng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0Nzk1MQ==", "bodyText": "Just an observation: a rather far fetched scenario, but since neither of these are now pure virtual it's technically possible for a persistence implementation to override neither of remove or removeAsync, causing infinite recursion here if any of the two are called (same applies to the other sync/async pairings).", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r419947951", "createdAt": "2020-05-05T08:35:50Z", "author": {"login": "vekterli"}, "path": "persistence/src/vespa/persistence/spi/persistenceprovider.cpp", "diffHunk": "@@ -29,9 +36,42 @@ PersistenceProvider::put(const Bucket& bucket, Timestamp timestamp, DocumentSP d\n \n void\n PersistenceProvider::putAsync(const Bucket &bucket, Timestamp timestamp, DocumentSP doc, Context &context,\n-                              OperationComplete::UP onComplete) {\n+                              OperationComplete::UP onComplete)\n+{\n     Result result = put(bucket, timestamp, std::move(doc), context);\n     onComplete->onComplete(std::make_unique<Result>(result));\n }\n \n+RemoveResult\n+PersistenceProvider::remove(const Bucket& bucket, Timestamp timestamp, const DocumentId & docId, Context& context) {\n+    auto catcher = std::make_unique<CatchResult>();\n+    auto future = catcher->future_result();\n+    removeAsync(bucket, timestamp, docId, context, std::move(catcher));\n+    return dynamic_cast<const RemoveResult &>(*future.get());\n+}\n+\n+void\n+PersistenceProvider::removeAsync(const Bucket &bucket, Timestamp timestamp, const DocumentId & docId, Context &context,\n+                                 OperationComplete::UP onComplete)\n+{\n+    RemoveResult result = remove(bucket, timestamp, docId, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b83b031718d466df9fc0c4abd89f7fe0bcdbbf8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2MDk5MA==", "bodyText": "Consider pulling makeResultTask out above this call to make the code less deeply nested here", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r419960990", "createdAt": "2020-05-05T08:58:48Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -91,42 +165,72 @@ PersistenceThread::tasConditionMatches(const api::TestAndSetCommand & cmd, Messa\n }\n \n MessageTracker::UP\n-PersistenceThread::handlePut(api::PutCommand& cmd, MessageTracker::UP tracker)\n+PersistenceThread::handlePut(api::PutCommand& cmd, MessageTracker::UP trackerUP)\n {\n+    MessageTracker & tracker = *trackerUP;\n     auto& metrics = _env._metrics.put[cmd.getLoadType()];\n-    tracker->setMetric(metrics);\n+    tracker.setMetric(metrics);\n     metrics.request_size.addValue(cmd.getApproxByteSize());\n \n-    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, *tracker, tracker->context())) {\n-        return tracker;\n+    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, tracker, tracker.context())) {\n+        return trackerUP;\n     }\n \n-    spi::Result response = _spi.put(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                    spi::Timestamp(cmd.getTimestamp()), std::move(cmd.getDocument()), tracker->context());\n-    tracker->checkForError(response);\n-    return tracker;\n+    if (_sequencedExecutor == nullptr) {\n+        spi::Result response = _spi.put(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n+                                        spi::Timestamp(cmd.getTimestamp()), std::move(cmd.getDocument()),\n+                                        tracker.context());\n+        tracker.checkForError(response);\n+    } else {\n+        _spi.putAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()), spi::Timestamp(cmd.getTimestamp()),\n+                      std::move(cmd.getDocument()), tracker.context(),\n+                      std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n+                              makeResultTask([tracker = std::move(trackerUP)](spi::Result::UP response) {\n+                                  tracker->checkForError(*response);\n+                                  tracker->sendReply();\n+                              })));\n+    }\n+    return trackerUP;\n }\n \n MessageTracker::UP\n-PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP tracker)\n+PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP trackerUP)\n {\n+    MessageTracker & tracker = *trackerUP;\n     auto& metrics = _env._metrics.remove[cmd.getLoadType()];\n-    tracker->setMetric(metrics);\n+    tracker.setMetric(metrics);\n     metrics.request_size.addValue(cmd.getApproxByteSize());\n \n-    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, *tracker, tracker->context())) {\n-        return tracker;\n+    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, tracker, tracker.context())) {\n+        return trackerUP;\n     }\n \n-    spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                                    spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker->context());\n-    if (tracker->checkForError(response)) {\n-        tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n-    }\n-    if (!response.wasFound()) {\n-        _env._metrics.remove[cmd.getLoadType()].notFound.inc();\n-    }\n-    return tracker;\n+    if (_sequencedExecutor == nullptr) {\n+        spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n+                                                        spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),\n+                                                        tracker.context());\n+        if (tracker.checkForError(response)) {\n+            tracker.setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n+        }\n+        if (!response.wasFound()) {\n+            metrics.notFound.inc();\n+        }\n+    } else {\n+        _spi.removeIfFoundAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n+                         spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n+                         std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n+                               makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n+                                   const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n+                                   if (tracker->checkForError(response)) {\n+                                       tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n+                                   }\n+                                   if (!response.wasFound()) {\n+                                       metrics.notFound.inc();\n+                                   }\n+                                   tracker->sendReply();\n+                               })));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b83b031718d466df9fc0c4abd89f7fe0bcdbbf8"}, "originalPosition": 186}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/bbfebdcf506f8b638ce40b28e47c3657cf002055", "committedDate": "2020-05-05T10:06:41Z", "message": "Add async update and followup on PR comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3951cf1ed16f56674a28f4efbb7973bfbe4e7c6c", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/3951cf1ed16f56674a28f4efbb7973bfbe4e7c6c", "committedDate": "2020-05-05T10:19:42Z", "message": "Add comment about mandatory implementations."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NzEwOTM0", "url": "https://github.com/vespa-engine/vespa/pull/13153#pullrequestreview-405710934", "createdAt": "2020-05-05T11:46:31Z", "commit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTo0NjozMVrOGQlrkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTo1MTozMlrOGQl1TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0Nzc2Mw==", "bodyText": "Nit: spurious whitespace", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420047763", "createdAt": "2020-05-05T11:46:31Z", "author": {"login": "vekterli"}, "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/persistenceengine.cpp", "diffHunk": "@@ -368,59 +368,55 @@ PersistenceEngine::removeAsync(const Bucket& b, Timestamp t, const DocumentId& d\n }\n \n \n-PersistenceEngine::UpdateResult\n-PersistenceEngine::update(const Bucket& b, Timestamp t, const DocumentUpdate::SP& upd, Context&)\n+void\n+PersistenceEngine::updateAsync(const Bucket& b, Timestamp t, DocumentUpdate::SP upd, Context&, OperationComplete::UP onComplete)\n {\n     if (!_writeFilter.acceptWriteOperation()) {\n         IResourceWriteFilter::State state = _writeFilter.getAcceptState();\n         if (!state.acceptWriteOperation()) {\n-            return UpdateResult(Result::ErrorType::RESOURCE_EXHAUSTED,\n+            return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::RESOURCE_EXHAUSTED,\n                                 make_string(\"Update operation rejected for document '%s': '%s'\",\n-                                            upd->getId().toString().c_str(), state.message().c_str()));\n+                                            upd->getId().toString().c_str(), state.message().c_str())));\n         }\n     }\n     try {\n         upd->eagerDeserialize();\n     } catch (document::FieldNotFoundException & e) {\n-        return UpdateResult(Result::ErrorType::TRANSIENT_ERROR,\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::TRANSIENT_ERROR,\n                             make_string(\"Update operation rejected for document '%s' of type '%s': 'Field not found'\",\n-                                        upd->getId().toString().c_str(), upd->getType().getName().c_str()));\n+                                        upd->getId().toString().c_str(), upd->getType().getName().c_str())));\n     } catch (document::DocumentTypeNotFoundException & e) {\n-        return UpdateResult(Result::ErrorType::TRANSIENT_ERROR,\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::TRANSIENT_ERROR,\n                             make_string(\"Update operation rejected for document '%s' of type '%s'.\",\n-                                        upd->getId().toString().c_str(), e.getDocumentTypeName().c_str()));\n+                                        upd->getId().toString().c_str(), e.getDocumentTypeName().c_str())));\n \n     } catch (document::WrongTensorTypeException &e) {\n-        return UpdateResult(Result::ErrorType::TRANSIENT_ERROR,\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::TRANSIENT_ERROR,\n                             make_string(\"Update operation rejected for document '%s' of type '%s': 'Wrong tensor type: %s'\",\n                                         upd->getId().toString().c_str(),\n                                         upd->getType().getName().c_str(),\n-                                        e.getMessage().c_str()));\n+                                        e.getMessage().c_str())));\n     }\n     std::shared_lock<std::shared_timed_mutex> rguard(_rwMutex);\n     DocTypeName docType(upd->getType());\n     LOG(spam, \"update(%s, %\" PRIu64 \", (\\\"%s\\\", \\\"%s\\\"), createIfNonExistent='%s')\",\n         b.toString().c_str(), static_cast<uint64_t>(t.getValue()), docType.toString().c_str(),\n         upd->getId().toString().c_str(), (upd->getCreateIfNonExistent() ? \"true\" : \"false\"));\n     if (!upd->getId().hasDocType()) {\n-        return UpdateResult(Result::ErrorType::PERMANENT_ERROR,\n-                            make_string(\"Old id scheme not supported in elastic mode (%s)\", upd->getId().toString().c_str()));\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::PERMANENT_ERROR,\n+                            make_string(\"Old id scheme not supported in elastic mode (%s)\", upd->getId().toString().c_str())));\n     }\n     if (upd->getId().getDocType() != docType.getName()) {\n-        return UpdateResult(Result::ErrorType::PERMANENT_ERROR,\n-                            make_string(\"Update operation rejected due to bad id (%s, %s)\", upd->getId().toString().c_str(), docType.getName().c_str()));\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::PERMANENT_ERROR,\n+                            make_string(\"Update operation rejected due to bad id (%s, %s)\", upd->getId().toString().c_str(), docType.getName().c_str())));\n     }\n     IPersistenceHandler * handler = getHandler(rguard, b.getBucketSpace(), docType);\n \n-    if (handler) {\n-        TransportLatch latch(1);\n-        LOG(debug, \"update = %s\", upd->toXml().c_str());\n-        handler->handleUpdate(feedtoken::make(latch), b, t, upd);\n-        latch.await();\n-        return latch.getUpdateResult();\n-    } else {\n-        return UpdateResult(Result::ErrorType::PERMANENT_ERROR, make_string(\"No handler for document type '%s'\", docType.toString().c_str()));\n+    if ( handler == nullptr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MDIwMw==", "bodyText": "Consider adding a comment stating why it's safe to refer to cmd as a reference capture to the argument given to the function itself, since the lifetime semantics aren't necessarily obvious.", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420050203", "createdAt": "2020-05-05T11:51:25Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -205,53 +203,66 @@ PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP trac\n         return trackerUP;\n     }\n \n+    spi::Bucket bucket = getBucket(cmd.getDocumentId(), cmd.getBucket());\n     if (_sequencedExecutor == nullptr) {\n-        spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                                        spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),\n-                                                        tracker.context());\n+        spi::RemoveResult response = _spi.removeIfFound(bucket, spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),tracker.context());\n         if (tracker.checkForError(response)) {\n             tracker.setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n         }\n         if (!response.wasFound()) {\n             metrics.notFound.inc();\n         }\n     } else {\n-        _spi.removeIfFoundAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                         spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n-                         std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n-                               makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n-                                   const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n-                                   if (tracker->checkForError(response)) {\n-                                       tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n-                                   }\n-                                   if (!response.wasFound()) {\n-                                       metrics.notFound.inc();\n-                                   }\n-                                   tracker->sendReply();\n-                               })));\n+        auto task = makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MDI1Mg==", "bodyText": "Consider adding a comment stating why it's safe to refer to cmd as a reference capture to the argument given to the function itself, since the lifetime semantics aren't necessarily obvious.", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420050252", "createdAt": "2020-05-05T11:51:32Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -205,53 +203,66 @@ PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP trac\n         return trackerUP;\n     }\n \n+    spi::Bucket bucket = getBucket(cmd.getDocumentId(), cmd.getBucket());\n     if (_sequencedExecutor == nullptr) {\n-        spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                                        spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),\n-                                                        tracker.context());\n+        spi::RemoveResult response = _spi.removeIfFound(bucket, spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),tracker.context());\n         if (tracker.checkForError(response)) {\n             tracker.setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n         }\n         if (!response.wasFound()) {\n             metrics.notFound.inc();\n         }\n     } else {\n-        _spi.removeIfFoundAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                         spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n-                         std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n-                               makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n-                                   const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n-                                   if (tracker->checkForError(response)) {\n-                                       tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n-                                   }\n-                                   if (!response.wasFound()) {\n-                                       metrics.notFound.inc();\n-                                   }\n-                                   tracker->sendReply();\n-                               })));\n+        auto task = makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n+            const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n+            if (tracker->checkForError(response)) {\n+                tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n+            }\n+            if (!response.wasFound()) {\n+                metrics.notFound.inc();\n+            }\n+            tracker->sendReply();\n+        });\n+        _spi.removeIfFoundAsync(bucket, spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n+                                std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(), std::move(task)));\n     }\n     return trackerUP;\n }\n \n MessageTracker::UP\n-PersistenceThread::handleUpdate(api::UpdateCommand& cmd, MessageTracker::UP tracker)\n+PersistenceThread::handleUpdate(api::UpdateCommand& cmd, MessageTracker::UP trackerUP)\n {\n+    MessageTracker & tracker = *trackerUP;\n     auto& metrics = _env._metrics.update[cmd.getLoadType()];\n-    tracker->setMetric(metrics);\n+    tracker.setMetric(metrics);\n     metrics.request_size.addValue(cmd.getApproxByteSize());\n \n-    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, *tracker, tracker->context(), cmd.getUpdate()->getCreateIfNonExistent())) {\n-        return tracker;\n+    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, tracker, tracker.context(), cmd.getUpdate()->getCreateIfNonExistent())) {\n+        return trackerUP;\n     }\n-    \n-    spi::UpdateResult response = _spi.update(getBucket(cmd.getUpdate()->getId(), cmd.getBucket()),\n-                                             spi::Timestamp(cmd.getTimestamp()), cmd.getUpdate(), tracker->context());\n-    if (tracker->checkForError(response)) {\n-        auto reply = std::make_shared<api::UpdateReply>(cmd);\n-        reply->setOldTimestamp(response.getExistingTimestamp());\n-        tracker->setReply(std::move(reply));\n+\n+    spi::Bucket bucket = getBucket(cmd.getDocumentId(), cmd.getBucket());\n+    if (_sequencedExecutor == nullptr) {\n+        spi::UpdateResult response = _spi.update(bucket, spi::Timestamp(cmd.getTimestamp()), std::move(cmd.getUpdate()),tracker.context());\n+        if (tracker.checkForError(response)) {\n+            auto reply = std::make_shared<api::UpdateReply>(cmd);\n+            reply->setOldTimestamp(response.getExistingTimestamp());\n+            tracker.setReply(std::move(reply));\n+        }\n+    } else {\n+        auto task = makeResultTask([&cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11c7ca4c164bec4c0afbc2fec70b61ff8755ea7d", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/11c7ca4c164bec4c0afbc2fec70b61ff8755ea7d", "committedDate": "2020-05-05T12:04:54Z", "message": "Update comments."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3319, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}