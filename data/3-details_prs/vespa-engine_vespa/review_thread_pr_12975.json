{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1NTg4MjQw", "number": 12975, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNDoyNjowMlrODzZ9NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjoyNjozOFrODzs2xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MjI5MjM3OnYy", "diffSide": "RIGHT", "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNDoyNjowMlrOGH4ZmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxODozOTo0NlrOGH7TOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzI3Mg==", "bodyText": "Edited: looking at the use in AFListBase, the side effect of a teared load is just a retry. So this should be OK for the use, but we might want to add comment describing that a teared load is not an issue.", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410917272", "createdAt": "2020-04-19T14:26:02Z", "author": {"login": "toregge"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,48 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+#define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "499c47d54b37b067e764821e232f78ab643a5b98"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2NDc5NQ==", "bodyText": "Agree, I will do that.", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410964795", "createdAt": "2020-04-19T18:39:46Z", "author": {"login": "baldersheim"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,48 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+#define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzI3Mg=="}, "originalCommit": {"oid": "499c47d54b37b067e764821e232f78ab643a5b98"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MjI5NTk4OnYy", "diffSide": "RIGHT", "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNDoyODozMFrOGH4bUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxODozOTo0OVrOGH7TRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzcxNA==", "bodyText": "Edited: The store is not atomic, but it is only used in a unit test before starting the test threads. Perhaps add a comment describing that a teared store is not an issue.", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410917714", "createdAt": "2020-04-19T14:28:30Z", "author": {"login": "toregge"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,48 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+#define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "499c47d54b37b067e764821e232f78ab643a5b98"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk2NDgwNg==", "bodyText": "I also noticed that it was used in a uint test so I not look at the details. I will do that and see if it is necessary.", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410964806", "createdAt": "2020-04-19T18:39:49Z", "author": {"login": "baldersheim"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,48 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+#define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzcxNA=="}, "originalCommit": {"oid": "499c47d54b37b067e764821e232f78ab643a5b98"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTIxODUyOnYy", "diffSide": "RIGHT", "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMTo0Mjo0NFrOGIQYSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMTo0Mjo0NFrOGIQYSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxMDE1NQ==", "bodyText": "store/load/compare_exchange_weak could be noexcept", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r411310155", "createdAt": "2020-04-20T11:42:44Z", "author": {"login": "vekterli"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,53 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+    #define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        // Note that this is NOT an atomic load. The current use as the initial load\n+        // in a compare_exchange loop is safe as a teared load will just give a retry.\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {\n+        // Note that this is NOT an atomic store. The current use is in a unit test as an initial\n+        // store before any threads are started. Just done so to keep api compatible with std::atomic as\n+        // that is the preferred implementation..\n+        *this = ptr;\n+    }\n+    bool\n+    compare_exchange_weak(TaggedPtr & oldPtr, TaggedPtr newPtr, std::memory_order, std::memory_order) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99834fd9c67c9baad2e56f151a4bbe30edfd5322"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTM4ODg1OnYy", "diffSide": "RIGHT", "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjoyNjozOFrOGIR7Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjoyNjozOFrOGIR7Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNTQ5OA==", "bodyText": "What does %6 signify in this case?", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r411335498", "createdAt": "2020-04-20T12:26:38Z", "author": {"login": "vekterli"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,53 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+    #define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        // Note that this is NOT an atomic load. The current use as the initial load\n+        // in a compare_exchange loop is safe as a teared load will just give a retry.\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {\n+        // Note that this is NOT an atomic store. The current use is in a unit test as an initial\n+        // store before any threads are started. Just done so to keep api compatible with std::atomic as\n+        // that is the preferred implementation..\n+        *this = ptr;\n+    }\n+    bool\n+    compare_exchange_weak(TaggedPtr & oldPtr, TaggedPtr newPtr, std::memory_order, std::memory_order) {\n+        char result;\n+        __asm__ volatile (\n+        \"lock ;\"\n+        \"cmpxchg16b %6;\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99834fd9c67c9baad2e56f151a4bbe30edfd5322"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1717, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}