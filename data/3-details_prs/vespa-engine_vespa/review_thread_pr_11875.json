{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MzMzMjE4", "number": 11875, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMToxMjo0MlrODi2oGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjowMTowN1rODjDLwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODczMTc2OnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/maintenance/NodeMetricsDbMaintainer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMToxMjo0MlrOFuVXUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMToxMjo0MlrOFuVXUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyODg1MA==", "bodyText": "@author", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384128850", "createdAt": "2020-02-25T21:12:42Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/maintenance/NodeMetricsDbMaintainer.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.maintenance;\n+\n+import com.yahoo.config.provision.ApplicationId;\n+import com.yahoo.vespa.hosted.provision.autoscale.NodeMetrics;\n+import com.yahoo.vespa.hosted.provision.NodeRepository;\n+import com.yahoo.vespa.hosted.provision.autoscale.NodeMetricsDb;\n+\n+import java.time.Duration;\n+import java.util.logging.Level;\n+\n+/**\n+ * Maintainer which keeps the node metric db up to date by periodically fetching metrics from all\n+ * active nodes.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODc3MzcxOnYy", "diffSide": "RIGHT", "path": "node-repository/src/test/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsFetcherTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMToyNjoxMVrOFuVxTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjoxNDoyNVrOFupPtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNTUwMw==", "bodyText": "Compare the actual object instead? (Otherwise you should at least format the float with locale)", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384135503", "createdAt": "2020-02-25T21:26:11Z", "author": {"login": "freva"}, "path": "node-repository/src/test/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsFetcherTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.autoscale;\n+\n+import com.yahoo.config.provision.ApplicationId;\n+import com.yahoo.config.provision.Capacity;\n+import com.yahoo.config.provision.NodeResources;\n+import com.yahoo.vespa.hosted.provision.provisioning.ProvisioningTester;\n+import com.yahoo.vespa.hosted.provision.testutils.OrchestratorMock;\n+import com.yahoo.vespa.applicationmodel.HostName;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class NodeMetricsFetcherTest {\n+\n+    @Test\n+    public void testMetricsFetch() {\n+        NodeResources resources = new NodeResources(1, 10, 100, 1);\n+        ProvisioningTester tester = new ProvisioningTester.Builder().build();\n+        OrchestratorMock orchestrator = new OrchestratorMock();\n+        MockHttpClient httpClient = new MockHttpClient();\n+        NodeMetricsFetcher fetcher = new NodeMetricsFetcher(tester.nodeRepository(), orchestrator, httpClient);\n+\n+        tester.makeReadyNodes(4, resources); // Creates (in order) host-1.yahoo.com, host-2.yahoo.com, host-3.yahoo.com, host-4.yahoo.com\n+        tester.deployZoneApp();\n+\n+        ApplicationId application1 = tester.makeApplicationId();\n+        ApplicationId application2 = tester.makeApplicationId();\n+        tester.deploy(application1, Capacity.fromCount(2, resources)); // host-1.yahoo.com, host-2.yahoo.com\n+        tester.deploy(application2, Capacity.fromCount(2, resources)); // host-4.yahoo.com, host-3.yahoo.com\n+\n+        orchestrator.suspend(new HostName(\"host-4.yahoo.com\"));\n+\n+        {\n+            httpClient.cannedResponse = cannedResponseForApplication1;\n+            List<NodeMetrics.MetricValue> values = new ArrayList<>(fetcher.fetchMetrics(application1));\n+            assertEquals(\"http://host-1.yahoo.com:4080/metrics/v2/values?consumer=vespa-consumer-metrics\",\n+                         httpClient.requestsReceived.get(0));\n+            assertEquals(5, values.size());\n+            assertEquals(\"metric value cpu.util: 16.2 at 1234 for host-1.yahoo.com\", values.get(0).toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1NDU4Mg==", "bodyText": "I think this is more readable. Afaik Float.toString() is locale-independent, which is one of the benefits of not using String.format in most cases ...", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384454582", "createdAt": "2020-02-26T12:14:25Z", "author": {"login": "bratseth"}, "path": "node-repository/src/test/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsFetcherTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.autoscale;\n+\n+import com.yahoo.config.provision.ApplicationId;\n+import com.yahoo.config.provision.Capacity;\n+import com.yahoo.config.provision.NodeResources;\n+import com.yahoo.vespa.hosted.provision.provisioning.ProvisioningTester;\n+import com.yahoo.vespa.hosted.provision.testutils.OrchestratorMock;\n+import com.yahoo.vespa.applicationmodel.HostName;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class NodeMetricsFetcherTest {\n+\n+    @Test\n+    public void testMetricsFetch() {\n+        NodeResources resources = new NodeResources(1, 10, 100, 1);\n+        ProvisioningTester tester = new ProvisioningTester.Builder().build();\n+        OrchestratorMock orchestrator = new OrchestratorMock();\n+        MockHttpClient httpClient = new MockHttpClient();\n+        NodeMetricsFetcher fetcher = new NodeMetricsFetcher(tester.nodeRepository(), orchestrator, httpClient);\n+\n+        tester.makeReadyNodes(4, resources); // Creates (in order) host-1.yahoo.com, host-2.yahoo.com, host-3.yahoo.com, host-4.yahoo.com\n+        tester.deployZoneApp();\n+\n+        ApplicationId application1 = tester.makeApplicationId();\n+        ApplicationId application2 = tester.makeApplicationId();\n+        tester.deploy(application1, Capacity.fromCount(2, resources)); // host-1.yahoo.com, host-2.yahoo.com\n+        tester.deploy(application2, Capacity.fromCount(2, resources)); // host-4.yahoo.com, host-3.yahoo.com\n+\n+        orchestrator.suspend(new HostName(\"host-4.yahoo.com\"));\n+\n+        {\n+            httpClient.cannedResponse = cannedResponseForApplication1;\n+            List<NodeMetrics.MetricValue> values = new ArrayList<>(fetcher.fetchMetrics(application1));\n+            assertEquals(\"http://host-1.yahoo.com:4080/metrics/v2/values?consumer=vespa-consumer-metrics\",\n+                         httpClient.requestsReceived.get(0));\n+            assertEquals(5, values.size());\n+            assertEquals(\"metric value cpu.util: 16.2 at 1234 for host-1.yahoo.com\", values.get(0).toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNTUwMw=="}, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODgxNzQxOnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsDb.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTo0MDoyOVrOFuWMfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjoyMDoxN1rOFupZ-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0MjQ2Mg==", "bodyText": "Consider using LinkedList/Deque for this", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384142462", "createdAt": "2020-02-25T21:40:29Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsDb.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.autoscale;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An in-memory time-series \"database\" of node metrics.\n+ * Thread model: One writer, many readers.\n+ *\n+ * @author bratseth\n+ */\n+public class NodeMetricsDb {\n+\n+    private static final Duration dbWindow = Duration.ofHours(24);\n+\n+    /** Measurements by key. Each list of measurements is sorted by increasing timestamp */\n+    private Map<MeasurementKey, List<Measurement>> db = new HashMap<>();\n+\n+    /** Lock all access for now since we modify lists inside a map */\n+    private final Object lock = new Object();\n+\n+    /** Add a measurement to this */\n+    public void add(Collection<NodeMetrics.MetricValue> metricValues) {\n+        synchronized (lock) {\n+            for (var value : metricValues) {\n+                List<Measurement> measurements = db.computeIfAbsent(new MeasurementKey(value.hostname(),\n+                                                                                       Resource.fromMetric(value.name())),\n+                                                                    (__) -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ1NzIxMQ==", "bodyText": "I want an array and then it's just a question of whether the additional API in Deque is useful. I don't think so right now, but maybe later ...", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384457211", "createdAt": "2020-02-26T12:20:17Z", "author": {"login": "bratseth"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsDb.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.autoscale;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An in-memory time-series \"database\" of node metrics.\n+ * Thread model: One writer, many readers.\n+ *\n+ * @author bratseth\n+ */\n+public class NodeMetricsDb {\n+\n+    private static final Duration dbWindow = Duration.ofHours(24);\n+\n+    /** Measurements by key. Each list of measurements is sorted by increasing timestamp */\n+    private Map<MeasurementKey, List<Measurement>> db = new HashMap<>();\n+\n+    /** Lock all access for now since we modify lists inside a map */\n+    private final Object lock = new Object();\n+\n+    /** Add a measurement to this */\n+    public void add(Collection<NodeMetrics.MetricValue> metricValues) {\n+        synchronized (lock) {\n+            for (var value : metricValues) {\n+                List<Measurement> measurements = db.computeIfAbsent(new MeasurementKey(value.hostname(),\n+                                                                                       Resource.fromMetric(value.name())),\n+                                                                    (__) -> new ArrayList<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0MjQ2Mg=="}, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3ODk4MTY4OnYy", "diffSide": "RIGHT", "path": "node-repository/src/test/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsDbTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMjozNjoxOFrOFuXzJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjozNjo0NFrOFup2lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODc0MQ==", "bodyText": "Why is this 32? It should be 30... I think you are missing brackets in\n\n  \n    \n      vespa/node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsDb.java\n    \n    \n         Line 86\n      in\n      a54b2bb\n    \n    \n    \n    \n\n        \n          \n           int measurementsInWindow = measurements.size() - largestIndexOutsideWindow(measurements) + 1; \n        \n    \n  \n\n\nThough I think the stream version is much easier to read:\nreturn (int) keys.stream()\n        .map(db::get)\n        .flatMap(measurements -> measurements == null ? Stream.empty() : measurements.stream())\n        .filter(measurement -> measurement.timestamp >= startTime)\n        .count();", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384168741", "createdAt": "2020-02-25T22:36:18Z", "author": {"login": "freva"}, "path": "node-repository/src/test/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsDbTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.autoscale;\n+\n+import com.yahoo.test.ManualClock;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class NodeMetricsDbTest {\n+\n+    @Test\n+    public void testNodeMetricsDb() {\n+        ManualClock clock = new ManualClock();\n+        NodeMetricsDb db = new NodeMetricsDb();\n+        List<NodeMetrics.MetricValue> values = new ArrayList<>();\n+        for (int i = 0; i < 40; i++) {\n+            values.add(new NodeMetrics.MetricValue(\"host0\", \"cpu.util\", clock.instant().toEpochMilli(), 0.9f));\n+            clock.advance(Duration.ofHours(1));\n+        }\n+        db.add(values);\n+\n+        assertEquals(32, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.cpu,    List.of(\"host0\")).measurementCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ2NDUzMg==", "bodyText": "You are right about the brackets, thanks!\nStream version: or even just\n                return (int) keys.stream()\n                                 .flatMap(key -> db.getOrDefault(key, List.of()).stream())\n                                 .filter(measurement -> measurement.timestamp >= startTime)\n                                 .count();\n\nI guess this is way more expensive though, but you are right it's too early to worry about it.", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384464532", "createdAt": "2020-02-26T12:36:44Z", "author": {"login": "bratseth"}, "path": "node-repository/src/test/java/com/yahoo/vespa/hosted/provision/autoscale/NodeMetricsDbTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.autoscale;\n+\n+import com.yahoo.test.ManualClock;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class NodeMetricsDbTest {\n+\n+    @Test\n+    public void testNodeMetricsDb() {\n+        ManualClock clock = new ManualClock();\n+        NodeMetricsDb db = new NodeMetricsDb();\n+        List<NodeMetrics.MetricValue> values = new ArrayList<>();\n+        for (int i = 0; i < 40; i++) {\n+            values.add(new NodeMetrics.MetricValue(\"host0\", \"cpu.util\", clock.instant().toEpochMilli(), 0.9f));\n+            clock.advance(Duration.ofHours(1));\n+        }\n+        db.add(values);\n+\n+        assertEquals(32, db.getWindow(clock.instant().minus(Duration.ofHours(30)), Resource.cpu,    List.of(\"host0\")).measurementCount());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2ODc0MQ=="}, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MDM2MjI0OnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/Autoscaler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwOTo1MTo0NlrOFuk1ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjozOTozNlrOFup7rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM4MjM5NA==", "bodyText": "AWS flavors with remote disk are configured with 16 TB disk (EBS max), so this will basically never match. You need to find a host flavor that has same vcpu, memory, storage type and disk speed, then copy disk size from cluster resources. For reference, host provisioner will throw if no AWS flavor satisfies this:\nprivate boolean satisfies(Flavor flavor, NodeResources requestedResources) {\n    NodeResources hostResources = hostResourcesCalculator.availableCapacityOf(flavor.name(), flavor.resources());\n    if (hostResources.storageType() == NodeResources.StorageType.remote) // Then any disk size will work\n        hostResources = hostResources.withDiskGb(requestedResources.diskGb());\n\n    return hostResources.withBandwidthGbps(requestedResources.bandwidthGbps())\n            .compatibleWith(requestedResources);\n}", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384382394", "createdAt": "2020-02-26T09:51:46Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/Autoscaler.java", "diffHunk": "@@ -0,0 +1,187 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.autoscale;\n+\n+import com.yahoo.config.provision.ApplicationId;\n+import com.yahoo.config.provision.CloudName;\n+import com.yahoo.config.provision.ClusterSpec;\n+import com.yahoo.config.provision.Flavor;\n+import com.yahoo.config.provision.NodeResources;\n+import com.yahoo.vespa.hosted.provision.Node;\n+import com.yahoo.vespa.hosted.provision.NodeRepository;\n+import com.yahoo.vespa.hosted.provision.provisioning.HostResourcesCalculator;\n+import com.yahoo.vespa.hosted.provision.provisioning.NodeResourceLimits;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The autoscaler makes decisions about the flavor and node count that should be allocated to a cluster\n+ * based on observed behavior.\n+ *\n+ * @author bratseth\n+ */\n+public class Autoscaler {\n+\n+    /*\n+     TODO:\n+     - X Implement node metrics fetch\n+     - X Avoid making decisions for the same app at multiple config servers\n+     - Scale group size\n+     - Have a better idea about whether we have sufficient information to make decisions\n+     - Consider taking spikes/variance into account\n+     - Measure observed regulation lag (startup+redistribution) into account when deciding regulation observation window\n+     - Test AutoscalingMaintainer\n+     - Scale by performance not just load+cost\n+     */\n+\n+    private static final int minimumMeasurements = 500; // TODO: Per node instead? Also say something about interval?\n+\n+    /** What cost difference factor warrants reallocation? */\n+    private static final double costDifferenceRatioWorthReallocation = 0.1;\n+    /** What difference factor from ideal (for any resource) warrants a change? */\n+    private static final double idealDivergenceWorthReallocation = 0.1;\n+\n+    // We only depend on the ratios between these values\n+    private static final double cpuUnitCost = 12.0;\n+    private static final double memoryUnitCost = 1.2;\n+    private static final double diskUnitCost = 0.045;\n+\n+    private final HostResourcesCalculator hostResourcesCalculator;\n+    private final NodeMetricsDb metricsDb;\n+    private final NodeRepository nodeRepository;\n+    private final NodeResourceLimits nodeResourceLimits;\n+\n+    public Autoscaler(HostResourcesCalculator hostResourcesCalculator,\n+                      NodeMetricsDb metricsDb,\n+                      NodeRepository nodeRepository) {\n+        this.hostResourcesCalculator = hostResourcesCalculator;\n+        this.metricsDb = metricsDb;\n+        this.nodeRepository = nodeRepository;\n+        this.nodeResourceLimits = new NodeResourceLimits(nodeRepository.zone());\n+    }\n+\n+    public Optional<ClusterResources> autoscale(ApplicationId applicationId, ClusterSpec cluster, List<Node> clusterNodes) {\n+        if (clusterNodes.stream().anyMatch(node -> node.status().wantToRetire() ||\n+                                                   node.allocation().get().membership().retired() ||\n+                                                   node.allocation().get().isRemovable()))\n+            return Optional.empty(); // Don't autoscale clusters that are in flux\n+        ClusterResources currentAllocation = new ClusterResources(clusterNodes);\n+        Optional<Double> cpuLoad    = averageLoad(Resource.cpu, cluster, clusterNodes);\n+        Optional<Double> memoryLoad = averageLoad(Resource.memory, cluster, clusterNodes);\n+        Optional<Double> diskLoad   = averageLoad(Resource.disk, cluster, clusterNodes);\n+        if (cpuLoad.isEmpty() || memoryLoad.isEmpty() || diskLoad.isEmpty()) return Optional.empty();\n+\n+        Optional<ClusterResourcesWithCost> bestAllocation = findBestAllocation(cpuLoad.get(),\n+                                                                               memoryLoad.get(),\n+                                                                               diskLoad.get(),\n+                                                                               currentAllocation,\n+                                                                               cluster);\n+        if (bestAllocation.isEmpty()) return Optional.empty();\n+\n+        if (closeToIdeal(Resource.cpu, cpuLoad.get()) &&\n+            closeToIdeal(Resource.memory, memoryLoad.get()) &&\n+            closeToIdeal(Resource.disk, diskLoad.get()) &&\n+            similarCost(bestAllocation.get().cost(), currentAllocation.nodes() * costOf(currentAllocation.nodeResources())))\n+            return Optional.empty(); // Avoid small, unnecessary changes\n+        return bestAllocation.map(a -> a.clusterResources());\n+    }\n+\n+    private Optional<ClusterResourcesWithCost> findBestAllocation(double cpuLoad, double memoryLoad, double diskLoad,\n+                                                                  ClusterResources currentAllocation, ClusterSpec cluster) {\n+        Optional<ClusterResourcesWithCost> bestAllocation = Optional.empty();\n+        for (ResourceIterator i = new ResourceIterator(cpuLoad, memoryLoad, diskLoad, currentAllocation); i.hasNext(); ) {\n+            ClusterResources allocation = i.next();\n+            Optional<ClusterResourcesWithCost> allocatableResources = toAllocatableResources(allocation, cluster);\n+            if (allocatableResources.isEmpty()) continue;\n+            if (bestAllocation.isEmpty() || allocatableResources.get().cost() < bestAllocation.get().cost())\n+                bestAllocation = allocatableResources;\n+        }\n+        return bestAllocation;\n+    }\n+\n+    private boolean similarCost(double cost1, double cost2) {\n+        return similar(cost1, cost2, costDifferenceRatioWorthReallocation);\n+    }\n+\n+    private boolean closeToIdeal(Resource resource, double value) {\n+        return similar(resource.idealAverageLoad(), value, idealDivergenceWorthReallocation);\n+    }\n+\n+    private boolean similar(double r1, double r2, double threshold) {\n+        return Math.abs(r1 - r2) / r1 < threshold;\n+    }\n+\n+    /**\n+     * Returns the smallest allocatable node resources larger than the given node resources,\n+     * or empty if none available.\n+     */\n+    private Optional<ClusterResourcesWithCost> toAllocatableResources(ClusterResources resources, ClusterSpec cluster) {\n+        if (allowsHostSharing(nodeRepository.zone().cloud())) {\n+            // Return the requested resources, adjusted to be legal or empty if they cannot fit on existing hosts\n+            NodeResources nodeResources = nodeResourceLimits.enlargeToLegal(resources.nodeResources(), cluster.type());\n+            for (Flavor flavor : nodeRepository.getAvailableFlavors().getFlavors())\n+                if (flavor.resources().satisfies(nodeResources))\n+                    return Optional.of(new ClusterResourcesWithCost(resources.with(nodeResources),\n+                                                                    costOf(nodeResources) * resources.nodes()));\n+            return Optional.empty();\n+        }\n+        else {\n+            // return the cheapest flavor satisfying the target resources, if any\n+            double bestCost = Double.MAX_VALUE;\n+            Optional<Flavor> bestFlavor = Optional.empty();\n+            for (Flavor flavor : nodeRepository.getAvailableFlavors().getFlavors()) {\n+                if ( ! flavor.resources().satisfies(resources.nodeResources())) continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ2NTgzOQ==", "bodyText": "Thanks! I'll do this in another PR ...", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384465839", "createdAt": "2020-02-26T12:39:36Z", "author": {"login": "bratseth"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/Autoscaler.java", "diffHunk": "@@ -0,0 +1,187 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.autoscale;\n+\n+import com.yahoo.config.provision.ApplicationId;\n+import com.yahoo.config.provision.CloudName;\n+import com.yahoo.config.provision.ClusterSpec;\n+import com.yahoo.config.provision.Flavor;\n+import com.yahoo.config.provision.NodeResources;\n+import com.yahoo.vespa.hosted.provision.Node;\n+import com.yahoo.vespa.hosted.provision.NodeRepository;\n+import com.yahoo.vespa.hosted.provision.provisioning.HostResourcesCalculator;\n+import com.yahoo.vespa.hosted.provision.provisioning.NodeResourceLimits;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The autoscaler makes decisions about the flavor and node count that should be allocated to a cluster\n+ * based on observed behavior.\n+ *\n+ * @author bratseth\n+ */\n+public class Autoscaler {\n+\n+    /*\n+     TODO:\n+     - X Implement node metrics fetch\n+     - X Avoid making decisions for the same app at multiple config servers\n+     - Scale group size\n+     - Have a better idea about whether we have sufficient information to make decisions\n+     - Consider taking spikes/variance into account\n+     - Measure observed regulation lag (startup+redistribution) into account when deciding regulation observation window\n+     - Test AutoscalingMaintainer\n+     - Scale by performance not just load+cost\n+     */\n+\n+    private static final int minimumMeasurements = 500; // TODO: Per node instead? Also say something about interval?\n+\n+    /** What cost difference factor warrants reallocation? */\n+    private static final double costDifferenceRatioWorthReallocation = 0.1;\n+    /** What difference factor from ideal (for any resource) warrants a change? */\n+    private static final double idealDivergenceWorthReallocation = 0.1;\n+\n+    // We only depend on the ratios between these values\n+    private static final double cpuUnitCost = 12.0;\n+    private static final double memoryUnitCost = 1.2;\n+    private static final double diskUnitCost = 0.045;\n+\n+    private final HostResourcesCalculator hostResourcesCalculator;\n+    private final NodeMetricsDb metricsDb;\n+    private final NodeRepository nodeRepository;\n+    private final NodeResourceLimits nodeResourceLimits;\n+\n+    public Autoscaler(HostResourcesCalculator hostResourcesCalculator,\n+                      NodeMetricsDb metricsDb,\n+                      NodeRepository nodeRepository) {\n+        this.hostResourcesCalculator = hostResourcesCalculator;\n+        this.metricsDb = metricsDb;\n+        this.nodeRepository = nodeRepository;\n+        this.nodeResourceLimits = new NodeResourceLimits(nodeRepository.zone());\n+    }\n+\n+    public Optional<ClusterResources> autoscale(ApplicationId applicationId, ClusterSpec cluster, List<Node> clusterNodes) {\n+        if (clusterNodes.stream().anyMatch(node -> node.status().wantToRetire() ||\n+                                                   node.allocation().get().membership().retired() ||\n+                                                   node.allocation().get().isRemovable()))\n+            return Optional.empty(); // Don't autoscale clusters that are in flux\n+        ClusterResources currentAllocation = new ClusterResources(clusterNodes);\n+        Optional<Double> cpuLoad    = averageLoad(Resource.cpu, cluster, clusterNodes);\n+        Optional<Double> memoryLoad = averageLoad(Resource.memory, cluster, clusterNodes);\n+        Optional<Double> diskLoad   = averageLoad(Resource.disk, cluster, clusterNodes);\n+        if (cpuLoad.isEmpty() || memoryLoad.isEmpty() || diskLoad.isEmpty()) return Optional.empty();\n+\n+        Optional<ClusterResourcesWithCost> bestAllocation = findBestAllocation(cpuLoad.get(),\n+                                                                               memoryLoad.get(),\n+                                                                               diskLoad.get(),\n+                                                                               currentAllocation,\n+                                                                               cluster);\n+        if (bestAllocation.isEmpty()) return Optional.empty();\n+\n+        if (closeToIdeal(Resource.cpu, cpuLoad.get()) &&\n+            closeToIdeal(Resource.memory, memoryLoad.get()) &&\n+            closeToIdeal(Resource.disk, diskLoad.get()) &&\n+            similarCost(bestAllocation.get().cost(), currentAllocation.nodes() * costOf(currentAllocation.nodeResources())))\n+            return Optional.empty(); // Avoid small, unnecessary changes\n+        return bestAllocation.map(a -> a.clusterResources());\n+    }\n+\n+    private Optional<ClusterResourcesWithCost> findBestAllocation(double cpuLoad, double memoryLoad, double diskLoad,\n+                                                                  ClusterResources currentAllocation, ClusterSpec cluster) {\n+        Optional<ClusterResourcesWithCost> bestAllocation = Optional.empty();\n+        for (ResourceIterator i = new ResourceIterator(cpuLoad, memoryLoad, diskLoad, currentAllocation); i.hasNext(); ) {\n+            ClusterResources allocation = i.next();\n+            Optional<ClusterResourcesWithCost> allocatableResources = toAllocatableResources(allocation, cluster);\n+            if (allocatableResources.isEmpty()) continue;\n+            if (bestAllocation.isEmpty() || allocatableResources.get().cost() < bestAllocation.get().cost())\n+                bestAllocation = allocatableResources;\n+        }\n+        return bestAllocation;\n+    }\n+\n+    private boolean similarCost(double cost1, double cost2) {\n+        return similar(cost1, cost2, costDifferenceRatioWorthReallocation);\n+    }\n+\n+    private boolean closeToIdeal(Resource resource, double value) {\n+        return similar(resource.idealAverageLoad(), value, idealDivergenceWorthReallocation);\n+    }\n+\n+    private boolean similar(double r1, double r2, double threshold) {\n+        return Math.abs(r1 - r2) / r1 < threshold;\n+    }\n+\n+    /**\n+     * Returns the smallest allocatable node resources larger than the given node resources,\n+     * or empty if none available.\n+     */\n+    private Optional<ClusterResourcesWithCost> toAllocatableResources(ClusterResources resources, ClusterSpec cluster) {\n+        if (allowsHostSharing(nodeRepository.zone().cloud())) {\n+            // Return the requested resources, adjusted to be legal or empty if they cannot fit on existing hosts\n+            NodeResources nodeResources = nodeResourceLimits.enlargeToLegal(resources.nodeResources(), cluster.type());\n+            for (Flavor flavor : nodeRepository.getAvailableFlavors().getFlavors())\n+                if (flavor.resources().satisfies(nodeResources))\n+                    return Optional.of(new ClusterResourcesWithCost(resources.with(nodeResources),\n+                                                                    costOf(nodeResources) * resources.nodes()));\n+            return Optional.empty();\n+        }\n+        else {\n+            // return the cheapest flavor satisfying the target resources, if any\n+            double bestCost = Double.MAX_VALUE;\n+            Optional<Flavor> bestFlavor = Optional.empty();\n+            for (Flavor flavor : nodeRepository.getAvailableFlavors().getFlavors()) {\n+                if ( ! flavor.resources().satisfies(resources.nodeResources())) continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM4MjM5NA=="}, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MDc4OTEyOnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/ResourceIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjowMTowN1rOFuo52g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMjowMTowN1rOFuo52g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ0ODk4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // and we decide tyhe number of groups.\n          \n          \n            \n                    // and we decide the number of groups.", "url": "https://github.com/vespa-engine/vespa/pull/11875#discussion_r384448986", "createdAt": "2020-02-26T12:01:07Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/autoscale/ResourceIterator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.autoscale;\n+\n+import com.yahoo.config.provision.NodeResources;\n+\n+/**\n+ * Provides iteration over possible cluster resource allocations given a target total load\n+ * and current groups/nodes allocation.\n+ */\n+public class ResourceIterator {\n+\n+    // Configured min and max nodes TODO: These should come from the application package\n+    private static final int minimumNodesPerCluster = 3; // Since this is with redundancy it cannot be lower than 2\n+    private static final int maximumNodesPerCluster = 150;\n+\n+    // When a query is issued on a node the cost is the sum of a fixed cost component and a cost component\n+    // proportional to document count. We must account for this when comparing configurations with more or fewer nodes.\n+    // TODO: Measure this, and only take it into account with queries\n+    private static final double fixedCpuCostFraction = 0.1;\n+\n+    // Describes the observed state\n+    private final ClusterResources allocation;\n+    private final double cpuLoad;\n+    private final double memoryLoad;\n+    private final double diskLoad;\n+    private final int groupSize;\n+\n+    // Derived from the observed state\n+    private final int nodeIncrement;\n+    private final boolean singleGroupMode;\n+\n+    // Iterator state\n+    private int currentNodes;\n+\n+    public ResourceIterator(double cpuLoad, double memoryLoad, double diskLoad, ClusterResources currentAllocation) {\n+        this.cpuLoad = cpuLoad;\n+        this.memoryLoad = memoryLoad;\n+        this.diskLoad = diskLoad;\n+\n+        // ceil: If the division does not produce a whole number we assume some node is missing\n+        groupSize = (int)Math.ceil((double)currentAllocation.nodes() / currentAllocation.groups());\n+        allocation = currentAllocation;\n+\n+        // What number of nodes is it effective to add or remove at the time from this cluster?\n+        // This is the group size, since we (for now) assume the group size is decided by someone wiser than us\n+        // and we decide tyhe number of groups.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a54b2bbceb9604023259e404472ec08fa9ca885e"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2605, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}