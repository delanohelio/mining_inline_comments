{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxNTY0MTIx", "number": 14818, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoyNjoxNFrOEtET5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwODozMjowMlrOEu5c3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NjkyMDA0OnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/node/Agent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoyNjoxNFrOHgpjiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNDoyNjoxNFrOHgpjiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk5NzMyMA==", "bodyText": "Also add to https://github.com/vespa-engine/vespa/blob/master/controller-api/src/main/java/com/yahoo/vespa/hosted/controller/api/integration/noderepository/NodeHistory.java", "url": "https://github.com/vespa-engine/vespa/pull/14818#discussion_r503997320", "createdAt": "2020-10-13T14:26:14Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/node/Agent.java", "diffHunk": "@@ -22,6 +22,7 @@\n     ReservationExpirer,\n     DynamicProvisioningMaintainer,\n     RetiringUpgrader,\n-    SpareCapacityMaintainer\n+    SpareCapacityMaintainer,\n+    SwitchRebalancer,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b63536dd563a3a69b29b5bd875c3a5d325cb1c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NzEwNTY3OnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNTowMzo1OVrOHgrY4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwNzo0ODo0OVrOHhGctA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNzM2Mg==", "bodyText": "When we will try to add new nodes in addNewDockerNodesOn(), wont this lead to us only considering the node on the first host that we read from ZK (or whatever order the hosts in allNodes are)?", "url": "https://github.com/vespa-engine/vespa/pull/14818#discussion_r504027362", "createdAt": "2020-10-13T15:03:59Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "diffHunk": "@@ -168,14 +171,38 @@ private NodeCandidate candidateFrom(Node node, boolean isSurplus) {\n                                                                          currentClusterSize));\n         }\n         else {\n-            return NodeCandidate.createStandalone(node, isSurplus, false);\n+            return NodeCandidate.createStandalone(node, isSurplus, false, exclusiveSwitch);\n         }\n     }\n \n-    private boolean isReplacement(int nofNodesInCluster, int nodeFailedNodes) {\n-        if (nodeFailedNodes == 0) return false;\n+    /** Returns whether given node is on an exclusive switch */\n+    private boolean onExclusiveSwitch(Node node, Optional<Node> parent) {\n+        Node host = parent.orElse(node);\n+        return unusedSwitch(host, node.allocation()\n+                                      .map(allocation -> allocation.membership().cluster().id())\n+                                      .orElseGet(clusterSpec::id));\n+    }\n+\n+    /** Returns whether switch of host is unused by any existing candidates for given cluster */\n+    private boolean unusedSwitch(Node host, ClusterSpec.Id cluster) {\n+        if (host.switchHostname().isEmpty()) return true;\n+        String switchHostname = host.switchHostname().get();\n+        for (var candidate : nodes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59b63536dd563a3a69b29b5bd875c3a5d325cb1c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI1Njg2OQ==", "bodyText": "How? Each node added is checked against all the (parents of) candidates already added.", "url": "https://github.com/vespa-engine/vespa/pull/14818#discussion_r504256869", "createdAt": "2020-10-13T21:03:08Z", "author": {"login": "mpolden"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "diffHunk": "@@ -168,14 +171,38 @@ private NodeCandidate candidateFrom(Node node, boolean isSurplus) {\n                                                                          currentClusterSize));\n         }\n         else {\n-            return NodeCandidate.createStandalone(node, isSurplus, false);\n+            return NodeCandidate.createStandalone(node, isSurplus, false, exclusiveSwitch);\n         }\n     }\n \n-    private boolean isReplacement(int nofNodesInCluster, int nodeFailedNodes) {\n-        if (nodeFailedNodes == 0) return false;\n+    /** Returns whether given node is on an exclusive switch */\n+    private boolean onExclusiveSwitch(Node node, Optional<Node> parent) {\n+        Node host = parent.orElse(node);\n+        return unusedSwitch(host, node.allocation()\n+                                      .map(allocation -> allocation.membership().cluster().id())\n+                                      .orElseGet(clusterSpec::id));\n+    }\n+\n+    /** Returns whether switch of host is unused by any existing candidates for given cluster */\n+    private boolean unusedSwitch(Node host, ClusterSpec.Id cluster) {\n+        if (host.switchHostname().isEmpty()) return true;\n+        String switchHostname = host.switchHostname().get();\n+        for (var candidate : nodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNzM2Mg=="}, "originalCommit": {"oid": "59b63536dd563a3a69b29b5bd875c3a5d325cb1c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MjQxMw==", "bodyText": "Lets say we need to allocate 1 node, we have 2 hosts: a and b. b has massive skew, so allocation to a should be preferred. Both a and b are on the same switch, s.\nSince we need to allocate 1 node, we start by creating a virtual reserved node on both a and b: a1 and b1, as we create them, we check if nodes already has a node on s (initially, that is not the case). After we add the first of a1 and b1, the second one will be deemed as not on exclusive switch, so skew is completely ignored.", "url": "https://github.com/vespa-engine/vespa/pull/14818#discussion_r504452413", "createdAt": "2020-10-14T07:15:22Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "diffHunk": "@@ -168,14 +171,38 @@ private NodeCandidate candidateFrom(Node node, boolean isSurplus) {\n                                                                          currentClusterSize));\n         }\n         else {\n-            return NodeCandidate.createStandalone(node, isSurplus, false);\n+            return NodeCandidate.createStandalone(node, isSurplus, false, exclusiveSwitch);\n         }\n     }\n \n-    private boolean isReplacement(int nofNodesInCluster, int nodeFailedNodes) {\n-        if (nodeFailedNodes == 0) return false;\n+    /** Returns whether given node is on an exclusive switch */\n+    private boolean onExclusiveSwitch(Node node, Optional<Node> parent) {\n+        Node host = parent.orElse(node);\n+        return unusedSwitch(host, node.allocation()\n+                                      .map(allocation -> allocation.membership().cluster().id())\n+                                      .orElseGet(clusterSpec::id));\n+    }\n+\n+    /** Returns whether switch of host is unused by any existing candidates for given cluster */\n+    private boolean unusedSwitch(Node host, ClusterSpec.Id cluster) {\n+        if (host.switchHostname().isEmpty()) return true;\n+        String switchHostname = host.switchHostname().get();\n+        for (var candidate : nodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNzM2Mg=="}, "originalCommit": {"oid": "59b63536dd563a3a69b29b5bd875c3a5d325cb1c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1OTk1Mw==", "bodyText": "So given two hosts on the same switch, you want to prefer the candidate on the host with the least skew?", "url": "https://github.com/vespa-engine/vespa/pull/14818#discussion_r504459953", "createdAt": "2020-10-14T07:29:37Z", "author": {"login": "mpolden"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "diffHunk": "@@ -168,14 +171,38 @@ private NodeCandidate candidateFrom(Node node, boolean isSurplus) {\n                                                                          currentClusterSize));\n         }\n         else {\n-            return NodeCandidate.createStandalone(node, isSurplus, false);\n+            return NodeCandidate.createStandalone(node, isSurplus, false, exclusiveSwitch);\n         }\n     }\n \n-    private boolean isReplacement(int nofNodesInCluster, int nodeFailedNodes) {\n-        if (nodeFailedNodes == 0) return false;\n+    /** Returns whether given node is on an exclusive switch */\n+    private boolean onExclusiveSwitch(Node node, Optional<Node> parent) {\n+        Node host = parent.orElse(node);\n+        return unusedSwitch(host, node.allocation()\n+                                      .map(allocation -> allocation.membership().cluster().id())\n+                                      .orElseGet(clusterSpec::id));\n+    }\n+\n+    /** Returns whether switch of host is unused by any existing candidates for given cluster */\n+    private boolean unusedSwitch(Node host, ClusterSpec.Id cluster) {\n+        if (host.switchHostname().isEmpty()) return true;\n+        String switchHostname = host.switchHostname().get();\n+        for (var candidate : nodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNzM2Mg=="}, "originalCommit": {"oid": "59b63536dd563a3a69b29b5bd875c3a5d325cb1c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ2MjIzOA==", "bodyText": "The point is that while a1 and b1 are on the same switch, only 1 of them will be actually allocated anyway, so they cant be in conflict with each other", "url": "https://github.com/vespa-engine/vespa/pull/14818#discussion_r504462238", "createdAt": "2020-10-14T07:33:49Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "diffHunk": "@@ -168,14 +171,38 @@ private NodeCandidate candidateFrom(Node node, boolean isSurplus) {\n                                                                          currentClusterSize));\n         }\n         else {\n-            return NodeCandidate.createStandalone(node, isSurplus, false);\n+            return NodeCandidate.createStandalone(node, isSurplus, false, exclusiveSwitch);\n         }\n     }\n \n-    private boolean isReplacement(int nofNodesInCluster, int nodeFailedNodes) {\n-        if (nodeFailedNodes == 0) return false;\n+    /** Returns whether given node is on an exclusive switch */\n+    private boolean onExclusiveSwitch(Node node, Optional<Node> parent) {\n+        Node host = parent.orElse(node);\n+        return unusedSwitch(host, node.allocation()\n+                                      .map(allocation -> allocation.membership().cluster().id())\n+                                      .orElseGet(clusterSpec::id));\n+    }\n+\n+    /** Returns whether switch of host is unused by any existing candidates for given cluster */\n+    private boolean unusedSwitch(Node host, ClusterSpec.Id cluster) {\n+        if (host.switchHostname().isEmpty()) return true;\n+        String switchHostname = host.switchHostname().get();\n+        for (var candidate : nodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNzM2Mg=="}, "originalCommit": {"oid": "59b63536dd563a3a69b29b5bd875c3a5d325cb1c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ3MDcwOA==", "bodyText": "only 1 of them will be actually allocated anyway\n\nThe exclusive switch isn't a hard requirement though. If you ask for 2 nodes, you will allocate both a1 and b1 if no better candidate on an exclusive switch exists.", "url": "https://github.com/vespa-engine/vespa/pull/14818#discussion_r504470708", "createdAt": "2020-10-14T07:48:49Z", "author": {"login": "mpolden"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "diffHunk": "@@ -168,14 +171,38 @@ private NodeCandidate candidateFrom(Node node, boolean isSurplus) {\n                                                                          currentClusterSize));\n         }\n         else {\n-            return NodeCandidate.createStandalone(node, isSurplus, false);\n+            return NodeCandidate.createStandalone(node, isSurplus, false, exclusiveSwitch);\n         }\n     }\n \n-    private boolean isReplacement(int nofNodesInCluster, int nodeFailedNodes) {\n-        if (nodeFailedNodes == 0) return false;\n+    /** Returns whether given node is on an exclusive switch */\n+    private boolean onExclusiveSwitch(Node node, Optional<Node> parent) {\n+        Node host = parent.orElse(node);\n+        return unusedSwitch(host, node.allocation()\n+                                      .map(allocation -> allocation.membership().cluster().id())\n+                                      .orElseGet(clusterSpec::id));\n+    }\n+\n+    /** Returns whether switch of host is unused by any existing candidates for given cluster */\n+    private boolean unusedSwitch(Node host, ClusterSpec.Id cluster) {\n+        if (host.switchHostname().isEmpty()) return true;\n+        String switchHostname = host.switchHostname().get();\n+        for (var candidate : nodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDAyNzM2Mg=="}, "originalCommit": {"oid": "59b63536dd563a3a69b29b5bd875c3a5d325cb1c"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NjExMjMxOnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQwODozMjowMlrOHjjb0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNjo1Nzo0M1rOHkALDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA0Mjc2OQ==", "bodyText": "All the nodes should be on the same cluster, but they aren't because we add all application nodes (addApplicationNodes()) instead of just adding cluster nodes. I think we should fix addApplicationNodes() to just add cluster nodes (they are immediately just dropped in NodeAllocation::offer anyway) and then we wont need this class, just group by switchHostname.", "url": "https://github.com/vespa-engine/vespa/pull/14818#discussion_r507042769", "createdAt": "2020-10-18T08:32:02Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "diffHunk": "@@ -191,9 +222,38 @@ private boolean canStillAllocateToParentOf(Node node) {\n         return nodeRepository.canAllocateTenantNodeTo(parent.get());\n     }\n \n-    private static NodeResources resources(NodeSpec requestedNodes) {\n-        if ( ! (requestedNodes instanceof NodeSpec.CountNodeSpec)) return null;\n-        return requestedNodes.resources().get();\n+    /** A cluster and its network switch */\n+    private static class ClusterSwitch {\n+\n+        private static final ClusterSwitch unknown = new ClusterSwitch(null, null);\n+\n+        private final ClusterSpec.Id cluster;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53cd32ca6bff33a336e84d279c4961fd1f19f9c"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUxMzYxNQ==", "bodyText": "I'll look into it. \ud83d\udc4d", "url": "https://github.com/vespa-engine/vespa/pull/14818#discussion_r507513615", "createdAt": "2020-10-19T06:57:43Z", "author": {"login": "mpolden"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/NodePrioritizer.java", "diffHunk": "@@ -191,9 +222,38 @@ private boolean canStillAllocateToParentOf(Node node) {\n         return nodeRepository.canAllocateTenantNodeTo(parent.get());\n     }\n \n-    private static NodeResources resources(NodeSpec requestedNodes) {\n-        if ( ! (requestedNodes instanceof NodeSpec.CountNodeSpec)) return null;\n-        return requestedNodes.resources().get();\n+    /** A cluster and its network switch */\n+    private static class ClusterSwitch {\n+\n+        private static final ClusterSwitch unknown = new ClusterSwitch(null, null);\n+\n+        private final ClusterSpec.Id cluster;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzA0Mjc2OQ=="}, "originalCommit": {"oid": "f53cd32ca6bff33a336e84d279c4961fd1f19f9c"}, "originalPosition": 232}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1128, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}