{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNjk3ODYx", "number": 13572, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzo1NzoyNlrOEFjEmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzowNDowOFrOEGVxXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MjUyOTU0OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/hnsw_graph.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzo1NzoyNlrOGjzXMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzo1NzoyNlrOGjzXMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5NDg2Nw==", "bodyText": "Indentation seems off.", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r440194867", "createdAt": "2020-06-15T13:57:26Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/hnsw_graph.h", "diffHunk": "@@ -102,15 +112,43 @@ struct HnswGraph {\n         uint64_t value = node.level;\n         value <<= 32;\n         value |= node.docid;\n+        if (node.node_ref.valid()) {\n+            assert(node.level >= 0);\n+            assert(node.docid > 0);\n+        } else {\n+            assert(node.level == -1);\n+            assert(node.docid == 0);\n+        }\n         entry_docid_and_level.store(value, std::memory_order_release);\n     }\n \n+    uint64_t get_entry_atomic() const {\n+        return entry_docid_and_level.load(std::memory_order_acquire);\n+    }\n+\n     EntryNode get_entry_node() const {\n         EntryNode entry;\n-        uint64_t value = entry_docid_and_level.load(std::memory_order_acquire);\n-        entry.docid = (uint32_t)value;\n-        entry.level = (int32_t)(value >> 32);\n-        return entry;\n+        while (true) {\n+\t    uint64_t value = get_entry_atomic();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d42fba42c3a8e58e87d3b03ad0124169c7b96e51"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDY2MjU3OnYy", "diffSide": "RIGHT", "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNjo0OVrOGlDAuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNjo0OVrOGlDAuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5OTgzMg==", "bodyText": "Please update copyright.", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441499832", "createdAt": "2020-06-17T12:16:49Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright 2020 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e01810c179b2593d7eae286fca7664eb6065d0fe"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDgxODE0OnYy", "diffSide": "RIGHT", "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo1OToyOVrOGlEi1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo1OToyOVrOGlEi1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyNDk1MQ==", "bodyText": "The order of the tasks posted to write_thread is not critical in this test, but we could consider doing it similar to the upcoming functionality in AttributeWriter where we post to both multi_prepare_workers and write_thread with a future binding the two together: 8c0fa90#diff-fe6cb86f93de54a95217644d498483cbR611", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441524951", "createdAt": "2020-06-17T12:59:29Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright 2020 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/tensor/dense/typed_cells.h>\n+#include <vespa/searchlib/common/bitvector.h>\n+#include <vespa/searchlib/tensor/distance_functions.h>\n+#include <vespa/searchlib/tensor/doc_vector_access.h>\n+#include <vespa/searchlib/tensor/hnsw_index.h>\n+#include <vespa/searchlib/tensor/random_level_generator.h>\n+#include <vespa/searchlib/tensor/inv_log_level_generator.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <vespa/vespalib/util/generationhandler.h>\n+#include <vespa/vespalib/data/slime/slime.h>\n+#include <vespa/vespalib/util/threadstackexecutor.h>\n+#include <vespa/vespalib/util/blockingthreadstackexecutor.h>\n+#include <vespa/vespalib/util/gate.h>\n+#include <vespa/vespalib/util/lambdatask.h>\n+\n+#include <vector>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+#include <cstdlib>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\"stress_hnsw_mt\");\n+\n+using vespalib::GenerationHandler;\n+using vespalib::MemoryUsage;\n+using namespace search::tensor;\n+using namespace vespalib::slime;\n+using vespalib::Slime;\n+using search::BitVector;\n+\n+#define NUM_DIMS 128\n+#define NUM_POSSIBLE_V 100000\n+#define NUM_POSSIBLE_DOCS 10000\n+#define NUM_OPS 50000\n+\n+class RndGen {\n+private:\n+    std::mt19937_64 urng;\n+    std::uniform_real_distribution<double> uf;\n+public:\n+    RndGen() : urng(0x1234deadbeef5678uLL), uf(0.0, 1.0) {}\n+\n+    double nextUniform() {\n+        return uf(urng);\n+    }\n+};\n+\n+using ConstVectorRef = vespalib::ConstArrayRef<float>;\n+\n+struct MallocPointVector {\n+    float v[NUM_DIMS];\n+    operator ConstVectorRef() const { return ConstVectorRef(v, NUM_DIMS); }\n+};\n+static MallocPointVector *aligned_alloc_pv(size_t num) {\n+    size_t num_bytes = num * sizeof(MallocPointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return reinterpret_cast<MallocPointVector *>(mem);\n+}\n+\n+void read_vector_file(MallocPointVector *p) {\n+    std::string data_set = \"sift\";\n+    std::string data_dir = \".\";\n+    char *home = getenv(\"HOME\");\n+    if (home) {\n+        data_dir = home;\n+        data_dir += \"/\" + data_set;\n+    }\n+    std::string fn = data_dir + \"/\" + data_set + \"_base.fvecs\";\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    if (fd < 0) {\n+        perror(fn.c_str());\n+        exit(1);\n+    }\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u vectors from %s\\n\", NUM_POSSIBLE_V, fn.c_str());\n+    for (uint32_t i = 0; i < NUM_POSSIBLE_V; ++i) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQ(rv, 4u);\n+        ASSERT_EQ(d, NUM_DIMS);\n+        rv = read(fd, &p[i].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQ(rv, sizeof(MallocPointVector));\n+    }\n+    close(fd);\n+    fprintf(stderr, \"reading %u vectors OK\\n\", NUM_POSSIBLE_V);\n+}\n+\n+class MyDocVectorStore : public DocVectorAccess {\n+private:\n+    using Vector = std::vector<float>;\n+    std::vector<Vector> _vectors;\n+\n+public:\n+    MyDocVectorStore() : _vectors() {}\n+    MyDocVectorStore& set(uint32_t docid, ConstVectorRef vec) {\n+        if (docid >= _vectors.size()) {\n+            _vectors.resize(docid + 1);\n+        }\n+        _vectors[docid] = Vector(vec.begin(), vec.end());\n+        return *this;\n+    }\n+    vespalib::tensor::TypedCells get_vector(uint32_t docid) const override {\n+        ConstVectorRef ref(_vectors[docid]);\n+        return vespalib::tensor::TypedCells(ref);\n+    }\n+};\n+\n+using FloatSqEuclideanDistance = SquaredEuclideanDistance<float>;\n+using HnswIndexUP = std::unique_ptr<HnswIndex>;\n+\n+class Stressor : public ::testing::Test {\n+private:\n+    struct LoadedVectors {\n+        MallocPointVector *pv_storage;\n+        void load() {\n+            pv_storage = aligned_alloc_pv(size());\n+            read_vector_file(pv_storage);\n+        }\n+        size_t size() const { return NUM_POSSIBLE_V; }\n+        vespalib::ConstArrayRef<float> operator[] (size_t i) {\n+            return pv_storage[i];\n+        }\n+    } loaded_vectors;\n+public:\n+    BitVector::UP in_progress;\n+    BitVector::UP existing_ids;\n+    RndGen rng;\n+    MyDocVectorStore vectors;\n+    GenerationHandler gen_handler;\n+    HnswIndexUP index;\n+    vespalib::BlockingThreadStackExecutor multi_prepare_workers;\n+    vespalib::BlockingThreadStackExecutor write_thread;\n+\n+    using PrepUP = std::unique_ptr<PrepareResult>;\n+    using ReadGuard = GenerationHandler::Guard;\n+\n+    struct CompleteAddTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        PrepUP prepare_result;\n+\n+        CompleteAddTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            parent.existing_ids->setBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseAddTask  : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseAddTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            auto task = std::make_unique<CompleteAddTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete add task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+\n+        CompleteRemoveTask(Stressor &p, uint32_t d)\n+            : parent(p), docid(d)\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.existing_ids->clearBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseRemoveTask(Stressor &p, uint32_t d, ReadGuard r)\n+            : parent(p), docid(d), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto task = std::make_unique<CompleteRemoveTask>(parent, docid);\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        std::unique_ptr<PrepareResult> prepare_result;\n+\n+        CompleteUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            EXPECT_EQ(parent.existing_ids->testBit(docid), true);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            EXPECT_EQ(bool(up), true);\n+            auto task = std::make_unique<CompleteUpdateTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    Stressor()\n+        : loaded_vectors(),\n+          in_progress(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          existing_ids(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          rng(),\n+          vectors(),\n+          gen_handler(),\n+          index(),\n+          multi_prepare_workers(10, 128*1024, 50),\n+          write_thread(1, 128*1024, 15)\n+    {\n+        loaded_vectors.load();\n+    }\n+\n+    ~Stressor() {}\n+\n+    void init() {\n+        uint32_t m = 16;\n+        index = std::make_unique<HnswIndex>(vectors, std::make_unique<FloatSqEuclideanDistance>(),\n+                                            std::make_unique<InvLogLevelGenerator>(m),\n+                                            HnswIndex::Config(2*m, m, 200, true));\n+        vectors.set(NUM_POSSIBLE_DOCS, loaded_vectors[0]);\n+    }\n+    size_t get_rnd(size_t size) {\n+        return rng.nextUniform() * size;\n+    }\n+    void add_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseAddTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e01810c179b2593d7eae286fca7664eb6065d0fe"}, "originalPosition": 296}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDgyMTg2OnYy", "diffSide": "RIGHT", "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzowMDoyNVrOGlElJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzowMDoyNVrOGlElJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyNTU0Mg==", "bodyText": "Same comment as with add_document().", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441525542", "createdAt": "2020-06-17T13:00:25Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright 2020 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/tensor/dense/typed_cells.h>\n+#include <vespa/searchlib/common/bitvector.h>\n+#include <vespa/searchlib/tensor/distance_functions.h>\n+#include <vespa/searchlib/tensor/doc_vector_access.h>\n+#include <vespa/searchlib/tensor/hnsw_index.h>\n+#include <vespa/searchlib/tensor/random_level_generator.h>\n+#include <vespa/searchlib/tensor/inv_log_level_generator.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <vespa/vespalib/util/generationhandler.h>\n+#include <vespa/vespalib/data/slime/slime.h>\n+#include <vespa/vespalib/util/threadstackexecutor.h>\n+#include <vespa/vespalib/util/blockingthreadstackexecutor.h>\n+#include <vespa/vespalib/util/gate.h>\n+#include <vespa/vespalib/util/lambdatask.h>\n+\n+#include <vector>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+#include <cstdlib>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\"stress_hnsw_mt\");\n+\n+using vespalib::GenerationHandler;\n+using vespalib::MemoryUsage;\n+using namespace search::tensor;\n+using namespace vespalib::slime;\n+using vespalib::Slime;\n+using search::BitVector;\n+\n+#define NUM_DIMS 128\n+#define NUM_POSSIBLE_V 100000\n+#define NUM_POSSIBLE_DOCS 10000\n+#define NUM_OPS 50000\n+\n+class RndGen {\n+private:\n+    std::mt19937_64 urng;\n+    std::uniform_real_distribution<double> uf;\n+public:\n+    RndGen() : urng(0x1234deadbeef5678uLL), uf(0.0, 1.0) {}\n+\n+    double nextUniform() {\n+        return uf(urng);\n+    }\n+};\n+\n+using ConstVectorRef = vespalib::ConstArrayRef<float>;\n+\n+struct MallocPointVector {\n+    float v[NUM_DIMS];\n+    operator ConstVectorRef() const { return ConstVectorRef(v, NUM_DIMS); }\n+};\n+static MallocPointVector *aligned_alloc_pv(size_t num) {\n+    size_t num_bytes = num * sizeof(MallocPointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return reinterpret_cast<MallocPointVector *>(mem);\n+}\n+\n+void read_vector_file(MallocPointVector *p) {\n+    std::string data_set = \"sift\";\n+    std::string data_dir = \".\";\n+    char *home = getenv(\"HOME\");\n+    if (home) {\n+        data_dir = home;\n+        data_dir += \"/\" + data_set;\n+    }\n+    std::string fn = data_dir + \"/\" + data_set + \"_base.fvecs\";\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    if (fd < 0) {\n+        perror(fn.c_str());\n+        exit(1);\n+    }\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u vectors from %s\\n\", NUM_POSSIBLE_V, fn.c_str());\n+    for (uint32_t i = 0; i < NUM_POSSIBLE_V; ++i) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQ(rv, 4u);\n+        ASSERT_EQ(d, NUM_DIMS);\n+        rv = read(fd, &p[i].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQ(rv, sizeof(MallocPointVector));\n+    }\n+    close(fd);\n+    fprintf(stderr, \"reading %u vectors OK\\n\", NUM_POSSIBLE_V);\n+}\n+\n+class MyDocVectorStore : public DocVectorAccess {\n+private:\n+    using Vector = std::vector<float>;\n+    std::vector<Vector> _vectors;\n+\n+public:\n+    MyDocVectorStore() : _vectors() {}\n+    MyDocVectorStore& set(uint32_t docid, ConstVectorRef vec) {\n+        if (docid >= _vectors.size()) {\n+            _vectors.resize(docid + 1);\n+        }\n+        _vectors[docid] = Vector(vec.begin(), vec.end());\n+        return *this;\n+    }\n+    vespalib::tensor::TypedCells get_vector(uint32_t docid) const override {\n+        ConstVectorRef ref(_vectors[docid]);\n+        return vespalib::tensor::TypedCells(ref);\n+    }\n+};\n+\n+using FloatSqEuclideanDistance = SquaredEuclideanDistance<float>;\n+using HnswIndexUP = std::unique_ptr<HnswIndex>;\n+\n+class Stressor : public ::testing::Test {\n+private:\n+    struct LoadedVectors {\n+        MallocPointVector *pv_storage;\n+        void load() {\n+            pv_storage = aligned_alloc_pv(size());\n+            read_vector_file(pv_storage);\n+        }\n+        size_t size() const { return NUM_POSSIBLE_V; }\n+        vespalib::ConstArrayRef<float> operator[] (size_t i) {\n+            return pv_storage[i];\n+        }\n+    } loaded_vectors;\n+public:\n+    BitVector::UP in_progress;\n+    BitVector::UP existing_ids;\n+    RndGen rng;\n+    MyDocVectorStore vectors;\n+    GenerationHandler gen_handler;\n+    HnswIndexUP index;\n+    vespalib::BlockingThreadStackExecutor multi_prepare_workers;\n+    vespalib::BlockingThreadStackExecutor write_thread;\n+\n+    using PrepUP = std::unique_ptr<PrepareResult>;\n+    using ReadGuard = GenerationHandler::Guard;\n+\n+    struct CompleteAddTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        PrepUP prepare_result;\n+\n+        CompleteAddTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            parent.existing_ids->setBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseAddTask  : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseAddTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            auto task = std::make_unique<CompleteAddTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete add task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+\n+        CompleteRemoveTask(Stressor &p, uint32_t d)\n+            : parent(p), docid(d)\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.existing_ids->clearBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseRemoveTask(Stressor &p, uint32_t d, ReadGuard r)\n+            : parent(p), docid(d), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto task = std::make_unique<CompleteRemoveTask>(parent, docid);\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        std::unique_ptr<PrepareResult> prepare_result;\n+\n+        CompleteUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            EXPECT_EQ(parent.existing_ids->testBit(docid), true);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            EXPECT_EQ(bool(up), true);\n+            auto task = std::make_unique<CompleteUpdateTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    Stressor()\n+        : loaded_vectors(),\n+          in_progress(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          existing_ids(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          rng(),\n+          vectors(),\n+          gen_handler(),\n+          index(),\n+          multi_prepare_workers(10, 128*1024, 50),\n+          write_thread(1, 128*1024, 15)\n+    {\n+        loaded_vectors.load();\n+    }\n+\n+    ~Stressor() {}\n+\n+    void init() {\n+        uint32_t m = 16;\n+        index = std::make_unique<HnswIndex>(vectors, std::make_unique<FloatSqEuclideanDistance>(),\n+                                            std::make_unique<InvLogLevelGenerator>(m),\n+                                            HnswIndex::Config(2*m, m, 200, true));\n+        vectors.set(NUM_POSSIBLE_DOCS, loaded_vectors[0]);\n+    }\n+    size_t get_rnd(size_t size) {\n+        return rng.nextUniform() * size;\n+    }\n+    void add_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseAddTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void remove_document(uint32_t docid) {\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseRemoveTask>(*this, docid, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void update_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseUpdateTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e01810c179b2593d7eae286fca7664eb6065d0fe"}, "originalPosition": 310}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDgzMzM5OnYy", "diffSide": "RIGHT", "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzowMzoyMVrOGlEsiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzowMzoyMVrOGlEsiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyNzQzNQ==", "bodyText": "Is this racing with what happens in gen_operation(). Should we protect it with a mutex?", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441527435", "createdAt": "2020-06-17T13:03:21Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/tensor/hnsw_index/stress_hnsw_mt.cpp", "diffHunk": "@@ -0,0 +1,367 @@\n+// Copyright 2020 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/tensor/dense/typed_cells.h>\n+#include <vespa/searchlib/common/bitvector.h>\n+#include <vespa/searchlib/tensor/distance_functions.h>\n+#include <vespa/searchlib/tensor/doc_vector_access.h>\n+#include <vespa/searchlib/tensor/hnsw_index.h>\n+#include <vespa/searchlib/tensor/random_level_generator.h>\n+#include <vespa/searchlib/tensor/inv_log_level_generator.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <vespa/vespalib/util/generationhandler.h>\n+#include <vespa/vespalib/data/slime/slime.h>\n+#include <vespa/vespalib/util/threadstackexecutor.h>\n+#include <vespa/vespalib/util/blockingthreadstackexecutor.h>\n+#include <vespa/vespalib/util/gate.h>\n+#include <vespa/vespalib/util/lambdatask.h>\n+\n+#include <vector>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+#include <cstdlib>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\"stress_hnsw_mt\");\n+\n+using vespalib::GenerationHandler;\n+using vespalib::MemoryUsage;\n+using namespace search::tensor;\n+using namespace vespalib::slime;\n+using vespalib::Slime;\n+using search::BitVector;\n+\n+#define NUM_DIMS 128\n+#define NUM_POSSIBLE_V 100000\n+#define NUM_POSSIBLE_DOCS 10000\n+#define NUM_OPS 50000\n+\n+class RndGen {\n+private:\n+    std::mt19937_64 urng;\n+    std::uniform_real_distribution<double> uf;\n+public:\n+    RndGen() : urng(0x1234deadbeef5678uLL), uf(0.0, 1.0) {}\n+\n+    double nextUniform() {\n+        return uf(urng);\n+    }\n+};\n+\n+using ConstVectorRef = vespalib::ConstArrayRef<float>;\n+\n+struct MallocPointVector {\n+    float v[NUM_DIMS];\n+    operator ConstVectorRef() const { return ConstVectorRef(v, NUM_DIMS); }\n+};\n+static MallocPointVector *aligned_alloc_pv(size_t num) {\n+    size_t num_bytes = num * sizeof(MallocPointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return reinterpret_cast<MallocPointVector *>(mem);\n+}\n+\n+void read_vector_file(MallocPointVector *p) {\n+    std::string data_set = \"sift\";\n+    std::string data_dir = \".\";\n+    char *home = getenv(\"HOME\");\n+    if (home) {\n+        data_dir = home;\n+        data_dir += \"/\" + data_set;\n+    }\n+    std::string fn = data_dir + \"/\" + data_set + \"_base.fvecs\";\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    if (fd < 0) {\n+        perror(fn.c_str());\n+        exit(1);\n+    }\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u vectors from %s\\n\", NUM_POSSIBLE_V, fn.c_str());\n+    for (uint32_t i = 0; i < NUM_POSSIBLE_V; ++i) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQ(rv, 4u);\n+        ASSERT_EQ(d, NUM_DIMS);\n+        rv = read(fd, &p[i].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQ(rv, sizeof(MallocPointVector));\n+    }\n+    close(fd);\n+    fprintf(stderr, \"reading %u vectors OK\\n\", NUM_POSSIBLE_V);\n+}\n+\n+class MyDocVectorStore : public DocVectorAccess {\n+private:\n+    using Vector = std::vector<float>;\n+    std::vector<Vector> _vectors;\n+\n+public:\n+    MyDocVectorStore() : _vectors() {}\n+    MyDocVectorStore& set(uint32_t docid, ConstVectorRef vec) {\n+        if (docid >= _vectors.size()) {\n+            _vectors.resize(docid + 1);\n+        }\n+        _vectors[docid] = Vector(vec.begin(), vec.end());\n+        return *this;\n+    }\n+    vespalib::tensor::TypedCells get_vector(uint32_t docid) const override {\n+        ConstVectorRef ref(_vectors[docid]);\n+        return vespalib::tensor::TypedCells(ref);\n+    }\n+};\n+\n+using FloatSqEuclideanDistance = SquaredEuclideanDistance<float>;\n+using HnswIndexUP = std::unique_ptr<HnswIndex>;\n+\n+class Stressor : public ::testing::Test {\n+private:\n+    struct LoadedVectors {\n+        MallocPointVector *pv_storage;\n+        void load() {\n+            pv_storage = aligned_alloc_pv(size());\n+            read_vector_file(pv_storage);\n+        }\n+        size_t size() const { return NUM_POSSIBLE_V; }\n+        vespalib::ConstArrayRef<float> operator[] (size_t i) {\n+            return pv_storage[i];\n+        }\n+    } loaded_vectors;\n+public:\n+    BitVector::UP in_progress;\n+    BitVector::UP existing_ids;\n+    RndGen rng;\n+    MyDocVectorStore vectors;\n+    GenerationHandler gen_handler;\n+    HnswIndexUP index;\n+    vespalib::BlockingThreadStackExecutor multi_prepare_workers;\n+    vespalib::BlockingThreadStackExecutor write_thread;\n+\n+    using PrepUP = std::unique_ptr<PrepareResult>;\n+    using ReadGuard = GenerationHandler::Guard;\n+\n+    struct CompleteAddTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        PrepUP prepare_result;\n+\n+        CompleteAddTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            parent.existing_ids->setBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseAddTask  : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseAddTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            auto task = std::make_unique<CompleteAddTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete add task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+\n+        CompleteRemoveTask(Stressor &p, uint32_t d)\n+            : parent(p), docid(d)\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.existing_ids->clearBit(docid);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseRemoveTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseRemoveTask(Stressor &p, uint32_t d, ReadGuard r)\n+            : parent(p), docid(d), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto task = std::make_unique<CompleteRemoveTask>(parent, docid);\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    struct CompleteUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        std::unique_ptr<PrepareResult> prepare_result;\n+\n+        CompleteUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, PrepUP r)\n+            : parent(p), docid(d), vec(v), prepare_result(std::move(r))\n+        {}\n+\n+        void run() override {\n+            parent.index->remove_document(docid);\n+            parent.vectors.set(docid, vec);\n+            parent.index->complete_add_document(docid, std::move(prepare_result));\n+            EXPECT_EQ(parent.existing_ids->testBit(docid), true);\n+            parent.commit(docid);\n+        }\n+    };\n+\n+    struct TwoPhaseUpdateTask : vespalib::Executor::Task {\n+        Stressor &parent;\n+        uint32_t docid;\n+        ConstVectorRef vec;\n+        GenerationHandler::Guard read_guard;\n+\n+        TwoPhaseUpdateTask(Stressor &p, uint32_t d, ConstVectorRef v, ReadGuard r)\n+            : parent(p), docid(d), vec(v), read_guard(r)\n+        {}\n+\n+        void run() override {\n+            auto v = vespalib::tensor::TypedCells(vec);\n+            auto up = parent.index->prepare_add_document(docid, v, read_guard);\n+            EXPECT_EQ(bool(up), true);\n+            auto task = std::make_unique<CompleteUpdateTask>(parent, docid, vec, std::move(up));\n+            auto r = parent.write_thread.execute(std::move(task));\n+            if (r) {\n+                fprintf(stderr, \"Failed posting complete remove task!\");\n+                abort();\n+            }\n+        }\n+    };\n+\n+    Stressor()\n+        : loaded_vectors(),\n+          in_progress(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          existing_ids(BitVector::create(NUM_POSSIBLE_DOCS)),\n+          rng(),\n+          vectors(),\n+          gen_handler(),\n+          index(),\n+          multi_prepare_workers(10, 128*1024, 50),\n+          write_thread(1, 128*1024, 15)\n+    {\n+        loaded_vectors.load();\n+    }\n+\n+    ~Stressor() {}\n+\n+    void init() {\n+        uint32_t m = 16;\n+        index = std::make_unique<HnswIndex>(vectors, std::make_unique<FloatSqEuclideanDistance>(),\n+                                            std::make_unique<InvLogLevelGenerator>(m),\n+                                            HnswIndex::Config(2*m, m, 200, true));\n+        vectors.set(NUM_POSSIBLE_DOCS, loaded_vectors[0]);\n+    }\n+    size_t get_rnd(size_t size) {\n+        return rng.nextUniform() * size;\n+    }\n+    void add_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseAddTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void remove_document(uint32_t docid) {\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseRemoveTask>(*this, docid, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void update_document(uint32_t docid) {\n+        size_t vec_num = get_rnd(loaded_vectors.size());\n+        ConstVectorRef vec = loaded_vectors[vec_num];\n+        auto guard = take_read_guard();\n+        auto task = std::make_unique<TwoPhaseUpdateTask>(*this, docid, vec, guard);\n+        auto r = multi_prepare_workers.execute(std::move(task));\n+        ASSERT_EQ(bool(r), false);\n+    }\n+    void commit(uint32_t docid) {\n+        index->transfer_hold_lists(gen_handler.getCurrentGeneration());\n+        gen_handler.incGeneration();\n+        gen_handler.updateFirstUsedGeneration();\n+        index->trim_hold_lists(gen_handler.getFirstUsedGeneration());\n+        in_progress->clearBit(docid);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e01810c179b2593d7eae286fca7664eb6065d0fe"}, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDgzNjE0OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/hnsw_index.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzowNDowOFrOGlEuUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzowNDowOFrOGlEuUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyNzg5MQ==", "bodyText": "Consider rename 'me' -> 'me_docid' / 'self_docid'", "url": "https://github.com/vespa-engine/vespa/pull/13572#discussion_r441527891", "createdAt": "2020-06-17T13:04:08Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/hnsw_index.cpp", "diffHunk": "@@ -322,14 +322,21 @@ HnswIndex::internal_prepare_add(uint32_t docid, TypedCells input_vector) const\n }\n \n HnswIndex::LinkArray \n-HnswIndex::filter_valid_docids(const LinkArrayRef &docids)\n+HnswIndex::filter_valid_docids(uint32_t level, const LinkArrayRef &docids, uint32_t me)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb2b67a51102aa4ae3bfa9e1432d00073fd68e89"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1937, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}