{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzMzQ4MDc5", "number": 13153, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODozNTo1MFrOD5TiXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTo1MTozMlrOD5XiGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDE1NTE5OnYy", "diffSide": "RIGHT", "path": "persistence/src/vespa/persistence/spi/persistenceprovider.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODozNTo1MFrOGQflrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDoxMDowNVrOGQiyZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0Nzk1MQ==", "bodyText": "Just an observation: a rather far fetched scenario, but since neither of these are now pure virtual it's technically possible for a persistence implementation to override neither of remove or removeAsync, causing infinite recursion here if any of the two are called (same applies to the other sync/async pairings).", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r419947951", "createdAt": "2020-05-05T08:35:50Z", "author": {"login": "vekterli"}, "path": "persistence/src/vespa/persistence/spi/persistenceprovider.cpp", "diffHunk": "@@ -29,9 +36,42 @@ PersistenceProvider::put(const Bucket& bucket, Timestamp timestamp, DocumentSP d\n \n void\n PersistenceProvider::putAsync(const Bucket &bucket, Timestamp timestamp, DocumentSP doc, Context &context,\n-                              OperationComplete::UP onComplete) {\n+                              OperationComplete::UP onComplete)\n+{\n     Result result = put(bucket, timestamp, std::move(doc), context);\n     onComplete->onComplete(std::make_unique<Result>(result));\n }\n \n+RemoveResult\n+PersistenceProvider::remove(const Bucket& bucket, Timestamp timestamp, const DocumentId & docId, Context& context) {\n+    auto catcher = std::make_unique<CatchResult>();\n+    auto future = catcher->future_result();\n+    removeAsync(bucket, timestamp, docId, context, std::move(catcher));\n+    return dynamic_cast<const RemoveResult &>(*future.get());\n+}\n+\n+void\n+PersistenceProvider::removeAsync(const Bucket &bucket, Timestamp timestamp, const DocumentId & docId, Context &context,\n+                                 OperationComplete::UP onComplete)\n+{\n+    RemoveResult result = remove(bucket, timestamp, docId, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b83b031718d466df9fc0c4abd89f7fe0bcdbbf8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwMDM1Ng==", "bodyText": "Yes, that is correct. I will add a comment about that.\nI do not think the conformance test will pass in that case :)", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420000356", "createdAt": "2020-05-05T10:10:05Z", "author": {"login": "baldersheim"}, "path": "persistence/src/vespa/persistence/spi/persistenceprovider.cpp", "diffHunk": "@@ -29,9 +36,42 @@ PersistenceProvider::put(const Bucket& bucket, Timestamp timestamp, DocumentSP d\n \n void\n PersistenceProvider::putAsync(const Bucket &bucket, Timestamp timestamp, DocumentSP doc, Context &context,\n-                              OperationComplete::UP onComplete) {\n+                              OperationComplete::UP onComplete)\n+{\n     Result result = put(bucket, timestamp, std::move(doc), context);\n     onComplete->onComplete(std::make_unique<Result>(result));\n }\n \n+RemoveResult\n+PersistenceProvider::remove(const Bucket& bucket, Timestamp timestamp, const DocumentId & docId, Context& context) {\n+    auto catcher = std::make_unique<CatchResult>();\n+    auto future = catcher->future_result();\n+    removeAsync(bucket, timestamp, docId, context, std::move(catcher));\n+    return dynamic_cast<const RemoveResult &>(*future.get());\n+}\n+\n+void\n+PersistenceProvider::removeAsync(const Bucket &bucket, Timestamp timestamp, const DocumentId & docId, Context &context,\n+                                 OperationComplete::UP onComplete)\n+{\n+    RemoveResult result = remove(bucket, timestamp, docId, context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0Nzk1MQ=="}, "originalCommit": {"oid": "2b83b031718d466df9fc0c4abd89f7fe0bcdbbf8"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDIzODc2OnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODo1ODo0OFrOGQgYng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMDoxMDoxN1rOGQiyvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2MDk5MA==", "bodyText": "Consider pulling makeResultTask out above this call to make the code less deeply nested here", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r419960990", "createdAt": "2020-05-05T08:58:48Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -91,42 +165,72 @@ PersistenceThread::tasConditionMatches(const api::TestAndSetCommand & cmd, Messa\n }\n \n MessageTracker::UP\n-PersistenceThread::handlePut(api::PutCommand& cmd, MessageTracker::UP tracker)\n+PersistenceThread::handlePut(api::PutCommand& cmd, MessageTracker::UP trackerUP)\n {\n+    MessageTracker & tracker = *trackerUP;\n     auto& metrics = _env._metrics.put[cmd.getLoadType()];\n-    tracker->setMetric(metrics);\n+    tracker.setMetric(metrics);\n     metrics.request_size.addValue(cmd.getApproxByteSize());\n \n-    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, *tracker, tracker->context())) {\n-        return tracker;\n+    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, tracker, tracker.context())) {\n+        return trackerUP;\n     }\n \n-    spi::Result response = _spi.put(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                    spi::Timestamp(cmd.getTimestamp()), std::move(cmd.getDocument()), tracker->context());\n-    tracker->checkForError(response);\n-    return tracker;\n+    if (_sequencedExecutor == nullptr) {\n+        spi::Result response = _spi.put(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n+                                        spi::Timestamp(cmd.getTimestamp()), std::move(cmd.getDocument()),\n+                                        tracker.context());\n+        tracker.checkForError(response);\n+    } else {\n+        _spi.putAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()), spi::Timestamp(cmd.getTimestamp()),\n+                      std::move(cmd.getDocument()), tracker.context(),\n+                      std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n+                              makeResultTask([tracker = std::move(trackerUP)](spi::Result::UP response) {\n+                                  tracker->checkForError(*response);\n+                                  tracker->sendReply();\n+                              })));\n+    }\n+    return trackerUP;\n }\n \n MessageTracker::UP\n-PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP tracker)\n+PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP trackerUP)\n {\n+    MessageTracker & tracker = *trackerUP;\n     auto& metrics = _env._metrics.remove[cmd.getLoadType()];\n-    tracker->setMetric(metrics);\n+    tracker.setMetric(metrics);\n     metrics.request_size.addValue(cmd.getApproxByteSize());\n \n-    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, *tracker, tracker->context())) {\n-        return tracker;\n+    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, tracker, tracker.context())) {\n+        return trackerUP;\n     }\n \n-    spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                                    spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker->context());\n-    if (tracker->checkForError(response)) {\n-        tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n-    }\n-    if (!response.wasFound()) {\n-        _env._metrics.remove[cmd.getLoadType()].notFound.inc();\n-    }\n-    return tracker;\n+    if (_sequencedExecutor == nullptr) {\n+        spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n+                                                        spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),\n+                                                        tracker.context());\n+        if (tracker.checkForError(response)) {\n+            tracker.setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n+        }\n+        if (!response.wasFound()) {\n+            metrics.notFound.inc();\n+        }\n+    } else {\n+        _spi.removeIfFoundAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n+                         spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n+                         std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n+                               makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n+                                   const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n+                                   if (tracker->checkForError(response)) {\n+                                       tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n+                                   }\n+                                   if (!response.wasFound()) {\n+                                       metrics.notFound.inc();\n+                                   }\n+                                   tracker->sendReply();\n+                               })));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b83b031718d466df9fc0c4abd89f7fe0bcdbbf8"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwMDQ0Nw==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420000447", "createdAt": "2020-05-05T10:10:17Z", "author": {"login": "baldersheim"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -91,42 +165,72 @@ PersistenceThread::tasConditionMatches(const api::TestAndSetCommand & cmd, Messa\n }\n \n MessageTracker::UP\n-PersistenceThread::handlePut(api::PutCommand& cmd, MessageTracker::UP tracker)\n+PersistenceThread::handlePut(api::PutCommand& cmd, MessageTracker::UP trackerUP)\n {\n+    MessageTracker & tracker = *trackerUP;\n     auto& metrics = _env._metrics.put[cmd.getLoadType()];\n-    tracker->setMetric(metrics);\n+    tracker.setMetric(metrics);\n     metrics.request_size.addValue(cmd.getApproxByteSize());\n \n-    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, *tracker, tracker->context())) {\n-        return tracker;\n+    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, tracker, tracker.context())) {\n+        return trackerUP;\n     }\n \n-    spi::Result response = _spi.put(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                    spi::Timestamp(cmd.getTimestamp()), std::move(cmd.getDocument()), tracker->context());\n-    tracker->checkForError(response);\n-    return tracker;\n+    if (_sequencedExecutor == nullptr) {\n+        spi::Result response = _spi.put(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n+                                        spi::Timestamp(cmd.getTimestamp()), std::move(cmd.getDocument()),\n+                                        tracker.context());\n+        tracker.checkForError(response);\n+    } else {\n+        _spi.putAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()), spi::Timestamp(cmd.getTimestamp()),\n+                      std::move(cmd.getDocument()), tracker.context(),\n+                      std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n+                              makeResultTask([tracker = std::move(trackerUP)](spi::Result::UP response) {\n+                                  tracker->checkForError(*response);\n+                                  tracker->sendReply();\n+                              })));\n+    }\n+    return trackerUP;\n }\n \n MessageTracker::UP\n-PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP tracker)\n+PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP trackerUP)\n {\n+    MessageTracker & tracker = *trackerUP;\n     auto& metrics = _env._metrics.remove[cmd.getLoadType()];\n-    tracker->setMetric(metrics);\n+    tracker.setMetric(metrics);\n     metrics.request_size.addValue(cmd.getApproxByteSize());\n \n-    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, *tracker, tracker->context())) {\n-        return tracker;\n+    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, tracker, tracker.context())) {\n+        return trackerUP;\n     }\n \n-    spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                                    spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker->context());\n-    if (tracker->checkForError(response)) {\n-        tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n-    }\n-    if (!response.wasFound()) {\n-        _env._metrics.remove[cmd.getLoadType()].notFound.inc();\n-    }\n-    return tracker;\n+    if (_sequencedExecutor == nullptr) {\n+        spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n+                                                        spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),\n+                                                        tracker.context());\n+        if (tracker.checkForError(response)) {\n+            tracker.setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n+        }\n+        if (!response.wasFound()) {\n+            metrics.notFound.inc();\n+        }\n+    } else {\n+        _spi.removeIfFoundAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n+                         spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n+                         std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n+                               makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n+                                   const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n+                                   if (tracker->checkForError(response)) {\n+                                       tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n+                                   }\n+                                   if (!response.wasFound()) {\n+                                       metrics.notFound.inc();\n+                                   }\n+                                   tracker->sendReply();\n+                               })));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2MDk5MA=="}, "originalCommit": {"oid": "2b83b031718d466df9fc0c4abd89f7fe0bcdbbf8"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDc5MzcwOnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/persistenceengine.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTo0NjozMVrOGQlrkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMjowNjoxMlrOGQmS3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0Nzc2Mw==", "bodyText": "Nit: spurious whitespace", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420047763", "createdAt": "2020-05-05T11:46:31Z", "author": {"login": "vekterli"}, "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/persistenceengine.cpp", "diffHunk": "@@ -368,59 +368,55 @@ PersistenceEngine::removeAsync(const Bucket& b, Timestamp t, const DocumentId& d\n }\n \n \n-PersistenceEngine::UpdateResult\n-PersistenceEngine::update(const Bucket& b, Timestamp t, const DocumentUpdate::SP& upd, Context&)\n+void\n+PersistenceEngine::updateAsync(const Bucket& b, Timestamp t, DocumentUpdate::SP upd, Context&, OperationComplete::UP onComplete)\n {\n     if (!_writeFilter.acceptWriteOperation()) {\n         IResourceWriteFilter::State state = _writeFilter.getAcceptState();\n         if (!state.acceptWriteOperation()) {\n-            return UpdateResult(Result::ErrorType::RESOURCE_EXHAUSTED,\n+            return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::RESOURCE_EXHAUSTED,\n                                 make_string(\"Update operation rejected for document '%s': '%s'\",\n-                                            upd->getId().toString().c_str(), state.message().c_str()));\n+                                            upd->getId().toString().c_str(), state.message().c_str())));\n         }\n     }\n     try {\n         upd->eagerDeserialize();\n     } catch (document::FieldNotFoundException & e) {\n-        return UpdateResult(Result::ErrorType::TRANSIENT_ERROR,\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::TRANSIENT_ERROR,\n                             make_string(\"Update operation rejected for document '%s' of type '%s': 'Field not found'\",\n-                                        upd->getId().toString().c_str(), upd->getType().getName().c_str()));\n+                                        upd->getId().toString().c_str(), upd->getType().getName().c_str())));\n     } catch (document::DocumentTypeNotFoundException & e) {\n-        return UpdateResult(Result::ErrorType::TRANSIENT_ERROR,\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::TRANSIENT_ERROR,\n                             make_string(\"Update operation rejected for document '%s' of type '%s'.\",\n-                                        upd->getId().toString().c_str(), e.getDocumentTypeName().c_str()));\n+                                        upd->getId().toString().c_str(), e.getDocumentTypeName().c_str())));\n \n     } catch (document::WrongTensorTypeException &e) {\n-        return UpdateResult(Result::ErrorType::TRANSIENT_ERROR,\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::TRANSIENT_ERROR,\n                             make_string(\"Update operation rejected for document '%s' of type '%s': 'Wrong tensor type: %s'\",\n                                         upd->getId().toString().c_str(),\n                                         upd->getType().getName().c_str(),\n-                                        e.getMessage().c_str()));\n+                                        e.getMessage().c_str())));\n     }\n     std::shared_lock<std::shared_timed_mutex> rguard(_rwMutex);\n     DocTypeName docType(upd->getType());\n     LOG(spam, \"update(%s, %\" PRIu64 \", (\\\"%s\\\", \\\"%s\\\"), createIfNonExistent='%s')\",\n         b.toString().c_str(), static_cast<uint64_t>(t.getValue()), docType.toString().c_str(),\n         upd->getId().toString().c_str(), (upd->getCreateIfNonExistent() ? \"true\" : \"false\"));\n     if (!upd->getId().hasDocType()) {\n-        return UpdateResult(Result::ErrorType::PERMANENT_ERROR,\n-                            make_string(\"Old id scheme not supported in elastic mode (%s)\", upd->getId().toString().c_str()));\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::PERMANENT_ERROR,\n+                            make_string(\"Old id scheme not supported in elastic mode (%s)\", upd->getId().toString().c_str())));\n     }\n     if (upd->getId().getDocType() != docType.getName()) {\n-        return UpdateResult(Result::ErrorType::PERMANENT_ERROR,\n-                            make_string(\"Update operation rejected due to bad id (%s, %s)\", upd->getId().toString().c_str(), docType.getName().c_str()));\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::PERMANENT_ERROR,\n+                            make_string(\"Update operation rejected due to bad id (%s, %s)\", upd->getId().toString().c_str(), docType.getName().c_str())));\n     }\n     IPersistenceHandler * handler = getHandler(rguard, b.getBucketSpace(), docType);\n \n-    if (handler) {\n-        TransportLatch latch(1);\n-        LOG(debug, \"update = %s\", upd->toXml().c_str());\n-        handler->handleUpdate(feedtoken::make(latch), b, t, upd);\n-        latch.await();\n-        return latch.getUpdateResult();\n-    } else {\n-        return UpdateResult(Result::ErrorType::PERMANENT_ERROR, make_string(\"No handler for document type '%s'\", docType.toString().c_str()));\n+    if ( handler == nullptr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1NzgyMA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420057820", "createdAt": "2020-05-05T12:06:12Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/persistenceengine.cpp", "diffHunk": "@@ -368,59 +368,55 @@ PersistenceEngine::removeAsync(const Bucket& b, Timestamp t, const DocumentId& d\n }\n \n \n-PersistenceEngine::UpdateResult\n-PersistenceEngine::update(const Bucket& b, Timestamp t, const DocumentUpdate::SP& upd, Context&)\n+void\n+PersistenceEngine::updateAsync(const Bucket& b, Timestamp t, DocumentUpdate::SP upd, Context&, OperationComplete::UP onComplete)\n {\n     if (!_writeFilter.acceptWriteOperation()) {\n         IResourceWriteFilter::State state = _writeFilter.getAcceptState();\n         if (!state.acceptWriteOperation()) {\n-            return UpdateResult(Result::ErrorType::RESOURCE_EXHAUSTED,\n+            return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::RESOURCE_EXHAUSTED,\n                                 make_string(\"Update operation rejected for document '%s': '%s'\",\n-                                            upd->getId().toString().c_str(), state.message().c_str()));\n+                                            upd->getId().toString().c_str(), state.message().c_str())));\n         }\n     }\n     try {\n         upd->eagerDeserialize();\n     } catch (document::FieldNotFoundException & e) {\n-        return UpdateResult(Result::ErrorType::TRANSIENT_ERROR,\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::TRANSIENT_ERROR,\n                             make_string(\"Update operation rejected for document '%s' of type '%s': 'Field not found'\",\n-                                        upd->getId().toString().c_str(), upd->getType().getName().c_str()));\n+                                        upd->getId().toString().c_str(), upd->getType().getName().c_str())));\n     } catch (document::DocumentTypeNotFoundException & e) {\n-        return UpdateResult(Result::ErrorType::TRANSIENT_ERROR,\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::TRANSIENT_ERROR,\n                             make_string(\"Update operation rejected for document '%s' of type '%s'.\",\n-                                        upd->getId().toString().c_str(), e.getDocumentTypeName().c_str()));\n+                                        upd->getId().toString().c_str(), e.getDocumentTypeName().c_str())));\n \n     } catch (document::WrongTensorTypeException &e) {\n-        return UpdateResult(Result::ErrorType::TRANSIENT_ERROR,\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::TRANSIENT_ERROR,\n                             make_string(\"Update operation rejected for document '%s' of type '%s': 'Wrong tensor type: %s'\",\n                                         upd->getId().toString().c_str(),\n                                         upd->getType().getName().c_str(),\n-                                        e.getMessage().c_str()));\n+                                        e.getMessage().c_str())));\n     }\n     std::shared_lock<std::shared_timed_mutex> rguard(_rwMutex);\n     DocTypeName docType(upd->getType());\n     LOG(spam, \"update(%s, %\" PRIu64 \", (\\\"%s\\\", \\\"%s\\\"), createIfNonExistent='%s')\",\n         b.toString().c_str(), static_cast<uint64_t>(t.getValue()), docType.toString().c_str(),\n         upd->getId().toString().c_str(), (upd->getCreateIfNonExistent() ? \"true\" : \"false\"));\n     if (!upd->getId().hasDocType()) {\n-        return UpdateResult(Result::ErrorType::PERMANENT_ERROR,\n-                            make_string(\"Old id scheme not supported in elastic mode (%s)\", upd->getId().toString().c_str()));\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::PERMANENT_ERROR,\n+                            make_string(\"Old id scheme not supported in elastic mode (%s)\", upd->getId().toString().c_str())));\n     }\n     if (upd->getId().getDocType() != docType.getName()) {\n-        return UpdateResult(Result::ErrorType::PERMANENT_ERROR,\n-                            make_string(\"Update operation rejected due to bad id (%s, %s)\", upd->getId().toString().c_str(), docType.getName().c_str()));\n+        return onComplete->onComplete(std::make_unique<UpdateResult>(Result::ErrorType::PERMANENT_ERROR,\n+                            make_string(\"Update operation rejected due to bad id (%s, %s)\", upd->getId().toString().c_str(), docType.getName().c_str())));\n     }\n     IPersistenceHandler * handler = getHandler(rguard, b.getBucketSpace(), docType);\n \n-    if (handler) {\n-        TransportLatch latch(1);\n-        LOG(debug, \"update = %s\", upd->toXml().c_str());\n-        handler->handleUpdate(feedtoken::make(latch), b, t, upd);\n-        latch.await();\n-        return latch.getUpdateResult();\n-    } else {\n-        return UpdateResult(Result::ErrorType::PERMANENT_ERROR, make_string(\"No handler for document type '%s'\", docType.toString().c_str()));\n+    if ( handler == nullptr) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0Nzc2Mw=="}, "originalCommit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDgwOTUzOnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTo1MToyNVrOGQl1Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMjowNTozNVrOGQmRqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MDIwMw==", "bodyText": "Consider adding a comment stating why it's safe to refer to cmd as a reference capture to the argument given to the function itself, since the lifetime semantics aren't necessarily obvious.", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420050203", "createdAt": "2020-05-05T11:51:25Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -205,53 +203,66 @@ PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP trac\n         return trackerUP;\n     }\n \n+    spi::Bucket bucket = getBucket(cmd.getDocumentId(), cmd.getBucket());\n     if (_sequencedExecutor == nullptr) {\n-        spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                                        spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),\n-                                                        tracker.context());\n+        spi::RemoveResult response = _spi.removeIfFound(bucket, spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),tracker.context());\n         if (tracker.checkForError(response)) {\n             tracker.setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n         }\n         if (!response.wasFound()) {\n             metrics.notFound.inc();\n         }\n     } else {\n-        _spi.removeIfFoundAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                         spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n-                         std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n-                               makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n-                                   const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n-                                   if (tracker->checkForError(response)) {\n-                                       tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n-                                   }\n-                                   if (!response.wasFound()) {\n-                                       metrics.notFound.inc();\n-                                   }\n-                                   tracker->sendReply();\n-                               })));\n+        auto task = makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1NzUxNA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420057514", "createdAt": "2020-05-05T12:05:35Z", "author": {"login": "baldersheim"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -205,53 +203,66 @@ PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP trac\n         return trackerUP;\n     }\n \n+    spi::Bucket bucket = getBucket(cmd.getDocumentId(), cmd.getBucket());\n     if (_sequencedExecutor == nullptr) {\n-        spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                                        spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),\n-                                                        tracker.context());\n+        spi::RemoveResult response = _spi.removeIfFound(bucket, spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),tracker.context());\n         if (tracker.checkForError(response)) {\n             tracker.setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n         }\n         if (!response.wasFound()) {\n             metrics.notFound.inc();\n         }\n     } else {\n-        _spi.removeIfFoundAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                         spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n-                         std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n-                               makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n-                                   const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n-                                   if (tracker->checkForError(response)) {\n-                                       tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n-                                   }\n-                                   if (!response.wasFound()) {\n-                                       metrics.notFound.inc();\n-                                   }\n-                                   tracker->sendReply();\n-                               })));\n+        auto task = makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MDIwMw=="}, "originalCommit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDgwOTg0OnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTo1MTozMlrOGQl1TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMjowNTo1OFrOGQmSgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MDI1Mg==", "bodyText": "Consider adding a comment stating why it's safe to refer to cmd as a reference capture to the argument given to the function itself, since the lifetime semantics aren't necessarily obvious.", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420050252", "createdAt": "2020-05-05T11:51:32Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -205,53 +203,66 @@ PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP trac\n         return trackerUP;\n     }\n \n+    spi::Bucket bucket = getBucket(cmd.getDocumentId(), cmd.getBucket());\n     if (_sequencedExecutor == nullptr) {\n-        spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                                        spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),\n-                                                        tracker.context());\n+        spi::RemoveResult response = _spi.removeIfFound(bucket, spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),tracker.context());\n         if (tracker.checkForError(response)) {\n             tracker.setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n         }\n         if (!response.wasFound()) {\n             metrics.notFound.inc();\n         }\n     } else {\n-        _spi.removeIfFoundAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                         spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n-                         std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n-                               makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n-                                   const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n-                                   if (tracker->checkForError(response)) {\n-                                       tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n-                                   }\n-                                   if (!response.wasFound()) {\n-                                       metrics.notFound.inc();\n-                                   }\n-                                   tracker->sendReply();\n-                               })));\n+        auto task = makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n+            const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n+            if (tracker->checkForError(response)) {\n+                tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n+            }\n+            if (!response.wasFound()) {\n+                metrics.notFound.inc();\n+            }\n+            tracker->sendReply();\n+        });\n+        _spi.removeIfFoundAsync(bucket, spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n+                                std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(), std::move(task)));\n     }\n     return trackerUP;\n }\n \n MessageTracker::UP\n-PersistenceThread::handleUpdate(api::UpdateCommand& cmd, MessageTracker::UP tracker)\n+PersistenceThread::handleUpdate(api::UpdateCommand& cmd, MessageTracker::UP trackerUP)\n {\n+    MessageTracker & tracker = *trackerUP;\n     auto& metrics = _env._metrics.update[cmd.getLoadType()];\n-    tracker->setMetric(metrics);\n+    tracker.setMetric(metrics);\n     metrics.request_size.addValue(cmd.getApproxByteSize());\n \n-    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, *tracker, tracker->context(), cmd.getUpdate()->getCreateIfNonExistent())) {\n-        return tracker;\n+    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, tracker, tracker.context(), cmd.getUpdate()->getCreateIfNonExistent())) {\n+        return trackerUP;\n     }\n-    \n-    spi::UpdateResult response = _spi.update(getBucket(cmd.getUpdate()->getId(), cmd.getBucket()),\n-                                             spi::Timestamp(cmd.getTimestamp()), cmd.getUpdate(), tracker->context());\n-    if (tracker->checkForError(response)) {\n-        auto reply = std::make_shared<api::UpdateReply>(cmd);\n-        reply->setOldTimestamp(response.getExistingTimestamp());\n-        tracker->setReply(std::move(reply));\n+\n+    spi::Bucket bucket = getBucket(cmd.getDocumentId(), cmd.getBucket());\n+    if (_sequencedExecutor == nullptr) {\n+        spi::UpdateResult response = _spi.update(bucket, spi::Timestamp(cmd.getTimestamp()), std::move(cmd.getUpdate()),tracker.context());\n+        if (tracker.checkForError(response)) {\n+            auto reply = std::make_shared<api::UpdateReply>(cmd);\n+            reply->setOldTimestamp(response.getExistingTimestamp());\n+            tracker.setReply(std::move(reply));\n+        }\n+    } else {\n+        auto task = makeResultTask([&cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1NzczMA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13153#discussion_r420057730", "createdAt": "2020-05-05T12:05:58Z", "author": {"login": "baldersheim"}, "path": "storage/src/vespa/storage/persistence/persistencethread.cpp", "diffHunk": "@@ -205,53 +203,66 @@ PersistenceThread::handleRemove(api::RemoveCommand& cmd, MessageTracker::UP trac\n         return trackerUP;\n     }\n \n+    spi::Bucket bucket = getBucket(cmd.getDocumentId(), cmd.getBucket());\n     if (_sequencedExecutor == nullptr) {\n-        spi::RemoveResult response = _spi.removeIfFound(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                                                        spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),\n-                                                        tracker.context());\n+        spi::RemoveResult response = _spi.removeIfFound(bucket, spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(),tracker.context());\n         if (tracker.checkForError(response)) {\n             tracker.setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n         }\n         if (!response.wasFound()) {\n             metrics.notFound.inc();\n         }\n     } else {\n-        _spi.removeIfFoundAsync(getBucket(cmd.getDocumentId(), cmd.getBucket()),\n-                         spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n-                         std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(),\n-                               makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n-                                   const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n-                                   if (tracker->checkForError(response)) {\n-                                       tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n-                                   }\n-                                   if (!response.wasFound()) {\n-                                       metrics.notFound.inc();\n-                                   }\n-                                   tracker->sendReply();\n-                               })));\n+        auto task = makeResultTask([&metrics, &cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {\n+            const spi::RemoveResult & response = dynamic_cast<const spi::RemoveResult &>(*responseUP);\n+            if (tracker->checkForError(response)) {\n+                tracker->setReply(std::make_shared<api::RemoveReply>(cmd, response.wasFound() ? cmd.getTimestamp() : 0));\n+            }\n+            if (!response.wasFound()) {\n+                metrics.notFound.inc();\n+            }\n+            tracker->sendReply();\n+        });\n+        _spi.removeIfFoundAsync(bucket, spi::Timestamp(cmd.getTimestamp()), cmd.getDocumentId(), tracker.context(),\n+                                std::make_unique<ResultTaskOperationDone>(*_sequencedExecutor, cmd.getBucketId(), std::move(task)));\n     }\n     return trackerUP;\n }\n \n MessageTracker::UP\n-PersistenceThread::handleUpdate(api::UpdateCommand& cmd, MessageTracker::UP tracker)\n+PersistenceThread::handleUpdate(api::UpdateCommand& cmd, MessageTracker::UP trackerUP)\n {\n+    MessageTracker & tracker = *trackerUP;\n     auto& metrics = _env._metrics.update[cmd.getLoadType()];\n-    tracker->setMetric(metrics);\n+    tracker.setMetric(metrics);\n     metrics.request_size.addValue(cmd.getApproxByteSize());\n \n-    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, *tracker, tracker->context(), cmd.getUpdate()->getCreateIfNonExistent())) {\n-        return tracker;\n+    if (tasConditionExists(cmd) && !tasConditionMatches(cmd, tracker, tracker.context(), cmd.getUpdate()->getCreateIfNonExistent())) {\n+        return trackerUP;\n     }\n-    \n-    spi::UpdateResult response = _spi.update(getBucket(cmd.getUpdate()->getId(), cmd.getBucket()),\n-                                             spi::Timestamp(cmd.getTimestamp()), cmd.getUpdate(), tracker->context());\n-    if (tracker->checkForError(response)) {\n-        auto reply = std::make_shared<api::UpdateReply>(cmd);\n-        reply->setOldTimestamp(response.getExistingTimestamp());\n-        tracker->setReply(std::move(reply));\n+\n+    spi::Bucket bucket = getBucket(cmd.getDocumentId(), cmd.getBucket());\n+    if (_sequencedExecutor == nullptr) {\n+        spi::UpdateResult response = _spi.update(bucket, spi::Timestamp(cmd.getTimestamp()), std::move(cmd.getUpdate()),tracker.context());\n+        if (tracker.checkForError(response)) {\n+            auto reply = std::make_shared<api::UpdateReply>(cmd);\n+            reply->setOldTimestamp(response.getExistingTimestamp());\n+            tracker.setReply(std::move(reply));\n+        }\n+    } else {\n+        auto task = makeResultTask([&cmd, tracker = std::move(trackerUP)](spi::Result::UP responseUP) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MDI1Mg=="}, "originalCommit": {"oid": "bbfebdcf506f8b638ce40b28e47c3657cf002055"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1701, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}