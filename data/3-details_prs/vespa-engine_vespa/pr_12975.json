{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1NTg4MjQw", "number": 12975, "title": "Since gcc does not provide lock free 16 byte access we must do so our\u2026", "bodyText": "\u2026selves.\n@toregge and @vekterli PR", "createdAt": "2020-04-19T01:38:51Z", "url": "https://github.com/vespa-engine/vespa/pull/12975", "merged": true, "mergeCommit": {"oid": "38de83ee72a4e39befc021f8be797e91f0c1a422"}, "closed": true, "closedAt": "2020-04-19T19:07:46Z", "author": {"login": "baldersheim"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZAVQCAH2gAyNDA1NTg4MjQwOjQ5OWM0N2Q1NGIzN2IwNjdlNzY0ODIxZTIzMmY3OGFiNjQzYTViOTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZeQJvgFqTM5NjM3NjQ0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "499c47d54b37b067e764821e232f78ab643a5b98", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/499c47d54b37b067e764821e232f78ab643a5b98", "committedDate": "2020-04-19T01:37:24Z", "message": "Since gcc does not provide lock free 16 byte access we must do so ourselves."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MDI0NTg1", "url": "https://github.com/vespa-engine/vespa/pull/12975#pullrequestreview-396024585", "createdAt": "2020-04-19T14:26:02Z", "commit": {"oid": "499c47d54b37b067e764821e232f78ab643a5b98"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNDoyNjowMlrOGH4ZmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQxNDoyODozMFrOGH4bUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzI3Mg==", "bodyText": "Edited: looking at the use in AFListBase, the side effect of a teared load is just a retry. So this should be OK for the use, but we might want to add comment describing that a teared load is not an issue.", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410917272", "createdAt": "2020-04-19T14:26:02Z", "author": {"login": "toregge"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,48 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+#define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "499c47d54b37b067e764821e232f78ab643a5b98"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDkxNzcxNA==", "bodyText": "Edited: The store is not atomic, but it is only used in a unit test before starting the test threads. Perhaps add a comment describing that a teared store is not an issue.", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r410917714", "createdAt": "2020-04-19T14:28:30Z", "author": {"login": "toregge"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,48 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+#define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "499c47d54b37b067e764821e232f78ab643a5b98"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MDI3MzY3", "url": "https://github.com/vespa-engine/vespa/pull/12975#pullrequestreview-396027367", "createdAt": "2020-04-19T14:52:58Z", "commit": {"oid": "499c47d54b37b067e764821e232f78ab643a5b98"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa70ed3fa69fa0393e21945adeec56314619536b", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/aa70ed3fa69fa0393e21945adeec56314619536b", "committedDate": "2020-04-19T18:46:59Z", "message": "Add comment about shortcut."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99834fd9c67c9baad2e56f151a4bbe30edfd5322", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/99834fd9c67c9baad2e56f151a4bbe30edfd5322", "committedDate": "2020-04-19T19:01:34Z", "message": "Fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MDUxMjE1", "url": "https://github.com/vespa-engine/vespa/pull/12975#pullrequestreview-396051215", "createdAt": "2020-04-19T19:03:59Z", "commit": {"oid": "99834fd9c67c9baad2e56f151a4bbe30edfd5322"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2Mzc2NDQz", "url": "https://github.com/vespa-engine/vespa/pull/12975#pullrequestreview-396376443", "createdAt": "2020-04-20T11:42:44Z", "commit": {"oid": "99834fd9c67c9baad2e56f151a4bbe30edfd5322"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMTo0Mjo0NFrOGIQYSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMjoyNjozOFrOGIR7Sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxMDE1NQ==", "bodyText": "store/load/compare_exchange_weak could be noexcept", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r411310155", "createdAt": "2020-04-20T11:42:44Z", "author": {"login": "vekterli"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,53 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+    #define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        // Note that this is NOT an atomic load. The current use as the initial load\n+        // in a compare_exchange loop is safe as a teared load will just give a retry.\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {\n+        // Note that this is NOT an atomic store. The current use is in a unit test as an initial\n+        // store before any threads are started. Just done so to keep api compatible with std::atomic as\n+        // that is the preferred implementation..\n+        *this = ptr;\n+    }\n+    bool\n+    compare_exchange_weak(TaggedPtr & oldPtr, TaggedPtr newPtr, std::memory_order, std::memory_order) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99834fd9c67c9baad2e56f151a4bbe30edfd5322"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMzNTQ5OA==", "bodyText": "What does %6 signify in this case?", "url": "https://github.com/vespa-engine/vespa/pull/12975#discussion_r411335498", "createdAt": "2020-04-20T12:26:38Z", "author": {"login": "vekterli"}, "path": "vespamalloc/src/vespamalloc/malloc/allocchunk.h", "diffHunk": "@@ -20,16 +20,53 @@ struct TaggedPtr {\n     TaggedPtr() noexcept : _ptr(nullptr), _tag(0) { }\n     TaggedPtr(void *h, size_t t) noexcept : _ptr(h), _tag(t) {}\n \n+#if defined(__x86_64__)\n+    #define VESPA_USE_ATOMIC_TAGGEDPTR\n+    TaggedPtr load(std::memory_order = std::memory_order_seq_cst) {\n+        // Note that this is NOT an atomic load. The current use as the initial load\n+        // in a compare_exchange loop is safe as a teared load will just give a retry.\n+        return *this;\n+    }\n+    void store(TaggedPtr ptr) {\n+        // Note that this is NOT an atomic store. The current use is in a unit test as an initial\n+        // store before any threads are started. Just done so to keep api compatible with std::atomic as\n+        // that is the preferred implementation..\n+        *this = ptr;\n+    }\n+    bool\n+    compare_exchange_weak(TaggedPtr & oldPtr, TaggedPtr newPtr, std::memory_order, std::memory_order) {\n+        char result;\n+        __asm__ volatile (\n+        \"lock ;\"\n+        \"cmpxchg16b %6;\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99834fd9c67c9baad2e56f151a4bbe30edfd5322"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3340, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}