{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczODMzOTk2", "number": 14165, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowOToyNFrOEdMR1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNjo1Mjo1NlrOEewOLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ1MzMzOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/application.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowOToyNFrOHINUxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxOTo1NzowOFrOHKHLWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2ODk2Nw==", "bodyText": "Not sure if this works against the local docker instance.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478368967", "createdAt": "2020-08-27T12:09:24Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -87,7 +90,7 @@ def query(\n         if debug_request:\n             return VespaResult(vespa_result={}, request_body=body)\n         else:\n-            r = post(self.search_end_point, json=body)\n+            r = post(self.search_end_point, json=body, cert=self.cert)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM2NTQwMw==", "bodyText": "Yes, it works.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480365403", "createdAt": "2020-08-31T19:57:08Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -87,7 +90,7 @@ def query(\n         if debug_request:\n             return VespaResult(vespa_result={}, request_body=body)\n         else:\n-            r = post(self.search_end_point, json=body)\n+            r = post(self.search_end_point, json=body, cert=self.cert)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2ODk2Nw=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ1MzYwOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/application.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowOToyOVrOHINU7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowOToyOVrOHINU7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2OTAwNQ==", "bodyText": "Same here.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478369005", "createdAt": "2020-08-27T12:09:29Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -103,7 +106,7 @@ def feed_data_point(self, schema: str, data_id: str, fields: Dict) -> Response:\n             self.end_point, schema, schema, str(data_id)\n         )\n         vespa_format = {\"fields\": fields}\n-        response = post(end_point, json=vespa_format)\n+        response = post(end_point, json=vespa_format, cert=self.cert)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ2MTEyOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMToyM1rOHINZUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoxMTozMlrOHJAyUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ==", "bodyText": "This file can only be read by the user writing it, and is deleted immediately when closed. The VespaCloud closes this file on its close, and is meant to be used like\nwith VespaCloud('tenant', 'application', '/path/to/api_key') as cloud:\n    ...", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478370131", "createdAt": "2020-08-27T12:11:23Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3NTY1Ng==", "bodyText": "Is there a way to use an in-memory file object instead of a temporary on-disk file?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478875656", "createdAt": "2020-08-28T07:13:54Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg4NTI1MQ==", "bodyText": "Absolutely not, unfortunately. It's been filed as a \"bug\" for 8 years, but nothing has happened.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478885251", "createdAt": "2020-08-28T07:29:58Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg4NjA2Nw==", "bodyText": "There were even made PRs to address the issue, but the maintainers rejected them because they wanted a \"perfect\" solution, but this solution has, of course, not arrived, nor does it seem like it will.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478886067", "createdAt": "2020-08-28T07:30:55Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg4OTc5MA==", "bodyText": "How pythonic", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478889790", "createdAt": "2020-08-28T07:35:21Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE5ODY0Nw==", "bodyText": "Another option is to use\nvespa_cloud = VespaCloud(\"vespa-team\", \"ms-marco\", \"/Users/tmartins/sample_application/tmartins.vespa-team.pem\")\napp = vespa_cloud.deploy('from-notebook', app_package)\n\nThen continue  doing all the operation like app.feed_data_point(...) and then use app.close() when you are done.\nDoes that makes sense @jonmv?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479198647", "createdAt": "2020-08-28T11:59:49Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIwNTUzMw==", "bodyText": "Do you mean if it makes sense to move generation of data place key/cert to when you deploy, so it lives only while  a particular deployment (Vespa object) is in scope? I think that makes sense, but there's not much practical difference. You can avoid keeping the VespaCloud object in scope, but that's it.\nAnd for the certificates, it's possible to just never .close() the object, of course. But you'd have a hard time finding the certificate file without printing its name somewhere ... :)", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479205533", "createdAt": "2020-08-28T12:05:59Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIwNzg5Nw==", "bodyText": "with VespaCloud(...) as cloud:\n    with cloud.deploy(...) as app:\n        # both variables are in scope now, as you can't have the Vespa in scope without the VespaCloud anyway\n        # and the VespaCloud is intended to be closed regardless of where the certs are, due to its HTTPConnection", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479207897", "createdAt": "2020-08-28T12:08:06Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIwOTMwMA==", "bodyText": "\u00a0I guess you could perhaps do\nwith VespaCloud(...) as cloud:\n    app = cloud.deploy(...)\n\nwith app:\n    # do stuff", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479209300", "createdAt": "2020-08-28T12:09:16Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxMjExMw==", "bodyText": "Anyway, these are all details. Do whatever you think is better :)", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479212113", "createdAt": "2020-08-28T12:11:32Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ2NTgyOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMjoyOFrOHINb8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMjoyOFrOHINb8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDgwMA==", "bodyText": "Hard-coded container name here. Remember this is the container name changes (in services.xml).", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478370800", "createdAt": "2020-08-27T12:12:28Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')\n+        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP521R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n+        certificate = x509.CertificateBuilder() \\\n+            .subject_name(name) \\\n+            .issuer_name(name) \\\n+            .serial_number(x509.random_serial_number()) \\\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n+            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n+            .public_key(key.public_key()) \\\n+            .sign(key, hashes.SHA256(), default_backend())\n+        return (key, certificate)\n+\n+    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n+        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n+        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n+        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n+\n+    def get_endpoint(self, instance: str, region: str) -> str:\n+        endpoints = self.request('GET',\n+                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n+                                 .format(self.tenant, self.application, instance, region))['endpoints']\n+        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDQ3ODQxOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxNTowOFrOHINjEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjo0MzoyM1rOHJDDqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjYyNw==", "bodyText": "This deletes the data key/cert forever. Consider allowing the user to specify the certificate file, for persistent storage, if it's meaningful to allow the user to keep talking to its endpoint outside of the python code, or if the VespaCloud variable can't be kept in scope.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478372627", "createdAt": "2020-08-27T12:15:08Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')\n+        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP521R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n+        certificate = x509.CertificateBuilder() \\\n+            .subject_name(name) \\\n+            .issuer_name(name) \\\n+            .serial_number(x509.random_serial_number()) \\\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n+            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n+            .public_key(key.public_key()) \\\n+            .sign(key, hashes.SHA256(), default_backend())\n+        return (key, certificate)\n+\n+    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n+        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n+        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n+        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n+\n+    def get_endpoint(self, instance: str, region: str) -> str:\n+        endpoints = self.request('GET',\n+                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n+                                 .format(self.tenant, self.application, instance, region))['endpoints']\n+        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n+        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n+            .format(self.tenant, self.application, instance, job)\n+        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n+        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n+        print(response['message'])\n+        return response['run']\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request('GET',\n+                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n+                                  .format(self.tenant, self.application, instance, job, run, last))\n+\n+            for step, entries in update['log'].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get('lastId', last)\n+\n+            if update['active']:\n+                sleep(1)\n+            else:\n+                status = update['status']\n+                if   status == 'success':                    return\n+                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n+                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n+                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n+                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n+                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n+                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime('%H:%M:%S', gmtime(entry['at'] / 1e3))\n+        message = entry['message'].replace('\\n', '\\n' + ' '*23)\n+        if step != 'copyVespaLogs' or entry['type'] == 'error':\n+            print('{:<7} [{}]  {}'.format(entry['type'].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+\n+        region = self.get_dev_region()\n+        job = 'dev-' + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(instance, region)\n+        return Vespa(url = endpoint_url, cert = self.data_cert_file.name)\n+\n+    def close(self):\n+        self.connection.close()\n+        self.data_cert_file.close()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIwMDc1MQ==", "bodyText": "I believe that using\nvespa_cloud = VespaCloud(\"vespa-team\", \"ms-marco\", \"/Users/tmartins/sample_application/tmartins.vespa-team.pem\")\napp = vespa_cloud.deploy('from-notebook', app_package)\n# run as many commands as one needs\napp.close()\n\nsolves the case where the VespaCloud variable can't be kept in scope.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479200751", "createdAt": "2020-08-28T12:01:44Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')\n+        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP521R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n+        certificate = x509.CertificateBuilder() \\\n+            .subject_name(name) \\\n+            .issuer_name(name) \\\n+            .serial_number(x509.random_serial_number()) \\\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n+            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n+            .public_key(key.public_key()) \\\n+            .sign(key, hashes.SHA256(), default_backend())\n+        return (key, certificate)\n+\n+    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n+        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n+        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n+        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n+\n+    def get_endpoint(self, instance: str, region: str) -> str:\n+        endpoints = self.request('GET',\n+                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n+                                 .format(self.tenant, self.application, instance, region))['endpoints']\n+        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n+        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n+            .format(self.tenant, self.application, instance, job)\n+        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n+        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n+        print(response['message'])\n+        return response['run']\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request('GET',\n+                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n+                                  .format(self.tenant, self.application, instance, job, run, last))\n+\n+            for step, entries in update['log'].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get('lastId', last)\n+\n+            if update['active']:\n+                sleep(1)\n+            else:\n+                status = update['status']\n+                if   status == 'success':                    return\n+                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n+                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n+                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n+                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n+                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n+                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime('%H:%M:%S', gmtime(entry['at'] / 1e3))\n+        message = entry['message'].replace('\\n', '\\n' + ' '*23)\n+        if step != 'copyVespaLogs' or entry['type'] == 'error':\n+            print('{:<7} [{}]  {}'.format(entry['type'].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+\n+        region = self.get_dev_region()\n+        job = 'dev-' + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(instance, region)\n+        return Vespa(url = endpoint_url, cert = self.data_cert_file.name)\n+\n+    def close(self):\n+        self.connection.close()\n+        self.data_cert_file.close()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjYyNw=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIwMjA4Mw==", "bodyText": "I think it is best to let them generate the certificate themselves if they want to talk to the end-point outside of the python code. As the intent of this library is to make experiments from a python environment.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479202083", "createdAt": "2020-08-28T12:02:56Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')\n+        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP521R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n+        certificate = x509.CertificateBuilder() \\\n+            .subject_name(name) \\\n+            .issuer_name(name) \\\n+            .serial_number(x509.random_serial_number()) \\\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n+            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n+            .public_key(key.public_key()) \\\n+            .sign(key, hashes.SHA256(), default_backend())\n+        return (key, certificate)\n+\n+    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n+        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n+        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n+        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n+\n+    def get_endpoint(self, instance: str, region: str) -> str:\n+        endpoints = self.request('GET',\n+                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n+                                 .format(self.tenant, self.application, instance, region))['endpoints']\n+        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n+        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n+            .format(self.tenant, self.application, instance, job)\n+        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n+        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n+        print(response['message'])\n+        return response['run']\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request('GET',\n+                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n+                                  .format(self.tenant, self.application, instance, job, run, last))\n+\n+            for step, entries in update['log'].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get('lastId', last)\n+\n+            if update['active']:\n+                sleep(1)\n+            else:\n+                status = update['status']\n+                if   status == 'success':                    return\n+                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n+                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n+                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n+                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n+                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n+                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime('%H:%M:%S', gmtime(entry['at'] / 1e3))\n+        message = entry['message'].replace('\\n', '\\n' + ' '*23)\n+        if step != 'copyVespaLogs' or entry['type'] == 'error':\n+            print('{:<7} [{}]  {}'.format(entry['type'].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+\n+        region = self.get_dev_region()\n+        job = 'dev-' + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(instance, region)\n+        return Vespa(url = endpoint_url, cert = self.data_cert_file.name)\n+\n+    def close(self):\n+        self.connection.close()\n+        self.data_cert_file.close()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjYyNw=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzNDYzNw==", "bodyText": "Yes, you'd need to move the key/cert stuff to the deploy(...) call, but that's possible.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479234637", "createdAt": "2020-08-28T12:30:47Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')\n+        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP521R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n+        certificate = x509.CertificateBuilder() \\\n+            .subject_name(name) \\\n+            .issuer_name(name) \\\n+            .serial_number(x509.random_serial_number()) \\\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n+            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n+            .public_key(key.public_key()) \\\n+            .sign(key, hashes.SHA256(), default_backend())\n+        return (key, certificate)\n+\n+    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n+        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n+        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n+        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n+\n+    def get_endpoint(self, instance: str, region: str) -> str:\n+        endpoints = self.request('GET',\n+                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n+                                 .format(self.tenant, self.application, instance, region))['endpoints']\n+        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n+        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n+            .format(self.tenant, self.application, instance, job)\n+        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n+        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n+        print(response['message'])\n+        return response['run']\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request('GET',\n+                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n+                                  .format(self.tenant, self.application, instance, job, run, last))\n+\n+            for step, entries in update['log'].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get('lastId', last)\n+\n+            if update['active']:\n+                sleep(1)\n+            else:\n+                status = update['status']\n+                if   status == 'success':                    return\n+                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n+                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n+                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n+                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n+                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n+                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime('%H:%M:%S', gmtime(entry['at'] / 1e3))\n+        message = entry['message'].replace('\\n', '\\n' + ' '*23)\n+        if step != 'copyVespaLogs' or entry['type'] == 'error':\n+            print('{:<7} [{}]  {}'.format(entry['type'].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+\n+        region = self.get_dev_region()\n+        job = 'dev-' + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(instance, region)\n+        return Vespa(url = endpoint_url, cert = self.data_cert_file.name)\n+\n+    def close(self):\n+        self.connection.close()\n+        self.data_cert_file.close()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjYyNw=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzNTY4NQ==", "bodyText": "You should prefer with ...:, though, to ensure resources are closed when exceptions are thrown.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479235685", "createdAt": "2020-08-28T12:31:40Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')\n+        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP521R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n+        certificate = x509.CertificateBuilder() \\\n+            .subject_name(name) \\\n+            .issuer_name(name) \\\n+            .serial_number(x509.random_serial_number()) \\\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n+            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n+            .public_key(key.public_key()) \\\n+            .sign(key, hashes.SHA256(), default_backend())\n+        return (key, certificate)\n+\n+    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n+        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n+        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n+        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n+\n+    def get_endpoint(self, instance: str, region: str) -> str:\n+        endpoints = self.request('GET',\n+                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n+                                 .format(self.tenant, self.application, instance, region))['endpoints']\n+        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n+        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n+            .format(self.tenant, self.application, instance, job)\n+        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n+        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n+        print(response['message'])\n+        return response['run']\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request('GET',\n+                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n+                                  .format(self.tenant, self.application, instance, job, run, last))\n+\n+            for step, entries in update['log'].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get('lastId', last)\n+\n+            if update['active']:\n+                sleep(1)\n+            else:\n+                status = update['status']\n+                if   status == 'success':                    return\n+                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n+                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n+                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n+                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n+                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n+                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime('%H:%M:%S', gmtime(entry['at'] / 1e3))\n+        message = entry['message'].replace('\\n', '\\n' + ' '*23)\n+        if step != 'copyVespaLogs' or entry['type'] == 'error':\n+            print('{:<7} [{}]  {}'.format(entry['type'].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+\n+        region = self.get_dev_region()\n+        job = 'dev-' + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(instance, region)\n+        return Vespa(url = endpoint_url, cert = self.data_cert_file.name)\n+\n+    def close(self):\n+        self.connection.close()\n+        self.data_cert_file.close()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjYyNw=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0OTMyMg==", "bodyText": "No, I don't need to change anything. My code above is wrong and I meant vespa_cloud.close() instead of app.close()\nI don't need to move anything to .deploy() as the Vespa instance knows the location of the cert.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479249322", "createdAt": "2020-08-28T12:43:23Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')\n+        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP521R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n+        certificate = x509.CertificateBuilder() \\\n+            .subject_name(name) \\\n+            .issuer_name(name) \\\n+            .serial_number(x509.random_serial_number()) \\\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n+            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n+            .public_key(key.public_key()) \\\n+            .sign(key, hashes.SHA256(), default_backend())\n+        return (key, certificate)\n+\n+    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n+        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n+        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n+        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n+\n+    def get_endpoint(self, instance: str, region: str) -> str:\n+        endpoints = self.request('GET',\n+                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n+                                 .format(self.tenant, self.application, instance, region))['endpoints']\n+        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n+        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n+            .format(self.tenant, self.application, instance, job)\n+        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n+        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n+        print(response['message'])\n+        return response['run']\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request('GET',\n+                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n+                                  .format(self.tenant, self.application, instance, job, run, last))\n+\n+            for step, entries in update['log'].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get('lastId', last)\n+\n+            if update['active']:\n+                sleep(1)\n+            else:\n+                status = update['status']\n+                if   status == 'success':                    return\n+                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n+                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n+                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n+                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n+                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n+                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime('%H:%M:%S', gmtime(entry['at'] / 1e3))\n+        message = entry['message'].replace('\\n', '\\n' + ' '*23)\n+        if step != 'copyVespaLogs' or entry['type'] == 'error':\n+            print('{:<7} [{}]  {}'.format(entry['type'].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+\n+        region = self.get_dev_region()\n+        job = 'dev-' + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(instance, region)\n+        return Vespa(url = endpoint_url, cert = self.data_cert_file.name)\n+\n+    def close(self):\n+        self.connection.close()\n+        self.data_cert_file.close()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjYyNw=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzY4NTQ2OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/application.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzowMjoyMlrOHIr79w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoxNzowNFrOHJBLAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3MDUxOQ==", "bodyText": "Please indicate the type of the string. Is it a filename, two PEM encoded objects, etc.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478870519", "createdAt": "2020-08-28T07:02:22Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -15,13 +15,15 @@ def __init__(\n         url: str,\n         port: Optional[int] = None,\n         deployment_message: Optional[List[str]] = None,\n+        cert: Optional[str] = None,\n     ) -> None:\n         \"\"\"\n         Establish a connection with a Vespa application.\n \n         :param url: URL\n         :param port: Port\n         :param deployment_message: Message returned by Vespa engine after deployment.\n+        :param cert: Certificate and key pair used for mTLS.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg4NjI3MQ==", "bodyText": "Fixed.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478886271", "createdAt": "2020-08-28T07:31:10Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -15,13 +15,15 @@ def __init__(\n         url: str,\n         port: Optional[int] = None,\n         deployment_message: Optional[List[str]] = None,\n+        cert: Optional[str] = None,\n     ) -> None:\n         \"\"\"\n         Establish a connection with a Vespa application.\n \n         :param url: URL\n         :param port: Port\n         :param deployment_message: Message returned by Vespa engine after deployment.\n+        :param cert: Certificate and key pair used for mTLS.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3MDUxOQ=="}, "originalCommit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxODQzNA==", "bodyText": "I initially believed it would be possible to send the actual cert and key, of course ... >_<", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479218434", "createdAt": "2020-08-28T12:17:04Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -15,13 +15,15 @@ def __init__(\n         url: str,\n         port: Optional[int] = None,\n         deployment_message: Optional[List[str]] = None,\n+        cert: Optional[str] = None,\n     ) -> None:\n         \"\"\"\n         Establish a connection with a Vespa application.\n \n         :param url: URL\n         :param port: Port\n         :param deployment_message: Message returned by Vespa engine after deployment.\n+        :param cert: Certificate and key pair used for mTLS.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3MDUxOQ=="}, "originalCommit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MzcxOTkzOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/application.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoxNDozMlrOHIsRHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzozMTozMFrOHIs6nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3NTkzNA==", "bodyText": "This should indicate the type in the cert. Is it a file name or the object itself?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478875934", "createdAt": "2020-08-28T07:14:32Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -15,13 +15,15 @@ def __init__(\n         url: str,\n         port: Optional[int] = None,\n         deployment_message: Optional[List[str]] = None,\n+        cert: Optional[str] = None,\n     ) -> None:\n         \"\"\"\n         Establish a connection with a Vespa application.\n \n         :param url: URL\n         :param port: Port\n         :param deployment_message: Message returned by Vespa engine after deployment.\n+        :param cert: Certificate and key pair used for mTLS.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3NjYxOA==", "bodyText": "This is a duplicate of the comment above \ud83e\udd37", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478876618", "createdAt": "2020-08-28T07:16:04Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -15,13 +15,15 @@ def __init__(\n         url: str,\n         port: Optional[int] = None,\n         deployment_message: Optional[List[str]] = None,\n+        cert: Optional[str] = None,\n     ) -> None:\n         \"\"\"\n         Establish a connection with a Vespa application.\n \n         :param url: URL\n         :param port: Port\n         :param deployment_message: Message returned by Vespa engine after deployment.\n+        :param cert: Certificate and key pair used for mTLS.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3NTkzNA=="}, "originalCommit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg4NjU1OQ==", "bodyText": "Yeah \ud83e\udd37\u200d\u2642\ufe0f", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478886559", "createdAt": "2020-08-28T07:31:30Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -15,13 +15,15 @@ def __init__(\n         url: str,\n         port: Optional[int] = None,\n         deployment_message: Optional[List[str]] = None,\n+        cert: Optional[str] = None,\n     ) -> None:\n         \"\"\"\n         Establish a connection with a Vespa application.\n \n         :param url: URL\n         :param port: Port\n         :param deployment_message: Message returned by Vespa engine after deployment.\n+        :param cert: Certificate and key pair used for mTLS.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3NTkzNA=="}, "originalCommit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NTc3MzM2OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoxMzoxOVrOHJA57A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQwNjoyNjozM1rOHJr8TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNDA2MA==", "bodyText": "Hehe, this is why I hate autoformatters :)", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479214060", "createdAt": "2020-08-28T12:13:19Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -504,122 +513,208 @@ def __init__(self, tenant: str, application: str, key_location: str) -> None:\n         self.tenant = tenant\n         self.application = application\n         self.api_key = self.read_private_key(key_location)\n-        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n         self.data_key, self.data_certificate = self.create_certificate_pair()\n-        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n-        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+        self.data_cert_file = self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate\n+        )\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n \n     @staticmethod\n     def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n-        with open(key_location, 'rb') as key_data:\n-            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n             if not isinstance(key, ec.EllipticCurvePrivateKey):\n-                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n             return key\n \n     @staticmethod\n-    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n-        cert_file = tempfile.NamedTemporaryFile('wt')\n-        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n-        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+    def write_private_key_and_cert(\n+        key: ec.EllipticCurvePrivateKey, cert: x509.Certificate\n+    ) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile(\"wt\")\n+        cert_file.write(\n+            key.private_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PrivateFormat.TraditionalOpenSSL,\n+                serialization.NoEncryption(),\n+            ).decode(\"UTF-8\")\n+        )\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n         cert_file.flush()\n         return cert_file\n \n     @staticmethod\n     def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n         key = ec.generate_private_key(ec.SECP384R1, default_backend())\n-        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n-        certificate = x509.CertificateBuilder() \\\n-            .subject_name(name) \\\n-            .issuer_name(name) \\\n-            .serial_number(x509.random_serial_number()) \\\n-            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n-            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n-            .public_key(key.public_key()) \\\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n             .sign(key, hashes.SHA256(), default_backend())\n+        )\n         return (key, certificate)\n \n-    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n         digest = hashes.Hash(hashes.SHA256(), default_backend())\n         body.seek(0)\n         digest.update(body.read())\n-        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n-        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n-        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n-\n-        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n-        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n \n         headers = {\n             \"X-Timestamp\": timestamp,\n             \"X-Content-Hash\": content_hash,\n-            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n             \"X-Key\": self.api_public_key_bytes,\n             \"X-Authorization\": standard_b64encode(signature),\n-            **headers\n+            **headers,\n         }\n \n         body.seek(0)\n         self.connection.request(method, path, body, headers)\n         with self.connection.getresponse() as response:\n             parsed = json.load(response)\n             if response.status != 200:\n-                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n             return parsed\n \n     def get_dev_region(self) -> str:\n-        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n-\n-    def get_endpoint(self, instance: str, region: str) -> str:\n-        endpoints = self.request('GET',\n-                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n-                                 .format(self.tenant, self.application, instance, region))['endpoints']\n-        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n         if not container_url:\n             raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n         return container_url[0]\n \n-    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n-        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n-            .format(self.tenant, self.application, instance, job)\n-        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n-        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n-        print(response['message'])\n-        return response['run']\n+    def start_deployment(\n+        self, instance: str, job: str, application_package: ApplicationPackage\n+    ) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+        application_zip_bytes = application_package.to_application_zip(\n+            {\n+                \"application/security/clients.pem\": self.data_certificate.public_bytes(\n+                    serialization.Encoding.PEM\n+                )\n+            }\n+        )\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n \n     def follow_deployment(self, instance: str, job: str, run: int):\n         last = -1\n         while True:\n-            update = self.request('GET',\n-                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n-                                  .format(self.tenant, self.application, instance, job, run, last))\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n \n-            for step, entries in update['log'].items():\n+            for step, entries in update[\"log\"].items():\n                 for entry in entries:\n                     self.print_log_entry(step, entry)\n-            last = update.get('lastId', last)\n+            last = update.get(\"lastId\", last)\n \n-            if update['active']:\n+            if update[\"active\"]:\n                 sleep(1)\n             else:\n-                status = update['status']\n-                if   status == 'success':                    return\n-                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n-                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n-                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n-                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n-                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n-                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n-                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n-                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n-                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI2NTQ4Mg==", "bodyText": "@oyving sold me on black a while ago, now it is hard to live without it.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479265482", "createdAt": "2020-08-28T13:02:15Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -504,122 +513,208 @@ def __init__(self, tenant: str, application: str, key_location: str) -> None:\n         self.tenant = tenant\n         self.application = application\n         self.api_key = self.read_private_key(key_location)\n-        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n         self.data_key, self.data_certificate = self.create_certificate_pair()\n-        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n-        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+        self.data_cert_file = self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate\n+        )\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n \n     @staticmethod\n     def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n-        with open(key_location, 'rb') as key_data:\n-            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n             if not isinstance(key, ec.EllipticCurvePrivateKey):\n-                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n             return key\n \n     @staticmethod\n-    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n-        cert_file = tempfile.NamedTemporaryFile('wt')\n-        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n-        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+    def write_private_key_and_cert(\n+        key: ec.EllipticCurvePrivateKey, cert: x509.Certificate\n+    ) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile(\"wt\")\n+        cert_file.write(\n+            key.private_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PrivateFormat.TraditionalOpenSSL,\n+                serialization.NoEncryption(),\n+            ).decode(\"UTF-8\")\n+        )\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n         cert_file.flush()\n         return cert_file\n \n     @staticmethod\n     def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n         key = ec.generate_private_key(ec.SECP384R1, default_backend())\n-        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n-        certificate = x509.CertificateBuilder() \\\n-            .subject_name(name) \\\n-            .issuer_name(name) \\\n-            .serial_number(x509.random_serial_number()) \\\n-            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n-            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n-            .public_key(key.public_key()) \\\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n             .sign(key, hashes.SHA256(), default_backend())\n+        )\n         return (key, certificate)\n \n-    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n         digest = hashes.Hash(hashes.SHA256(), default_backend())\n         body.seek(0)\n         digest.update(body.read())\n-        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n-        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n-        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n-\n-        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n-        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n \n         headers = {\n             \"X-Timestamp\": timestamp,\n             \"X-Content-Hash\": content_hash,\n-            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n             \"X-Key\": self.api_public_key_bytes,\n             \"X-Authorization\": standard_b64encode(signature),\n-            **headers\n+            **headers,\n         }\n \n         body.seek(0)\n         self.connection.request(method, path, body, headers)\n         with self.connection.getresponse() as response:\n             parsed = json.load(response)\n             if response.status != 200:\n-                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n             return parsed\n \n     def get_dev_region(self) -> str:\n-        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n-\n-    def get_endpoint(self, instance: str, region: str) -> str:\n-        endpoints = self.request('GET',\n-                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n-                                 .format(self.tenant, self.application, instance, region))['endpoints']\n-        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n         if not container_url:\n             raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n         return container_url[0]\n \n-    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n-        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n-            .format(self.tenant, self.application, instance, job)\n-        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n-        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n-        print(response['message'])\n-        return response['run']\n+    def start_deployment(\n+        self, instance: str, job: str, application_package: ApplicationPackage\n+    ) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+        application_zip_bytes = application_package.to_application_zip(\n+            {\n+                \"application/security/clients.pem\": self.data_certificate.public_bytes(\n+                    serialization.Encoding.PEM\n+                )\n+            }\n+        )\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n \n     def follow_deployment(self, instance: str, job: str, run: int):\n         last = -1\n         while True:\n-            update = self.request('GET',\n-                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n-                                  .format(self.tenant, self.application, instance, job, run, last))\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n \n-            for step, entries in update['log'].items():\n+            for step, entries in update[\"log\"].items():\n                 for entry in entries:\n                     self.print_log_entry(step, entry)\n-            last = update.get('lastId', last)\n+            last = update.get(\"lastId\", last)\n \n-            if update['active']:\n+            if update[\"active\"]:\n                 sleep(1)\n             else:\n-                status = update['status']\n-                if   status == 'success':                    return\n-                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n-                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n-                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n-                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n-                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n-                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n-                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n-                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n-                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNDA2MA=="}, "originalCommit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTkxOTE4MA==", "bodyText": "Yeah, pros and cons :)", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479919180", "createdAt": "2020-08-31T06:26:33Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -504,122 +513,208 @@ def __init__(self, tenant: str, application: str, key_location: str) -> None:\n         self.tenant = tenant\n         self.application = application\n         self.api_key = self.read_private_key(key_location)\n-        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n         self.data_key, self.data_certificate = self.create_certificate_pair()\n-        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n-        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+        self.data_cert_file = self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate\n+        )\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n \n     @staticmethod\n     def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n-        with open(key_location, 'rb') as key_data:\n-            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n             if not isinstance(key, ec.EllipticCurvePrivateKey):\n-                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n             return key\n \n     @staticmethod\n-    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n-        cert_file = tempfile.NamedTemporaryFile('wt')\n-        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n-        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+    def write_private_key_and_cert(\n+        key: ec.EllipticCurvePrivateKey, cert: x509.Certificate\n+    ) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile(\"wt\")\n+        cert_file.write(\n+            key.private_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PrivateFormat.TraditionalOpenSSL,\n+                serialization.NoEncryption(),\n+            ).decode(\"UTF-8\")\n+        )\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n         cert_file.flush()\n         return cert_file\n \n     @staticmethod\n     def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n         key = ec.generate_private_key(ec.SECP384R1, default_backend())\n-        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n-        certificate = x509.CertificateBuilder() \\\n-            .subject_name(name) \\\n-            .issuer_name(name) \\\n-            .serial_number(x509.random_serial_number()) \\\n-            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n-            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n-            .public_key(key.public_key()) \\\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n             .sign(key, hashes.SHA256(), default_backend())\n+        )\n         return (key, certificate)\n \n-    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n         digest = hashes.Hash(hashes.SHA256(), default_backend())\n         body.seek(0)\n         digest.update(body.read())\n-        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n-        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n-        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n-\n-        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n-        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n \n         headers = {\n             \"X-Timestamp\": timestamp,\n             \"X-Content-Hash\": content_hash,\n-            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n             \"X-Key\": self.api_public_key_bytes,\n             \"X-Authorization\": standard_b64encode(signature),\n-            **headers\n+            **headers,\n         }\n \n         body.seek(0)\n         self.connection.request(method, path, body, headers)\n         with self.connection.getresponse() as response:\n             parsed = json.load(response)\n             if response.status != 200:\n-                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n             return parsed\n \n     def get_dev_region(self) -> str:\n-        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n-\n-    def get_endpoint(self, instance: str, region: str) -> str:\n-        endpoints = self.request('GET',\n-                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n-                                 .format(self.tenant, self.application, instance, region))['endpoints']\n-        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n         if not container_url:\n             raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n         return container_url[0]\n \n-    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n-        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n-            .format(self.tenant, self.application, instance, job)\n-        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n-        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n-        print(response['message'])\n-        return response['run']\n+    def start_deployment(\n+        self, instance: str, job: str, application_package: ApplicationPackage\n+    ) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+        application_zip_bytes = application_package.to_application_zip(\n+            {\n+                \"application/security/clients.pem\": self.data_certificate.public_bytes(\n+                    serialization.Encoding.PEM\n+                )\n+            }\n+        )\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n \n     def follow_deployment(self, instance: str, job: str, run: int):\n         last = -1\n         while True:\n-            update = self.request('GET',\n-                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n-                                  .format(self.tenant, self.application, instance, job, run, last))\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n \n-            for step, entries in update['log'].items():\n+            for step, entries in update[\"log\"].items():\n                 for entry in entries:\n                     self.print_log_entry(step, entry)\n-            last = update.get('lastId', last)\n+            last = update.get(\"lastId\", last)\n \n-            if update['active']:\n+            if update[\"active\"]:\n                 sleep(1)\n             else:\n-                status = update['status']\n-                if   status == 'success':                    return\n-                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n-                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n-                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n-                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n-                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n-                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n-                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n-                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n-                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNDA2MA=="}, "originalCommit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "originalPosition": 319}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NTc3NDkzOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoxMzozNFrOHJA7CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjo0MDozNVrOHJC4cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNDM0NA==", "bodyText": "@jonmv It would be nice to include the deployment_message argument when creating the Vespa instance. What would best represent the deployment message in the Vespa Cloud case?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479214344", "createdAt": "2020-08-28T12:13:34Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +499,264 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate\n+        )\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(\n+        key: ec.EllipticCurvePrivateKey, cert: x509.Certificate\n+    ) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile(\"wt\")\n+        cert_file.write(\n+            key.private_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PrivateFormat.TraditionalOpenSSL,\n+                serialization.NoEncryption(),\n+            ).decode(\"UTF-8\")\n+        )\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(\n+        self, instance: str, job: str, application_package: ApplicationPackage\n+    ) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+        application_zip_bytes = application_package.to_application_zip(\n+            {\n+                \"application/security/clients.pem\": self.data_certificate.public_bytes(\n+                    serialization.Encoding.PEM\n+                )\n+            }\n+        )\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n+\n+            for step, entries in update[\"log\"].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get(\"lastId\", last)\n+\n+            if update[\"active\"]:\n+                sleep(1)\n+            else:\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime(\"%H:%M:%S\", gmtime(entry[\"at\"] / 1e3))\n+        message = entry[\"message\"].replace(\"\\n\", \"\\n\" + \" \" * 23)\n+        if step != \"copyVespaLogs\" or entry[\"type\"] == \"error\":\n+            print(\"{:<7} [{}]  {}\".format(entry[\"type\"].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+        region = self.get_dev_region()\n+        job = \"dev-\" + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(\n+            instance=instance,\n+            region=region,\n+            application_package_name=application_package.name,\n+        )\n+        return Vespa(url=endpoint_url, cert=self.data_cert_file.name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNzc4MQ==", "bodyText": "I guess that depends. What is it used for? The whole log could be it. It's usually not that long for dev deployments. So, everything that's printed in follow_deployment.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479217781", "createdAt": "2020-08-28T12:16:32Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +499,264 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate\n+        )\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(\n+        key: ec.EllipticCurvePrivateKey, cert: x509.Certificate\n+    ) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile(\"wt\")\n+        cert_file.write(\n+            key.private_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PrivateFormat.TraditionalOpenSSL,\n+                serialization.NoEncryption(),\n+            ).decode(\"UTF-8\")\n+        )\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(\n+        self, instance: str, job: str, application_package: ApplicationPackage\n+    ) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+        application_zip_bytes = application_package.to_application_zip(\n+            {\n+                \"application/security/clients.pem\": self.data_certificate.public_bytes(\n+                    serialization.Encoding.PEM\n+                )\n+            }\n+        )\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n+\n+            for step, entries in update[\"log\"].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get(\"lastId\", last)\n+\n+            if update[\"active\"]:\n+                sleep(1)\n+            else:\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime(\"%H:%M:%S\", gmtime(entry[\"at\"] / 1e3))\n+        message = entry[\"message\"].replace(\"\\n\", \"\\n\" + \" \" * 23)\n+        if step != \"copyVespaLogs\" or entry[\"type\"] == \"error\":\n+            print(\"{:<7} [{}]  {}\".format(entry[\"type\"].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+        region = self.get_dev_region()\n+        job = \"dev-\" + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(\n+            instance=instance,\n+            region=region,\n+            application_package_name=application_package.name,\n+        )\n+        return Vespa(url=endpoint_url, cert=self.data_cert_file.name)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNDM0NA=="}, "originalCommit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0MzM5Mg==", "bodyText": "Ok, for now it is just for informational purposes.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479243392", "createdAt": "2020-08-28T12:38:05Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +499,264 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate\n+        )\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(\n+        key: ec.EllipticCurvePrivateKey, cert: x509.Certificate\n+    ) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile(\"wt\")\n+        cert_file.write(\n+            key.private_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PrivateFormat.TraditionalOpenSSL,\n+                serialization.NoEncryption(),\n+            ).decode(\"UTF-8\")\n+        )\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(\n+        self, instance: str, job: str, application_package: ApplicationPackage\n+    ) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+        application_zip_bytes = application_package.to_application_zip(\n+            {\n+                \"application/security/clients.pem\": self.data_certificate.public_bytes(\n+                    serialization.Encoding.PEM\n+                )\n+            }\n+        )\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n+\n+            for step, entries in update[\"log\"].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get(\"lastId\", last)\n+\n+            if update[\"active\"]:\n+                sleep(1)\n+            else:\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime(\"%H:%M:%S\", gmtime(entry[\"at\"] / 1e3))\n+        message = entry[\"message\"].replace(\"\\n\", \"\\n\" + \" \" * 23)\n+        if step != \"copyVespaLogs\" or entry[\"type\"] == \"error\":\n+            print(\"{:<7} [{}]  {}\".format(entry[\"type\"].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+        region = self.get_dev_region()\n+        job = \"dev-\" + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(\n+            instance=instance,\n+            region=region,\n+            application_package_name=application_package.name,\n+        )\n+        return Vespa(url=endpoint_url, cert=self.data_cert_file.name)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNDM0NA=="}, "originalCommit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NjQ0OQ==", "bodyText": "The deployment message from the config server is in there, if you do substring search, etc..", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479246449", "createdAt": "2020-08-28T12:40:35Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +499,264 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate\n+        )\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(\n+        key: ec.EllipticCurvePrivateKey, cert: x509.Certificate\n+    ) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile(\"wt\")\n+        cert_file.write(\n+            key.private_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PrivateFormat.TraditionalOpenSSL,\n+                serialization.NoEncryption(),\n+            ).decode(\"UTF-8\")\n+        )\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(\n+        self, instance: str, job: str, application_package: ApplicationPackage\n+    ) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+        application_zip_bytes = application_package.to_application_zip(\n+            {\n+                \"application/security/clients.pem\": self.data_certificate.public_bytes(\n+                    serialization.Encoding.PEM\n+                )\n+            }\n+        )\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n+\n+            for step, entries in update[\"log\"].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get(\"lastId\", last)\n+\n+            if update[\"active\"]:\n+                sleep(1)\n+            else:\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime(\"%H:%M:%S\", gmtime(entry[\"at\"] / 1e3))\n+        message = entry[\"message\"].replace(\"\\n\", \"\\n\" + \" \" * 23)\n+        if step != \"copyVespaLogs\" or entry[\"type\"] == \"error\":\n+            print(\"{:<7} [{}]  {}\".format(entry[\"type\"].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+        region = self.get_dev_region()\n+        job = \"dev-\" + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(\n+            instance=instance,\n+            region=region,\n+            application_package_name=application_package.name,\n+        )\n+        return Vespa(url=endpoint_url, cert=self.data_cert_file.name)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNDM0NA=="}, "originalCommit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNjc4MzM1OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNjo0Mzo1NFrOHKmwsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODoxMzozMVrOHKrJmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4Mjg2NQ==", "bodyText": "What is the difference between application_package_name and self.application?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480882865", "createdAt": "2020-09-01T06:43:54Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1NDc3OA==", "bodyText": "application_package_name is unnecessary here as the info is available through self.application_package.name. Made the changes.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480954778", "createdAt": "2020-09-01T08:13:31Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4Mjg2NQ=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNjc5MTQ4OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNjo0NTozNVrOHKm10Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMDozODoyNlrOHKwhBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDE3Nw==", "bodyText": "Debug print() leftover?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480884177", "createdAt": "2020-09-01T06:45:35Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk0OTEwOA==", "bodyText": "No, it contains a message intended for the user.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480949108", "createdAt": "2020-09-01T08:04:26Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDE3Nw=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1MTQ1NQ==", "bodyText": "Wouldn't it be better to return that value from the method instead? Library code printing stuff is a bit iffy. I know there's a contention here between regular library code and interactive notebooks, but it would be nice to see if there was a better way.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480951455", "createdAt": "2020-09-01T08:07:44Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDE3Nw=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1Mjc3Nw==", "bodyText": "Yes, moving it up one level is a good idea.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480952777", "createdAt": "2020-09-01T08:10:06Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDE3Nw=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1ODY5Mw==", "bodyText": "I don't think this was a left over. The idea is to print the deployment messages so that the user knows which stage he is. This response[\"message\"] contains the following\nDeployment started in run 6 of dev-aws-us-east-1c for vespa-team.ms-marco.from-notebook. This may take about 15 minutes the first time.\n\nThe entire message including the updates looks something like:\nDeployment started in run 6 of dev-aws-us-east-1c for vespa-team.ms-marco.from-notebook. This may take about 15 minutes the first time.\nINFO    [08:08:03]  Deploying platform version 7.276.8 and application version unknown ...\nINFO    [08:08:04]  No services requiring restart.\nINFO    [08:08:04]  Deployment successful.\nINFO    [08:08:05]  Session 13618 for tenant 'vespa-team' prepared and activated.\nINFO    [08:08:05]  ######## Details for all nodes ########\nINFO    [08:08:05]  h711a.dev.aws-us-east-1c.vespa-external.aws.oath.cloud: expected to be UP\nINFO    [08:08:05]  --- platform docker.ouroath.com:4443/vespa/centos-tenant:7.276.8\nINFO    [08:08:05]  --- container on port 4080 has config generation 13618, wanted is 13618\nINFO    [08:08:05]  h712a.dev.aws-us-east-1c.vespa-external.aws.oath.cloud: expected to be UP\nINFO    [08:08:05]  --- platform docker.ouroath.com:4443/vespa/centos-tenant:7.276.8\nINFO    [08:08:05]  --- logserver-container on port 4080 has config generation 13618, wanted is 13618\nINFO    [08:08:05]  h713a.dev.aws-us-east-1c.vespa-external.aws.oath.cloud: expected to be UP\nINFO    [08:08:05]  --- platform docker.ouroath.com:4443/vespa/centos-tenant:7.276.8\nINFO    [08:08:05]  --- container-clustercontroller on port 19050 has config generation 13618, wanted is 13618\nINFO    [08:08:05]  --- storagenode on port 19102 has config generation 13618, wanted is 13618\nINFO    [08:08:05]  --- searchnode on port 19107 has config generation 13618, wanted is 13618\nINFO    [08:08:05]  --- distributor on port 19111 has config generation 13618, wanted is 13618\nINFO    [08:08:05]  Found endpoints:\nINFO    [08:08:05]  - dev.aws-us-east-1c\nINFO    [08:08:05]   |-- https://msmarco-container.from-notebook.ms-marco.vespa-team.aws-us-east-1c.dev.public.vespa.oath.cloud/ (cluster 'msmarco_container')\nINFO    [08:08:06]  Installation succeeded!", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480958693", "createdAt": "2020-09-01T08:20:10Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDE3Nw=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1OTIwMg==", "bodyText": "@oyving Would you change it?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480959202", "createdAt": "2020-09-01T08:20:59Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDE3Nw=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NDIzMg==", "bodyText": "I think it should be changed, but it might be over-engineering it. It's your call. But as a minimum I would have a self.output file-handle that you write these messages to (that default to sys.stdout). That way the output can at least be controlled by the user if they wish.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480964232", "createdAt": "2020-09-01T08:29:02Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDE3Nw=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA0MjY5Mg==", "bodyText": "Done.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r481042692", "createdAt": "2020-09-01T10:38:26Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDE3Nw=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNjc5NjYwOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNjo0NjozNVrOHKm4yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxMDozMTowNlrOHKwS0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDkzOQ==", "bodyText": "Why write the zip file to disk when you just send the memory backed buffer to self.request()?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480884939", "createdAt": "2020-09-01T06:46:35Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MzA3NA==", "bodyText": "This is a good question. It is not necessary but I thought it would be nice to have a copy in case the user wants to check the config files that got deployed.\nA future change would include the option to deploy a user generated .zip file to Cloud from pyvespa, instead of building the .zip file from our limited application package API.\nThat way assuming there will always be a .zip file in the disk_folder would tie those two use cases together. But for now it is mostly for the user convenience of checking the config files.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480963074", "createdAt": "2020-09-01T08:27:10Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDkzOQ=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk3MDY2Mg==", "bodyText": "I think that's a mixing of concerns. Also, wouldn't it be better for the user to just inspect the application package object and get the files printed to stdout?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480970662", "createdAt": "2020-09-01T08:39:45Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDkzOQ=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAzOTA1Ng==", "bodyText": "I removed the step that write zip file to disk. I can revisit that if needed.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r481039056", "createdAt": "2020-09-01T10:31:06Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDkzOQ=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNjgxMDI5OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNjo0OToxM1rOHKnBRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwODo1ODoyNlrOHKs0Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NzExMQ==", "bodyText": "I would consider splitting this into two methods. One that does a single poll and status report, and one that blocks and continually polls until deployment is done.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480887111", "createdAt": "2020-09-01T06:49:13Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk4MjA4Mw==", "bodyText": "Made the change. Check if it was that what you had in mind.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480982083", "createdAt": "2020-09-01T08:58:26Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NzExMQ=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 309}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNjgyNzk4OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNjo1Mjo1NlrOHKnMgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwOTowODoxOVrOHKtK2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4OTk4NA==", "bodyText": "Consider moving status code -> message into a separate map to make this if-elif-else block shorter.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480889984", "createdAt": "2020-09-01T06:52:56Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n+\n+            for step, entries in update[\"log\"].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get(\"lastId\", last)\n+\n+            if update[\"active\"]:\n+                sleep(1)\n+            else:\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk4Nzg2Ng==", "bodyText": "Done.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480987866", "createdAt": "2020-09-01T09:08:19Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n+\n+            for step, entries in update[\"log\"].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get(\"lastId\", last)\n+\n+            if update[\"active\"]:\n+                sleep(1)\n+            else:\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4OTk4NA=="}, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 357}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1496, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}