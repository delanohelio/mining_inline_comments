{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5MDg1MDM2", "number": 12011, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzo1NDo1NVrODb6_dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzo1OToxNFrODb7FqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjA0NjYzOnYy", "diffSide": "RIGHT", "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzo1NDo1NVrOFjrrOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzo1NDo1NVrOFjrrOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk2MDA1OA==", "bodyText": "This will select the highest keyversion and certversion. We should only consider cert since we might be in the middle of a refresh (where keyversion might be incremented, but certversion still not ready)", "url": "https://github.com/vespa-engine/vespa/pull/12011#discussion_r372960058", "createdAt": "2020-01-30T13:54:55Z", "author": {"login": "tokle"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "diffHunk": "@@ -42,32 +51,58 @@\n     private final SecretStore secretStore;\n     private final ApplicationCertificateProvider applicationCertificateProvider;\n     private final Clock clock;\n+    private final FlagSource flagSource;\n \n     public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n                                       CuratorDb curator,\n                                       SecretStore secretStore,\n                                       ApplicationCertificateProvider applicationCertificateProvider,\n-                                      Clock clock) {\n+                                      Clock clock, FlagSource flagSource) {\n         this.zoneRegistry = zoneRegistry;\n         this.curator = curator;\n         this.secretStore = secretStore;\n         this.applicationCertificateProvider = applicationCertificateProvider;\n         this.clock = clock;\n+        this.flagSource = flagSource;\n     }\n \n     public Optional<EndpointCertificateMetadata> getEndpointCertificateMetadata(Instance instance, ZoneId zone) {\n \n         if (!zoneRegistry.zones().directlyRouted().ids().contains(zone)) return Optional.empty();\n \n-        // Re-use certificate if already provisioned\n-        Optional<EndpointCertificateMetadata> endpointCertificateMetadata =\n+        // Re-use existing certificate if already provisioned\n+        var endpointCertificateMetadata =\n                 curator.readEndpointCertificateMetadata(instance.id())\n-                        .or(() -> Optional.of(provisionEndpointCertificate(instance)));\n+                        .orElse(provisionEndpointCertificate(instance));\n+\n+        // If feature flag set for application, look for and use refreshed certificate\n+        var useRefreshedEndpointCertificate = Flags.USE_REFRESHED_ENDPOINT_CERTIFICATE.bindTo(flagSource);\n+        if (useRefreshedEndpointCertificate.with(FetchVector.Dimension.APPLICATION_ID, instance.id().serializedForm()).value()) {\n+            var latestAvailableVersion = greatestVersionInSecretStore(endpointCertificateMetadata);\n+\n+            if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > endpointCertificateMetadata.version()) {\n+                var refreshedCertificateMetadata = new EndpointCertificateMetadata(\n+                        endpointCertificateMetadata.keyName(),\n+                        endpointCertificateMetadata.certName(),\n+                        latestAvailableVersion.getAsInt()\n+                );\n+\n+                if (verifyEndpointCertificate(refreshedCertificateMetadata, instance, zone, \"Did not refresh, problems with refreshed certificate: \"))\n+                    return Optional.of(refreshedCertificateMetadata);\n+            }\n+        }\n+\n+        // Only log warnings\n+        verifyEndpointCertificate(endpointCertificateMetadata, instance, zone, \"Problems while verifying certificate: \");\n+\n+        return Optional.of(endpointCertificateMetadata);\n+    }\n \n-        // Only logs warnings for now\n-        endpointCertificateMetadata.ifPresent(certificateMetadata -> verifyEndpointCertificate(certificateMetadata, instance, zone));\n+    private OptionalInt greatestVersionInSecretStore(EndpointCertificateMetadata originalCertificateMetadata) {\n+        var certVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.certName()));\n+        var keyVersions = new HashSet<>(secretStore.listSecretVersions(originalCertificateMetadata.keyName()));\n \n-        return endpointCertificateMetadata;\n+        return Sets.union(certVersions, keyVersions).stream().mapToInt(Integer::intValue).max();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edb072d91c404d74a2c0cedc564a38e4f7a4dbac"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjA1OTU5OnYy", "diffSide": "RIGHT", "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzo1ODozNVrOFjry8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzo1ODozNVrOFjry8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk2MjAzNQ==", "bodyText": "Consider moving this to the constructor.", "url": "https://github.com/vespa-engine/vespa/pull/12011#discussion_r372962035", "createdAt": "2020-01-30T13:58:35Z", "author": {"login": "tokle"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "diffHunk": "@@ -42,32 +51,58 @@\n     private final SecretStore secretStore;\n     private final ApplicationCertificateProvider applicationCertificateProvider;\n     private final Clock clock;\n+    private final FlagSource flagSource;\n \n     public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n                                       CuratorDb curator,\n                                       SecretStore secretStore,\n                                       ApplicationCertificateProvider applicationCertificateProvider,\n-                                      Clock clock) {\n+                                      Clock clock, FlagSource flagSource) {\n         this.zoneRegistry = zoneRegistry;\n         this.curator = curator;\n         this.secretStore = secretStore;\n         this.applicationCertificateProvider = applicationCertificateProvider;\n         this.clock = clock;\n+        this.flagSource = flagSource;\n     }\n \n     public Optional<EndpointCertificateMetadata> getEndpointCertificateMetadata(Instance instance, ZoneId zone) {\n \n         if (!zoneRegistry.zones().directlyRouted().ids().contains(zone)) return Optional.empty();\n \n-        // Re-use certificate if already provisioned\n-        Optional<EndpointCertificateMetadata> endpointCertificateMetadata =\n+        // Re-use existing certificate if already provisioned\n+        var endpointCertificateMetadata =\n                 curator.readEndpointCertificateMetadata(instance.id())\n-                        .or(() -> Optional.of(provisionEndpointCertificate(instance)));\n+                        .orElse(provisionEndpointCertificate(instance));\n+\n+        // If feature flag set for application, look for and use refreshed certificate\n+        var useRefreshedEndpointCertificate = Flags.USE_REFRESHED_ENDPOINT_CERTIFICATE.bindTo(flagSource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edb072d91c404d74a2c0cedc564a38e4f7a4dbac"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNjA2MjQ5OnYy", "diffSide": "RIGHT", "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzo1OToxNFrOFjr0ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQxMzo1OToxNFrOFjr0ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk2MjQ2Mg==", "bodyText": "rename greatest -> latest ?", "url": "https://github.com/vespa-engine/vespa/pull/12011#discussion_r372962462", "createdAt": "2020-01-30T13:59:14Z", "author": {"login": "tokle"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "diffHunk": "@@ -42,32 +51,58 @@\n     private final SecretStore secretStore;\n     private final ApplicationCertificateProvider applicationCertificateProvider;\n     private final Clock clock;\n+    private final FlagSource flagSource;\n \n     public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n                                       CuratorDb curator,\n                                       SecretStore secretStore,\n                                       ApplicationCertificateProvider applicationCertificateProvider,\n-                                      Clock clock) {\n+                                      Clock clock, FlagSource flagSource) {\n         this.zoneRegistry = zoneRegistry;\n         this.curator = curator;\n         this.secretStore = secretStore;\n         this.applicationCertificateProvider = applicationCertificateProvider;\n         this.clock = clock;\n+        this.flagSource = flagSource;\n     }\n \n     public Optional<EndpointCertificateMetadata> getEndpointCertificateMetadata(Instance instance, ZoneId zone) {\n \n         if (!zoneRegistry.zones().directlyRouted().ids().contains(zone)) return Optional.empty();\n \n-        // Re-use certificate if already provisioned\n-        Optional<EndpointCertificateMetadata> endpointCertificateMetadata =\n+        // Re-use existing certificate if already provisioned\n+        var endpointCertificateMetadata =\n                 curator.readEndpointCertificateMetadata(instance.id())\n-                        .or(() -> Optional.of(provisionEndpointCertificate(instance)));\n+                        .orElse(provisionEndpointCertificate(instance));\n+\n+        // If feature flag set for application, look for and use refreshed certificate\n+        var useRefreshedEndpointCertificate = Flags.USE_REFRESHED_ENDPOINT_CERTIFICATE.bindTo(flagSource);\n+        if (useRefreshedEndpointCertificate.with(FetchVector.Dimension.APPLICATION_ID, instance.id().serializedForm()).value()) {\n+            var latestAvailableVersion = greatestVersionInSecretStore(endpointCertificateMetadata);\n+\n+            if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > endpointCertificateMetadata.version()) {\n+                var refreshedCertificateMetadata = new EndpointCertificateMetadata(\n+                        endpointCertificateMetadata.keyName(),\n+                        endpointCertificateMetadata.certName(),\n+                        latestAvailableVersion.getAsInt()\n+                );\n+\n+                if (verifyEndpointCertificate(refreshedCertificateMetadata, instance, zone, \"Did not refresh, problems with refreshed certificate: \"))\n+                    return Optional.of(refreshedCertificateMetadata);\n+            }\n+        }\n+\n+        // Only log warnings\n+        verifyEndpointCertificate(endpointCertificateMetadata, instance, zone, \"Problems while verifying certificate: \");\n+\n+        return Optional.of(endpointCertificateMetadata);\n+    }\n \n-        // Only logs warnings for now\n-        endpointCertificateMetadata.ifPresent(certificateMetadata -> verifyEndpointCertificate(certificateMetadata, instance, zone));\n+    private OptionalInt greatestVersionInSecretStore(EndpointCertificateMetadata originalCertificateMetadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edb072d91c404d74a2c0cedc564a38e4f7a4dbac"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2567, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}