{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5NTE5NjU5", "number": 15809, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjoxNToyOFrOFFjp0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDoxNTowNlrOFGNqIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzcxMzQ1OnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/distributor/distributor_bucket_space.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjoxNToyOVrOIGH9bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowMzoyOVrOIGTBQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5Mjc4MQ==", "bodyText": "My main concern about this change is if there exists some code path which directly or indirectly ends up calling this function with a bucket ID that is not normalized to have used-bits == distribution bits. If that happens the cache has a max size of 2^58 rather than (usually) 2^16...", "url": "https://github.com/vespa-engine/vespa/pull/15809#discussion_r543292781", "createdAt": "2020-12-15T12:15:29Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/distributor/distributor_bucket_space.cpp", "diffHunk": "@@ -118,20 +114,20 @@ DistributorBucketSpace::owns_bucket_in_state(\n     return owns_bucket_in_state(*_distribution, clusterState, bucket);\n }\n \n-std::vector<uint16_t>\n-DistributorBucketSpace::get_ideal_nodes(document::BucketId bucket) const\n+const IdealServiceLayerNodesBundle&\n+DistributorBucketSpace::get_ideal_service_layer_nodes_bundle(document::BucketId bucket) const\n {\n     assert(bucket.getUsedBits() >= _distribution_bits);\n-    if (bucket.getUsedBits() > 33) { // cf. storage::lib::Distribution::getStorageSeed\n-        // Cannot map to super bucket ==> cannot cache result\n-        return get_ideal_nodes_fallback(bucket);\n-    }\n-    document::BucketId super_bucket(_distribution_bits, bucket.getId());\n-    auto itr = _ideal_nodes.find(super_bucket);\n+    document::BucketId lookup_bucket((bucket.getUsedBits() > 33) ? bucket.getUsedBits() : _distribution_bits, bucket.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "696d1c40a7530331957a8304602b2724335d7c5f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM1MTIzNw==", "bodyText": "I tried temporarily adding assert(bucket.getUsedBits() < 58);. All unit tests passed. Thus it would have to be a code path not covered by current unit tests.\nIt is possible to partially disable caching, but should that only be for bucket.getUsedBits() == 58, or should it be for bucket.getUsedBits() > 33 ?", "url": "https://github.com/vespa-engine/vespa/pull/15809#discussion_r543351237", "createdAt": "2020-12-15T13:43:42Z", "author": {"login": "toregge"}, "path": "storage/src/vespa/storage/distributor/distributor_bucket_space.cpp", "diffHunk": "@@ -118,20 +114,20 @@ DistributorBucketSpace::owns_bucket_in_state(\n     return owns_bucket_in_state(*_distribution, clusterState, bucket);\n }\n \n-std::vector<uint16_t>\n-DistributorBucketSpace::get_ideal_nodes(document::BucketId bucket) const\n+const IdealServiceLayerNodesBundle&\n+DistributorBucketSpace::get_ideal_service_layer_nodes_bundle(document::BucketId bucket) const\n {\n     assert(bucket.getUsedBits() >= _distribution_bits);\n-    if (bucket.getUsedBits() > 33) { // cf. storage::lib::Distribution::getStorageSeed\n-        // Cannot map to super bucket ==> cannot cache result\n-        return get_ideal_nodes_fallback(bucket);\n-    }\n-    document::BucketId super_bucket(_distribution_bits, bucket.getId());\n-    auto itr = _ideal_nodes.find(super_bucket);\n+    document::BucketId lookup_bucket((bucket.getUsedBits() > 33) ? bucket.getUsedBits() : _distribution_bits, bucket.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5Mjc4MQ=="}, "originalCommit": {"oid": "696d1c40a7530331957a8304602b2724335d7c5f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3Mzk4Nw==", "bodyText": "As a conservative first step I think we might opt to not cache for > 33 for now. We can then get some time to observe the delta in performance and memory usage for the two cases. We can trivially change it later.", "url": "https://github.com/vespa-engine/vespa/pull/15809#discussion_r543473987", "createdAt": "2020-12-15T16:03:29Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/distributor/distributor_bucket_space.cpp", "diffHunk": "@@ -118,20 +114,20 @@ DistributorBucketSpace::owns_bucket_in_state(\n     return owns_bucket_in_state(*_distribution, clusterState, bucket);\n }\n \n-std::vector<uint16_t>\n-DistributorBucketSpace::get_ideal_nodes(document::BucketId bucket) const\n+const IdealServiceLayerNodesBundle&\n+DistributorBucketSpace::get_ideal_service_layer_nodes_bundle(document::BucketId bucket) const\n {\n     assert(bucket.getUsedBits() >= _distribution_bits);\n-    if (bucket.getUsedBits() > 33) { // cf. storage::lib::Distribution::getStorageSeed\n-        // Cannot map to super bucket ==> cannot cache result\n-        return get_ideal_nodes_fallback(bucket);\n-    }\n-    document::BucketId super_bucket(_distribution_bits, bucket.getId());\n-    auto itr = _ideal_nodes.find(super_bucket);\n+    document::BucketId lookup_bucket((bucket.getUsedBits() > 33) ? bucket.getUsedBits() : _distribution_bits, bucket.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5Mjc4MQ=="}, "originalCommit": {"oid": "696d1c40a7530331957a8304602b2724335d7c5f"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMzczODMwOnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/distributor/ideal_service_layer_nodes_bundle.h", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMjoyMTo0MFrOIGIMNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMzo0OToxOFrOIGLyBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5NjU2NQ==", "bodyText": "Perhaps a premature optimization, but the common case is that there are no nodes in retired state or maintenance. Should we then let these vectors be empty and just return _available_nodes iff this is the case?", "url": "https://github.com/vespa-engine/vespa/pull/15809#discussion_r543296565", "createdAt": "2020-12-15T12:21:40Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/distributor/ideal_service_layer_nodes_bundle.h", "diffHunk": "@@ -0,0 +1,28 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+#pragma once\n+\n+#include <vector>\n+#include <cstdint>\n+\n+namespace storage::distributor {\n+\n+/*\n+ * Bundle of ideal service layer nodes for a bucket.\n+ */\n+class IdealServiceLayerNodesBundle {\n+    std::vector<uint16_t> _available_nodes;\n+    std::vector<uint16_t> _available_nonretired_nodes;\n+    std::vector<uint16_t> _available_nonretired_or_maintenance_nodes;\n+public:\n+    IdealServiceLayerNodesBundle() noexcept;\n+    ~IdealServiceLayerNodesBundle();\n+\n+    void set_available_nodes(std::vector<uint16_t> available_nodes) { _available_nodes = std::move(available_nodes); }\n+    void set_available_nonretired_nodes(std::vector<uint16_t> available_nonretired_nodes) { _available_nonretired_nodes = std::move(available_nonretired_nodes); }\n+    void set_available_nonretired_or_maintenance_nodes(std::vector<uint16_t> available_nonretired_or_maintenance_nodes) { _available_nonretired_or_maintenance_nodes = std::move(available_nonretired_or_maintenance_nodes); }\n+    std::vector<uint16_t> get_available_nodes() const { return _available_nodes; }\n+    std::vector<uint16_t> get_available_nonretired_nodes() const { return _available_nonretired_nodes; }\n+    std::vector<uint16_t> get_available_nonretired_or_maintenance_nodes() const { return _available_nonretired_or_maintenance_nodes; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "696d1c40a7530331957a8304602b2724335d7c5f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM1NTM5Ng==", "bodyText": "We would have to return _available_nonretired_nodes in that case unless we add a flag.", "url": "https://github.com/vespa-engine/vespa/pull/15809#discussion_r543355396", "createdAt": "2020-12-15T13:49:18Z", "author": {"login": "toregge"}, "path": "storage/src/vespa/storage/distributor/ideal_service_layer_nodes_bundle.h", "diffHunk": "@@ -0,0 +1,28 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+#pragma once\n+\n+#include <vector>\n+#include <cstdint>\n+\n+namespace storage::distributor {\n+\n+/*\n+ * Bundle of ideal service layer nodes for a bucket.\n+ */\n+class IdealServiceLayerNodesBundle {\n+    std::vector<uint16_t> _available_nodes;\n+    std::vector<uint16_t> _available_nonretired_nodes;\n+    std::vector<uint16_t> _available_nonretired_or_maintenance_nodes;\n+public:\n+    IdealServiceLayerNodesBundle() noexcept;\n+    ~IdealServiceLayerNodesBundle();\n+\n+    void set_available_nodes(std::vector<uint16_t> available_nodes) { _available_nodes = std::move(available_nodes); }\n+    void set_available_nonretired_nodes(std::vector<uint16_t> available_nonretired_nodes) { _available_nonretired_nodes = std::move(available_nonretired_nodes); }\n+    void set_available_nonretired_or_maintenance_nodes(std::vector<uint16_t> available_nonretired_or_maintenance_nodes) { _available_nonretired_or_maintenance_nodes = std::move(available_nonretired_or_maintenance_nodes); }\n+    std::vector<uint16_t> get_available_nodes() const { return _available_nodes; }\n+    std::vector<uint16_t> get_available_nonretired_nodes() const { return _available_nonretired_nodes; }\n+    std::vector<uint16_t> get_available_nonretired_or_maintenance_nodes() const { return _available_nonretired_or_maintenance_nodes; }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5NjU2NQ=="}, "originalCommit": {"oid": "696d1c40a7530331957a8304602b2724335d7c5f"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTMzNjE4OnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/distributor/distributor_bucket_space.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTozMToxM1rOIG78cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwOTozMToxM1rOIG78cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE0NDQ5Nw==", "bodyText": "Ah, I didn't consider how returning a const ref would make things tricker when not caching entries... \ud83d\ude42", "url": "https://github.com/vespa-engine/vespa/pull/15809#discussion_r544144497", "createdAt": "2020-12-16T09:31:13Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/distributor/distributor_bucket_space.cpp", "diffHunk": "@@ -114,19 +114,40 @@ DistributorBucketSpace::owns_bucket_in_state(\n     return owns_bucket_in_state(*_distribution, clusterState, bucket);\n }\n \n+namespace {\n+\n+void\n+setup_ideal_nodes_bundle(IdealServiceLayerNodesBundle& ideal_nodes_bundle,\n+                         const lib::Distribution& distribution,\n+                         const lib::ClusterState& cluster_state,\n+                         document::BucketId bucket)\n+{\n+    ideal_nodes_bundle.set_available_nodes(distribution.getIdealStorageNodes(cluster_state, bucket, up_states));\n+    ideal_nodes_bundle.set_available_nonretired_nodes(distribution.getIdealStorageNodes(cluster_state, bucket, nonretired_up_states));\n+    ideal_nodes_bundle.set_available_nonretired_or_maintenance_nodes(distribution.getIdealStorageNodes(cluster_state, bucket, nonretired_or_maintenance_up_states));\n+}\n+\n+// Ideal service layer nodes bundle used when bucket id used bits > 33.\n+thread_local IdealServiceLayerNodesBundle fallback_ideal_nodes_bundle;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "284765d452553caeecc222b513bfd5f3147ef950"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMDU5NTUyOnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/distributor/distributor_bucket_space.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDoxNTowNlrOIHHVQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxNDoxNTowNlrOIHHVQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMTA3Mw==", "bodyText": "Consider adding a constexpr variable for this to make it clearer. It is also used elsewhere (e.g. L143). Would be nice with a comment on why 33 is selected as well.", "url": "https://github.com/vespa-engine/vespa/pull/15809#discussion_r544331073", "createdAt": "2020-12-16T14:15:06Z", "author": {"login": "geirst"}, "path": "storage/src/vespa/storage/distributor/distributor_bucket_space.cpp", "diffHunk": "@@ -114,19 +114,40 @@ DistributorBucketSpace::owns_bucket_in_state(\n     return owns_bucket_in_state(*_distribution, clusterState, bucket);\n }\n \n+namespace {\n+\n+void\n+setup_ideal_nodes_bundle(IdealServiceLayerNodesBundle& ideal_nodes_bundle,\n+                         const lib::Distribution& distribution,\n+                         const lib::ClusterState& cluster_state,\n+                         document::BucketId bucket)\n+{\n+    ideal_nodes_bundle.set_available_nodes(distribution.getIdealStorageNodes(cluster_state, bucket, up_states));\n+    ideal_nodes_bundle.set_available_nonretired_nodes(distribution.getIdealStorageNodes(cluster_state, bucket, nonretired_up_states));\n+    ideal_nodes_bundle.set_available_nonretired_or_maintenance_nodes(distribution.getIdealStorageNodes(cluster_state, bucket, nonretired_or_maintenance_up_states));\n+}\n+\n+// Ideal service layer nodes bundle used when bucket id used bits > 33.\n+thread_local IdealServiceLayerNodesBundle fallback_ideal_nodes_bundle;\n+\n+}\n+\n const IdealServiceLayerNodesBundle&\n DistributorBucketSpace::get_ideal_service_layer_nodes_bundle(document::BucketId bucket) const\n {\n     assert(bucket.getUsedBits() >= _distribution_bits);\n+    if (bucket.getUsedBits() > 33) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "284765d452553caeecc222b513bfd5f3147ef950"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2044, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}