{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0MDYzMzI0", "number": 14901, "title": "andreer/delete unused certs 1", "bodyText": "I confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.", "createdAt": "2020-10-15T12:24:10Z", "url": "https://github.com/vespa-engine/vespa/pull/14901", "merged": true, "mergeCommit": {"oid": "9eced7520126471ec0845df53d192243130e8ff0"}, "closed": true, "closedAt": "2020-10-16T05:04:46Z", "author": {"login": "andreer"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdRzwIsgH2gAyNTA0MDYzMzI0OjhjN2FkNDQ2MWY4N2M0ODk5MGZmNzViOThjNTgxODlmZmJlYmMwNGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSykWpAFqTUwOTQzNTkwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8c7ad4461f87c48990ff75b98c58189ffbebc04e", "author": {"user": {"login": "andreer", "name": "Andreas Eriksen"}}, "url": "https://github.com/vespa-engine/vespa/commit/8c7ad4461f87c48990ff75b98c58189ffbebc04e", "committedDate": "2020-10-12T13:11:41Z", "message": "add delete cert method to endpoint certificate providers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1", "author": {"user": {"login": "andreer", "name": "Andreas Eriksen"}}, "url": "https://github.com/vespa-engine/vespa/commit/c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1", "committedDate": "2020-10-15T12:21:30Z", "message": "delete unused certificates (guarded by feature flag)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NDMyNTQ2", "url": "https://github.com/vespa-engine/vespa/pull/14901#pullrequestreview-509432546", "createdAt": "2020-10-15T14:19:49Z", "commit": {"oid": "c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDoxOTo0OVrOHiKQdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDoxOTo0OVrOHiKQdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4MTY4Nw==", "bodyText": "What's the reason this isn't done through the ApplicationController?", "url": "https://github.com/vespa-engine/vespa/pull/14901#discussion_r505581687", "createdAt": "2020-10-15T14:19:49Z", "author": {"login": "jonmv"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/certificate/EndpointCertificateManager.java", "diffHunk": "@@ -129,76 +129,52 @@ public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n             return Optional.of(reprovisionedCertificateMetadata);\n         }\n \n-        // If feature flag set for application, look for and use refreshed certificate\n-        if (useRefreshedEndpointCertificate.with(FetchVector.Dimension.APPLICATION_ID, instance.id().serializedForm()).value()) {\n-            var latestAvailableVersion = latestVersionInSecretStore(currentCertificateMetadata.get());\n-\n-            if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > currentCertificateMetadata.get().version()) {\n-                var refreshedCertificateMetadata = currentCertificateMetadata.get().withVersion(latestAvailableVersion.getAsInt());\n-                validateEndpointCertificate(refreshedCertificateMetadata, instance, zone);\n-                curator.writeEndpointCertificateMetadata(instance.id(), refreshedCertificateMetadata);\n-                return Optional.of(refreshedCertificateMetadata);\n-            }\n+        // Look for and use refreshed certificate\n+        var latestAvailableVersion = latestVersionInSecretStore(currentCertificateMetadata.get());\n+        if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > currentCertificateMetadata.get().version()) {\n+            var refreshedCertificateMetadata = currentCertificateMetadata.get().withVersion(latestAvailableVersion.getAsInt());\n+            validateEndpointCertificate(refreshedCertificateMetadata, instance, zone);\n+            curator.writeEndpointCertificateMetadata(instance.id(), refreshedCertificateMetadata);\n+            return Optional.of(refreshedCertificateMetadata);\n         }\n \n         validateEndpointCertificate(currentCertificateMetadata.get(), instance, zone);\n         return currentCertificateMetadata;\n     }\n \n-    enum BackfillMode {\n+    enum CleanupMode {\n         DISABLE,\n         DRYRUN,\n         ENABLE\n     }\n \n-    private void backfillCertificateMetadata() {\n-        BackfillMode mode = BackfillMode.valueOf(endpointCertificateBackfill.value());\n-        if (mode == BackfillMode.DISABLE) return;\n-\n-        List<EndpointCertificateMetadata> allProviderCertificateMetadata = endpointCertificateProvider.listCertificates();\n-        Map<String, EndpointCertificateMetadata> sanToEndpointCertificate = new HashMap<>();\n-\n-        allProviderCertificateMetadata.forEach((providerMetadata -> {\n-            if (providerMetadata.request_id().isEmpty())\n-                throw new RuntimeException(\"Backfill failed - provider metadata missing request_id\");\n-            if (providerMetadata.requestedDnsSans().isEmpty())\n-                throw new RuntimeException(\"Backfill failed - provider metadata missing DNS SANs for \" + providerMetadata.request_id().get());\n-            providerMetadata.requestedDnsSans().get().forEach(san -> sanToEndpointCertificate.put(san, providerMetadata)\n-            );\n-        }));\n-\n-        Map<ApplicationId, EndpointCertificateMetadata> allEndpointCertificateMetadata = curator.readAllEndpointCertificateMetadata();\n-\n-        allEndpointCertificateMetadata.forEach((applicationId, storedMetaData) -> {\n-            if (storedMetaData.requestedDnsSans().isPresent() && storedMetaData.request_id().isPresent() && storedMetaData.issuer().isPresent())\n-                return;\n-\n-            var hashedCn = commonNameHashOf(applicationId, zoneRegistry.system()); // use as join key\n-            EndpointCertificateMetadata providerMetadata = sanToEndpointCertificate.get(hashedCn);\n-\n-            if (providerMetadata == null) {\n-                log.log(Level.INFO, \"No matching certificate provider metadata found for application \" + applicationId.serializedForm());\n-                return;\n-            }\n-\n-            EndpointCertificateMetadata backfilledMetadata =\n-                    new EndpointCertificateMetadata(\n-                            storedMetaData.keyName(),\n-                            storedMetaData.certName(),\n-                            storedMetaData.version(),\n-                            Instant.now().getEpochSecond(),\n-                            providerMetadata.request_id(),\n-                            providerMetadata.requestedDnsSans(),\n-                            providerMetadata.issuer());\n-\n-            if (mode == BackfillMode.DRYRUN) {\n-                log.log(Level.INFO, \"Would update stored metadata \" + storedMetaData + \" with data from provider: \" + backfilledMetadata);\n-            } else if (mode == BackfillMode.ENABLE) {\n-                curator.writeEndpointCertificateMetadata(applicationId, backfilledMetadata);\n+    private void deleteUnusedCertificates() {\n+        CleanupMode mode = CleanupMode.valueOf(deleteUnusedEndpointCertificates.value());\n+        if (mode == CleanupMode.DISABLE) return;\n+\n+        var oneMonthAgo = clock.instant().minus(1, ChronoUnit.MONTHS);\n+        curator.readAllEndpointCertificateMetadata().forEach((applicationId, storedMetaData) -> {\n+            var lastRequested = Instant.ofEpochSecond(storedMetaData.lastRequested());\n+            if (lastRequested.isBefore(oneMonthAgo) && hasNoDeployments(applicationId)) {\n+                log.log(LogLevel.INFO, \"Cert for app \" + applicationId.serializedForm()\n+                        + \" has not been requested in a month and app has no deployments\"\n+                        + (mode == CleanupMode.ENABLE ? \", deleting from provider and ZK\" : \"\"));\n+                if (mode == CleanupMode.ENABLE) {\n+                    endpointCertificateProvider.deleteCertificate(applicationId, storedMetaData);\n+                    curator.deleteEndpointCertificateMetadata(applicationId);\n+                }\n             }\n         });\n     }\n \n+    private boolean hasNoDeployments(ApplicationId applicationId) {\n+        var deployments = curator.readApplication(TenantAndApplicationId.from(applicationId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1"}, "originalPosition": 169}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NDM1OTA3", "url": "https://github.com/vespa-engine/vespa/pull/14901#pullrequestreview-509435907", "createdAt": "2020-10-15T14:22:50Z", "commit": {"oid": "c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2422, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}