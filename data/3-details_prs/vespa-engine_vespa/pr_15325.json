{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwMDA2MTU5", "number": 15325, "title": "added spin lock with test", "bodyText": "The micro-benchmark shows promise (run test manually with 'verbose' as\nparameter). It indicates that taking and releasing the spin lock from\na single thread is cheaper than doing the same with a normal mutex (as\nexpected based on previous tests). However, it also indicates that it\nis competitive with a normal mutex for short critical sections with\nmultiple threads involved. (on my laptop, only the cases using more\nthreads than cores run faster with a normal mutex, which is a better\nresult than expected).\nI confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.\n@baldersheim @vekterli @arnej27959 @toregge please review", "createdAt": "2020-11-12T16:33:20Z", "url": "https://github.com/vespa-engine/vespa/pull/15325", "merged": true, "mergeCommit": {"oid": "8d26b1e6f1aa56892c6a8be95a1bc9b55660e97d"}, "closed": true, "closedAt": "2020-11-13T10:11:30Z", "author": {"login": "havardpe"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdb0--DAH2gAyNTIwMDA2MTU5OmI2MjY4ZWE3OTFiYzk4OTY3OTIyN2ZhY2JmNTI4Y2M5OGYwOTZmZjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdcEGKcAH2gAyNTIwMDA2MTU5Ojc2ZjEzYTFjNjNmMmEzNWZiZjkwMTkwNjc5Yzc5ZjFjMTY5ZjZmMTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b6268ea791bc989679227facbf528cc98f096ff4", "author": {"user": {"login": "havardpe", "name": "H\u00e5vard Pettersen"}}, "url": "https://github.com/vespa-engine/vespa/commit/b6268ea791bc989679227facbf528cc98f096ff4", "committedDate": "2020-11-12T16:17:02Z", "message": "added spin lock with test\n\nThe micro-benchmark shows promise (run test manually with 'verbose' as\nparameter). It indicates that taking and releasing the spin lock from\na single thread is cheaper than doing the same with a normal mutex (as\nexpected based on previous tests). However, it also indicates that it\nis competitive with a normal mutex for short critical sections with\nmultiple threads involved. (on my laptop, only the cases using more\nthreads than cores run faster with a normal mutex, which is a better\nresult than expected)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MzAwMzMy", "url": "https://github.com/vespa-engine/vespa/pull/15325#pullrequestreview-529300332", "createdAt": "2020-11-12T17:05:51Z", "commit": {"oid": "b6268ea791bc989679227facbf528cc98f096ff4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNzowNTo1MVrOHyEucg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNzowNTo1MVrOHyEucg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2ODI3NA==", "bodyText": "SpinLock -> std::mutex", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522268274", "createdAt": "2020-11-12T17:05:51Z", "author": {"login": "arnej27959"}, "path": "vespalib/src/tests/spin_lock/spin_lock_test.cpp", "diffHunk": "@@ -0,0 +1,174 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/util/spin_lock.h>\n+#include <vespa/vespalib/util/benchmark_timer.h>\n+#include <vespa/vespalib/util/time.h>\n+#include <vespa/vespalib/testkit/test_kit.h>\n+\n+using namespace vespalib;\n+\n+bool verbose = false;\n+double budget = 0.25;\n+size_t thread_safety_work = 1000000;\n+\n+struct DummyLock {\n+    void lock() {}\n+    void unlock() {}\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+struct MyState {\n+    static constexpr size_t SZ = 5;\n+    std::array<size_t,SZ> state = {0,0,0,0,0};\n+    void update() {\n+        std::array<size_t,SZ> tmp;\n+        for (size_t i = 0; i < SZ; ++i) {\n+            tmp[i] = state[i];\n+        }\n+        for (size_t i = 0; i < SZ; ++i) {\n+            state[i] = tmp[i] + 1;\n+        }\n+    }\n+    bool check(size_t expect) const {\n+        for (size_t value: state) {\n+            if (value != expect) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    void report(size_t expect, const char *name) const {\n+        if (check(expect)) {\n+            fprintf(stderr, \"%s is thread safe\\n\", name);\n+        } else {\n+            fprintf(stderr, \"%s is not thread safe\\n\", name);\n+            fprintf(stderr, \"    expected %zu, got [%zu,%zu,%zu,%zu,%zu]\\n\",\n+                    expect, state[0], state[1], state[2], state[3], state[4]);\n+        }\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> void  basic_usage() {\n+    T lock;\n+    {\n+        std::lock_guard guard(lock);\n+    }\n+    {\n+        std::unique_lock guard(lock);\n+    }\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> size_t thread_safety_loop(T &lock, MyState &state, size_t thread_id, size_t thread_limit) {\n+    size_t loop_cnt = (thread_safety_work / thread_limit);\n+    TEST_BARRIER();\n+    auto t0 = steady_clock::now();\n+    TEST_BARRIER();\n+    if (thread_id < thread_limit) {\n+        for (size_t i = 0; i < loop_cnt; ++i) {\n+            std::lock_guard guard(lock);\n+            state.update();\n+        }\n+    }\n+    auto t1 = steady_clock::now();\n+    TEST_BARRIER();\n+    if (thread_id == 0) {\n+        auto t2 = steady_clock::now();\n+        size_t total_ms = count_ms(t2 - t0);\n+        fprintf(stderr, \"---> thread_safety_loop with %zu threads used %zu ms\\n\", thread_limit, total_ms);\n+    }\n+    TEST_BARRIER();\n+    if (verbose && (thread_id < thread_limit)) {\n+        size_t local_ms = count_ms(t1 - t0);\n+        fprintf(stderr, \"    -- thread %zu used %zu ms\\n\", thread_id, local_ms);\n+    }\n+    TEST_BARRIER();\n+    return (loop_cnt * thread_limit);\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> void estimate_cost(const char *name) __attribute__((noinline));\n+template <typename T> void estimate_cost(const char *name) {\n+    T lock;\n+    auto lock_loop = [&]()\n+                     {\n+                         // 250 * 4 = 1000 times lock/unlock\n+                         for (size_t i = 0; i < 250; ++i) {\n+                             // 4 times lock/unlock\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                         }\n+                     };\n+    BenchmarkTimer timer(budget);\n+    while (timer.has_budget()) {\n+        timer.before();\n+        lock_loop();\n+        timer.after();\n+    }\n+    auto cost_ns = timer.min_time() * 1000.0 * 1000.0;\n+    fprintf(stderr, \"%s: estimated lock/unlock time: %g ns\\n\", name, cost_ns);\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+TEST(\"require that locks can be used with lock_guard and unique_lock\") {\n+    TEST_DO(basic_usage<DummyLock>());\n+    TEST_DO(basic_usage<SpinLock>());\n+}\n+\n+TEST_MT_FF(\"report whether DummyLock is thread safe\", 24, DummyLock(), MyState()) {\n+    size_t expect = thread_safety_loop(f1, f2, thread_id, 24);\n+    if (thread_id == 0) {\n+        f2.report(expect, \"DummyLock\");\n+    }\n+}\n+\n+TEST_MT_FF(\"require that SpinLock is thread safe\", 24, SpinLock(), MyState()) {\n+    size_t expect = thread_safety_loop(f1, f2, thread_id, 24);\n+    expect += thread_safety_loop(f1, f2, thread_id, 12);\n+    expect += thread_safety_loop(f1, f2, thread_id, 6);\n+    expect += thread_safety_loop(f1, f2, thread_id, 3);\n+    if (thread_id == 0) {\n+        f2.report(expect, \"SpinLock\");\n+        EXPECT_TRUE(f2.check(expect));\n+    }\n+}\n+\n+TEST_MT_FF(\"require that SpinLock is thread safe\", 24, std::mutex(), MyState()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6268ea791bc989679227facbf528cc98f096ff4"}, "originalPosition": 148}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d", "author": {"user": {"login": "havardpe", "name": "H\u00e5vard Pettersen"}}, "url": "https://github.com/vespa-engine/vespa/commit/5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d", "committedDate": "2020-11-13T08:52:53Z", "message": "fix typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5ODg3NDU0", "url": "https://github.com/vespa-engine/vespa/pull/15325#pullrequestreview-529887454", "createdAt": "2020-11-13T09:02:54Z", "commit": {"oid": "b6268ea791bc989679227facbf528cc98f096ff4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTowMjo1NFrOHymFhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTowMjo1NFrOHymFhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgxNDg1Mg==", "bodyText": "Note that the spin lock does not provide priority inheritance, a low priority thread preempted while holding the spin lock can cause excessive spinning in a high priority thread if the system has few (e.g. a single) cpu cores.", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522814852", "createdAt": "2020-11-13T09:02:54Z", "author": {"login": "toregge"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6268ea791bc989679227facbf528cc98f096ff4"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e", "author": {"user": {"login": "havardpe", "name": "H\u00e5vard Pettersen"}}, "url": "https://github.com/vespa-engine/vespa/commit/7201a4f8b2e54686f6898998fc5b9c9962f3f20e", "committedDate": "2020-11-13T09:25:23Z", "message": "add more warnings"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5OTA2Nzcy", "url": "https://github.com/vespa-engine/vespa/pull/15325#pullrequestreview-529906772", "createdAt": "2020-11-13T09:30:48Z", "commit": {"oid": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5ODk1OTUy", "url": "https://github.com/vespa-engine/vespa/pull/15325#pullrequestreview-529895952", "createdAt": "2020-11-13T09:15:23Z", "commit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOToxNToyM1rOHymfgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOToyMDo1MVrOHymrAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMTUwNw==", "bodyText": "Could consider using std::atomic_flag here. It has a simpler interface than std::atomic but is the only atomic type guaranteed to be lock free (that means the static_assert below could be removed). The inner relaxed load loop seems to require a C++20 addition for it, so hopefully we have it..!", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522821507", "createdAt": "2020-11-13T09:15:23Z", "author": {"login": "vekterli"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMzUzNA==", "bodyText": "_mm_pause may be more portable, but I believe it requires xmmintrin.h so if used maybe it should be wrapped away in its own translation unit to avoid header pollution.", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522823534", "createdAt": "2020-11-13T09:19:16Z", "author": {"login": "vekterli"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {\n+            while (_lock.load(std::memory_order_relaxed)) {\n+                __builtin_ia32_pause();                ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyNDQ0OQ==", "bodyText": "Are we on a new and cool\u2122 enough version of GCC to be able to use the C++20 [[likely]] attribute?", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522824449", "createdAt": "2020-11-13T09:20:51Z", "author": {"login": "vekterli"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5OTA3Mzkw", "url": "https://github.com/vespa-engine/vespa/pull/15325#pullrequestreview-529907390", "createdAt": "2020-11-13T09:31:45Z", "commit": {"oid": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5OTExMjAw", "url": "https://github.com/vespa-engine/vespa/pull/15325#pullrequestreview-529911200", "createdAt": "2020-11-13T09:37:13Z", "commit": {"oid": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTozNzoxM1rOHynOMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTozNzoxM1rOHynOMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzMzQ1OQ==", "bodyText": "Have you compared this to using yield ?", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522833459", "createdAt": "2020-11-13T09:37:13Z", "author": {"login": "baldersheim"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,42 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * Note that multiple threads trying to obtain the lock at the same\n+ * time will reduce performance due to atomic writes against the same\n+ * cache line.\n+ *\n+ * Note that being preempted while holding the lock will reduce\n+ * performance, even more if the thread holding the lock is lower\n+ * priority than the threads trying to obtain the lock. With a\n+ * deterministic scheduler this could even lead to deadlock.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {\n+            while (_lock.load(std::memory_order_relaxed)) {\n+                __builtin_ia32_pause();                ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5OTExMjg2", "url": "https://github.com/vespa-engine/vespa/pull/15325#pullrequestreview-529911286", "createdAt": "2020-11-13T09:37:20Z", "commit": {"oid": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76f13a1c63f2a35fbf90190679c79f1c169f6f10", "author": {"user": {"login": "havardpe", "name": "H\u00e5vard Pettersen"}}, "url": "https://github.com/vespa-engine/vespa/commit/76f13a1c63f2a35fbf90190679c79f1c169f6f10", "committedDate": "2020-11-13T09:53:28Z", "message": "use yield instead of pause"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1932, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}