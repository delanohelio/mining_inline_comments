{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MDgxOTkx", "number": 15484, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoxNzoyOVrOE9_i_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxNjoxNlrOE-AvOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDM5NzQzOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoxNzoyOVrOH6-FBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoxNzoyOVrOH6-FBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5NjU0OQ==", "bodyText": "Please add copyright.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531596549", "createdAt": "2020-11-27T13:17:29Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.h", "diffHunk": "@@ -0,0 +1,26 @@\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDM5Nzg1OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoxNzo0MlrOH6-FYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoxNzo0MlrOH6-FYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5NjY0MA==", "bodyText": "Please add copyright.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531596640", "createdAt": "2020-11-27T13:17:42Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.cpp", "diffHunk": "@@ -0,0 +1,207 @@\n+#include \"serialized_fast_value_attribute.h\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDM5OTkwOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoxODoyOVrOH6-GxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoxODoyOVrOH6-GxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5Njk5Ng==", "bodyText": "Please add copyright.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531596996", "createdAt": "2020-11-27T13:18:29Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDQzMDYwOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoyNzozNlrOH6-ZRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoyNzozNlrOH6-ZRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwMTczMw==", "bodyText": "Please rename to a more descriptive name.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531601733", "createdAt": "2020-11-27T13:27:36Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+\n+#include \"streamed_value_store.h\"\n+#include \"tensor_deserialize.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/streamed/streamed_value_builder_factory.h>\n+#include <vespa/eval/streamed/streamed_value_view.h>\n+#include <vespa/vespalib/datastore/datastore.hpp>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_store\");\n+\n+using vespalib::datastore::Handle;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+constexpr size_t MIN_BUFFER_ARRAYS = 1024;\n+\n+struct CellsMemBlock {\n+    uint32_t num;\n+    uint32_t total_sz;\n+    const char *ptr;\n+    CellsMemBlock(TypedCells cells)\n+      : num(cells.size),\n+        total_sz(CellTypeUtils::mem_size(cells.type, num)),\n+        ptr((const char *)cells.data)\n+    {}\n+};\n+\n+template<typename T>\n+T *fix_alignment(T *ptr, size_t align)\n+{\n+    static_assert(sizeof(T) == 1);\n+    assert((align & (align-1)) == 0); // must be 2^N\n+    size_t ptr_val = (size_t)ptr;\n+    size_t unalign = ptr_val & (align - 1);\n+    if (unalign == 0) {\n+        return ptr;\n+    } else {\n+        return ptr + (align - unalign);\n+    }\n+}\n+\n+} // namespace <unnamed>\n+\n+StreamedValueStore::StreamedValueStore(const ValueType &tensor_type)\n+  : TensorStore(_concreteStore),\n+    _concreteStore(),\n+    _bufferType(RefType::align(1),\n+                MIN_BUFFER_ARRAYS,\n+                RefType::offsetSize() / RefType::align(1)),\n+    _tensor_type(tensor_type),\n+    _data_from_type(_tensor_type)\n+{\n+    _store.addType(&_bufferType);\n+    _store.initActiveBuffers();\n+}\n+\n+StreamedValueStore::~StreamedValueStore()\n+{\n+    _store.dropBuffers();\n+}\n+\n+std::pair<const char *, uint32_t>\n+StreamedValueStore::getRawBuffer(RefType ref) const\n+{\n+    if (!ref.valid()) {\n+        return std::make_pair(nullptr, 0u);\n+    }\n+    const char *buf = _store.getEntry<char>(ref);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    return std::make_pair(buf + sizeof(uint32_t), len);\n+}\n+\n+Handle<char>\n+StreamedValueStore::allocRawBuffer(uint32_t size)\n+{\n+    if (size == 0) {\n+        return Handle<char>();\n+    }\n+    size_t extSize = size + sizeof(uint32_t);\n+    size_t bufSize = RefType::align(extSize);\n+    auto result = _concreteStore.rawAllocator<char>(_typeId).alloc(bufSize);\n+    *reinterpret_cast<uint32_t *>(result.data) = size;\n+    char *padWritePtr = result.data + extSize;\n+    for (size_t i = extSize; i < bufSize; ++i) {\n+        *padWritePtr++ = 0;\n+    }\n+    // Hide length of buffer (first 4 bytes) from users of the buffer.\n+    return Handle<char>(result.ref, result.data + sizeof(uint32_t));\n+}\n+\n+void\n+StreamedValueStore::holdTensor(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return;\n+    }\n+    RefType iRef(ref);\n+    const char *buf = _store.getEntry<char>(iRef);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    _concreteStore.holdElem(ref, len + sizeof(uint32_t));\n+}\n+\n+TensorStore::EntryRef\n+StreamedValueStore::move(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return RefType();\n+    }\n+    auto oldraw = getRawBuffer(ref);\n+    auto newraw = allocRawBuffer(oldraw.second);\n+    memcpy(newraw.data, oldraw.first, oldraw.second);\n+    _concreteStore.holdElem(ref, oldraw.second + sizeof(uint32_t));\n+    return newraw.ref;\n+}\n+\n+StreamedValueStore::StreamedValueData\n+StreamedValueStore::get_tensor_data(EntryRef ref) const\n+{\n+    StreamedValueData retval;\n+    retval.valid = false;\n+    auto raw = getRawBuffer(ref);\n+    if (raw.second == 0u) {\n+        return retval;\n+    }\n+    vespalib::nbostream_longlivedbuf source(raw.first, raw.second);\n+    uint32_t num_cells = source.readValue<uint32_t>();\n+    {\n+        uint32_t alignment = CellTypeUtils::alignment(_data_from_type.cell_type);\n+        const char *aligned_ptr = fix_alignment(source.peek(), alignment);\n+        size_t adjustment = aligned_ptr - source.peek();\n+        source.adjustReadPos(adjustment);\n+    }\n+    retval.cells_ref = TypedCells(source.peek(), _data_from_type.cell_type, num_cells);\n+    source.adjustReadPos(CellTypeUtils::mem_size(_data_from_type.cell_type, num_cells));\n+    retval.num_subspaces = source.readValue<uint32_t>();\n+    retval.labels_buffer = vespalib::ConstArrayRef<char>(source.peek(), source.size());\n+ \n+    if (retval.num_subspaces * _data_from_type.dense_subspace_size == num_cells) {\n+        retval.valid = true;\n+        return retval;\n+    }\n+    LOG(warning, \"inconsistent stored tensor data: \"\n+        \"num_subspaces[%zu] * dense_subspace_size[%u] = %zu != num_cells[%u]\",\n+        retval.num_subspaces, _data_from_type.dense_subspace_size,\n+        retval.num_subspaces * _data_from_type.dense_subspace_size,\n+        num_cells);\n+    return retval;\n+}\n+\n+bool\n+StreamedValueStore::encode_tensor(EntryRef ref, vespalib::nbostream &target) const\n+{\n+    if (auto data = get_tensor_data(ref)) {\n+        StreamedValueView value(\n+            _tensor_type, _data_from_type.num_mapped_dimensions,\n+            data.cells_ref, data.num_subspaces, data.labels_buffer);\n+        vespalib::eval::encode_value(value, target);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+void\n+StreamedValueStore::my_encode(const Value::Index &index,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDQ0MjkyOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzozMToxMFrOH6-glA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzozMToxMFrOH6-glA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwMzYwNA==", "bodyText": "Please update copyright.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531603604", "createdAt": "2020-11-27T13:31:10Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.h", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDQ0NTc0OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzozMjowM1rOH6-iTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzozMjowM1rOH6-iTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNDA0NQ==", "bodyText": "Please update description to reflect implementation. Would also be nice with a short description of the serialisation format used.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531604045", "createdAt": "2020-11-27T13:32:03Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.h", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"tensor_store.h\"\n+#include <vespa/eval/eval/value_type.h>\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/typify.h>\n+\n+namespace search::tensor {\n+\n+/**\n+ * Class for storing serialized tensors in memory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDU4NjQ3OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxNDozNVrOH6_2UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxNDozNVrOH6_2UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNTU1Mw==", "bodyText": "Consider adding labels to error message.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531625553", "createdAt": "2020-11-27T14:14:35Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.cpp", "diffHunk": "@@ -0,0 +1,207 @@\n+#include \"serialized_fast_value_attribute.h\"\n+#include \"streamed_value_saver.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/fast_value.hpp>\n+#include <vespa/eval/streamed/streamed_value_utils.h>\n+#include <vespa/fastlib/io/bufferedfile.h>\n+#include <vespa/searchlib/attribute/readerbase.h>\n+#include <vespa/searchlib/util/fileutil.h>\n+#include <vespa/vespalib/util/rcuvector.hpp>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.serialized_fast_value_attribute\");\n+\n+#include \"blob_sequence_reader.h\"\n+#include \"tensor_attribute.hpp\"\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+struct ValueBlock : LabelBlock {\n+    TypedCells cells;\n+};\n+\n+class ValueBlockStream {\n+private:\n+    const StreamedValueStore::DataFromType &_from_type;\n+    LabelBlockStream _label_block_stream;\n+    const char *_cells_ptr;\n+\n+    size_t dsss() const { return _from_type.dense_subspace_size; }\n+    auto cell_type() const { return _from_type.cell_type; }\n+public:\n+    ValueBlock next_block() {\n+        auto labels = _label_block_stream.next_block();\n+        if (labels) {\n+            TypedCells subspace_cells(_cells_ptr, cell_type(), dsss());\n+            _cells_ptr += CellTypeUtils::mem_size(cell_type(), dsss());\n+            return ValueBlock{labels, subspace_cells};\n+        } else {\n+            TypedCells none(nullptr, cell_type(), 0);\n+            return ValueBlock{labels, none};\n+        }\n+    }\n+    \n+    ValueBlockStream(const StreamedValueStore::DataFromType &from_type,\n+                     const StreamedValueStore::StreamedValueData &from_store)\n+      : _from_type(from_type),\n+        _label_block_stream(from_store.num_subspaces,\n+                            from_store.labels_buffer,\n+                            from_type.num_mapped_dimensions),\n+        _cells_ptr((const char *)from_store.cells_ref.data)\n+    {\n+        _label_block_stream.reset();\n+    }\n+    \n+    ~ValueBlockStream();\n+};\n+\n+ValueBlockStream::~ValueBlockStream() = default;\n+\n+class OnlyFastValueIndex : public Value {\n+private:\n+    const ValueType &_type;\n+    TypedCells _cells;\n+    FastValueIndex my_index;\n+public:\n+    OnlyFastValueIndex(const ValueType &type,\n+                       const StreamedValueStore::DataFromType &from_type,\n+                       const StreamedValueStore::StreamedValueData &from_store)\n+      : _type(type),\n+        _cells(from_store.cells_ref),\n+        my_index(from_type.num_mapped_dimensions,\n+                 from_store.num_subspaces)\n+    {\n+        assert(_type.cell_type() == _cells.type);\n+        std::vector<vespalib::stringref> address(from_type.num_mapped_dimensions);\n+        auto block_stream = ValueBlockStream(from_type, from_store);\n+        size_t ss = 0;\n+        while (auto block = block_stream.next_block()) {\n+            size_t idx = my_index.map.add_mapping(block.address);\n+            if (idx != ss) {\n+                LOG(error, \"add_mapping returned idx=%zu for subspace %zu\", idx, ss);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDU4OTcwOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxNToyOFrOH6_4Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxNToyOFrOH6_4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNjAzOQ==", "bodyText": "Change to an assert.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531626039", "createdAt": "2020-11-27T14:15:28Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+\n+#include \"streamed_value_store.h\"\n+#include \"tensor_deserialize.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/streamed/streamed_value_builder_factory.h>\n+#include <vespa/eval/streamed/streamed_value_view.h>\n+#include <vespa/vespalib/datastore/datastore.hpp>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_store\");\n+\n+using vespalib::datastore::Handle;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+constexpr size_t MIN_BUFFER_ARRAYS = 1024;\n+\n+struct CellsMemBlock {\n+    uint32_t num;\n+    uint32_t total_sz;\n+    const char *ptr;\n+    CellsMemBlock(TypedCells cells)\n+      : num(cells.size),\n+        total_sz(CellTypeUtils::mem_size(cells.type, num)),\n+        ptr((const char *)cells.data)\n+    {}\n+};\n+\n+template<typename T>\n+T *fix_alignment(T *ptr, size_t align)\n+{\n+    static_assert(sizeof(T) == 1);\n+    assert((align & (align-1)) == 0); // must be 2^N\n+    size_t ptr_val = (size_t)ptr;\n+    size_t unalign = ptr_val & (align - 1);\n+    if (unalign == 0) {\n+        return ptr;\n+    } else {\n+        return ptr + (align - unalign);\n+    }\n+}\n+\n+} // namespace <unnamed>\n+\n+StreamedValueStore::StreamedValueStore(const ValueType &tensor_type)\n+  : TensorStore(_concreteStore),\n+    _concreteStore(),\n+    _bufferType(RefType::align(1),\n+                MIN_BUFFER_ARRAYS,\n+                RefType::offsetSize() / RefType::align(1)),\n+    _tensor_type(tensor_type),\n+    _data_from_type(_tensor_type)\n+{\n+    _store.addType(&_bufferType);\n+    _store.initActiveBuffers();\n+}\n+\n+StreamedValueStore::~StreamedValueStore()\n+{\n+    _store.dropBuffers();\n+}\n+\n+std::pair<const char *, uint32_t>\n+StreamedValueStore::getRawBuffer(RefType ref) const\n+{\n+    if (!ref.valid()) {\n+        return std::make_pair(nullptr, 0u);\n+    }\n+    const char *buf = _store.getEntry<char>(ref);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    return std::make_pair(buf + sizeof(uint32_t), len);\n+}\n+\n+Handle<char>\n+StreamedValueStore::allocRawBuffer(uint32_t size)\n+{\n+    if (size == 0) {\n+        return Handle<char>();\n+    }\n+    size_t extSize = size + sizeof(uint32_t);\n+    size_t bufSize = RefType::align(extSize);\n+    auto result = _concreteStore.rawAllocator<char>(_typeId).alloc(bufSize);\n+    *reinterpret_cast<uint32_t *>(result.data) = size;\n+    char *padWritePtr = result.data + extSize;\n+    for (size_t i = extSize; i < bufSize; ++i) {\n+        *padWritePtr++ = 0;\n+    }\n+    // Hide length of buffer (first 4 bytes) from users of the buffer.\n+    return Handle<char>(result.ref, result.data + sizeof(uint32_t));\n+}\n+\n+void\n+StreamedValueStore::holdTensor(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return;\n+    }\n+    RefType iRef(ref);\n+    const char *buf = _store.getEntry<char>(iRef);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    _concreteStore.holdElem(ref, len + sizeof(uint32_t));\n+}\n+\n+TensorStore::EntryRef\n+StreamedValueStore::move(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return RefType();\n+    }\n+    auto oldraw = getRawBuffer(ref);\n+    auto newraw = allocRawBuffer(oldraw.second);\n+    memcpy(newraw.data, oldraw.first, oldraw.second);\n+    _concreteStore.holdElem(ref, oldraw.second + sizeof(uint32_t));\n+    return newraw.ref;\n+}\n+\n+StreamedValueStore::StreamedValueData\n+StreamedValueStore::get_tensor_data(EntryRef ref) const\n+{\n+    StreamedValueData retval;\n+    retval.valid = false;\n+    auto raw = getRawBuffer(ref);\n+    if (raw.second == 0u) {\n+        return retval;\n+    }\n+    vespalib::nbostream_longlivedbuf source(raw.first, raw.second);\n+    uint32_t num_cells = source.readValue<uint32_t>();\n+    {\n+        uint32_t alignment = CellTypeUtils::alignment(_data_from_type.cell_type);\n+        const char *aligned_ptr = fix_alignment(source.peek(), alignment);\n+        size_t adjustment = aligned_ptr - source.peek();\n+        source.adjustReadPos(adjustment);\n+    }\n+    retval.cells_ref = TypedCells(source.peek(), _data_from_type.cell_type, num_cells);\n+    source.adjustReadPos(CellTypeUtils::mem_size(_data_from_type.cell_type, num_cells));\n+    retval.num_subspaces = source.readValue<uint32_t>();\n+    retval.labels_buffer = vespalib::ConstArrayRef<char>(source.peek(), source.size());\n+ \n+    if (retval.num_subspaces * _data_from_type.dense_subspace_size == num_cells) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNDU5MjU2OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxNjoxNlrOH6_56Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxNjoxNlrOH6_56Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNjQ3Mw==", "bodyText": "We can remove the log message with the assert above.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531626473", "createdAt": "2020-11-27T14:16:16Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+\n+#include \"streamed_value_store.h\"\n+#include \"tensor_deserialize.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/streamed/streamed_value_builder_factory.h>\n+#include <vespa/eval/streamed/streamed_value_view.h>\n+#include <vespa/vespalib/datastore/datastore.hpp>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_store\");\n+\n+using vespalib::datastore::Handle;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+constexpr size_t MIN_BUFFER_ARRAYS = 1024;\n+\n+struct CellsMemBlock {\n+    uint32_t num;\n+    uint32_t total_sz;\n+    const char *ptr;\n+    CellsMemBlock(TypedCells cells)\n+      : num(cells.size),\n+        total_sz(CellTypeUtils::mem_size(cells.type, num)),\n+        ptr((const char *)cells.data)\n+    {}\n+};\n+\n+template<typename T>\n+T *fix_alignment(T *ptr, size_t align)\n+{\n+    static_assert(sizeof(T) == 1);\n+    assert((align & (align-1)) == 0); // must be 2^N\n+    size_t ptr_val = (size_t)ptr;\n+    size_t unalign = ptr_val & (align - 1);\n+    if (unalign == 0) {\n+        return ptr;\n+    } else {\n+        return ptr + (align - unalign);\n+    }\n+}\n+\n+} // namespace <unnamed>\n+\n+StreamedValueStore::StreamedValueStore(const ValueType &tensor_type)\n+  : TensorStore(_concreteStore),\n+    _concreteStore(),\n+    _bufferType(RefType::align(1),\n+                MIN_BUFFER_ARRAYS,\n+                RefType::offsetSize() / RefType::align(1)),\n+    _tensor_type(tensor_type),\n+    _data_from_type(_tensor_type)\n+{\n+    _store.addType(&_bufferType);\n+    _store.initActiveBuffers();\n+}\n+\n+StreamedValueStore::~StreamedValueStore()\n+{\n+    _store.dropBuffers();\n+}\n+\n+std::pair<const char *, uint32_t>\n+StreamedValueStore::getRawBuffer(RefType ref) const\n+{\n+    if (!ref.valid()) {\n+        return std::make_pair(nullptr, 0u);\n+    }\n+    const char *buf = _store.getEntry<char>(ref);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    return std::make_pair(buf + sizeof(uint32_t), len);\n+}\n+\n+Handle<char>\n+StreamedValueStore::allocRawBuffer(uint32_t size)\n+{\n+    if (size == 0) {\n+        return Handle<char>();\n+    }\n+    size_t extSize = size + sizeof(uint32_t);\n+    size_t bufSize = RefType::align(extSize);\n+    auto result = _concreteStore.rawAllocator<char>(_typeId).alloc(bufSize);\n+    *reinterpret_cast<uint32_t *>(result.data) = size;\n+    char *padWritePtr = result.data + extSize;\n+    for (size_t i = extSize; i < bufSize; ++i) {\n+        *padWritePtr++ = 0;\n+    }\n+    // Hide length of buffer (first 4 bytes) from users of the buffer.\n+    return Handle<char>(result.ref, result.data + sizeof(uint32_t));\n+}\n+\n+void\n+StreamedValueStore::holdTensor(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return;\n+    }\n+    RefType iRef(ref);\n+    const char *buf = _store.getEntry<char>(iRef);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    _concreteStore.holdElem(ref, len + sizeof(uint32_t));\n+}\n+\n+TensorStore::EntryRef\n+StreamedValueStore::move(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return RefType();\n+    }\n+    auto oldraw = getRawBuffer(ref);\n+    auto newraw = allocRawBuffer(oldraw.second);\n+    memcpy(newraw.data, oldraw.first, oldraw.second);\n+    _concreteStore.holdElem(ref, oldraw.second + sizeof(uint32_t));\n+    return newraw.ref;\n+}\n+\n+StreamedValueStore::StreamedValueData\n+StreamedValueStore::get_tensor_data(EntryRef ref) const\n+{\n+    StreamedValueData retval;\n+    retval.valid = false;\n+    auto raw = getRawBuffer(ref);\n+    if (raw.second == 0u) {\n+        return retval;\n+    }\n+    vespalib::nbostream_longlivedbuf source(raw.first, raw.second);\n+    uint32_t num_cells = source.readValue<uint32_t>();\n+    {\n+        uint32_t alignment = CellTypeUtils::alignment(_data_from_type.cell_type);\n+        const char *aligned_ptr = fix_alignment(source.peek(), alignment);\n+        size_t adjustment = aligned_ptr - source.peek();\n+        source.adjustReadPos(adjustment);\n+    }\n+    retval.cells_ref = TypedCells(source.peek(), _data_from_type.cell_type, num_cells);\n+    source.adjustReadPos(CellTypeUtils::mem_size(_data_from_type.cell_type, num_cells));\n+    retval.num_subspaces = source.readValue<uint32_t>();\n+    retval.labels_buffer = vespalib::ConstArrayRef<char>(source.peek(), source.size());\n+ \n+    if (retval.num_subspaces * _data_from_type.dense_subspace_size == num_cells) {\n+        retval.valid = true;\n+        return retval;\n+    }\n+    LOG(warning, \"inconsistent stored tensor data: \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c"}, "originalPosition": 149}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 820, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}