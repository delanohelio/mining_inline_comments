{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0ODcwOTI0", "number": 15168, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0NTo1N1rOE1OuHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwOTo0NjoyMlrOE1k57g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjUxMTY1OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/node_types.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0NTo1N1rOHtYtjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo0NTo1N1rOHtYtjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1Mjg0Ng==", "bodyText": "consider adding test of nested lambda type exporting", "url": "https://github.com/vespa-engine/vespa/pull/15168#discussion_r517352846", "createdAt": "2020-11-04T13:45:57Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/node_types.cpp", "diffHunk": "@@ -307,7 +307,13 @@ struct TypeExporter : public NodeTraverser {\n         : parent_type_map(parent_type_map_in),\n           exported_type_map(exported_type_map_out),\n           missing_cnt(0) {}\n-    bool open(const Node &) override { return true; }\n+    bool open(const Node &node) override {\n+        if (auto lambda = as<TensorLambda>(node)) {\n+            lambda->lambda().root().traverse(*this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc1685fc5a2eaff414a78c0e1bfec5b43df2cc10"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjUyOTI4OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/instruction/generic_lambda.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MDoxMFrOHtY4mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzo1MDoxMFrOHtY4mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM1NTY3Mw==", "bodyText": "consider creating uninitialized array", "url": "https://github.com/vespa-engine/vespa/pull/15168#discussion_r517355673", "createdAt": "2020-11-04T13:50:10Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/instruction/generic_lambda.cpp", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"generic_lambda.h\"\n+#include <vespa/eval/eval/llvm/compiled_function.h>\n+#include <vespa/eval/eval/llvm/compile_cache.h>\n+#include <assert.h>\n+\n+using namespace vespalib::eval::tensor_function;\n+\n+namespace vespalib::eval::instruction {\n+\n+using Instruction = InterpretedFunction::Instruction;\n+using State = InterpretedFunction::State;\n+\n+namespace {\n+\n+//-----------------------------------------------------------------------------\n+\n+bool step_labels(double *labels, const ValueType &type) {\n+    for (size_t idx = type.dimensions().size(); idx-- > 0; ) {\n+        if ((labels[idx] += 1.0) < type.dimensions()[idx].size) {\n+            return true;\n+        } else {\n+            labels[idx] = 0.0;\n+        }\n+    }\n+    return false;\n+}\n+\n+struct ParamProxy : public LazyParams {\n+    const std::vector<double> &labels;\n+    const LazyParams          &params;\n+    const std::vector<size_t> &bindings;\n+    ParamProxy(const std::vector<double> &labels_in, const LazyParams &params_in, const std::vector<size_t> &bindings_in)\n+        : labels(labels_in), params(params_in), bindings(bindings_in) {}\n+    const Value &resolve(size_t idx, Stash &stash) const override {\n+        if (idx < labels.size()) {\n+            return stash.create<DoubleValue>(labels[idx]);\n+        }\n+        return params.resolve(bindings[idx - labels.size()], stash);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+struct CompiledParams {\n+    const ValueType &result_type;\n+    const std::vector<size_t> &bindings;\n+    size_t num_cells;\n+    CompileCache::Token::UP token;\n+    CompiledParams(const Lambda &lambda) \n+        : result_type(lambda.result_type()),\n+          bindings(lambda.bindings()),\n+          num_cells(result_type.dense_subspace_size()),\n+          token(CompileCache::compile(lambda.lambda(), PassParams::ARRAY))\n+    {\n+        assert(lambda.lambda().num_params() == (result_type.dimensions().size() + bindings.size()));\n+    }\n+};\n+\n+template <typename CT>\n+void my_compiled_lambda_op(eval::InterpretedFunction::State &state, uint64_t param) {\n+    const CompiledParams &params = unwrap_param<CompiledParams>(param);\n+    std::vector<double> args(params.result_type.dimensions().size() + params.bindings.size(), 0.0);\n+    double *bind_next = &args[params.result_type.dimensions().size()];\n+    for (size_t binding: params.bindings) {\n+        *bind_next++ = state.params->resolve(binding, state.stash).as_double();\n+    }\n+    auto fun = params.token->get().get_function();\n+    ArrayRef<CT> dst_cells = state.stash.create_array<CT>(params.num_cells);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc1685fc5a2eaff414a78c0e1bfec5b43df2cc10"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Mjc2OTc1OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo0MjoxMFrOHtbLdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo0MjoxMFrOHtbLdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5MzI2OA==", "bodyText": "should verify that outer is equal to types", "url": "https://github.com/vespa-engine/vespa/pull/15168#discussion_r517393268", "createdAt": "2020-11-04T14:42:10Z", "author": {"login": "havardpe"}, "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -215,4 +215,16 @@ TEST(\"require that type resolving also include nodes in the inner tensor lambda\n     EXPECT_EQUAL(types.get_type(*symbol).to_spec(), \"double\");\n }\n \n+TEST(\"require that type exporting also include nodes in the inner tensor lambda function\") {\n+    auto fun = Function::parse(\"tensor(x[2])(tensor(y[2])((x+y)+a){y:(x)})\");\n+    NodeTypes types(*fun, {ValueType::from_spec(\"double\")});\n+    const auto &root = fun->root();\n+    auto lambda = nodes::as<nodes::TensorLambda>(root);\n+    ASSERT_TRUE(lambda != nullptr);\n+    NodeTypes outer = types.export_types(root);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88bbff8050f59d19b7cad81ae6067ab8b4c1636"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0Mjc3MjMxOnYy", "diffSide": "RIGHT", "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo0Mjo0M1rOHtbNCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo0Mjo0M1rOHtbNCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5MzY3NA==", "bodyText": "should also try to export the internal types of the inner lambda", "url": "https://github.com/vespa-engine/vespa/pull/15168#discussion_r517393674", "createdAt": "2020-11-04T14:42:43Z", "author": {"login": "havardpe"}, "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -215,4 +215,16 @@ TEST(\"require that type resolving also include nodes in the inner tensor lambda\n     EXPECT_EQUAL(types.get_type(*symbol).to_spec(), \"double\");\n }\n \n+TEST(\"require that type exporting also include nodes in the inner tensor lambda function\") {\n+    auto fun = Function::parse(\"tensor(x[2])(tensor(y[2])((x+y)+a){y:(x)})\");\n+    NodeTypes types(*fun, {ValueType::from_spec(\"double\")});\n+    const auto &root = fun->root();\n+    auto lambda = nodes::as<nodes::TensorLambda>(root);\n+    ASSERT_TRUE(lambda != nullptr);\n+    NodeTypes outer = types.export_types(root);\n+    ASSERT_TRUE(outer.errors().empty());\n+    NodeTypes inner = outer.export_types(lambda->lambda().root());\n+    EXPECT_TRUE(inner.errors().empty());\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88bbff8050f59d19b7cad81ae6067ab8b4c1636"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjgwNjA2OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/node_types.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo1MDowMVrOHtbiAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNDo1MDowMVrOHtbiAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5OTA0MQ==", "bodyText": "we need to also bind our own type, unfortunately, removing return false is the simplest way, which is a bit confusing.", "url": "https://github.com/vespa-engine/vespa/pull/15168#discussion_r517399041", "createdAt": "2020-11-04T14:50:01Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/node_types.cpp", "diffHunk": "@@ -307,7 +307,13 @@ struct TypeExporter : public NodeTraverser {\n         : parent_type_map(parent_type_map_in),\n           exported_type_map(exported_type_map_out),\n           missing_cnt(0) {}\n-    bool open(const Node &) override { return true; }\n+    bool open(const Node &node) override {\n+        if (auto lambda = as<TensorLambda>(node)) {\n+            lambda->lambda().root().traverse(*this);\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d88bbff8050f59d19b7cad81ae6067ab8b4c1636"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NjE0NjM4OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwOTo0NjoyMlrOHt7OWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwOTo0NjoyMlrOHt7OWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzkxODI5Nw==", "bodyText": "I would prefer something like count_types, since this is not really related to exporting", "url": "https://github.com/vespa-engine/vespa/pull/15168#discussion_r517918297", "createdAt": "2020-11-05T09:46:22Z", "author": {"login": "havardpe"}, "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -215,16 +215,31 @@ TEST(\"require that type resolving also include nodes in the inner tensor lambda\n     EXPECT_EQUAL(types.get_type(*symbol).to_spec(), \"double\");\n }\n \n+size_t num_exported(const NodeTypes &types) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8092b21022943489786fe27c02d4a79942382ee7"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 979, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}