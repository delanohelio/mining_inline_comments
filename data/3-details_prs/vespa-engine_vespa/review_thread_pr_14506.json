{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxNzI3MzYx", "number": 14506, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjoyNjozN1rOEmkGXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjo1MzozNVrOEmsSug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODcyNzk5OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/value_codec.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjoyNjozN1rOHWqjrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjoyNjozN1rOHWqjrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyNzk4Mg==", "bodyText": "I suggest we call this encode_value. Also, we could mention that this requires new api compliance in the comment.", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493527982", "createdAt": "2020-09-23T12:26:37Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/value_codec.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"simple_value.h\"\n+#include <vespa/vespalib/stllike/string.h>\n+\n+namespace vespalib { class nbostream; }\n+\n+namespace vespalib::eval {\n+\n+/**\n+ * encode a value to binary format\n+ **/\n+void new_encode(const Value &value, nbostream &output);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODcyOTc3OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/value_codec.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjoyNjo1OVrOHWqkwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjoyNjo1OVrOHWqkwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUyODI1OA==", "bodyText": "I suggest we call this decode_value", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493528258", "createdAt": "2020-09-23T12:26:59Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/value_codec.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"simple_value.h\"\n+#include <vespa/vespalib/stllike/string.h>\n+\n+namespace vespalib { class nbostream; }\n+\n+namespace vespalib::eval {\n+\n+/**\n+ * encode a value to binary format\n+ **/\n+void new_encode(const Value &value, nbostream &output);\n+\n+/**\n+ * decode a value from binary format\n+ **/\n+std::unique_ptr<Value> new_decode(nbostream &input, const ValueBuilderFactory &factory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODc3ODU3OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/codec.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjozNTowMlrOHWrClA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjozNTowMlrOHWrClA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNTg5Mg==", "bodyText": "this is a vital part of the SimpleTensor implementation that was re-used for encoding purposes, I do not think this should be moved out of like this. I think we should keep this one in SimpleTensor as-is and add a similar DecodePlan to value_codec.cpp", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493535892", "createdAt": "2020-09-23T12:35:02Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/codec.h", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"simple_tensor.h\"\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <cassert>\n+\n+namespace vespalib::eval::codec {\n+\n+using CellType = ValueType::CellType;\n+using IndexList = std::vector<size_t>;\n+\n+constexpr uint32_t DOUBLE_CELL_TYPE = 0;\n+constexpr uint32_t FLOAT_CELL_TYPE = 1;\n+\n+inline uint32_t cell_type_to_id(CellType cell_type) {\n+    switch (cell_type) {\n+    case CellType::DOUBLE: return DOUBLE_CELL_TYPE;\n+    case CellType::FLOAT: return FLOAT_CELL_TYPE;\n+    }\n+    abort();\n+}\n+\n+inline CellType id_to_cell_type(uint32_t id) {\n+    switch (id) {\n+    case DOUBLE_CELL_TYPE: return CellType::DOUBLE;\n+    case FLOAT_CELL_TYPE: return CellType::FLOAT;\n+    }\n+    abort();\n+}\n+\n+/**\n+ * Meta information about how a type can be decomposed into mapped and\n+ * indexed dimensions and also how large each block is. A block is a\n+ * dense-subspace consisting of all indexed dimensions that is\n+ * uniquely specified by the labels of all mapped dimensions.\n+ **/\n+struct TypeMeta {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODgxMDYxOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/simple_value.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MDozMlrOHWrWiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MDozMlrOHWrWiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MTAwMA==", "bodyText": "not really a hack since converting from a spec should use 0.0 as default value for all existing non-defined cells. good catch though.", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493541000", "createdAt": "2020-09-23T12:40:32Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/simple_value.cpp", "diffHunk": "@@ -45,6 +46,10 @@ struct CreateValueFromTensorSpec {\n             }\n             map[sparse_key][dense_key] = entry.second;\n         }\n+        // hack for passing some (invalid?) unit tests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODgyNDM3OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/simple_value.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MjozNlrOHWrfKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MjozNlrOHWrfKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0MzIxMQ==", "bodyText": "prefer using {} or similar instead of SparseKey()", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493543211", "createdAt": "2020-09-23T12:42:36Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/simple_value.cpp", "diffHunk": "@@ -45,6 +46,10 @@ struct CreateValueFromTensorSpec {\n             }\n             map[sparse_key][dense_key] = entry.second;\n         }\n+        // hack for passing some (invalid?) unit tests\n+        if (spec.cells().empty() && type.count_mapped_dimensions() == 0) {\n+            map[SparseKey()][0] = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4ODgyODQ0OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/simple_value.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MzoxNFrOHWrhvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxMjo0MzoxNFrOHWrhvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU0Mzg3MQ==", "bodyText": "prefer checking 'map' over spec", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493543871", "createdAt": "2020-09-23T12:43:14Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/simple_value.cpp", "diffHunk": "@@ -45,6 +46,10 @@ struct CreateValueFromTensorSpec {\n             }\n             map[sparse_key][dense_key] = entry.second;\n         }\n+        // hack for passing some (invalid?) unit tests\n+        if (spec.cells().empty() && type.count_mapped_dimensions() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff267e0d6323c3ad1ae10d3193e4c18c823a1b8"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDA2NzYzOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/value_type.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjo1Mjo1MVrOHW3vug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjo1Mjo1MVrOHW3vug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc0NDA1OA==", "bodyText": "should add unit test for this", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493744058", "createdAt": "2020-09-23T16:52:51Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/value_type.h", "diffHunk": "@@ -60,10 +60,12 @@ class ValueType\n     bool is_tensor() const { return (_type == Type::TENSOR); }\n     bool is_sparse() const;\n     bool is_dense() const;\n+    size_t count_indexed_dimensions() const;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a11a8d39ee7138e81fdc3d3b0adfd58cbeea84a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDA2ODU5OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/value_type.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjo1MzowNVrOHW3wVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjo1MzowNVrOHW3wVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc0NDIxMg==", "bodyText": "should add unit test for this", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493744212", "createdAt": "2020-09-23T16:53:05Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/value_type.h", "diffHunk": "@@ -60,10 +60,12 @@ class ValueType\n     bool is_tensor() const { return (_type == Type::TENSOR); }\n     bool is_sparse() const;\n     bool is_dense() const;\n+    size_t count_indexed_dimensions() const;\n     size_t count_mapped_dimensions() const;\n     size_t dense_subspace_size() const;\n     const std::vector<Dimension> &dimensions() const { return _dimensions; }\n     std::vector<Dimension> nontrivial_indexed_dimensions() const;\n+    std::vector<Dimension> indexed_dimensions() const;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a11a8d39ee7138e81fdc3d3b0adfd58cbeea84a"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDA3MDM0OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/value_codec.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjo1MzozNVrOHW3xeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjo1MzozNVrOHW3xeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc0NDUwNg==", "bodyText": "should also contain classes below", "url": "https://github.com/vespa-engine/vespa/pull/14506#discussion_r493744506", "createdAt": "2020-09-23T16:53:35Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/value_codec.cpp", "diffHunk": "@@ -0,0 +1,304 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"value_codec.h\"\n+#include \"tensor_spec.h\"\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/typify.h>\n+\n+namespace vespalib::eval {\n+\n+namespace {\n+\n+using CellType = ValueType::CellType;\n+using IndexList = std::vector<size_t>;\n+\n+constexpr uint32_t DOUBLE_CELL_TYPE = 0;\n+constexpr uint32_t FLOAT_CELL_TYPE = 1;\n+\n+inline uint32_t cell_type_to_id(CellType cell_type) {\n+    switch (cell_type) {\n+    case CellType::DOUBLE: return DOUBLE_CELL_TYPE;\n+    case CellType::FLOAT: return FLOAT_CELL_TYPE;\n+    }\n+    abort();\n+}\n+\n+inline CellType id_to_cell_type(uint32_t id) {\n+    switch (id) {\n+    case DOUBLE_CELL_TYPE: return CellType::DOUBLE;\n+    case FLOAT_CELL_TYPE: return CellType::FLOAT;\n+    }\n+    abort();\n+}\n+\n+struct Format {\n+    bool     has_sparse;\n+    bool     has_dense;\n+    bool     with_cell_type;\n+    uint32_t tag;\n+    explicit Format(const ValueType &type)\n+        : has_sparse(type.count_mapped_dimensions() > 0),\n+          has_dense((type.count_indexed_dimensions() > 0) || !has_sparse),\n+          with_cell_type(type.cell_type() != CellType::DOUBLE),\n+          tag((has_sparse ? 0x1 : 0) | (has_dense ? 0x2 : 0) | (with_cell_type ? 0x4 : 0)) {}\n+    explicit Format(uint32_t tag_in)\n+        : has_sparse((tag_in & 0x1) != 0),\n+          has_dense((tag_in & 0x2) != 0),\n+          with_cell_type((tag_in & 0x4) != 0),\n+          tag(tag_in) {}\n+    ~Format() {}\n+};\n+\n+void maybe_encode_cell_type(nbostream &output, const Format &format, CellType cell_type) {\n+    if (format.with_cell_type) {\n+        output.putInt1_4Bytes(cell_type_to_id(cell_type));\n+    }\n+}\n+\n+void encode_type(nbostream &output, const Format &format, const ValueType &type) {\n+    maybe_encode_cell_type(output, format, type.cell_type());\n+    if (format.has_sparse) {\n+        const auto & dims = type.mapped_dimensions();\n+        output.putInt1_4Bytes(dims.size());\n+        for (const auto & dim : dims) {\n+            output.writeSmallString(dim.name);\n+        }\n+    }\n+    if (format.has_dense) {\n+        const auto & dims = type.indexed_dimensions();\n+        output.putInt1_4Bytes(dims.size());\n+        for (const auto & dim : dims) {\n+            output.writeSmallString(dim.name);\n+            output.putInt1_4Bytes(dim.size);\n+        }\n+    }\n+}\n+\n+void maybe_encode_num_blocks(nbostream &output, bool has_mapped_dims, size_t num_blocks) {\n+    if (has_mapped_dims) {\n+        output.putInt1_4Bytes(num_blocks);\n+    }\n+}\n+\n+CellType maybe_decode_cell_type(nbostream &input, const Format &format) {\n+    if (format.with_cell_type) {\n+        return id_to_cell_type(input.getInt1_4Bytes());\n+    }\n+    return CellType::DOUBLE;\n+}\n+\n+ValueType decode_type(nbostream &input, const Format &format) {\n+    CellType cell_type = maybe_decode_cell_type(input, format);\n+    std::vector<ValueType::Dimension> dim_list;\n+    if (format.has_sparse) {\n+        size_t cnt = input.getInt1_4Bytes();\n+        for (size_t i = 0; i < cnt; ++i) {\n+            vespalib::string name;\n+            input.readSmallString(name);\n+            dim_list.emplace_back(name);\n+        }\n+    }\n+    if (format.has_dense) {\n+        size_t cnt = input.getInt1_4Bytes();\n+        for (size_t i = 0; i < cnt; ++i) {\n+            vespalib::string name;\n+            input.readSmallString(name);\n+            dim_list.emplace_back(name, input.getInt1_4Bytes());\n+        }\n+    }\n+    return ValueType::tensor_type(std::move(dim_list), cell_type);\n+}\n+\n+size_t maybe_decode_num_blocks(nbostream &input, bool has_mapped_dims, const Format &format) {\n+    if (has_mapped_dims || !format.has_dense) {\n+        return input.getInt1_4Bytes();\n+    }\n+    return 1;\n+}\n+\n+void encode_mapped_labels(nbostream &output, size_t num_mapped_dims, const std::vector<vespalib::stringref> &addr) {\n+    for (size_t i = 0; i < num_mapped_dims; ++i) {\n+        output.writeSmallString(addr[i]);\n+    }\n+}\n+\n+void decode_mapped_labels(nbostream &input, size_t num_mapped_dims, std::vector<vespalib::stringref> &addr) {\n+    for (size_t i = 0; i < num_mapped_dims; ++i) {\n+        size_t strSize = input.getInt1_4Bytes();\n+        addr[i] = vespalib::stringref(input.peek(), strSize);\n+        input.adjustReadPos(strSize);\n+    }\n+}\n+\n+\n+template<typename T>\n+void decode_cells(nbostream &input, size_t num_cells, ArrayRef<T> dst)\n+{\n+    T value;\n+    for (size_t i = 0; i < num_cells; ++i) {\n+        input >> value;\n+        dst[i] = value;\n+    }\n+}\n+\n+struct DecodeState {\n+    const ValueType &type;\n+    const size_t subspace_size;\n+    const size_t num_blocks;\n+    const size_t num_mapped_dims;\n+};\n+\n+struct ContentDecoder {\n+    template<typename T>\n+    static std::unique_ptr<Value> invoke(nbostream &input, const DecodeState &state, const ValueBuilderFactory &factory) {\n+        std::vector<vespalib::stringref> address(state.num_mapped_dims);\n+        auto builder = factory.create_value_builder<T>(state.type, state.num_mapped_dims, state.subspace_size, state.num_blocks);\n+        for (size_t i = 0; i < state.num_blocks; ++i) {\n+            decode_mapped_labels(input, state.num_mapped_dims, address);\n+            auto block_cells = builder->add_subspace(address);\n+            decode_cells(input, state.subspace_size, block_cells);\n+        }\n+        return builder->build(std::move(builder));\n+    }\n+};\n+\n+struct CreateValueFromTensorSpec {\n+    template <typename T> static std::unique_ptr<Value> invoke(const ValueType &type, const TensorSpec &spec, const ValueBuilderFactory &factory) {\n+        using SparseKey = std::vector<vespalib::stringref>;\n+        using DenseMap = std::map<size_t,T>;\n+        std::map<SparseKey,DenseMap> map;\n+        for (const auto &entry: spec.cells()) {\n+            SparseKey sparse_key;\n+            size_t dense_key = 0;\n+            for (const auto &dim: type.dimensions()) {\n+                auto pos = entry.first.find(dim.name);\n+                assert(pos != entry.first.end());\n+                assert(pos->second.is_mapped() == dim.is_mapped());\n+                if (dim.is_mapped()) {\n+                    sparse_key.emplace_back(pos->second.name);\n+                } else {\n+                    dense_key = (dense_key * dim.size) + pos->second.index;\n+                }\n+            }\n+            map[sparse_key][dense_key] = entry.second;\n+        }\n+        // if spec is missing the required dense space, add it here:\n+        if (map.empty() && type.count_mapped_dimensions() == 0) {\n+            map[{}][0] = 0;\n+        }\n+        auto builder = factory.create_value_builder<T>(type, type.count_mapped_dimensions(), type.dense_subspace_size(), map.size());\n+        for (const auto &entry: map) {\n+            auto subspace = builder->add_subspace(entry.first);\n+            for (const auto &cell: entry.second) {\n+                subspace[cell.first] = cell.second;\n+            }\n+        }\n+        return builder->build(std::move(builder));\n+    }\n+};\n+\n+struct CreateTensorSpecFromValue {\n+    template <typename T> static TensorSpec invoke(const Value &value) {\n+        auto cells = value.cells().typify<T>();\n+        TensorSpec spec(value.type().to_spec());\n+        size_t subspace_id = 0;\n+        size_t subspace_size = value.type().dense_subspace_size();\n+        std::vector<vespalib::stringref> labels(value.type().count_mapped_dimensions());\n+        std::vector<vespalib::stringref*> label_refs;\n+        for (auto &label: labels) {\n+            label_refs.push_back(&label);\n+        }\n+        auto view = value.index().create_view({});\n+        view->lookup({});\n+        while (view->next_result(label_refs, subspace_id)) {\n+            size_t label_idx = 0;\n+            TensorSpec::Address addr;\n+            for (const auto &dim: value.type().dimensions()) {\n+                if (dim.is_mapped()) {\n+                    addr.emplace(dim.name, labels[label_idx++]);\n+                }\n+            }\n+            for (size_t i = 0; i < subspace_size; ++i) {\n+                size_t dense_key = i;\n+                for (auto dim = value.type().dimensions().rbegin();\n+                     dim != value.type().dimensions().rend(); ++dim)\n+                {\n+                    if (dim->is_indexed()) {\n+                        size_t label = dense_key % dim->size;\n+                        addr.emplace(dim->name, label).first->second = TensorSpec::Label(label);\n+                        dense_key /= dim->size;\n+                    }\n+                }\n+                spec.add(addr, cells[(subspace_size * subspace_id) + i]);\n+            }\n+        }\n+        return spec;\n+    }\n+};\n+\n+} // namespace <unnamed>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a11a8d39ee7138e81fdc3d3b0adfd58cbeea84a"}, "originalPosition": 239}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1294, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}