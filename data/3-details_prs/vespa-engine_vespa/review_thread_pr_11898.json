{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2MTk0Mzcz", "number": 11898, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTo1NDoyNlrODaHFbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNTo1Nzo1MlrODaOP6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzA1NjQ2OnYy", "diffSide": "RIGHT", "path": "document/src/vespa/document/fieldvalue/serializablearray.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTo1NDoyNlrOFg4WtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNjoyMTo1MlrOFhEW9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMjA2OQ==", "bodyText": "Consider adding a if (&rhs != this) { self-assignment guard if this makes sense to have", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370022069", "createdAt": "2020-01-23T09:54:26Z", "author": {"login": "vekterli"}, "path": "document/src/vespa/document/fieldvalue/serializablearray.cpp", "diffHunk": "@@ -81,6 +81,13 @@ SerializableArray::SerializableArray(const SerializableArray& other)\n     }\n }\n \n+SerializableArray &\n+SerializableArray::operator=(const SerializableArray &rhs)\n+{\n+    *this = SerializableArray(rhs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "694e53f832e65010f246ba9ef4ab02796700c873"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIxODc0Mg==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370218742", "createdAt": "2020-01-23T16:21:52Z", "author": {"login": "baldersheim"}, "path": "document/src/vespa/document/fieldvalue/serializablearray.cpp", "diffHunk": "@@ -81,6 +81,13 @@ SerializableArray::SerializableArray(const SerializableArray& other)\n     }\n }\n \n+SerializableArray &\n+SerializableArray::operator=(const SerializableArray &rhs)\n+{\n+    *this = SerializableArray(rhs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMjA2OQ=="}, "originalCommit": {"oid": "694e53f832e65010f246ba9ef4ab02796700c873"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzM5NjE2OnYy", "diffSide": "RIGHT", "path": "document/src/vespa/document/base/documentid.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMTo1MTozNVrOFg7iuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNjoyMjo0OFrOFhEZPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA3NDI5OQ==", "bodyText": "As an aside, assuming there's no member with a potentially throwing destructor (marked noexcept(false)) destructors are implicitly noexcept by default. But even the core guidelines aren't 100% on when to specify it or not (https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c37-make-destructors-noexcept) so a core, complex type like this is probably a good place to have them.", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370074299", "createdAt": "2020-01-23T11:51:35Z", "author": {"login": "vekterli"}, "path": "document/src/vespa/document/base/documentid.cpp", "diffHunk": "@@ -29,7 +29,7 @@ DocumentId::DocumentId(vespalib::nbostream & is)\n \n DocumentId::DocumentId(const DocumentId & rhs) = default;\n DocumentId & DocumentId::operator = (const DocumentId & rhs) = default;\n-DocumentId::~DocumentId() = default;\n+DocumentId::~DocumentId() noexcept = default;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7f0c18c77929909632121f9baa52805addc4842"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIxOTMyNg==", "bodyText": "K, so more is better than less..", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370219326", "createdAt": "2020-01-23T16:22:48Z", "author": {"login": "baldersheim"}, "path": "document/src/vespa/document/base/documentid.cpp", "diffHunk": "@@ -29,7 +29,7 @@ DocumentId::DocumentId(vespalib::nbostream & is)\n \n DocumentId::DocumentId(const DocumentId & rhs) = default;\n DocumentId & DocumentId::operator = (const DocumentId & rhs) = default;\n-DocumentId::~DocumentId() = default;\n+DocumentId::~DocumentId() noexcept = default;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA3NDI5OQ=="}, "originalCommit": {"oid": "e7f0c18c77929909632121f9baa52805addc4842"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NzY1NDk3OnYy", "diffSide": "RIGHT", "path": "document/src/vespa/document/fieldvalue/serializablearray.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMzoyNjowMFrOFg99_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMzoyNjowMFrOFg99_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDExNDA0Ng==", "bodyText": "Consider renaming this type to something that describes the semantics a bit more. LazyUncompressableFieldData or something down that lane?", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370114046", "createdAt": "2020-01-23T13:26:00Z", "author": {"login": "vekterli"}, "path": "document/src/vespa/document/fieldvalue/serializablearray.h", "diffHunk": "@@ -159,17 +162,22 @@ class SerializableArray : public vespalib::Cloneable\n     }\n     void deCompress(); // throw (DeserializeException);\n \n+    struct Unlikely {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7f0c18c77929909632121f9baa52805addc4842"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODA1MjkzOnYy", "diffSide": "RIGHT", "path": "document/src/vespa/document/serialization/vespadocumentserializer.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNToxMTo1MFrOFhBuuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNjowOToyOVrOFhD65w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE3NTY3Mg==", "bodyText": "Presumably if we've merged two legacy chunks down to one, this ends up transitively setting hasChanged() == true for the struct, thereby causing it to be re-serialized as one chunk (as would be expected)?", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370175672", "createdAt": "2020-01-23T15:11:50Z", "author": {"login": "vekterli"}, "path": "document/src/vespa/document/serialization/vespadocumentserializer.cpp", "diffHunk": "@@ -86,89 +86,45 @@ void VespaDocumentSerializer::write(const DocumentType &value) {\n             << static_cast<uint16_t>(0);  // version\n }\n \n+namespace {\n+\n uint8_t\n-VespaDocumentSerializer::getContentCode(bool hasHeader, bool hasBody) const\n+getContentCode(bool hasContent)\n {\n-    uint8_t content = 0x01;  // Document type is always present.\n-    if (hasHeader) {\n-        content |= 0x02;  // Header is present.\n-    }\n-    if (hasBody) {\n-        content |= 0x04;  // Body is present.\n-    }\n-    return content;\n+    return 0x01u |  // Document type is always present\n+           (hasContent ? 0x02u : 0x00u);   // Payload ?\n }\n \n-static inline size_t wantChunks(bool hasHeader, bool hasBody) {\n-    size_t res = 0;\n-    if (hasHeader) ++res;\n-    if (hasBody) ++res;\n-    return res;\n }\n \n void\n-VespaDocumentSerializer::write(const Document &value, DocSerializationMode mode) {\n+VespaDocumentSerializer::write(const Document &value) {\n     nbostream doc_stream;\n     VespaDocumentSerializer doc_serializer(doc_stream);\n     doc_serializer.write(value.getId());\n \n-    bool hasHeader = false;\n-    bool hasBody = false;\n-\n-    const StructFieldValue::Chunks & chunks = value.getFields().getChunks();\n-\n-    for (const Field & field : value.getFields()) {\n-        if (field.isHeaderField()) {\n-            hasHeader = true;\n-        } else {\n-            hasBody = true;\n-        }\n-        if (hasHeader && hasBody) {\n-            break;\n-        }\n-    }\n-    if (mode != COMPLETE) {\n-        hasBody = false;\n-    }\n-    doc_stream << getContentCode(hasHeader, hasBody);\n+    bool hasContent = ! value.getFields().empty();\n+    doc_stream << getContentCode(hasContent);\n     doc_serializer.write(value.getType());\n \n-    if (chunks.size() == wantChunks(hasHeader, hasBody) &&\n-        !structNeedsReserialization(value.getFields()))\n-    {\n-        // here we assume the receiver can handle whatever serialization the\n-        // chunks contain, so we just send them as-is, even if some fields\n-        // may have moved from header to body or vice versa.\n-        if (hasHeader || hasBody) {\n-            assert( ! chunks.empty());\n-            doc_serializer.writeUnchanged(chunks[0]);\n-        }\n-        if (hasHeader && hasBody) {\n-            assert(chunks.size() == 2);\n-            doc_serializer.writeUnchanged(chunks[1]);\n-        }\n-    } else {\n-        if (hasHeader) {\n-            doc_serializer.write(value.getFields(), HeaderFields());\n-        }\n-        if (hasBody) {\n-            doc_serializer.write(value.getFields(), BodyFields());\n+    if ( hasContent ) {\n+        if (!structNeedsReserialization(value.getFields())) {\n+            doc_serializer.writeUnchanged(value.getFields().getFields());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7f0c18c77929909632121f9baa52805addc4842"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIxMTU1OQ==", "bodyText": "That was at least the intention.", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370211559", "createdAt": "2020-01-23T16:09:29Z", "author": {"login": "baldersheim"}, "path": "document/src/vespa/document/serialization/vespadocumentserializer.cpp", "diffHunk": "@@ -86,89 +86,45 @@ void VespaDocumentSerializer::write(const DocumentType &value) {\n             << static_cast<uint16_t>(0);  // version\n }\n \n+namespace {\n+\n uint8_t\n-VespaDocumentSerializer::getContentCode(bool hasHeader, bool hasBody) const\n+getContentCode(bool hasContent)\n {\n-    uint8_t content = 0x01;  // Document type is always present.\n-    if (hasHeader) {\n-        content |= 0x02;  // Header is present.\n-    }\n-    if (hasBody) {\n-        content |= 0x04;  // Body is present.\n-    }\n-    return content;\n+    return 0x01u |  // Document type is always present\n+           (hasContent ? 0x02u : 0x00u);   // Payload ?\n }\n \n-static inline size_t wantChunks(bool hasHeader, bool hasBody) {\n-    size_t res = 0;\n-    if (hasHeader) ++res;\n-    if (hasBody) ++res;\n-    return res;\n }\n \n void\n-VespaDocumentSerializer::write(const Document &value, DocSerializationMode mode) {\n+VespaDocumentSerializer::write(const Document &value) {\n     nbostream doc_stream;\n     VespaDocumentSerializer doc_serializer(doc_stream);\n     doc_serializer.write(value.getId());\n \n-    bool hasHeader = false;\n-    bool hasBody = false;\n-\n-    const StructFieldValue::Chunks & chunks = value.getFields().getChunks();\n-\n-    for (const Field & field : value.getFields()) {\n-        if (field.isHeaderField()) {\n-            hasHeader = true;\n-        } else {\n-            hasBody = true;\n-        }\n-        if (hasHeader && hasBody) {\n-            break;\n-        }\n-    }\n-    if (mode != COMPLETE) {\n-        hasBody = false;\n-    }\n-    doc_stream << getContentCode(hasHeader, hasBody);\n+    bool hasContent = ! value.getFields().empty();\n+    doc_stream << getContentCode(hasContent);\n     doc_serializer.write(value.getType());\n \n-    if (chunks.size() == wantChunks(hasHeader, hasBody) &&\n-        !structNeedsReserialization(value.getFields()))\n-    {\n-        // here we assume the receiver can handle whatever serialization the\n-        // chunks contain, so we just send them as-is, even if some fields\n-        // may have moved from header to body or vice versa.\n-        if (hasHeader || hasBody) {\n-            assert( ! chunks.empty());\n-            doc_serializer.writeUnchanged(chunks[0]);\n-        }\n-        if (hasHeader && hasBody) {\n-            assert(chunks.size() == 2);\n-            doc_serializer.writeUnchanged(chunks[1]);\n-        }\n-    } else {\n-        if (hasHeader) {\n-            doc_serializer.write(value.getFields(), HeaderFields());\n-        }\n-        if (hasBody) {\n-            doc_serializer.write(value.getFields(), BodyFields());\n+    if ( hasContent ) {\n+        if (!structNeedsReserialization(value.getFields())) {\n+            doc_serializer.writeUnchanged(value.getFields().getFields());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE3NTY3Mg=="}, "originalCommit": {"oid": "e7f0c18c77929909632121f9baa52805addc4842"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODA2NjY5OnYy", "diffSide": "RIGHT", "path": "storage/src/tests/persistence/processalltest.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNToxNToyOFrOFhB3Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNjoyMDowM1rOFhESog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE3Nzg2Nw==", "bodyText": "Nit: spurious extra indent", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370177867", "createdAt": "2020-01-23T15:15:28Z", "author": {"login": "vekterli"}, "path": "storage/src/tests/persistence/processalltest.cpp", "diffHunk": "@@ -166,7 +165,7 @@ TEST_F(ProcessAllHandlerTest, stat_bucket_request_can_returned_removed_entries)\n         \"  Timestamp: 208, id:mail:testdoctype1:n=4:42967.html, gid(0x04000000f19ece1668e6de48) (remove)\\n\"\n         \"  Timestamp: 209, id:mail:testdoctype1:n=4:6925.html, gid(0x04000000667c0b3cada830be) (remove)\\n\";\n \n-    EXPECT_EQ(expected, reply.getResults());\n+        EXPECT_EQ(expected, reply.getResults());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e7f0c18c77929909632121f9baa52805addc4842"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIxNzYzNA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370217634", "createdAt": "2020-01-23T16:20:03Z", "author": {"login": "baldersheim"}, "path": "storage/src/tests/persistence/processalltest.cpp", "diffHunk": "@@ -166,7 +165,7 @@ TEST_F(ProcessAllHandlerTest, stat_bucket_request_can_returned_removed_entries)\n         \"  Timestamp: 208, id:mail:testdoctype1:n=4:42967.html, gid(0x04000000f19ece1668e6de48) (remove)\\n\"\n         \"  Timestamp: 209, id:mail:testdoctype1:n=4:6925.html, gid(0x04000000667c0b3cada830be) (remove)\\n\";\n \n-    EXPECT_EQ(expected, reply.getResults());\n+        EXPECT_EQ(expected, reply.getResults());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE3Nzg2Nw=="}, "originalCommit": {"oid": "e7f0c18c77929909632121f9baa52805addc4842"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODE2NzQxOnYy", "diffSide": "RIGHT", "path": "document/src/vespa/document/fieldvalue/serializablearray.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNTo0MDo0NVrOFhC2KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNjoyODo0NFrOFhEm5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE5Mzk2MA==", "bodyText": "Is it possible for _unlikely to be nullptr at this point?", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370193960", "createdAt": "2020-01-23T15:40:45Z", "author": {"login": "vekterli"}, "path": "document/src/vespa/document/fieldvalue/serializablearray.cpp", "diffHunk": "@@ -26,84 +26,103 @@ class BufferMap : public BufferMapT {\n \n }\n \n-SerializableArray::SerializableArray()\n-    : _serializedCompression(CompressionConfig::NONE),\n-      _uncompressedLength(0)\n-{\n-}\n+SerializableArray::SerializableArray() = default;\n \n-SerializableArray::SerializableArray(EntryMap entries, ByteBuffer::UP buffer,\n+SerializableArray::SerializableArray(EntryMap entries, ByteBuffer buffer,\n                                      CompressionConfig::Type comp_type, uint32_t uncompressed_length)\n     : _entries(std::move(entries)),\n-      _owned(),\n-      _serializedCompression(comp_type)\n+      _uncompSerData(),\n+      _unlikely()\n {\n \n-    if (CompressionConfig::isCompressed(_serializedCompression)) {\n-        _compSerData = std::move(buffer);\n-        _uncompressedLength = uncompressed_length;\n+    if (CompressionConfig::isCompressed(comp_type)) {\n+        _unlikely = std::make_unique<Unlikely>();\n+        _unlikely->_compSerData = std::move(buffer);\n+        _unlikely->_serializedCompression = comp_type;\n+        _unlikely->_uncompressedLength = uncompressed_length;\n     } else {\n-        _uncompressedLength = buffer->getRemaining();\n         _uncompSerData = std::move(buffer);\n     }\n }\n \n-serializablearray::BufferMap &\n-ensure(std::unique_ptr<serializablearray::BufferMap> & owned) {\n+SerializableArray::SerializableArray(SerializableArray &&) noexcept = default;\n+SerializableArray& SerializableArray::operator=(SerializableArray &&) noexcept = default;\n+SerializableArray::~SerializableArray() = default;\n+\n+namespace {\n+\n+template <typename T>\n+T &\n+ensure(std::unique_ptr<T> &owned) {\n     if (!owned) {\n-        owned = std::make_unique<serializablearray::BufferMap>();\n+        owned = std::make_unique<T>();\n     }\n     return *owned;\n }\n \n-SerializableArray::SerializableArray(const SerializableArray& other)\n-    : Cloneable(),\n-      _entries(other._entries),\n-      _owned(),\n-      _uncompSerData(other._uncompSerData.get() ? new ByteBuffer(*other._uncompSerData) : nullptr),\n-      _compSerData(other._compSerData.get() ? new ByteBuffer(*other._compSerData) : nullptr),\n-      _serializedCompression(other._serializedCompression),\n-      _uncompressedLength(other._uncompressedLength)\n+}\n+\n+SerializableArray::Unlikely::Unlikely()\n+    : _owned(),\n+      _compSerData(nullptr, 0),\n+      _serializedCompression(CompressionConfig::NONE),\n+      _uncompressedLength(0)\n+{ }\n+SerializableArray::Unlikely::~Unlikely() = default;\n+\n+SerializableArray::Unlikely::Unlikely(const Unlikely & rhs)\n+    : _owned(),\n+      _compSerData(rhs._compSerData),\n+      _serializedCompression(rhs._serializedCompression),\n+      _uncompressedLength(rhs._uncompressedLength)\n+{ }\n+\n+SerializableArray::SerializableArray(const SerializableArray& rhs)\n+    : _entries(rhs._entries),\n+      _uncompSerData(rhs._uncompSerData),\n+      _unlikely(rhs._unlikely ? new Unlikely(*rhs._unlikely) : nullptr)\n {\n     for (size_t i(0); i < _entries.size(); i++) {\n         Entry & e(_entries[i]);\n         if (e.hasBuffer()) {\n             // Pointing to a buffer in the _owned structure.\n-            ByteBuffer::UP buf(ByteBuffer::copyBuffer(e.getBuffer(_uncompSerData.get()), e.size()));\n-            e.setBuffer(buf->getBuffer());\n-            ensure(_owned)[e.id()] = std::move(buf);\n+            ByteBuffer buf(ByteBuffer::copyBuffer(e.getBuffer(&_uncompSerData), e.size()));\n+            e.setBuffer(buf.getBuffer());\n+            ensure(_unlikely->_owned)[e.id()] = std::move(buf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a97a9c569be961b79bea5990296f414d7f3f935"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIyMjgyMg==", "bodyText": "No, that should not be possible.\ne.hasBuffer will only be true if rhs._unlikely._owened has an entry for e._id.\nAnd that again should guarantee that _unlikely is created in the initializer list.", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370222822", "createdAt": "2020-01-23T16:28:44Z", "author": {"login": "baldersheim"}, "path": "document/src/vespa/document/fieldvalue/serializablearray.cpp", "diffHunk": "@@ -26,84 +26,103 @@ class BufferMap : public BufferMapT {\n \n }\n \n-SerializableArray::SerializableArray()\n-    : _serializedCompression(CompressionConfig::NONE),\n-      _uncompressedLength(0)\n-{\n-}\n+SerializableArray::SerializableArray() = default;\n \n-SerializableArray::SerializableArray(EntryMap entries, ByteBuffer::UP buffer,\n+SerializableArray::SerializableArray(EntryMap entries, ByteBuffer buffer,\n                                      CompressionConfig::Type comp_type, uint32_t uncompressed_length)\n     : _entries(std::move(entries)),\n-      _owned(),\n-      _serializedCompression(comp_type)\n+      _uncompSerData(),\n+      _unlikely()\n {\n \n-    if (CompressionConfig::isCompressed(_serializedCompression)) {\n-        _compSerData = std::move(buffer);\n-        _uncompressedLength = uncompressed_length;\n+    if (CompressionConfig::isCompressed(comp_type)) {\n+        _unlikely = std::make_unique<Unlikely>();\n+        _unlikely->_compSerData = std::move(buffer);\n+        _unlikely->_serializedCompression = comp_type;\n+        _unlikely->_uncompressedLength = uncompressed_length;\n     } else {\n-        _uncompressedLength = buffer->getRemaining();\n         _uncompSerData = std::move(buffer);\n     }\n }\n \n-serializablearray::BufferMap &\n-ensure(std::unique_ptr<serializablearray::BufferMap> & owned) {\n+SerializableArray::SerializableArray(SerializableArray &&) noexcept = default;\n+SerializableArray& SerializableArray::operator=(SerializableArray &&) noexcept = default;\n+SerializableArray::~SerializableArray() = default;\n+\n+namespace {\n+\n+template <typename T>\n+T &\n+ensure(std::unique_ptr<T> &owned) {\n     if (!owned) {\n-        owned = std::make_unique<serializablearray::BufferMap>();\n+        owned = std::make_unique<T>();\n     }\n     return *owned;\n }\n \n-SerializableArray::SerializableArray(const SerializableArray& other)\n-    : Cloneable(),\n-      _entries(other._entries),\n-      _owned(),\n-      _uncompSerData(other._uncompSerData.get() ? new ByteBuffer(*other._uncompSerData) : nullptr),\n-      _compSerData(other._compSerData.get() ? new ByteBuffer(*other._compSerData) : nullptr),\n-      _serializedCompression(other._serializedCompression),\n-      _uncompressedLength(other._uncompressedLength)\n+}\n+\n+SerializableArray::Unlikely::Unlikely()\n+    : _owned(),\n+      _compSerData(nullptr, 0),\n+      _serializedCompression(CompressionConfig::NONE),\n+      _uncompressedLength(0)\n+{ }\n+SerializableArray::Unlikely::~Unlikely() = default;\n+\n+SerializableArray::Unlikely::Unlikely(const Unlikely & rhs)\n+    : _owned(),\n+      _compSerData(rhs._compSerData),\n+      _serializedCompression(rhs._serializedCompression),\n+      _uncompressedLength(rhs._uncompressedLength)\n+{ }\n+\n+SerializableArray::SerializableArray(const SerializableArray& rhs)\n+    : _entries(rhs._entries),\n+      _uncompSerData(rhs._uncompSerData),\n+      _unlikely(rhs._unlikely ? new Unlikely(*rhs._unlikely) : nullptr)\n {\n     for (size_t i(0); i < _entries.size(); i++) {\n         Entry & e(_entries[i]);\n         if (e.hasBuffer()) {\n             // Pointing to a buffer in the _owned structure.\n-            ByteBuffer::UP buf(ByteBuffer::copyBuffer(e.getBuffer(_uncompSerData.get()), e.size()));\n-            e.setBuffer(buf->getBuffer());\n-            ensure(_owned)[e.id()] = std::move(buf);\n+            ByteBuffer buf(ByteBuffer::copyBuffer(e.getBuffer(&_uncompSerData), e.size()));\n+            e.setBuffer(buf.getBuffer());\n+            ensure(_unlikely->_owned)[e.id()] = std::move(buf);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE5Mzk2MA=="}, "originalCommit": {"oid": "7a97a9c569be961b79bea5990296f414d7f3f935"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODIwNDE2OnYy", "diffSide": "RIGHT", "path": "document/src/vespa/document/fieldvalue/serializablearray.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNTo1MDozOFrOFhDONQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNjozNDo0N1rOFhE1RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIwMDExNw==", "bodyText": "Wondering if we should add an assert(buffer.getRemaining() < 0x80000000) to ensure Entry does not get tricked into believing the size MSB means something else than it does (it decides union interpretation based on this today).", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370200117", "createdAt": "2020-01-23T15:50:38Z", "author": {"login": "vekterli"}, "path": "document/src/vespa/document/fieldvalue/serializablearray.cpp", "diffHunk": "@@ -26,84 +26,103 @@ class BufferMap : public BufferMapT {\n \n }\n \n-SerializableArray::SerializableArray()\n-    : _serializedCompression(CompressionConfig::NONE),\n-      _uncompressedLength(0)\n-{\n-}\n+SerializableArray::SerializableArray() = default;\n \n-SerializableArray::SerializableArray(EntryMap entries, ByteBuffer::UP buffer,\n+SerializableArray::SerializableArray(EntryMap entries, ByteBuffer buffer,\n                                      CompressionConfig::Type comp_type, uint32_t uncompressed_length)\n     : _entries(std::move(entries)),\n-      _owned(),\n-      _serializedCompression(comp_type)\n+      _uncompSerData(),\n+      _unlikely()\n {\n \n-    if (CompressionConfig::isCompressed(_serializedCompression)) {\n-        _compSerData = std::move(buffer);\n-        _uncompressedLength = uncompressed_length;\n+    if (CompressionConfig::isCompressed(comp_type)) {\n+        _unlikely = std::make_unique<Unlikely>();\n+        _unlikely->_compSerData = std::move(buffer);\n+        _unlikely->_serializedCompression = comp_type;\n+        _unlikely->_uncompressedLength = uncompressed_length;\n     } else {\n-        _uncompressedLength = buffer->getRemaining();\n         _uncompSerData = std::move(buffer);\n     }\n }\n \n-serializablearray::BufferMap &\n-ensure(std::unique_ptr<serializablearray::BufferMap> & owned) {\n+SerializableArray::SerializableArray(SerializableArray &&) noexcept = default;\n+SerializableArray& SerializableArray::operator=(SerializableArray &&) noexcept = default;\n+SerializableArray::~SerializableArray() = default;\n+\n+namespace {\n+\n+template <typename T>\n+T &\n+ensure(std::unique_ptr<T> &owned) {\n     if (!owned) {\n-        owned = std::make_unique<serializablearray::BufferMap>();\n+        owned = std::make_unique<T>();\n     }\n     return *owned;\n }\n \n-SerializableArray::SerializableArray(const SerializableArray& other)\n-    : Cloneable(),\n-      _entries(other._entries),\n-      _owned(),\n-      _uncompSerData(other._uncompSerData.get() ? new ByteBuffer(*other._uncompSerData) : nullptr),\n-      _compSerData(other._compSerData.get() ? new ByteBuffer(*other._compSerData) : nullptr),\n-      _serializedCompression(other._serializedCompression),\n-      _uncompressedLength(other._uncompressedLength)\n+}\n+\n+SerializableArray::Unlikely::Unlikely()\n+    : _owned(),\n+      _compSerData(nullptr, 0),\n+      _serializedCompression(CompressionConfig::NONE),\n+      _uncompressedLength(0)\n+{ }\n+SerializableArray::Unlikely::~Unlikely() = default;\n+\n+SerializableArray::Unlikely::Unlikely(const Unlikely & rhs)\n+    : _owned(),\n+      _compSerData(rhs._compSerData),\n+      _serializedCompression(rhs._serializedCompression),\n+      _uncompressedLength(rhs._uncompressedLength)\n+{ }\n+\n+SerializableArray::SerializableArray(const SerializableArray& rhs)\n+    : _entries(rhs._entries),\n+      _uncompSerData(rhs._uncompSerData),\n+      _unlikely(rhs._unlikely ? new Unlikely(*rhs._unlikely) : nullptr)\n {\n     for (size_t i(0); i < _entries.size(); i++) {\n         Entry & e(_entries[i]);\n         if (e.hasBuffer()) {\n             // Pointing to a buffer in the _owned structure.\n-            ByteBuffer::UP buf(ByteBuffer::copyBuffer(e.getBuffer(_uncompSerData.get()), e.size()));\n-            e.setBuffer(buf->getBuffer());\n-            ensure(_owned)[e.id()] = std::move(buf);\n+            ByteBuffer buf(ByteBuffer::copyBuffer(e.getBuffer(&_uncompSerData), e.size()));\n+            e.setBuffer(buf.getBuffer());\n+            ensure(_unlikely->_owned)[e.id()] = std::move(buf);\n         } else {\n             // If not it is relative to the buffer _uncompSerData, and hence it is valid as is.\n         }\n     }\n-    if (_uncompSerData.get()) {\n-        LOG_ASSERT(_uncompressedLength == _uncompSerData->getRemaining());\n-    }\n+}\n+\n+SerializableArray &\n+SerializableArray::operator=(const SerializableArray &rhs)\n+{\n+    *this = SerializableArray(rhs);\n+    return *this;\n }\n \n void SerializableArray::clear()\n {\n     _entries.clear();\n-    _uncompSerData.reset();\n-    _compSerData.reset();\n-    _serializedCompression = CompressionConfig::NONE;\n-    _uncompressedLength = 0;\n+    _uncompSerData = ByteBuffer(nullptr, 0);\n+    _unlikely.reset();\n }\n \n-SerializableArray::~SerializableArray() = default;\n-\n void\n SerializableArray::invalidate()\n {\n-    _compSerData.reset();\n+    if (_unlikely) {\n+        _unlikely->_compSerData = ByteBuffer(nullptr, 0);;\n+    }\n }\n \n void\n-SerializableArray::set(int id, ByteBuffer::UP buffer)\n+SerializableArray::set(int id, ByteBuffer buffer)\n {\n     maybeDecompress();\n-    Entry e(id, buffer->getRemaining(), buffer->getBuffer());\n-    ensure(_owned)[id] = std::move(buffer);\n+    Entry e(id, buffer.getRemaining(), buffer.getBuffer());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a97a9c569be961b79bea5990296f414d7f3f935"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIyNjUwMA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370226500", "createdAt": "2020-01-23T16:34:47Z", "author": {"login": "baldersheim"}, "path": "document/src/vespa/document/fieldvalue/serializablearray.cpp", "diffHunk": "@@ -26,84 +26,103 @@ class BufferMap : public BufferMapT {\n \n }\n \n-SerializableArray::SerializableArray()\n-    : _serializedCompression(CompressionConfig::NONE),\n-      _uncompressedLength(0)\n-{\n-}\n+SerializableArray::SerializableArray() = default;\n \n-SerializableArray::SerializableArray(EntryMap entries, ByteBuffer::UP buffer,\n+SerializableArray::SerializableArray(EntryMap entries, ByteBuffer buffer,\n                                      CompressionConfig::Type comp_type, uint32_t uncompressed_length)\n     : _entries(std::move(entries)),\n-      _owned(),\n-      _serializedCompression(comp_type)\n+      _uncompSerData(),\n+      _unlikely()\n {\n \n-    if (CompressionConfig::isCompressed(_serializedCompression)) {\n-        _compSerData = std::move(buffer);\n-        _uncompressedLength = uncompressed_length;\n+    if (CompressionConfig::isCompressed(comp_type)) {\n+        _unlikely = std::make_unique<Unlikely>();\n+        _unlikely->_compSerData = std::move(buffer);\n+        _unlikely->_serializedCompression = comp_type;\n+        _unlikely->_uncompressedLength = uncompressed_length;\n     } else {\n-        _uncompressedLength = buffer->getRemaining();\n         _uncompSerData = std::move(buffer);\n     }\n }\n \n-serializablearray::BufferMap &\n-ensure(std::unique_ptr<serializablearray::BufferMap> & owned) {\n+SerializableArray::SerializableArray(SerializableArray &&) noexcept = default;\n+SerializableArray& SerializableArray::operator=(SerializableArray &&) noexcept = default;\n+SerializableArray::~SerializableArray() = default;\n+\n+namespace {\n+\n+template <typename T>\n+T &\n+ensure(std::unique_ptr<T> &owned) {\n     if (!owned) {\n-        owned = std::make_unique<serializablearray::BufferMap>();\n+        owned = std::make_unique<T>();\n     }\n     return *owned;\n }\n \n-SerializableArray::SerializableArray(const SerializableArray& other)\n-    : Cloneable(),\n-      _entries(other._entries),\n-      _owned(),\n-      _uncompSerData(other._uncompSerData.get() ? new ByteBuffer(*other._uncompSerData) : nullptr),\n-      _compSerData(other._compSerData.get() ? new ByteBuffer(*other._compSerData) : nullptr),\n-      _serializedCompression(other._serializedCompression),\n-      _uncompressedLength(other._uncompressedLength)\n+}\n+\n+SerializableArray::Unlikely::Unlikely()\n+    : _owned(),\n+      _compSerData(nullptr, 0),\n+      _serializedCompression(CompressionConfig::NONE),\n+      _uncompressedLength(0)\n+{ }\n+SerializableArray::Unlikely::~Unlikely() = default;\n+\n+SerializableArray::Unlikely::Unlikely(const Unlikely & rhs)\n+    : _owned(),\n+      _compSerData(rhs._compSerData),\n+      _serializedCompression(rhs._serializedCompression),\n+      _uncompressedLength(rhs._uncompressedLength)\n+{ }\n+\n+SerializableArray::SerializableArray(const SerializableArray& rhs)\n+    : _entries(rhs._entries),\n+      _uncompSerData(rhs._uncompSerData),\n+      _unlikely(rhs._unlikely ? new Unlikely(*rhs._unlikely) : nullptr)\n {\n     for (size_t i(0); i < _entries.size(); i++) {\n         Entry & e(_entries[i]);\n         if (e.hasBuffer()) {\n             // Pointing to a buffer in the _owned structure.\n-            ByteBuffer::UP buf(ByteBuffer::copyBuffer(e.getBuffer(_uncompSerData.get()), e.size()));\n-            e.setBuffer(buf->getBuffer());\n-            ensure(_owned)[e.id()] = std::move(buf);\n+            ByteBuffer buf(ByteBuffer::copyBuffer(e.getBuffer(&_uncompSerData), e.size()));\n+            e.setBuffer(buf.getBuffer());\n+            ensure(_unlikely->_owned)[e.id()] = std::move(buf);\n         } else {\n             // If not it is relative to the buffer _uncompSerData, and hence it is valid as is.\n         }\n     }\n-    if (_uncompSerData.get()) {\n-        LOG_ASSERT(_uncompressedLength == _uncompSerData->getRemaining());\n-    }\n+}\n+\n+SerializableArray &\n+SerializableArray::operator=(const SerializableArray &rhs)\n+{\n+    *this = SerializableArray(rhs);\n+    return *this;\n }\n \n void SerializableArray::clear()\n {\n     _entries.clear();\n-    _uncompSerData.reset();\n-    _compSerData.reset();\n-    _serializedCompression = CompressionConfig::NONE;\n-    _uncompressedLength = 0;\n+    _uncompSerData = ByteBuffer(nullptr, 0);\n+    _unlikely.reset();\n }\n \n-SerializableArray::~SerializableArray() = default;\n-\n void\n SerializableArray::invalidate()\n {\n-    _compSerData.reset();\n+    if (_unlikely) {\n+        _unlikely->_compSerData = ByteBuffer(nullptr, 0);;\n+    }\n }\n \n void\n-SerializableArray::set(int id, ByteBuffer::UP buffer)\n+SerializableArray::set(int id, ByteBuffer buffer)\n {\n     maybeDecompress();\n-    Entry e(id, buffer->getRemaining(), buffer->getBuffer());\n-    ensure(_owned)[id] = std::move(buffer);\n+    Entry e(id, buffer.getRemaining(), buffer.getBuffer());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIwMDExNw=="}, "originalCommit": {"oid": "7a97a9c569be961b79bea5990296f414d7f3f935"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4ODIzMDE2OnYy", "diffSide": "RIGHT", "path": "document/src/vespa/document/base/idstring.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNTo1Nzo1MlrOFhDfXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxNjozMjoyN1rOFhEvrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIwNDUwOQ==", "bodyText": "Will this be enough of a change in size that it will fail some sizeof-checking unit tests? PR build is broken on a presumably unrelated Java unit test, so C++ tests haven't been run.", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370204509", "createdAt": "2020-01-23T15:57:52Z", "author": {"login": "vekterli"}, "path": "document/src/vespa/document/base/idstring.h", "diffHunk": "@@ -57,7 +59,7 @@ class IdString {\n     private:\n         static constexpr uint32_t MAX_COMPONENTS = 4;\n         Offsets(vespalib::stringref id);\n-        uint16_t _offsets[MAX_COMPONENTS + 1];\n+        uint16_t _offsets[MAX_COMPONENTS];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a97a9c569be961b79bea5990296f414d7f3f935"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIyNTA3MA==", "bodyText": "No, it did not change size due to alignment requirement. Just added padding.", "url": "https://github.com/vespa-engine/vespa/pull/11898#discussion_r370225070", "createdAt": "2020-01-23T16:32:27Z", "author": {"login": "baldersheim"}, "path": "document/src/vespa/document/base/idstring.h", "diffHunk": "@@ -57,7 +59,7 @@ class IdString {\n     private:\n         static constexpr uint32_t MAX_COMPONENTS = 4;\n         Offsets(vespalib::stringref id);\n-        uint16_t _offsets[MAX_COMPONENTS + 1];\n+        uint16_t _offsets[MAX_COMPONENTS];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIwNDUwOQ=="}, "originalCommit": {"oid": "7a97a9c569be961b79bea5990296f414d7f3f935"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2614, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}