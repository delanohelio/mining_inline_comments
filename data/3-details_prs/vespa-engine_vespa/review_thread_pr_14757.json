{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5MjE0ODYx", "number": 14757, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozMDoxNlrOErhueA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwOTowMTowOFrOEr9tZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDc2NzkyOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/tensor_spec.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozMDoxNlrOHeV5lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozMDoxNlrOHeV5lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3ODEzNQ==", "bodyText": "I suggest just dropping concat, since others may also have use of this.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501578135", "createdAt": "2020-10-08T09:30:16Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/tensor_spec.cpp", "diffHunk": "@@ -46,9 +46,14 @@ TensorSpec & TensorSpec::operator = (const TensorSpec &) = default;\n TensorSpec::~TensorSpec() { }\n \n TensorSpec &\n-TensorSpec::set(Address address, double value) {\n-    auto res = _cells.emplace(std::move(address), value);\n-    if (!res.second) { assert(res.first->second.value == value); }\n+TensorSpec::add(Address address, double value) {\n+    auto [iter, inserted] = _cells.emplace(std::move(address), value);\n+    if (! inserted) {\n+        // to simplify reference concat implementation, allow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDc3NzU0OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozMjo0M1rOHeV_yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozMjo0M1rOHeV_yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3OTcyMw==", "bodyText": "vespalib::eval::operation::op2_t is the canonical type for this kind of function", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501579723", "createdAt": "2020-10-08T09:32:43Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.h", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::tensor {\n+\n+struct TensorPartialUpdate {\n+    using join_fun_t = double (*)(double, double);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDc4NzA2OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozNDo1OVrOHeWFUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozNDo1OVrOHeWFUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4MTEzOA==", "bodyText": "dimensions", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501581138", "createdAt": "2020-10-08T09:34:59Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.h", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::tensor {\n+\n+struct TensorPartialUpdate {\n+    using join_fun_t = double (*)(double, double);\n+    using Value = vespalib::eval::Value;\n+    using ValueBuilderFactory = vespalib::eval::ValueBuilderFactory;\n+\n+    // make a copy of the input, but apply function(oldvalue, modifier.cellvalue)\n+    // to cells which also exist in the \"modifier\".\n+    // modifier.type() must be sparse with exactly the same dimension names\n+    // as the input type.\n+    // returns null pointer if this constraint is violated.\n+    static Value::UP modify(const Value &input, join_fun_t function,\n+                            const Value &modifier, const ValueBuilderFactory &factory);\n+\n+    // make a copy of the input, but add or overwrite cells from add_cells.\n+    // requires same type for input and add_cells.\n+    // returns null pointer if this constraint is violated.\n+    static Value::UP add(const Value &input, const Value &add_cells, const ValueBuilderFactory &factory);\n+\n+    // make a copy of the input, but remove cells present in remove_spec.\n+    // cell values in remove_spec are ignored.\n+    // requires same set of mapped imensions input and remove_spec.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDgwNTE5OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozOToyOVrOHeWQlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozOToyOVrOHeWQlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4NDAyMg==", "bodyText": "is this too complicated?", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501584022", "createdAt": "2020-10-08T09:39:29Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDg0MDY4OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo0ODoyMFrOHeWmdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo0ODoyMFrOHeWmdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4OTYyMQ==", "bodyText": "const char * seems a bit low level", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501589621", "createdAt": "2020-10-08T09:48:20Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDg1MzEwOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo1MToyM1rOHeWt6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo1MToyM1rOHeWt6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5MTUzMA==", "bodyText": "no need for dimension name of you are not going to print stuff", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501591530", "createdAt": "2020-10-08T09:51:23Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MDg1OTU1OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo1Mjo1NVrOHeWxzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTo1Mjo1NVrOHeWxzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5MjUyNg==", "bodyText": "consider naming this something with Sparse; SparseAddresses, SparseCoords", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501592526", "createdAt": "2020-10-08T09:52:55Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTE2NTEzOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMToxNTo1NVrOHeZrkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMToxNTo1NVrOHeZrkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY0MDA4Mw==", "bodyText": "consider checking number of dimensions together with modifier sparseness and only checking valid here.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501640083", "createdAt": "2020-10-08T11:15:55Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTIwMDU5OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMToyNjozOFrOHeaBMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMToyNjozOFrOHeaBMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY0NTYxNw==", "bodyText": "consider doing simple encode/decode for value copy", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501645617", "createdAt": "2020-10-08T11:26:38Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||\n+            (input_dims.size() != modifier_dims.size()) ||\n+            (input_dims.size() != how.size()))\n+        {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.name.c_str(), dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, Addresses &helper, const ValueBuilderFactory &factory)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTI1MTE2OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMTo0MTowOVrOHeafbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMTo0MTowOVrOHeafbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY1MzM1Ng==", "bodyText": "compare to modifier.dimensions() directly to ensure there are no dense ones as well.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501653356", "createdAt": "2020-10-08T11:41:09Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||\n+            (input_dims.size() != modifier_dims.size()) ||\n+            (input_dims.size() != how.size()))\n+        {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.name.c_str(), dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, Addresses &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto view = input.index().create_view({});\n+    view->lookup({});\n+    auto input_cells = input.cells().typify<CT>();\n+    size_t input_subspace;\n+    while (view->next_result(helper.next_result_refs, input_subspace)) {\n+        size_t input_offset = input_subspace * dsss;\n+        auto src = input_cells.begin() + input_offset;\n+        auto dst = builder->add_subspace(helper.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_modify_value(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_modify_value<ICT,MCT>(input, function, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_add_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> overwritten_subspaces;\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(addrs.next_result_refs, modifier_subspace_index)) {\n+        size_t modifier_offset = dsss * modifier_subspace_index;\n+        auto src = modifier_cells.begin() + modifier_offset;\n+        auto dst = builder->add_subspace(addrs.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+        lookup_view->lookup(addrs.lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten_subspaces.insert(input_subspace_index);\n+        }\n+    }\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (overwritten_subspaces.count(input_subspace_index) == 0) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder->add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_add_cells<ICT,MCT>(input, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename ICT>\n+Value::UP\n+my_remove_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.mapped_dimensions()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTI1ODU3OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMTo0MzoyNFrOHeaj9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMTo0MzoyNFrOHeaj9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY1NDUxOQ==", "bodyText": "no need to precalculate this", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501654519", "createdAt": "2020-10-08T11:43:24Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||\n+            (input_dims.size() != modifier_dims.size()) ||\n+            (input_dims.size() != how.size()))\n+        {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.name.c_str(), dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, Addresses &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto view = input.index().create_view({});\n+    view->lookup({});\n+    auto input_cells = input.cells().typify<CT>();\n+    size_t input_subspace;\n+    while (view->next_result(helper.next_result_refs, input_subspace)) {\n+        size_t input_offset = input_subspace * dsss;\n+        auto src = input_cells.begin() + input_offset;\n+        auto dst = builder->add_subspace(helper.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_modify_value(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_modify_value<ICT,MCT>(input, function, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_add_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> overwritten_subspaces;\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(addrs.next_result_refs, modifier_subspace_index)) {\n+        size_t modifier_offset = dsss * modifier_subspace_index;\n+        auto src = modifier_cells.begin() + modifier_offset;\n+        auto dst = builder->add_subspace(addrs.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+        lookup_view->lookup(addrs.lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten_subspaces.insert(input_subspace_index);\n+        }\n+    }\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (overwritten_subspaces.count(input_subspace_index) == 0) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder->add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_add_cells<ICT,MCT>(input, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename ICT>\n+Value::UP\n+my_remove_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.mapped_dimensions()) {\n+        LOG(error, \"when removing cells from a tensor, mapped dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    if (input_type.mapped_dimensions().size() == 0) {\n+        LOG(error, \"cannot remove cells from a dense tensor\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> removed_subspaces;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 319}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTI2MDc4OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMTo0NDowN1rOHealZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMTo0NDowN1rOHealZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY1NDg4Ng==", "bodyText": "just look up directly in the modify view to find out which ones not to include", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501654886", "createdAt": "2020-10-08T11:44:07Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||\n+            (input_dims.size() != modifier_dims.size()) ||\n+            (input_dims.size() != how.size()))\n+        {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.name.c_str(), dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, Addresses &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto view = input.index().create_view({});\n+    view->lookup({});\n+    auto input_cells = input.cells().typify<CT>();\n+    size_t input_subspace;\n+    while (view->next_result(helper.next_result_refs, input_subspace)) {\n+        size_t input_offset = input_subspace * dsss;\n+        auto src = input_cells.begin() + input_offset;\n+        auto dst = builder->add_subspace(helper.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_modify_value(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_modify_value<ICT,MCT>(input, function, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_add_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> overwritten_subspaces;\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(addrs.next_result_refs, modifier_subspace_index)) {\n+        size_t modifier_offset = dsss * modifier_subspace_index;\n+        auto src = modifier_cells.begin() + modifier_offset;\n+        auto dst = builder->add_subspace(addrs.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+        lookup_view->lookup(addrs.lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten_subspaces.insert(input_subspace_index);\n+        }\n+    }\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (overwritten_subspaces.count(input_subspace_index) == 0) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder->add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_add_cells<ICT,MCT>(input, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename ICT>\n+Value::UP\n+my_remove_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.mapped_dimensions()) {\n+        LOG(error, \"when removing cells from a tensor, mapped dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    if (input_type.mapped_dimensions().size() == 0) {\n+        LOG(error, \"cannot remove cells from a dense tensor\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> removed_subspaces;\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(addrs.next_result_refs, modifier_subspace_index)) {\n+        lookup_view->lookup(addrs.lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            removed_subspaces.insert(input_subspace_index);\n+        }\n+    }\n+    const size_t expected_subspaces = input.index().size() - removed_subspaces.size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MTc2NjI1OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzo0NjoyOFrOHefZXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzo0NjoyOFrOHefZXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTczMzcyNw==", "bodyText": "I suggest switching from skip to keep semantic on the predicate. Also, I strongly suggest passing both the address and the subspace to avoid depending too much on side-effect on objects passed into this function.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501733727", "createdAt": "2020-10-08T13:46:28Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,347 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    MAPPED_MATCH, CONV_TO_INDEXED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                offset = npos();\n+                break;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(size_t sz) {\n+        dim_sizes.push_back(sz);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct SparseCoords {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    SparseCoords(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~SparseCoords();\n+};\n+SparseCoords::~SparseCoords() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    SparseCoords for_output;\n+    SparseCoords from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                   const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if (! valid) {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            return;\n+        }\n+        assert(input_dims.size() == modifier_dims.size());\n+        assert(input_dims.size() == how.size());\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT, typename ICT = CT, typename SkipFun>\n+void copy_tensor_with_filter(const Value &input,\n+                             size_t dsss,\n+                             SparseCoords &addrs,\n+                             ValueBuilder<CT> &builder,\n+                             SkipFun && skip_subspaces)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2ca43e7a54f922079e4778214708f7594fdac4c"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTA3NTk1OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwNzo0Mzo0NVrOHe-qpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwNzo0Mzo0NVrOHe-qpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI0NjA1NQ==", "bodyText": "Consider using /** */ for function comments (as done elsewhere). Also consider upper case letter when starting a sentence.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502246055", "createdAt": "2020-10-09T07:43:45Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/tensor/partial_update.h", "diffHunk": "@@ -0,0 +1,36 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::tensor {\n+\n+struct TensorPartialUpdate {\n+    using join_fun_t = double (*)(double, double);\n+    using Value = vespalib::eval::Value;\n+    using ValueBuilderFactory = vespalib::eval::ValueBuilderFactory;\n+\n+    // make a copy of the input, but apply function(oldvalue, modifier.cellvalue)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTA4OTQ0OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwNzo0Nzo0N1rOHe-y5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwNzo0Nzo0N1rOHe-y5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI0ODE2Ng==", "bodyText": "Consider printing tensor types in error message.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502248166", "createdAt": "2020-10-09T07:47:47Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,349 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    MAPPED_MATCH, CONV_TO_INDEXED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                offset = npos();\n+                break;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(size_t sz) {\n+        dim_sizes.push_back(sz);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct SparseCoords {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    SparseCoords(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~SparseCoords();\n+};\n+SparseCoords::~SparseCoords() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    SparseCoords for_output;\n+    SparseCoords from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                   const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if (! valid) {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            return;\n+        }\n+        assert(input_dims.size() == modifier_dims.size());\n+        assert(input_dims.size() == how.size());\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT, typename ICT = CT, typename KeepFun>\n+void copy_tensor_with_filter(const Value &input,\n+                             size_t dsss,\n+                             SparseCoords &addrs,\n+                             ValueBuilder<CT> &builder,\n+                             KeepFun && keep_subspace)\n+{\n+    const auto input_cells = input.cells().typify<ICT>();\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (keep_subspace(addrs.lookup_refs, input_subspace_index)) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder.add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+}\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, SparseCoords &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto no_filter = [] (const auto &, size_t) {\n+        return true;\n+    };\n+    copy_tensor_with_filter<CT>(input, dsss, helper, *builder, no_filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformModify::invoke(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformAdd::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTI4NTQzOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODo0MzowMlrOHfAqdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODo0MzowMlrOHfAqdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3ODc3NA==", "bodyText": "Consider printing tensor types in error message.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502278774", "createdAt": "2020-10-09T08:43:02Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,349 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    MAPPED_MATCH, CONV_TO_INDEXED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                offset = npos();\n+                break;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(size_t sz) {\n+        dim_sizes.push_back(sz);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct SparseCoords {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    SparseCoords(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~SparseCoords();\n+};\n+SparseCoords::~SparseCoords() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    SparseCoords for_output;\n+    SparseCoords from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                   const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if (! valid) {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            return;\n+        }\n+        assert(input_dims.size() == modifier_dims.size());\n+        assert(input_dims.size() == how.size());\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT, typename ICT = CT, typename KeepFun>\n+void copy_tensor_with_filter(const Value &input,\n+                             size_t dsss,\n+                             SparseCoords &addrs,\n+                             ValueBuilder<CT> &builder,\n+                             KeepFun && keep_subspace)\n+{\n+    const auto input_cells = input.cells().typify<ICT>();\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (keep_subspace(addrs.lookup_refs, input_subspace_index)) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder.add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+}\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, SparseCoords &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto no_filter = [] (const auto &, size_t) {\n+        return true;\n+    };\n+    copy_tensor_with_filter<CT>(input, dsss, helper, *builder, no_filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformModify::invoke(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformAdd::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    SparseCoords addrs(num_mapped_in_input);\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    std::vector<bool> overwritten(input.index().size(), false);\n+    auto remember_subspaces = [&] (const auto & lookup_refs, size_t) {\n+        lookup_view->lookup(lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten[input_subspace_index] = true;\n+        }\n+        return true;\n+    };\n+    copy_tensor_with_filter<ICT, MCT>(modifier, dsss, addrs, *builder, remember_subspaces);\n+    auto filter = [&] (const auto &, size_t input_subspace) {\n+        return ! overwritten[input_subspace];\n+    };\n+    copy_tensor_with_filter<ICT>(input, dsss, addrs, *builder, filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformRemove {\n+    template<typename ICT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT>\n+Value::UP\n+PerformRemove::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when removing cells from a tensor, mapped dimensions must be equal\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTI4NjQ5OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODo0MzoyMFrOHfArIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODo0MzoyMFrOHfArIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3ODk0Nw==", "bodyText": "Consider printing dense tensor type in error message.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502278947", "createdAt": "2020-10-09T08:43:20Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,349 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    MAPPED_MATCH, CONV_TO_INDEXED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                offset = npos();\n+                break;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(size_t sz) {\n+        dim_sizes.push_back(sz);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct SparseCoords {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    SparseCoords(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~SparseCoords();\n+};\n+SparseCoords::~SparseCoords() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    SparseCoords for_output;\n+    SparseCoords from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                   const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if (! valid) {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            return;\n+        }\n+        assert(input_dims.size() == modifier_dims.size());\n+        assert(input_dims.size() == how.size());\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT, typename ICT = CT, typename KeepFun>\n+void copy_tensor_with_filter(const Value &input,\n+                             size_t dsss,\n+                             SparseCoords &addrs,\n+                             ValueBuilder<CT> &builder,\n+                             KeepFun && keep_subspace)\n+{\n+    const auto input_cells = input.cells().typify<ICT>();\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (keep_subspace(addrs.lookup_refs, input_subspace_index)) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder.add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+}\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, SparseCoords &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto no_filter = [] (const auto &, size_t) {\n+        return true;\n+    };\n+    copy_tensor_with_filter<CT>(input, dsss, helper, *builder, no_filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformModify::invoke(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformAdd::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    SparseCoords addrs(num_mapped_in_input);\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    std::vector<bool> overwritten(input.index().size(), false);\n+    auto remember_subspaces = [&] (const auto & lookup_refs, size_t) {\n+        lookup_view->lookup(lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten[input_subspace_index] = true;\n+        }\n+        return true;\n+    };\n+    copy_tensor_with_filter<ICT, MCT>(modifier, dsss, addrs, *builder, remember_subspaces);\n+    auto filter = [&] (const auto &, size_t input_subspace) {\n+        return ! overwritten[input_subspace];\n+    };\n+    copy_tensor_with_filter<ICT>(input, dsss, addrs, *builder, filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformRemove {\n+    template<typename ICT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT>\n+Value::UP\n+PerformRemove::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when removing cells from a tensor, mapped dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    if (num_mapped_in_input == 0) {\n+        LOG(error, \"cannot remove cells from a dense tensor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTMyNjY1OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/tensor/partial_add/partial_add_test.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODo1NDoxNVrOHfBEAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODo1NDoxNVrOHfBEAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI4NTMxMw==", "bodyText": "Should we remove EXPECT_TRUE(up) on line 55 or the else clause?", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502285313", "createdAt": "2020-10-09T08:54:15Z", "author": {"login": "geirst"}, "path": "eval/src/tests/tensor/partial_add/partial_add_test.cpp", "diffHunk": "@@ -0,0 +1,123 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/tensor/cell_values.h>\n+#include <vespa/eval/tensor/default_tensor_engine.h>\n+#include <vespa/eval/tensor/partial_update.h>\n+#include <vespa/eval/tensor/sparse/sparse_tensor.h>\n+#include <vespa/eval/tensor/tensor.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <optional>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> add_layouts = {\n+    {x({\"a\"})},                           {x({\"b\"})},\n+    {x({\"a\",\"b\"})},                       {x({\"a\",\"c\"})},\n+    float_cells({x({\"a\",\"b\"})}),          {x({\"a\",\"c\"})},\n+    {x({\"a\",\"b\"})},                       float_cells({x({\"a\",\"c\"})}),\n+    float_cells({x({\"a\",\"b\"})}),          float_cells({x({\"a\",\"c\"})}),\n+    {x({\"a\",\"b\",\"c\"}),y({\"d\",\"e\"})},      {x({\"b\",\"f\"}),y({\"d\",\"g\"})},             \n+    {x(3),y({\"a\",\"b\"})},                  {x(3),y({\"b\",\"c\"})}\n+};\n+\n+TensorSpec reference_add(const TensorSpec &a, const TensorSpec &b) {\n+    TensorSpec result(a.type());\n+    for (const auto &cell: b.cells()) {\n+        result.add(cell.first, cell.second);\n+    }\n+    auto end_iter = b.cells().end();\n+    for (const auto &cell: a.cells()) {\n+        auto iter = b.cells().find(cell.first);\n+        if (iter == end_iter) {\n+            result.add(cell.first, cell.second);\n+        }\n+    }\n+    return result;\n+}\n+\n+Value::UP try_partial_add(const TensorSpec &a, const TensorSpec &b) {\n+    const auto &factory = SimpleValueBuilderFactory::get();\n+    auto lhs = value_from_spec(a, factory);\n+    auto rhs = value_from_spec(b, factory);\n+    return tensor::TensorPartialUpdate::add(*lhs, *rhs, factory);\n+}\n+\n+TensorSpec perform_partial_add(const TensorSpec &a, const TensorSpec &b) {\n+    auto up = try_partial_add(a, b);\n+    EXPECT_TRUE(up);\n+    if (up) {\n+        return spec_from_value(*up);\n+    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NTM1MjY5OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/tensor/partial_remove/partial_remove_test.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwOTowMTowOFrOHfBUIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwOTowMTowOFrOHfBUIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI4OTQ0Mw==", "bodyText": "Consider removing remains of debug printing.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502289443", "createdAt": "2020-10-09T09:01:08Z", "author": {"login": "geirst"}, "path": "eval/src/tests/tensor/partial_remove/partial_remove_test.cpp", "diffHunk": "@@ -0,0 +1,131 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/tensor/cell_values.h>\n+#include <vespa/eval/tensor/default_tensor_engine.h>\n+#include <vespa/eval/tensor/partial_update.h>\n+#include <vespa/eval/tensor/sparse/sparse_tensor.h>\n+#include <vespa/eval/tensor/tensor.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <optional>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> remove_layouts = {\n+    {x({\"a\"})},                           {x({\"b\"})},\n+    {x({\"a\",\"b\"})},                       {x({\"a\",\"c\"})},\n+    {x({\"a\",\"b\"})},                       {x({\"a\",\"b\"})},\n+    float_cells({x({\"a\",\"b\"})}),          {x({\"a\",\"c\"})},\n+    {x({\"a\",\"b\"})},                       float_cells({x({\"a\",\"c\"})}),\n+    float_cells({x({\"a\",\"b\"})}),          float_cells({x({\"a\",\"c\"})}),\n+    {x({\"a\",\"b\",\"c\"}),y({\"d\",\"e\"})},      {x({\"b\",\"f\"}),y({\"d\",\"g\"})},             \n+    {x(3),y({\"a\",\"b\"})},                  {y({\"b\",\"c\"})}\n+};\n+\n+TensorSpec::Address only_sparse(const TensorSpec::Address &input) {\n+    TensorSpec::Address output;\n+    for (const auto & kv : input) {\n+        if (kv.second.is_mapped()) {\n+            output.emplace(kv.first, kv.second);\n+        }\n+    }\n+    return output;\n+}\n+\n+TensorSpec reference_remove(const TensorSpec &a, const TensorSpec &b) {\n+    TensorSpec result(a.type());\n+    auto end_iter = b.cells().end();\n+    for (const auto &cell: a.cells()) {\n+        auto iter = b.cells().find(only_sparse(cell.first));\n+        if (iter == end_iter) {\n+            result.add(cell.first, cell.second);\n+        }\n+    }\n+    return result;\n+}\n+\n+Value::UP try_partial_remove(const TensorSpec &a, const TensorSpec &b) {\n+    const auto &factory = SimpleValueBuilderFactory::get();\n+    auto lhs = value_from_spec(a, factory);\n+    auto rhs = value_from_spec(b, factory);\n+    return tensor::TensorPartialUpdate::remove(*lhs, *rhs, factory);\n+}\n+\n+TensorSpec perform_partial_remove(const TensorSpec &a, const TensorSpec &b) {\n+    auto up = try_partial_remove(a, b);\n+    if (up) {\n+        return spec_from_value(*up);\n+    } else {\n+        return TensorSpec(a.type());\n+    }\n+}\n+\n+TensorSpec perform_old_remove(const TensorSpec &a, const TensorSpec &b) {\n+    const auto &engine = tensor::DefaultTensorEngine::ref();\n+    auto lhs = engine.from_spec(a);\n+    auto rhs = engine.from_spec(b);\n+    auto lhs_tensor = dynamic_cast<tensor::Tensor *>(lhs.get());\n+    EXPECT_TRUE(lhs_tensor);\n+    auto rhs_sparse = dynamic_cast<tensor::SparseTensor *>(rhs.get());\n+    EXPECT_TRUE(rhs_sparse);\n+    tensor::CellValues cell_values(*rhs_sparse);\n+    auto up = lhs_tensor->remove(cell_values);\n+    EXPECT_TRUE(up);\n+    return engine.to_spec(*up);\n+}\n+\n+\n+TEST(PartialAddTest, partial_remove_works_for_simple_values) {\n+    ASSERT_TRUE((remove_layouts.size() % 2) == 0);\n+    for (size_t i = 0; i < remove_layouts.size(); i += 2) {\n+        TensorSpec lhs = spec(remove_layouts[i], N());\n+        TensorSpec rhs = spec(remove_layouts[i + 1], Div16(N()));\n+        SCOPED_TRACE(fmt(\"\\n===\\nLHS: %s\\nRHS: %s\\n===\\n\", lhs.to_string().c_str(), rhs.to_string().c_str()));\n+        auto expect = reference_remove(lhs, rhs);\n+        auto actual = perform_partial_remove(lhs, rhs);\n+        EXPECT_EQ(actual, expect);\n+    }\n+}\n+\n+TEST(PartialAddTest, partial_remove_works_like_old_remove) {\n+    ASSERT_TRUE((remove_layouts.size() % 2) == 0);\n+    for (size_t i = 0; i < remove_layouts.size(); i += 2) {\n+        TensorSpec lhs = spec(remove_layouts[i], N());\n+        TensorSpec rhs = spec(remove_layouts[i + 1], Div16(N()));\n+        SCOPED_TRACE(fmt(\"\\n===\\nLHS: %s\\nRHS: %s\\n===\\n\", lhs.to_string().c_str(), rhs.to_string().c_str()));\n+        auto expect = perform_old_remove(lhs, rhs);\n+        auto actual = perform_partial_remove(lhs, rhs);\n+        EXPECT_EQ(actual, expect);\n+        // printf(\"%s remove %s -> %s\\n\", lhs.to_string().c_str(), rhs.to_string().c_str(), actual.to_string().c_str());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1211, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}