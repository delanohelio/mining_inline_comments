{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2OTM4NjY4", "number": 12540, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTozODoyNlrODnZIFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTowMzoyOFrODnyyQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNjMyNzI2OnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTozODoyNlrOF1XN8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTozOTowM1rOF1bHEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTI1MA==", "bodyText": "You can skip taking the lock here; consider using std::mutex and std::condition_variable instead.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391499250", "createdAt": "2020-03-12T09:38:26Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwODc2Ng==", "bodyText": "OK, will do, have not used them directly before.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391508766", "createdAt": "2020-03-12T09:55:04Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTI1MA=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU1NDU1NQ==", "bodyText": "cppreference doc on std::condition_variable is pretty handy on this subject:\n\nThe notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this \"hurry up and wait\" scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391554555", "createdAt": "2020-03-12T11:20:32Z", "author": {"login": "vekterli"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTI1MA=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MzAyNA==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391563024", "createdAt": "2020-03-12T11:39:03Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTI1MA=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNjMyNzc2OnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTozODozM1rOF1XOOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTozOToxNVrOF1bHYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTMyMA==", "bodyText": "You can skip taking the lock here; consider using std::mutex and std::condition_variable instead.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391499320", "createdAt": "2020-03-12T09:38:33Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.signal();\n+}\n+\n+void\n+SingleExecutor::sleepConsumer() {\n+    _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.wait(10ms);\n+    _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+}\n+\n+void\n+SingleExecutor::wakeupProducer() {\n+    MonitorGuard guard(_producerMonitor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MzEwNw==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391563107", "createdAt": "2020-03-12T11:39:15Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.signal();\n+}\n+\n+void\n+SingleExecutor::sleepConsumer() {\n+    _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.wait(10ms);\n+    _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+}\n+\n+void\n+SingleExecutor::wakeupProducer() {\n+    MonitorGuard guard(_producerMonitor);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTMyMA=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNjMzMTkwOnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTozOTo0NlrOF1XQwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTo1MjoyMlrOF1XtGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTk3MA==", "bodyText": "note that this signal may be lost since no state is being passed with the signal (the other thread might call wait after the signal has been discarded since no-one was waiting).", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391499970", "createdAt": "2020-03-12T09:39:46Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -60,7 +86,9 @@ SingleExecutor &\n SingleExecutor::sync() {\n     uint64_t wp = _wp.load(std::memory_order_relaxed);\n     while (wp > _rp.load(std::memory_order_acquire)) {\n-        std::this_thread::sleep_for(1ms);\n+        wakeupConsumer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwNzIyNQ==", "bodyText": "Yes, correct. The purpose is to wake up one that is sleeping waiting for low watermark to be reached.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391507225", "createdAt": "2020-03-12T09:52:22Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -60,7 +86,9 @@ SingleExecutor &\n SingleExecutor::sync() {\n     uint64_t wp = _wp.load(std::memory_order_relaxed);\n     while (wp > _rp.load(std::memory_order_acquire)) {\n-        std::this_thread::sleep_for(1ms);\n+        wakeupConsumer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ5OTk3MA=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNjM0NjAyOnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTo0MzozOFrOF1XZpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTo1Mzo0MVrOF1Xv5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjI0NQ==", "bodyText": "note that this signal may be lost since no state is being passed with the signal (the other thread might call wait after the signal has been discarded since no-one was waiting).", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391502245", "createdAt": "2020-03-12T09:43:38Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.signal();\n+}\n+\n+void\n+SingleExecutor::sleepConsumer() {\n+    _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.wait(10ms);\n+    _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+}\n+\n+void\n+SingleExecutor::wakeupProducer() {\n+    MonitorGuard guard(_producerMonitor);\n+    guard.signal();\n+}\n+\n+void\n+SingleExecutor::sleepProducer(MonitorGuard & guard) {\n+    _producerNeedWakeup.store(true, std::memory_order_relaxed);\n+    guard.wait(10ms);\n+    _producerNeedWakeup.store(false, std::memory_order_relaxed);\n+}\n+\n Executor::Task::UP\n SingleExecutor::execute(Task::UP task) {\n     uint64_t wp = addTask(std::move(task));\n     if (wp == _wakeupConsumerAt.load(std::memory_order_relaxed)) {\n-        MonitorGuard guard(_consumerMonitor);\n-        guard.signal();\n+        wakeupConsumer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwNzk0Mg==", "bodyText": "Yes, correct. The purpose is to wake up one that is sleeping waiting for low watermark to be reached.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391507942", "createdAt": "2020-03-12T09:53:41Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -41,12 +41,38 @@ SingleExecutor::addTask(Task::UP task) {\n     return wp;\n }\n \n+void\n+SingleExecutor::wakeupConsumer() {\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.signal();\n+}\n+\n+void\n+SingleExecutor::sleepConsumer() {\n+    _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n+    MonitorGuard guard(_consumerMonitor);\n+    guard.wait(10ms);\n+    _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+}\n+\n+void\n+SingleExecutor::wakeupProducer() {\n+    MonitorGuard guard(_producerMonitor);\n+    guard.signal();\n+}\n+\n+void\n+SingleExecutor::sleepProducer(MonitorGuard & guard) {\n+    _producerNeedWakeup.store(true, std::memory_order_relaxed);\n+    guard.wait(10ms);\n+    _producerNeedWakeup.store(false, std::memory_order_relaxed);\n+}\n+\n Executor::Task::UP\n SingleExecutor::execute(Task::UP task) {\n     uint64_t wp = addTask(std::move(task));\n     if (wp == _wakeupConsumerAt.load(std::memory_order_relaxed)) {\n-        MonitorGuard guard(_consumerMonitor);\n-        guard.signal();\n+        wakeupConsumer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjI0NQ=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNjM0ODg2OnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTo0NDoyNFrOF1XbUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTo1NDowNlrOF1Xw7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjY3Mw==", "bodyText": "note that this signal may be lost since no state is being passed with the signal (the other thread might call wait after the signal has been discarded since no-one was waiting).", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391502673", "createdAt": "2020-03-12T09:44:24Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -69,10 +97,8 @@ void\n SingleExecutor::run() {\n     while (!_thread.stopped()) {\n         drain_tasks();\n-        _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n-        MonitorGuard guard(_consumerMonitor);\n-        guard.wait(10ms);\n-        _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+        wakeupProducer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwODIwNw==", "bodyText": "Yes, correct. The purpose is to wake up one that is sleeping waiting for low watermark to be reached.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391508207", "createdAt": "2020-03-12T09:54:06Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -69,10 +97,8 @@ void\n SingleExecutor::run() {\n     while (!_thread.stopped()) {\n         drain_tasks();\n-        _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n-        MonitorGuard guard(_consumerMonitor);\n-        guard.wait(10ms);\n-        _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+        wakeupProducer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjY3Mw=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNjM0OTc3OnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwOTo0NDo0MFrOF1Xb6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTo0MToxOVrOF1bLNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjgyNw==", "bodyText": "note that this signal may be lost since no state is being passed with the signal (the other thread might call wait after the signal has been discarded since no-one was waiting).", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391502827", "createdAt": "2020-03-12T09:44:40Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -98,8 +124,7 @@ SingleExecutor::run_tasks_till(uint64_t available) {\n         task->run();\n         _rp.store(++consumed, std::memory_order_release);\n         if (wakeupLimit == consumed) {\n-            MonitorGuard guard(_producerMonitor);\n-            guard.broadcast();\n+            wakeupProducer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwODM2NQ==", "bodyText": "Yes, correct. The purpose is to wake up one that is sleeping waiting for low watermark to be reached.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391508365", "createdAt": "2020-03-12T09:54:19Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -98,8 +124,7 @@ SingleExecutor::run_tasks_till(uint64_t available) {\n         task->run();\n         _rp.store(++consumed, std::memory_order_release);\n         if (wakeupLimit == consumed) {\n-            MonitorGuard guard(_producerMonitor);\n-            guard.broadcast();\n+            wakeupProducer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjgyNw=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUyMDA5OQ==", "bodyText": "The purpose is irrelevant if the signal is lost. The thread you are trying to wake up will keep sleeping. This might not happen too often, but it could be a bit surprising when it does.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391520099", "createdAt": "2020-03-12T10:15:18Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -98,8 +124,7 @@ SingleExecutor::run_tasks_till(uint64_t available) {\n         task->run();\n         _rp.store(++consumed, std::memory_order_release);\n         if (wakeupLimit == consumed) {\n-            MonitorGuard guard(_producerMonitor);\n-            guard.broadcast();\n+            wakeupProducer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjgyNw=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2NDA4Ng==", "bodyText": "Now it will be attempted woken up again after every 100us. I think that should be good enough.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r391564086", "createdAt": "2020-03-12T11:41:19Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -98,8 +124,7 @@ SingleExecutor::run_tasks_till(uint64_t available) {\n         task->run();\n         _rp.store(++consumed, std::memory_order_release);\n         if (wakeupLimit == consumed) {\n-            MonitorGuard guard(_producerMonitor);\n-            guard.broadcast();\n+            wakeupProducer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUwMjgyNw=="}, "originalCommit": {"oid": "2c29c9d08fcaa0f23d6eb0015d904723bdc6976e"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDUzMTIyOnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMTowMzoyOFrOF1_rZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNTo0Njo1N1rOF2IugQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MjE0OA==", "bodyText": "letting go of the lock here will allow multiple threads to call drain at the same time. this might be ok, but could lead to creating more new buffers than you really need.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r392162148", "createdAt": "2020-03-13T11:03:28Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -56,11 +63,27 @@ SingleExecutor::setTaskLimit(uint32_t taskLimit) {\n     _wantedTaskLimit = vespalib::roundUp2inN(taskLimit);\n }\n \n+void\n+SingleExecutor::drain(Lock & lock) {\n+    uint64_t wp = _wp.load(std::memory_order_relaxed);\n+    while (numTasks() > 0) {\n+        _consumerCondition.notify_one();\n+        sleepProducer(lock, 100us, wp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3269532b70f203cd302820ce1adc3facfe35dcf8"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMxMDQwMQ==", "bodyText": "I think that is not a normal usecase.", "url": "https://github.com/vespa-engine/vespa/pull/12540#discussion_r392310401", "createdAt": "2020-03-13T15:46:57Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -56,11 +63,27 @@ SingleExecutor::setTaskLimit(uint32_t taskLimit) {\n     _wantedTaskLimit = vespalib::roundUp2inN(taskLimit);\n }\n \n+void\n+SingleExecutor::drain(Lock & lock) {\n+    uint64_t wp = _wp.load(std::memory_order_relaxed);\n+    while (numTasks() > 0) {\n+        _consumerCondition.notify_one();\n+        sleepProducer(lock, 100us, wp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MjE0OA=="}, "originalCommit": {"oid": "3269532b70f203cd302820ce1adc3facfe35dcf8"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2247, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}