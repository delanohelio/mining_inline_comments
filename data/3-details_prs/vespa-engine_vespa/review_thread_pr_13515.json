{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMxNjA4MTI4", "number": 13515, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODo1NTowMlrOEDxmaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoxODowNVrOED2FaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzkzODMyOnYy", "diffSide": "RIGHT", "path": "vespamalloc/src/tests/test1/new_test.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODo1NTowMlrOGg_V3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo0OToyOVrOGhBvKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0NTQwNA==", "bodyText": "As of C++17 you can leave out the message parameter to static_assert and it should just use the expression itself.", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437245404", "createdAt": "2020-06-09T08:55:02Z", "author": {"login": "vekterli"}, "path": "vespamalloc/src/tests/test1/new_test.cpp", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+#include <vespa/vespalib/testkit/testapp.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\"new_test\");\n+\n+void cmp(const void *a, const void *b) {\n+    EXPECT_EQUAL(a, b);\n+}\n+void cmp(const void *base, size_t offset, const void *p) {\n+    cmp((static_cast<const char *>(base) + offset), p);\n+}\n+\n+TEST(\"verify new with normal alignment\") {\n+    struct S {\n+        int a;\n+        long b;\n+        int c;\n+    };\n+    static_assert(sizeof(S) == 24, \"sizeof(S) == 16\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ef440733ef899251be945a1b3c985e76e4a6312"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NDY1MQ==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437284651", "createdAt": "2020-06-09T09:49:29Z", "author": {"login": "baldersheim"}, "path": "vespamalloc/src/tests/test1/new_test.cpp", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+#include <vespa/vespalib/testkit/testapp.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\"new_test\");\n+\n+void cmp(const void *a, const void *b) {\n+    EXPECT_EQUAL(a, b);\n+}\n+void cmp(const void *base, size_t offset, const void *p) {\n+    cmp((static_cast<const char *>(base) + offset), p);\n+}\n+\n+TEST(\"verify new with normal alignment\") {\n+    struct S {\n+        int a;\n+        long b;\n+        int c;\n+    };\n+    static_assert(sizeof(S) == 24, \"sizeof(S) == 16\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0NTQwNA=="}, "originalCommit": {"oid": "6ef440733ef899251be945a1b3c985e76e4a6312"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDAwMDkwOnYy", "diffSide": "RIGHT", "path": "vespamalloc/src/tests/test1/new_test.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTowNzowM1rOGg_7kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTo1MToyOFrOGhBzrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI1NTA1Nw==", "bodyText": "For these tests, should we additionally check the returned pointer alignment itself? The struct field alignments should be up to the compiler to get right. Might be enough to add a templated checker function that verifies  (uintptr_t(s.get()) % alignof(S)) == 0?", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437255057", "createdAt": "2020-06-09T09:07:03Z", "author": {"login": "vekterli"}, "path": "vespamalloc/src/tests/test1/new_test.cpp", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+#include <vespa/vespalib/testkit/testapp.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\"new_test\");\n+\n+void cmp(const void *a, const void *b) {\n+    EXPECT_EQUAL(a, b);\n+}\n+void cmp(const void *base, size_t offset, const void *p) {\n+    cmp((static_cast<const char *>(base) + offset), p);\n+}\n+\n+TEST(\"verify new with normal alignment\") {\n+    struct S {\n+        int a;\n+        long b;\n+        int c;\n+    };\n+    static_assert(sizeof(S) == 24, \"sizeof(S) == 16\");\n+    auto s = std::make_unique<S>();\n+    cmp(s.get(), &s->a);\n+    cmp(s.get(), 8, &s->b);\n+    cmp(s.get(), 16, &s->c);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "994452c26a88f406fc30056b3616eee79a7da651"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI4NTgwNA==", "bodyText": "Done, and I also remembered that only vespamalloc is naturally aligned. vespamallocd and vespamallocdst is not as they add preamble and postamble. So they need to be propagated.", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437285804", "createdAt": "2020-06-09T09:51:28Z", "author": {"login": "baldersheim"}, "path": "vespamalloc/src/tests/test1/new_test.cpp", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+#include <vespa/vespalib/testkit/testapp.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\"new_test\");\n+\n+void cmp(const void *a, const void *b) {\n+    EXPECT_EQUAL(a, b);\n+}\n+void cmp(const void *base, size_t offset, const void *p) {\n+    cmp((static_cast<const char *>(base) + offset), p);\n+}\n+\n+TEST(\"verify new with normal alignment\") {\n+    struct S {\n+        int a;\n+        long b;\n+        int c;\n+    };\n+    static_assert(sizeof(S) == 24, \"sizeof(S) == 16\");\n+    auto s = std::make_unique<S>();\n+    cmp(s.get(), &s->a);\n+    cmp(s.get(), 8, &s->b);\n+    cmp(s.get(), 16, &s->c);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI1NTA1Nw=="}, "originalCommit": {"oid": "994452c26a88f406fc30056b3616eee79a7da651"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDY1OTE2OnYy", "diffSide": "RIGHT", "path": "vespamalloc/src/vespamalloc/malloc/memblockboundscheck.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoxNDowNVrOGhGXjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjo0MTozMFrOGhHnqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MDUyNQ==", "bodyText": "Both these could be constexpr (though the compiler will do this in practice anyway)", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437360525", "createdAt": "2020-06-09T12:14:05Z", "author": {"login": "vekterli"}, "path": "vespamalloc/src/vespamalloc/malloc/memblockboundscheck.h", "diffHunk": "@@ -45,6 +59,12 @@ class MemBlockBoundsCheckBaseTBase : public CommonT<5>\n     void verifyFill() const __attribute__((noinline));\n \n     void setSize(size_t sz) { static_cast<uint64_t *>(_ptr)[0] = sz; }\n+    static size_t preambleOverhead(std::align_val_t alignment) {\n+        return std::max(4*sizeof(unsigned), size_t(alignment));\n+    }\n+    static size_t preambleOverhead() {\n+        return 4*sizeof(unsigned);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3c970b449bec64d0a3f7a91a08a9237400016ef"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4MTAzMg==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437381032", "createdAt": "2020-06-09T12:41:30Z", "author": {"login": "baldersheim"}, "path": "vespamalloc/src/vespamalloc/malloc/memblockboundscheck.h", "diffHunk": "@@ -45,6 +59,12 @@ class MemBlockBoundsCheckBaseTBase : public CommonT<5>\n     void verifyFill() const __attribute__((noinline));\n \n     void setSize(size_t sz) { static_cast<uint64_t *>(_ptr)[0] = sz; }\n+    static size_t preambleOverhead(std::align_val_t alignment) {\n+        return std::max(4*sizeof(unsigned), size_t(alignment));\n+    }\n+    static size_t preambleOverhead() {\n+        return 4*sizeof(unsigned);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MDUyNQ=="}, "originalCommit": {"oid": "b3c970b449bec64d0a3f7a91a08a9237400016ef"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDY2NTMyOnYy", "diffSide": "RIGHT", "path": "vespamalloc/src/vespamalloc/malloc/memblockboundscheck.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoxNTo1OFrOGhGbTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjo0MTo0MVrOGhHoLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MTQ4NA==", "bodyText": "These could also be constexpr", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437361484", "createdAt": "2020-06-09T12:15:58Z", "author": {"login": "vekterli"}, "path": "vespamalloc/src/vespamalloc/malloc/memblockboundscheck.h", "diffHunk": "@@ -121,13 +141,23 @@ class MemBlockBoundsCheckBaseT : public MemBlockBoundsCheckBaseTBase\n         }\n         return StackTraceLen;\n     }\n-    static size_t adjustSize(size_t sz)   { return sz + ((4+1)*sizeof(unsigned) + StackTraceLen*sizeof(void *)); }\n-    static size_t unAdjustSize(size_t sz) { return sz - ((4+1)*sizeof(unsigned) + StackTraceLen*sizeof(void *)); }\n+    static size_t adjustSize(size_t sz)   { return sz + overhead(); }\n+    static size_t adjustSize(size_t sz, std::align_val_t alignment)   { return sz + overhead(alignment); }\n+    static size_t unAdjustSize(size_t sz) { return sz - overhead(); }\n     static void dumpInfo(size_t level) __attribute__((noinline));\n     static size_t getMinSizeForAlignment(size_t align, size_t sz) { return sz + align; }\n     void info(FILE * os, unsigned level=0) const __attribute__((noinline));\n \n protected:\n+    static size_t postambleOverhead() {\n+        return sizeof(unsigned) + StackTraceLen*sizeof(void *);\n+    }\n+    static size_t overhead() {\n+        return preambleOverhead() + postambleOverhead();\n+    }\n+    static size_t overhead(std::align_val_t alignment) {\n+        return preambleOverhead(alignment) + postambleOverhead();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3c970b449bec64d0a3f7a91a08a9237400016ef"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4MTE2NA==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437381164", "createdAt": "2020-06-09T12:41:41Z", "author": {"login": "baldersheim"}, "path": "vespamalloc/src/vespamalloc/malloc/memblockboundscheck.h", "diffHunk": "@@ -121,13 +141,23 @@ class MemBlockBoundsCheckBaseT : public MemBlockBoundsCheckBaseTBase\n         }\n         return StackTraceLen;\n     }\n-    static size_t adjustSize(size_t sz)   { return sz + ((4+1)*sizeof(unsigned) + StackTraceLen*sizeof(void *)); }\n-    static size_t unAdjustSize(size_t sz) { return sz - ((4+1)*sizeof(unsigned) + StackTraceLen*sizeof(void *)); }\n+    static size_t adjustSize(size_t sz)   { return sz + overhead(); }\n+    static size_t adjustSize(size_t sz, std::align_val_t alignment)   { return sz + overhead(alignment); }\n+    static size_t unAdjustSize(size_t sz) { return sz - overhead(); }\n     static void dumpInfo(size_t level) __attribute__((noinline));\n     static size_t getMinSizeForAlignment(size_t align, size_t sz) { return sz + align; }\n     void info(FILE * os, unsigned level=0) const __attribute__((noinline));\n \n protected:\n+    static size_t postambleOverhead() {\n+        return sizeof(unsigned) + StackTraceLen*sizeof(void *);\n+    }\n+    static size_t overhead() {\n+        return preambleOverhead() + postambleOverhead();\n+    }\n+    static size_t overhead(std::align_val_t alignment) {\n+        return preambleOverhead(alignment) + postambleOverhead();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MTQ4NA=="}, "originalCommit": {"oid": "b3c970b449bec64d0a3f7a91a08a9237400016ef"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNDY3MzA1OnYy", "diffSide": "RIGHT", "path": "vespamalloc/src/vespamalloc/malloc/memblockboundscheck.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjoxODowNVrOGhGgDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjo0MTo1M1rOGhHosg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MjcwMQ==", "bodyText": "Could also be return std::max(preambleOverhead(), size_t(alignment));", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437362701", "createdAt": "2020-06-09T12:18:05Z", "author": {"login": "vekterli"}, "path": "vespamalloc/src/vespamalloc/malloc/memblockboundscheck.h", "diffHunk": "@@ -45,6 +59,12 @@ class MemBlockBoundsCheckBaseTBase : public CommonT<5>\n     void verifyFill() const __attribute__((noinline));\n \n     void setSize(size_t sz) { static_cast<uint64_t *>(_ptr)[0] = sz; }\n+    static size_t preambleOverhead(std::align_val_t alignment) {\n+        return std::max(4*sizeof(unsigned), size_t(alignment));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3c970b449bec64d0a3f7a91a08a9237400016ef"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM4MTI5OA==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/13515#discussion_r437381298", "createdAt": "2020-06-09T12:41:53Z", "author": {"login": "baldersheim"}, "path": "vespamalloc/src/vespamalloc/malloc/memblockboundscheck.h", "diffHunk": "@@ -45,6 +59,12 @@ class MemBlockBoundsCheckBaseTBase : public CommonT<5>\n     void verifyFill() const __attribute__((noinline));\n \n     void setSize(size_t sz) { static_cast<uint64_t *>(_ptr)[0] = sz; }\n+    static size_t preambleOverhead(std::align_val_t alignment) {\n+        return std::max(4*sizeof(unsigned), size_t(alignment));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MjcwMQ=="}, "originalCommit": {"oid": "b3c970b449bec64d0a3f7a91a08a9237400016ef"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2008, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}