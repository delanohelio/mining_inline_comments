{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMzIzOTA1", "number": 13120, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDozMTozNFrOD3_DsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMToyMjowNFrOD4ABSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDMxNDA5OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/tensor_function.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDozMTozNFrOGOjYpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMToxODoyNVrOGOk1FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkxMjk5Ng==", "bodyText": "I think you forgot the & to avoid copying the vector.", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417912996", "createdAt": "2020-04-30T10:31:34Z", "author": {"login": "baldersheim"}, "path": "eval/src/vespa/eval/eval/tensor_function.h", "diffHunk": "@@ -343,6 +343,9 @@ class Lambda : public Node\n public:\n     Lambda(const ValueType &result_type_in, const std::vector<size_t> &bindings_in, const Function &lambda_in, NodeTypes lambda_types_in)\n         : Node(result_type_in), _bindings(bindings_in), _lambda(lambda_in.shared_from_this()), _lambda_types(std::move(lambda_types_in)) {}\n+    const std::vector<size_t> bindings() const { return _bindings; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d0163069974aea86fbec8e43f55a21f12b5844"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNjY2MA==", "bodyText": "fixed", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417936660", "createdAt": "2020-04-30T11:18:25Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/tensor_function.h", "diffHunk": "@@ -343,6 +343,9 @@ class Lambda : public Node\n public:\n     Lambda(const ValueType &result_type_in, const std::vector<size_t> &bindings_in, const Function &lambda_in, NodeTypes lambda_types_in)\n         : Node(result_type_in), _bindings(bindings_in), _lambda(lambda_in.shared_from_this()), _lambda_types(std::move(lambda_types_in)) {}\n+    const std::vector<size_t> bindings() const { return _bindings; }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkxMjk5Ng=="}, "originalCommit": {"oid": "c6d0163069974aea86fbec8e43f55a21f12b5844"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDMxNjcxOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/dense/dense_cell_range_function.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDozMjoyMlrOGOjaVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMToxOTo1NVrOGOk4Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkxMzQyOA==", "bodyText": "Use = default.", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417913428", "createdAt": "2020-04-30T10:32:22Z", "author": {"login": "baldersheim"}, "path": "eval/src/vespa/eval/tensor/dense/dense_cell_range_function.cpp", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"dense_cell_range_function.h\"\n+#include \"dense_tensor_view.h\"\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::tensor {\n+\n+using eval::Value;\n+using eval::ValueType;\n+using eval::TensorFunction;\n+using eval::TensorEngine;\n+using eval::as;\n+using namespace eval::tensor_function;\n+\n+namespace {\n+\n+template <typename CT>\n+void my_cell_range_op(eval::InterpretedFunction::State &state, uint64_t param) {\n+    const auto *self = (const DenseCellRangeFunction *)(param);\n+    auto old_cells = DenseTensorView::typify_cells<CT>(state.peek(0));\n+    ConstArrayRef<CT> new_cells(&old_cells[self->offset()], self->length());\n+    state.pop_push(state.stash.create<DenseTensorView>(self->result_type(), TypedCells(new_cells)));\n+}\n+\n+struct MyCellRangeOp {\n+    template <typename CT>\n+    static auto get_fun() { return my_cell_range_op<CT>; }\n+};\n+\n+} // namespace vespalib::tensor::<unnamed>\n+\n+DenseCellRangeFunction::DenseCellRangeFunction(const eval::ValueType &result_type,\n+                                               const eval::TensorFunction &child,\n+                                               size_t offset, size_t length)\n+    : eval::tensor_function::Op1(result_type, child),\n+      _offset(offset),\n+      _length(length)\n+{\n+}\n+\n+DenseCellRangeFunction::~DenseCellRangeFunction()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6d0163069974aea86fbec8e43f55a21f12b5844"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNzQxMA==", "bodyText": "fixed", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417937410", "createdAt": "2020-04-30T11:19:55Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/dense/dense_cell_range_function.cpp", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"dense_cell_range_function.h\"\n+#include \"dense_tensor_view.h\"\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::tensor {\n+\n+using eval::Value;\n+using eval::ValueType;\n+using eval::TensorFunction;\n+using eval::TensorEngine;\n+using eval::as;\n+using namespace eval::tensor_function;\n+\n+namespace {\n+\n+template <typename CT>\n+void my_cell_range_op(eval::InterpretedFunction::State &state, uint64_t param) {\n+    const auto *self = (const DenseCellRangeFunction *)(param);\n+    auto old_cells = DenseTensorView::typify_cells<CT>(state.peek(0));\n+    ConstArrayRef<CT> new_cells(&old_cells[self->offset()], self->length());\n+    state.pop_push(state.stash.create<DenseTensorView>(self->result_type(), TypedCells(new_cells)));\n+}\n+\n+struct MyCellRangeOp {\n+    template <typename CT>\n+    static auto get_fun() { return my_cell_range_op<CT>; }\n+};\n+\n+} // namespace vespalib::tensor::<unnamed>\n+\n+DenseCellRangeFunction::DenseCellRangeFunction(const eval::ValueType &result_type,\n+                                               const eval::TensorFunction &child,\n+                                               size_t offset, size_t length)\n+    : eval::tensor_function::Op1(result_type, child),\n+      _offset(offset),\n+      _length(length)\n+{\n+}\n+\n+DenseCellRangeFunction::~DenseCellRangeFunction()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkxMzQyOA=="}, "originalCommit": {"oid": "c6d0163069974aea86fbec8e43f55a21f12b5844"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDM4MDY0OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/node_tools.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDo1MTo0MFrOGOkCSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMToyMjozNlrOGOk9AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyMzY1OA==", "bodyText": "get_ signals non destructive access.", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417923658", "createdAt": "2020-04-30T10:51:40Z", "author": {"login": "baldersheim"}, "path": "eval/src/vespa/eval/eval/node_tools.cpp", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"node_tools.h\"\n+#include <vespa/eval/eval/node_traverser.h>\n+#include <vespa/eval/eval/node_visitor.h>\n+\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::nodes;\n+\n+namespace vespalib::eval {\n+\n+namespace {\n+\n+struct CountParams : NodeTraverser, EmptyNodeVisitor {\n+    size_t result = 0;\n+    void visit(const Symbol &symbol) override {\n+        result = std::max(result, symbol.id() + 1);\n+    }\n+    bool open(const Node &) override { return true; }\n+    void close(const Node &node) override { node.accept(*this); }\n+};\n+\n+struct CopyNode : NodeTraverser, NodeVisitor {\n+\n+    std::unique_ptr<Error> error;\n+    std::vector<Node_UP> stack;\n+\n+    CopyNode() : error(), stack() {}\n+    ~CopyNode();\n+\n+    Node_UP get_result() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d6e9a97a5da936e8b72573b7477f6ec555138cd"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzODY4OA==", "bodyText": "fixed", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417938688", "createdAt": "2020-04-30T11:22:36Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/node_tools.cpp", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"node_tools.h\"\n+#include <vespa/eval/eval/node_traverser.h>\n+#include <vespa/eval/eval/node_visitor.h>\n+\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::nodes;\n+\n+namespace vespalib::eval {\n+\n+namespace {\n+\n+struct CountParams : NodeTraverser, EmptyNodeVisitor {\n+    size_t result = 0;\n+    void visit(const Symbol &symbol) override {\n+        result = std::max(result, symbol.id() + 1);\n+    }\n+    bool open(const Node &) override { return true; }\n+    void close(const Node &node) override { node.accept(*this); }\n+};\n+\n+struct CopyNode : NodeTraverser, NodeVisitor {\n+\n+    std::unique_ptr<Error> error;\n+    std::vector<Node_UP> stack;\n+\n+    CopyNode() : error(), stack() {}\n+    ~CopyNode();\n+\n+    Node_UP get_result() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyMzY1OA=="}, "originalCommit": {"oid": "8d6e9a97a5da936e8b72573b7477f6ec555138cd"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDQzMDg5OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/dense/dense_lambda_peek_optimizer.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTowNzo1N1rOGOkiQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMToyNTowMFrOGOlBaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzMTg0MA==", "bodyText": "remove this", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417931840", "createdAt": "2020-04-30T11:07:57Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/dense/dense_lambda_peek_optimizer.cpp", "diffHunk": "@@ -1,13 +1,204 @@\n // Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n #include \"dense_lambda_peek_optimizer.h\"\n+#include \"dense_tensor_view.h\"\n+#include \"dense_replace_type_function.h\"\n+#include \"dense_cell_range_function.h\"\n+#include \"dense_lambda_peek_function.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/node_tools.h>\n+#include <vespa/eval/eval/basic_nodes.h>\n+#include <vespa/eval/eval/operator_nodes.h>\n+#include <vespa/eval/eval/call_nodes.h>\n+#include <vespa/eval/eval/tensor_nodes.h>\n+#include <vespa/eval/eval/llvm/compile_cache.h>\n+#include <optional>\n+\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::nodes;\n \n namespace vespalib::tensor {\n \n-const eval::TensorFunction &\n-DenseLambdaPeekOptimizer::optimize(const eval::TensorFunction &expr, Stash &)\n+namespace {\n+\n+// 'simple peek': deterministic peek into a single parameter with\n+//                compilable dimension index expressions.\n+const TensorPeek *find_simple_peek(const tensor_function::Lambda &lambda) {\n+    const Function &function = lambda.lambda();\n+    const size_t num_dims = lambda.result_type().dimensions().size();\n+    auto peek = as<TensorPeek>(function.root());\n+    if (peek && (function.num_params() == (num_dims + 1))) {\n+        auto param = as<Symbol>(peek->get_child(0));\n+        if (param && (param->id() == num_dims)) {\n+            for (size_t i = 1; i < peek->num_children(); ++i) {\n+                const Node &dim_expr = peek->get_child(i);\n+                if (NodeTools::min_num_params(dim_expr) > num_dims) {\n+                    return nullptr;\n+                }\n+                if (CompiledFunction::detect_issues(dim_expr)) {\n+                    return nullptr;\n+                }\n+            }\n+            return peek;\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+Node_UP make_dim_expr(const TensorPeek::Dim &src_dim) {\n+    if (src_dim.second.is_expr()) {\n+        return NodeTools::copy(*src_dim.second.expr);\n+    } else {\n+        return std::make_unique<Number>(as_number(src_dim.second.label));\n+    }\n+}\n+\n+template <typename OP>\n+Node_UP make_op(Node_UP a, Node_UP b) {\n+    auto res = std::make_unique<OP>();\n+    res->bind(std::move(a), std::move(b));\n+    return res;\n+}\n+\n+Node_UP make_floor(Node_UP a) {\n+    auto res = std::make_unique<Floor>();\n+    res->bind_next(std::move(a));\n+    return res;\n+}\n+\n+struct PeekAnalyzer {\n+    std::vector<size_t> dst_dim_sizes;\n+    std::vector<size_t> src_dim_sizes;\n+    std::vector<CompiledFunction::UP> src_dim_funs;\n+    std::shared_ptr<Function const> src_idx_fun;\n+\n+    struct CellRange {\n+        size_t offset;\n+        size_t length;\n+        bool is_full(size_t num_cells) const {\n+            return ((offset == 0) && (length == num_cells));\n+        }\n+    };\n+\n+    struct Result {\n+        bool valid;\n+        std::optional<CellRange> cell_range;\n+        static Result simple(CellRange range) { return Result{true, range}; }\n+        static Result complex() { return Result{true, std::nullopt}; }\n+        static Result invalid() { return Result{false, std::nullopt}; }\n+    };\n+\n+    PeekAnalyzer(const ValueType &dst_type, const ValueType &src_type,\n+                 const TensorPeek::DimList &dim_list)\n+    {\n+        for (const auto dim: dst_type.dimensions()) {\n+            dst_dim_sizes.push_back(dim.size);\n+        }\n+        for (const auto dim: src_type.dimensions()) {\n+            src_dim_sizes.push_back(dim.size);\n+        }\n+        Node_UP idx_expr;\n+        size_t num_params = dst_dim_sizes.size();\n+        for (size_t i = 0; i < dim_list.size(); ++i) {\n+            auto dim_expr = make_dim_expr(dim_list[i]);\n+            src_dim_funs.push_back(std::make_unique<CompiledFunction>(*dim_expr, num_params, PassParams::ARRAY));\n+            if (i == 0) {\n+                idx_expr = std::move(dim_expr);\n+            } else {\n+                idx_expr = make_floor(std::move(idx_expr));\n+                idx_expr = make_op<Mul>(std::move(idx_expr), std::make_unique<Number>(src_dim_sizes[i]));\n+                idx_expr = make_op<Add>(std::move(idx_expr), std::move(dim_expr));\n+            }\n+        }\n+        src_idx_fun = Function::create(std::move(idx_expr), dst_type.dimension_names());\n+        auto str = src_idx_fun->dump_as_lambda();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d6e9a97a5da936e8b72573b7477f6ec555138cd"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzOTgxNw==", "bodyText": "fixed", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417939817", "createdAt": "2020-04-30T11:25:00Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/dense/dense_lambda_peek_optimizer.cpp", "diffHunk": "@@ -1,13 +1,204 @@\n // Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n #include \"dense_lambda_peek_optimizer.h\"\n+#include \"dense_tensor_view.h\"\n+#include \"dense_replace_type_function.h\"\n+#include \"dense_cell_range_function.h\"\n+#include \"dense_lambda_peek_function.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/node_tools.h>\n+#include <vespa/eval/eval/basic_nodes.h>\n+#include <vespa/eval/eval/operator_nodes.h>\n+#include <vespa/eval/eval/call_nodes.h>\n+#include <vespa/eval/eval/tensor_nodes.h>\n+#include <vespa/eval/eval/llvm/compile_cache.h>\n+#include <optional>\n+\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::nodes;\n \n namespace vespalib::tensor {\n \n-const eval::TensorFunction &\n-DenseLambdaPeekOptimizer::optimize(const eval::TensorFunction &expr, Stash &)\n+namespace {\n+\n+// 'simple peek': deterministic peek into a single parameter with\n+//                compilable dimension index expressions.\n+const TensorPeek *find_simple_peek(const tensor_function::Lambda &lambda) {\n+    const Function &function = lambda.lambda();\n+    const size_t num_dims = lambda.result_type().dimensions().size();\n+    auto peek = as<TensorPeek>(function.root());\n+    if (peek && (function.num_params() == (num_dims + 1))) {\n+        auto param = as<Symbol>(peek->get_child(0));\n+        if (param && (param->id() == num_dims)) {\n+            for (size_t i = 1; i < peek->num_children(); ++i) {\n+                const Node &dim_expr = peek->get_child(i);\n+                if (NodeTools::min_num_params(dim_expr) > num_dims) {\n+                    return nullptr;\n+                }\n+                if (CompiledFunction::detect_issues(dim_expr)) {\n+                    return nullptr;\n+                }\n+            }\n+            return peek;\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+Node_UP make_dim_expr(const TensorPeek::Dim &src_dim) {\n+    if (src_dim.second.is_expr()) {\n+        return NodeTools::copy(*src_dim.second.expr);\n+    } else {\n+        return std::make_unique<Number>(as_number(src_dim.second.label));\n+    }\n+}\n+\n+template <typename OP>\n+Node_UP make_op(Node_UP a, Node_UP b) {\n+    auto res = std::make_unique<OP>();\n+    res->bind(std::move(a), std::move(b));\n+    return res;\n+}\n+\n+Node_UP make_floor(Node_UP a) {\n+    auto res = std::make_unique<Floor>();\n+    res->bind_next(std::move(a));\n+    return res;\n+}\n+\n+struct PeekAnalyzer {\n+    std::vector<size_t> dst_dim_sizes;\n+    std::vector<size_t> src_dim_sizes;\n+    std::vector<CompiledFunction::UP> src_dim_funs;\n+    std::shared_ptr<Function const> src_idx_fun;\n+\n+    struct CellRange {\n+        size_t offset;\n+        size_t length;\n+        bool is_full(size_t num_cells) const {\n+            return ((offset == 0) && (length == num_cells));\n+        }\n+    };\n+\n+    struct Result {\n+        bool valid;\n+        std::optional<CellRange> cell_range;\n+        static Result simple(CellRange range) { return Result{true, range}; }\n+        static Result complex() { return Result{true, std::nullopt}; }\n+        static Result invalid() { return Result{false, std::nullopt}; }\n+    };\n+\n+    PeekAnalyzer(const ValueType &dst_type, const ValueType &src_type,\n+                 const TensorPeek::DimList &dim_list)\n+    {\n+        for (const auto dim: dst_type.dimensions()) {\n+            dst_dim_sizes.push_back(dim.size);\n+        }\n+        for (const auto dim: src_type.dimensions()) {\n+            src_dim_sizes.push_back(dim.size);\n+        }\n+        Node_UP idx_expr;\n+        size_t num_params = dst_dim_sizes.size();\n+        for (size_t i = 0; i < dim_list.size(); ++i) {\n+            auto dim_expr = make_dim_expr(dim_list[i]);\n+            src_dim_funs.push_back(std::make_unique<CompiledFunction>(*dim_expr, num_params, PassParams::ARRAY));\n+            if (i == 0) {\n+                idx_expr = std::move(dim_expr);\n+            } else {\n+                idx_expr = make_floor(std::move(idx_expr));\n+                idx_expr = make_op<Mul>(std::move(idx_expr), std::make_unique<Number>(src_dim_sizes[i]));\n+                idx_expr = make_op<Add>(std::move(idx_expr), std::move(dim_expr));\n+            }\n+        }\n+        src_idx_fun = Function::create(std::move(idx_expr), dst_type.dimension_names());\n+        auto str = src_idx_fun->dump_as_lambda();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzMTg0MA=="}, "originalCommit": {"oid": "8d6e9a97a5da936e8b72573b7477f6ec555138cd"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDQ2ODUwOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/dense/dense_lambda_peek_function.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMToyMTowMVrOGOk6AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTozMTo0OFrOGOlOcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNzkyMQ==", "bodyText": "= default", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417937921", "createdAt": "2020-04-30T11:21:01Z", "author": {"login": "baldersheim"}, "path": "eval/src/vespa/eval/tensor/dense/dense_lambda_peek_function.cpp", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"dense_lambda_peek_function.h\"\n+#include \"dense_tensor_view.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/llvm/compile_cache.h>\n+\n+namespace vespalib::tensor {\n+\n+using eval::CompileCache;\n+using eval::Function;\n+using eval::InterpretedFunction;\n+using eval::PassParams;\n+using eval::TensorEngine;\n+using eval::TensorFunction;\n+using eval::Value;\n+using eval::ValueType;\n+using eval::as;\n+using namespace eval::tensor_function;\n+\n+namespace {\n+\n+struct Self {\n+    const ValueType &result_type;\n+    CompileCache::Token::UP compile_token;\n+    Self(const ValueType &result_type_in, const Function &function)\n+        : result_type(result_type_in),\n+          compile_token(CompileCache::compile(function, PassParams::ARRAY)) {}\n+};\n+\n+bool step_params(std::vector<double> &params, const ValueType &type) {\n+    const auto &dims = type.dimensions();\n+    for (size_t idx = params.size(); idx-- > 0; ) {\n+        if (size_t(params[idx] += 1.0) < dims[idx].size) {\n+            return true;\n+        } else {\n+            params[idx] = 0.0;\n+        }\n+    }\n+    return false;\n+}\n+\n+template <typename DST_CT, typename SRC_CT>\n+void my_lambda_peek_op(InterpretedFunction::State &state, uint64_t param) {\n+    const auto *self = (const Self *)(param);\n+    auto src_cells = DenseTensorView::typify_cells<SRC_CT>(state.peek(0));\n+    ArrayRef<DST_CT> dst_cells = state.stash.create_array<DST_CT>(self->result_type.dense_subspace_size());\n+    DST_CT *dst = &dst_cells[0];\n+    std::vector<double> params(self->result_type.dimensions().size(), 0.0);\n+    auto idx_fun = self->compile_token->get().get_function();\n+    do {\n+        *dst++ = src_cells[size_t(idx_fun(&params[0]))];\n+    } while(step_params(params, self->result_type));\n+    state.pop_push(state.stash.create<DenseTensorView>(self->result_type, TypedCells(dst_cells)));\n+}\n+\n+struct MyLambdaPeekOp {\n+    template <typename DST_CT, typename SRC_CT>\n+    static auto get_fun() { return my_lambda_peek_op<DST_CT, SRC_CT>; }\n+};\n+\n+} // namespace vespalib::tensor::<unnamed>\n+\n+DenseLambdaPeekFunction::DenseLambdaPeekFunction(const ValueType &result_type,\n+                                                 const TensorFunction &child,\n+                                                 std::shared_ptr<Function const> idx_fun)\n+    : Op1(result_type, child),\n+      _idx_fun(std::move(idx_fun))\n+{\n+}\n+\n+DenseLambdaPeekFunction::~DenseLambdaPeekFunction()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d6e9a97a5da936e8b72573b7477f6ec555138cd"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk0MzE1NQ==", "bodyText": "fixed", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417943155", "createdAt": "2020-04-30T11:31:48Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/dense/dense_lambda_peek_function.cpp", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"dense_lambda_peek_function.h\"\n+#include \"dense_tensor_view.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/llvm/compile_cache.h>\n+\n+namespace vespalib::tensor {\n+\n+using eval::CompileCache;\n+using eval::Function;\n+using eval::InterpretedFunction;\n+using eval::PassParams;\n+using eval::TensorEngine;\n+using eval::TensorFunction;\n+using eval::Value;\n+using eval::ValueType;\n+using eval::as;\n+using namespace eval::tensor_function;\n+\n+namespace {\n+\n+struct Self {\n+    const ValueType &result_type;\n+    CompileCache::Token::UP compile_token;\n+    Self(const ValueType &result_type_in, const Function &function)\n+        : result_type(result_type_in),\n+          compile_token(CompileCache::compile(function, PassParams::ARRAY)) {}\n+};\n+\n+bool step_params(std::vector<double> &params, const ValueType &type) {\n+    const auto &dims = type.dimensions();\n+    for (size_t idx = params.size(); idx-- > 0; ) {\n+        if (size_t(params[idx] += 1.0) < dims[idx].size) {\n+            return true;\n+        } else {\n+            params[idx] = 0.0;\n+        }\n+    }\n+    return false;\n+}\n+\n+template <typename DST_CT, typename SRC_CT>\n+void my_lambda_peek_op(InterpretedFunction::State &state, uint64_t param) {\n+    const auto *self = (const Self *)(param);\n+    auto src_cells = DenseTensorView::typify_cells<SRC_CT>(state.peek(0));\n+    ArrayRef<DST_CT> dst_cells = state.stash.create_array<DST_CT>(self->result_type.dense_subspace_size());\n+    DST_CT *dst = &dst_cells[0];\n+    std::vector<double> params(self->result_type.dimensions().size(), 0.0);\n+    auto idx_fun = self->compile_token->get().get_function();\n+    do {\n+        *dst++ = src_cells[size_t(idx_fun(&params[0]))];\n+    } while(step_params(params, self->result_type));\n+    state.pop_push(state.stash.create<DenseTensorView>(self->result_type, TypedCells(dst_cells)));\n+}\n+\n+struct MyLambdaPeekOp {\n+    template <typename DST_CT, typename SRC_CT>\n+    static auto get_fun() { return my_lambda_peek_op<DST_CT, SRC_CT>; }\n+};\n+\n+} // namespace vespalib::tensor::<unnamed>\n+\n+DenseLambdaPeekFunction::DenseLambdaPeekFunction(const ValueType &result_type,\n+                                                 const TensorFunction &child,\n+                                                 std::shared_ptr<Function const> idx_fun)\n+    : Op1(result_type, child),\n+      _idx_fun(std::move(idx_fun))\n+{\n+}\n+\n+DenseLambdaPeekFunction::~DenseLambdaPeekFunction()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNzkyMQ=="}, "originalCommit": {"oid": "8d6e9a97a5da936e8b72573b7477f6ec555138cd"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDQ3MTc5OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/tensor/dense/dense_cell_range_function.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMToyMjowNFrOGOk8Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTozMjoyMFrOGOlPfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzODQ0Ng==", "bodyText": "I normally add override on destructors too. clion(clang) likes that.", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417938446", "createdAt": "2020-04-30T11:22:04Z", "author": {"login": "baldersheim"}, "path": "eval/src/vespa/eval/tensor/dense/dense_cell_range_function.h", "diffHunk": "@@ -0,0 +1,31 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/tensor_function.h>\n+\n+namespace vespalib::tensor {\n+\n+/**\n+ * Tensor function creating a view to a continuous range of cells in\n+ * another tensor. The value type will (typically) change, but the\n+ * cell type must remain the same.\n+ **/\n+class DenseCellRangeFunction : public eval::tensor_function::Op1\n+{\n+private:\n+    size_t _offset;\n+    size_t _length;\n+\n+public:\n+    DenseCellRangeFunction(const eval::ValueType &result_type,\n+                           const eval::TensorFunction &child,\n+                           size_t offset, size_t length);\n+    ~DenseCellRangeFunction();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d6e9a97a5da936e8b72573b7477f6ec555138cd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk0MzQyMw==", "bodyText": "I will try to remember that. Added override to new classes.", "url": "https://github.com/vespa-engine/vespa/pull/13120#discussion_r417943423", "createdAt": "2020-04-30T11:32:20Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/dense/dense_cell_range_function.h", "diffHunk": "@@ -0,0 +1,31 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/tensor_function.h>\n+\n+namespace vespalib::tensor {\n+\n+/**\n+ * Tensor function creating a view to a continuous range of cells in\n+ * another tensor. The value type will (typically) change, but the\n+ * cell type must remain the same.\n+ **/\n+class DenseCellRangeFunction : public eval::tensor_function::Op1\n+{\n+private:\n+    size_t _offset;\n+    size_t _length;\n+\n+public:\n+    DenseCellRangeFunction(const eval::ValueType &result_type,\n+                           const eval::TensorFunction &child,\n+                           size_t offset, size_t length);\n+    ~DenseCellRangeFunction();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzODQ0Ng=="}, "originalCommit": {"oid": "8d6e9a97a5da936e8b72573b7477f6ec555138cd"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1688, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}