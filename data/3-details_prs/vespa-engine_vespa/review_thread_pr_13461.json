{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NzQ4NjM4", "number": 13461, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOToyNTo1NFrOECEuuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowNDo1MlrOECFm_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjEwMTA3OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/common/allocatedbitvector.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOToyNTo1NFrOGeTmiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTo1NjoyN1rOGeUu8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMTYyNA==", "bodyText": "If size and capacity is reduced at the same time on the underlying bitvector then capacity can become less than size here.", "url": "https://github.com/vespa-engine/vespa/pull/13461#discussion_r434431624", "createdAt": "2020-06-03T09:25:54Z", "author": {"login": "toregge"}, "path": "searchlib/src/vespa/searchlib/common/allocatedbitvector.cpp", "diffHunk": "@@ -17,6 +17,21 @@ size_t computeCapacity(size_t capacity, size_t allocatedBytes) {\n     return possibleCapacity;\n }\n \n+// This is to ensure that we only read size and capacity once during copy\n+// to ensure that they do not change unexpectedly under our feet due to resizing in different thread.\n+std::pair<BitVector::Index, BitVector::Index>\n+extract_size_size(const BitVector & bv) {\n+    BitVector::Index size = bv.size();\n+    return std::pair<BitVector::Index, BitVector::Index>(size, size);\n+}\n+\n+std::pair<BitVector::Index, BitVector::Index>\n+extract_size_capacity(const AllocatedBitVector & bv) {\n+    BitVector::Index size = bv.size();\n+    BitVector::Index capacity = bv.capacity();\n+    return std::pair<BitVector::Index, BitVector::Index>(size, capacity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b38a099eb79efa9cf1fa4c9fce68a4d7e3d423b5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0NzI2OQ==", "bodyText": "capacity is updated before size when growing.\nHowever upon shrink that will not be safe.\nSo I guess a loop and a comment is needed here.", "url": "https://github.com/vespa-engine/vespa/pull/13461#discussion_r434447269", "createdAt": "2020-06-03T09:51:23Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/common/allocatedbitvector.cpp", "diffHunk": "@@ -17,6 +17,21 @@ size_t computeCapacity(size_t capacity, size_t allocatedBytes) {\n     return possibleCapacity;\n }\n \n+// This is to ensure that we only read size and capacity once during copy\n+// to ensure that they do not change unexpectedly under our feet due to resizing in different thread.\n+std::pair<BitVector::Index, BitVector::Index>\n+extract_size_size(const BitVector & bv) {\n+    BitVector::Index size = bv.size();\n+    return std::pair<BitVector::Index, BitVector::Index>(size, size);\n+}\n+\n+std::pair<BitVector::Index, BitVector::Index>\n+extract_size_capacity(const AllocatedBitVector & bv) {\n+    BitVector::Index size = bv.size();\n+    BitVector::Index capacity = bv.capacity();\n+    return std::pair<BitVector::Index, BitVector::Index>(size, capacity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMTYyNA=="}, "originalCommit": {"oid": "b38a099eb79efa9cf1fa4c9fce68a4d7e3d423b5"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1MDE2Mw==", "bodyText": "Fixed, @toregge PTAL", "url": "https://github.com/vespa-engine/vespa/pull/13461#discussion_r434450163", "createdAt": "2020-06-03T09:56:27Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/common/allocatedbitvector.cpp", "diffHunk": "@@ -17,6 +17,21 @@ size_t computeCapacity(size_t capacity, size_t allocatedBytes) {\n     return possibleCapacity;\n }\n \n+// This is to ensure that we only read size and capacity once during copy\n+// to ensure that they do not change unexpectedly under our feet due to resizing in different thread.\n+std::pair<BitVector::Index, BitVector::Index>\n+extract_size_size(const BitVector & bv) {\n+    BitVector::Index size = bv.size();\n+    return std::pair<BitVector::Index, BitVector::Index>(size, size);\n+}\n+\n+std::pair<BitVector::Index, BitVector::Index>\n+extract_size_capacity(const AllocatedBitVector & bv) {\n+    BitVector::Index size = bv.size();\n+    BitVector::Index capacity = bv.capacity();\n+    return std::pair<BitVector::Index, BitVector::Index>(size, capacity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMTYyNA=="}, "originalCommit": {"oid": "b38a099eb79efa9cf1fa4c9fce68a4d7e3d423b5"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjI0NTEwOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/common/allocatedbitvector.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowNDo1MlrOGeVBmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoxMzo0OVrOGeVUww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1NDkzNw==", "bodyText": "both size() and capacity() are very small inlined methods.  Thus the compiler can just cache the result in a register. You need to add a std::atomic_thread_fence or replace the loop with size = std::min(size, capacity);", "url": "https://github.com/vespa-engine/vespa/pull/13461#discussion_r434454937", "createdAt": "2020-06-03T10:04:52Z", "author": {"login": "toregge"}, "path": "searchlib/src/vespa/searchlib/common/allocatedbitvector.cpp", "diffHunk": "@@ -29,6 +29,12 @@ std::pair<BitVector::Index, BitVector::Index>\n extract_size_capacity(const AllocatedBitVector & bv) {\n     BitVector::Index size = bv.size();\n     BitVector::Index capacity = bv.capacity();\n+    while (capacity < size) {\n+        // Since size and capacity might be changed in another thread we need\n+        // this fallback to avoid inconsistency during shrink.\n+        size = bv.size();\n+        capacity = bv.capacity();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4babc05819a7bdf06a1082e238ad0751fbeacf0e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1OTg0Mw==", "bodyText": "Added sequential consistency.", "url": "https://github.com/vespa-engine/vespa/pull/13461#discussion_r434459843", "createdAt": "2020-06-03T10:13:49Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/common/allocatedbitvector.cpp", "diffHunk": "@@ -29,6 +29,12 @@ std::pair<BitVector::Index, BitVector::Index>\n extract_size_capacity(const AllocatedBitVector & bv) {\n     BitVector::Index size = bv.size();\n     BitVector::Index capacity = bv.capacity();\n+    while (capacity < size) {\n+        // Since size and capacity might be changed in another thread we need\n+        // this fallback to avoid inconsistency during shrink.\n+        size = bv.size();\n+        capacity = bv.capacity();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1NDkzNw=="}, "originalCommit": {"oid": "4babc05819a7bdf06a1082e238ad0751fbeacf0e"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1563, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}