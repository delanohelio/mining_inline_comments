{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNTE2NjEy", "number": 13542, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTo1NDoxOFrOEEW9kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTo1NTo0MlrOEEXALw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDA1OTcxOnYy", "diffSide": "RIGHT", "path": "searchcore/src/tests/proton/attribute/attribute_test.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTo1NDoxOFrOGh7iyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxOTo1NzoxNVrOGiENfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzMTc1NQ==", "bodyText": "No need for if, just reset _aw unconditionally.", "url": "https://github.com/vespa-engine/vespa/pull/13542#discussion_r438231755", "createdAt": "2020-06-10T15:54:18Z", "author": {"login": "toregge"}, "path": "searchcore/src/tests/proton/attribute/attribute_test.cpp", "diffHunk": "@@ -116,34 +115,38 @@ fillAttribute(const AttributeVector::SP &attr, uint32_t from, uint32_t to, int64\n const std::shared_ptr<IDestructorCallback> emptyCallback;\n \n \n-struct Fixture\n-{\n+class AttributeWriterTest : public ::testing::Test {\n+public:\n     DirectoryHandler _dirHandler;\n-    DummyFileHeaderContext   _fileHeaderContext;\n-    ForegroundTaskExecutor   _attributeFieldWriterReal;\n-    SequencedTaskExecutorObserver _attributeFieldWriter;\n-    HwInfo                   _hwInfo;\n+    DummyFileHeaderContext _fileHeaderContext;\n+    std::unique_ptr<ForegroundTaskExecutor> _attributeFieldWriterReal;\n+    std::unique_ptr<SequencedTaskExecutorObserver> _attributeFieldWriter;\n+    HwInfo _hwInfo;\n     proton::AttributeManager::SP _m;\n     std::unique_ptr<AttributeWriter> _aw;\n \n-    Fixture(uint32_t threads)\n+    AttributeWriterTest()\n         : _dirHandler(test_dir),\n           _fileHeaderContext(),\n-          _attributeFieldWriterReal(threads),\n-          _attributeFieldWriter(_attributeFieldWriterReal),\n+          _attributeFieldWriterReal(),\n+          _attributeFieldWriter(),\n           _hwInfo(),\n-          _m(std::make_shared<proton::AttributeManager>\n-             (test_dir, \"test.subdb\", TuneFileAttributes(),\n-              _fileHeaderContext, _attributeFieldWriter, _hwInfo)),\n+          _m(),\n           _aw()\n     {\n-        allocAttributeWriter();\n+        setup(1);\n     }\n-    Fixture()\n-        : Fixture(1)\n-    {\n+    ~AttributeWriterTest();\n+    void setup(uint32_t threads) {\n+        if (_aw) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e23f73971dc3e5ec8b1b6431837941e671603338"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3Mzc1Ng==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13542#discussion_r438373756", "createdAt": "2020-06-10T19:57:15Z", "author": {"login": "geirst"}, "path": "searchcore/src/tests/proton/attribute/attribute_test.cpp", "diffHunk": "@@ -116,34 +115,38 @@ fillAttribute(const AttributeVector::SP &attr, uint32_t from, uint32_t to, int64\n const std::shared_ptr<IDestructorCallback> emptyCallback;\n \n \n-struct Fixture\n-{\n+class AttributeWriterTest : public ::testing::Test {\n+public:\n     DirectoryHandler _dirHandler;\n-    DummyFileHeaderContext   _fileHeaderContext;\n-    ForegroundTaskExecutor   _attributeFieldWriterReal;\n-    SequencedTaskExecutorObserver _attributeFieldWriter;\n-    HwInfo                   _hwInfo;\n+    DummyFileHeaderContext _fileHeaderContext;\n+    std::unique_ptr<ForegroundTaskExecutor> _attributeFieldWriterReal;\n+    std::unique_ptr<SequencedTaskExecutorObserver> _attributeFieldWriter;\n+    HwInfo _hwInfo;\n     proton::AttributeManager::SP _m;\n     std::unique_ptr<AttributeWriter> _aw;\n \n-    Fixture(uint32_t threads)\n+    AttributeWriterTest()\n         : _dirHandler(test_dir),\n           _fileHeaderContext(),\n-          _attributeFieldWriterReal(threads),\n-          _attributeFieldWriter(_attributeFieldWriterReal),\n+          _attributeFieldWriterReal(),\n+          _attributeFieldWriter(),\n           _hwInfo(),\n-          _m(std::make_shared<proton::AttributeManager>\n-             (test_dir, \"test.subdb\", TuneFileAttributes(),\n-              _fileHeaderContext, _attributeFieldWriter, _hwInfo)),\n+          _m(),\n           _aw()\n     {\n-        allocAttributeWriter();\n+        setup(1);\n     }\n-    Fixture()\n-        : Fixture(1)\n-    {\n+    ~AttributeWriterTest();\n+    void setup(uint32_t threads) {\n+        if (_aw) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzMTc1NQ=="}, "originalCommit": {"oid": "e23f73971dc3e5ec8b1b6431837941e671603338"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDA2NjM5OnYy", "diffSide": "LEFT", "path": "searchcore/src/tests/proton/attribute/attribute_test.cpp", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNTo1NTo0MlrOGh7nBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNzo0MjozN1rOGiSGug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzMjgzNg==", "bodyText": "Removing this rmdir might cause the test to fail if restarted after an interrupted test run.", "url": "https://github.com/vespa-engine/vespa/pull/13542#discussion_r438232836", "createdAt": "2020-06-10T15:55:42Z", "author": {"login": "toregge"}, "path": "searchcore/src/tests/proton/attribute/attribute_test.cpp", "diffHunk": "@@ -917,38 +905,35 @@ struct StructMapFixture : public StructFixtureBase\n         doc->setValue(_structMapField, s);\n         return doc;\n     }\n+\n     void checkAttrs(uint32_t lid, int32_t expValue, const std::map<int32_t, int32_t> &expMap) {\n         auto valueAttr = _m->getAttribute(\"value\")->getSP();\n         auto mapKeyAttr = _m->getAttribute(\"map.key\")->getSP();\n         auto mapValueAttr = _m->getAttribute(\"map.value.value\")->getSP();\n-        EXPECT_EQUAL(expValue, valueAttr->getInt(lid));\n+        EXPECT_EQ(expValue, valueAttr->getInt(lid));\n         attribute::IntegerContent mapKeys;\n         mapKeys.fill(*mapKeyAttr, lid);\n         attribute::IntegerContent mapValues;\n         mapValues.fill(*mapValueAttr, lid);\n-        EXPECT_EQUAL(expMap.size(), mapValues.size());\n-        EXPECT_EQUAL(expMap.size(), mapKeys.size());\n+        EXPECT_EQ(expMap.size(), mapValues.size());\n+        EXPECT_EQ(expMap.size(), mapKeys.size());\n         size_t i = 0;\n         for (const auto &expMapElem : expMap) {\n-            EXPECT_EQUAL(expMapElem.first, mapKeys[i]);\n-            EXPECT_EQUAL(expMapElem.second, mapValues[i]);\n+            EXPECT_EQ(expMapElem.first, mapKeys[i]);\n+            EXPECT_EQ(expMapElem.second, mapValues[i]);\n             ++i;\n         }\n     }\n };\n \n-TEST_F(\"require that update with doc argument updates struct field attributes (map)\", StructMapFixture)\n+TEST_F(StructMapWriterTest, update_with_doc_argument_updates_struct_field_attributes)\n {\n-    auto doc = f.makeDoc(10,  {{1, 11}, {2, 12}});\n-    f.put(10, *doc, 1);\n-    TEST_DO(f.checkAttrs(1, 10, {{1, 11}, {2, 12}}));\n-    doc = f.makeDoc(20, {{42, 21}});\n-    f.update(11, *doc, 1, true);\n-    TEST_DO(f.checkAttrs(1, 10, {{42, 21}}));\n+    auto doc = makeDoc(10,  {{1, 11}, {2, 12}});\n+    put(10, *doc, 1);\n+    checkAttrs(1, 10, {{1, 11}, {2, 12}});\n+    doc = makeDoc(20, {{42, 21}});\n+    update(11, *doc, 1, true);\n+    checkAttrs(1, 10, {{42, 21}});\n }\n \n-TEST_MAIN()\n-{\n-    vespalib::rmdir(test_dir, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e23f73971dc3e5ec8b1b6431837941e671603338"}, "originalPosition": 1084}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3MjQ5OQ==", "bodyText": "I think it's fine like this. We have a lot of tests only using the DirectoryHandler without any extra cleanup at the end.", "url": "https://github.com/vespa-engine/vespa/pull/13542#discussion_r438372499", "createdAt": "2020-06-10T19:55:01Z", "author": {"login": "geirst"}, "path": "searchcore/src/tests/proton/attribute/attribute_test.cpp", "diffHunk": "@@ -917,38 +905,35 @@ struct StructMapFixture : public StructFixtureBase\n         doc->setValue(_structMapField, s);\n         return doc;\n     }\n+\n     void checkAttrs(uint32_t lid, int32_t expValue, const std::map<int32_t, int32_t> &expMap) {\n         auto valueAttr = _m->getAttribute(\"value\")->getSP();\n         auto mapKeyAttr = _m->getAttribute(\"map.key\")->getSP();\n         auto mapValueAttr = _m->getAttribute(\"map.value.value\")->getSP();\n-        EXPECT_EQUAL(expValue, valueAttr->getInt(lid));\n+        EXPECT_EQ(expValue, valueAttr->getInt(lid));\n         attribute::IntegerContent mapKeys;\n         mapKeys.fill(*mapKeyAttr, lid);\n         attribute::IntegerContent mapValues;\n         mapValues.fill(*mapValueAttr, lid);\n-        EXPECT_EQUAL(expMap.size(), mapValues.size());\n-        EXPECT_EQUAL(expMap.size(), mapKeys.size());\n+        EXPECT_EQ(expMap.size(), mapValues.size());\n+        EXPECT_EQ(expMap.size(), mapKeys.size());\n         size_t i = 0;\n         for (const auto &expMapElem : expMap) {\n-            EXPECT_EQUAL(expMapElem.first, mapKeys[i]);\n-            EXPECT_EQUAL(expMapElem.second, mapValues[i]);\n+            EXPECT_EQ(expMapElem.first, mapKeys[i]);\n+            EXPECT_EQ(expMapElem.second, mapValues[i]);\n             ++i;\n         }\n     }\n };\n \n-TEST_F(\"require that update with doc argument updates struct field attributes (map)\", StructMapFixture)\n+TEST_F(StructMapWriterTest, update_with_doc_argument_updates_struct_field_attributes)\n {\n-    auto doc = f.makeDoc(10,  {{1, 11}, {2, 12}});\n-    f.put(10, *doc, 1);\n-    TEST_DO(f.checkAttrs(1, 10, {{1, 11}, {2, 12}}));\n-    doc = f.makeDoc(20, {{42, 21}});\n-    f.update(11, *doc, 1, true);\n-    TEST_DO(f.checkAttrs(1, 10, {{42, 21}}));\n+    auto doc = makeDoc(10,  {{1, 11}, {2, 12}});\n+    put(10, *doc, 1);\n+    checkAttrs(1, 10, {{1, 11}, {2, 12}});\n+    doc = makeDoc(20, {{42, 21}});\n+    update(11, *doc, 1, true);\n+    checkAttrs(1, 10, {{42, 21}});\n }\n \n-TEST_MAIN()\n-{\n-    vespalib::rmdir(test_dir, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzMjgzNg=="}, "originalCommit": {"oid": "e23f73971dc3e5ec8b1b6431837941e671603338"}, "originalPosition": 1084}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5MTkxMg==", "bodyText": "I recompiled the test with an added abort() at end of the returns_flushed_serial_number test (line 608). First time it ran, it got SIGABRT when running that test, but later runs got SIGSEGV\nfor the first test (handles_put). Removing the abort() and recompiling still caused the test to fail. Manually removing the test_output directory before rerunning the test allowed it to run again.\nHaving a test depend on earlier state from before the test is run is not good.", "url": "https://github.com/vespa-engine/vespa/pull/13542#discussion_r438391912", "createdAt": "2020-06-10T20:33:29Z", "author": {"login": "toregge"}, "path": "searchcore/src/tests/proton/attribute/attribute_test.cpp", "diffHunk": "@@ -917,38 +905,35 @@ struct StructMapFixture : public StructFixtureBase\n         doc->setValue(_structMapField, s);\n         return doc;\n     }\n+\n     void checkAttrs(uint32_t lid, int32_t expValue, const std::map<int32_t, int32_t> &expMap) {\n         auto valueAttr = _m->getAttribute(\"value\")->getSP();\n         auto mapKeyAttr = _m->getAttribute(\"map.key\")->getSP();\n         auto mapValueAttr = _m->getAttribute(\"map.value.value\")->getSP();\n-        EXPECT_EQUAL(expValue, valueAttr->getInt(lid));\n+        EXPECT_EQ(expValue, valueAttr->getInt(lid));\n         attribute::IntegerContent mapKeys;\n         mapKeys.fill(*mapKeyAttr, lid);\n         attribute::IntegerContent mapValues;\n         mapValues.fill(*mapValueAttr, lid);\n-        EXPECT_EQUAL(expMap.size(), mapValues.size());\n-        EXPECT_EQUAL(expMap.size(), mapKeys.size());\n+        EXPECT_EQ(expMap.size(), mapValues.size());\n+        EXPECT_EQ(expMap.size(), mapKeys.size());\n         size_t i = 0;\n         for (const auto &expMapElem : expMap) {\n-            EXPECT_EQUAL(expMapElem.first, mapKeys[i]);\n-            EXPECT_EQUAL(expMapElem.second, mapValues[i]);\n+            EXPECT_EQ(expMapElem.first, mapKeys[i]);\n+            EXPECT_EQ(expMapElem.second, mapValues[i]);\n             ++i;\n         }\n     }\n };\n \n-TEST_F(\"require that update with doc argument updates struct field attributes (map)\", StructMapFixture)\n+TEST_F(StructMapWriterTest, update_with_doc_argument_updates_struct_field_attributes)\n {\n-    auto doc = f.makeDoc(10,  {{1, 11}, {2, 12}});\n-    f.put(10, *doc, 1);\n-    TEST_DO(f.checkAttrs(1, 10, {{1, 11}, {2, 12}}));\n-    doc = f.makeDoc(20, {{42, 21}});\n-    f.update(11, *doc, 1, true);\n-    TEST_DO(f.checkAttrs(1, 10, {{42, 21}}));\n+    auto doc = makeDoc(10,  {{1, 11}, {2, 12}});\n+    put(10, *doc, 1);\n+    checkAttrs(1, 10, {{1, 11}, {2, 12}});\n+    doc = makeDoc(20, {{42, 21}});\n+    update(11, *doc, 1, true);\n+    checkAttrs(1, 10, {{42, 21}});\n }\n \n-TEST_MAIN()\n-{\n-    vespalib::rmdir(test_dir, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzMjgzNg=="}, "originalCommit": {"oid": "e23f73971dc3e5ec8b1b6431837941e671603338"}, "originalPosition": 1084}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYwMTQwMg==", "bodyText": "Then I guess a more general solution will be to let DirectoryHandler do cleanup of the directory in the constructor. Feel free to fix that. It will help in other tests as well.", "url": "https://github.com/vespa-engine/vespa/pull/13542#discussion_r438601402", "createdAt": "2020-06-11T07:42:37Z", "author": {"login": "geirst"}, "path": "searchcore/src/tests/proton/attribute/attribute_test.cpp", "diffHunk": "@@ -917,38 +905,35 @@ struct StructMapFixture : public StructFixtureBase\n         doc->setValue(_structMapField, s);\n         return doc;\n     }\n+\n     void checkAttrs(uint32_t lid, int32_t expValue, const std::map<int32_t, int32_t> &expMap) {\n         auto valueAttr = _m->getAttribute(\"value\")->getSP();\n         auto mapKeyAttr = _m->getAttribute(\"map.key\")->getSP();\n         auto mapValueAttr = _m->getAttribute(\"map.value.value\")->getSP();\n-        EXPECT_EQUAL(expValue, valueAttr->getInt(lid));\n+        EXPECT_EQ(expValue, valueAttr->getInt(lid));\n         attribute::IntegerContent mapKeys;\n         mapKeys.fill(*mapKeyAttr, lid);\n         attribute::IntegerContent mapValues;\n         mapValues.fill(*mapValueAttr, lid);\n-        EXPECT_EQUAL(expMap.size(), mapValues.size());\n-        EXPECT_EQUAL(expMap.size(), mapKeys.size());\n+        EXPECT_EQ(expMap.size(), mapValues.size());\n+        EXPECT_EQ(expMap.size(), mapKeys.size());\n         size_t i = 0;\n         for (const auto &expMapElem : expMap) {\n-            EXPECT_EQUAL(expMapElem.first, mapKeys[i]);\n-            EXPECT_EQUAL(expMapElem.second, mapValues[i]);\n+            EXPECT_EQ(expMapElem.first, mapKeys[i]);\n+            EXPECT_EQ(expMapElem.second, mapValues[i]);\n             ++i;\n         }\n     }\n };\n \n-TEST_F(\"require that update with doc argument updates struct field attributes (map)\", StructMapFixture)\n+TEST_F(StructMapWriterTest, update_with_doc_argument_updates_struct_field_attributes)\n {\n-    auto doc = f.makeDoc(10,  {{1, 11}, {2, 12}});\n-    f.put(10, *doc, 1);\n-    TEST_DO(f.checkAttrs(1, 10, {{1, 11}, {2, 12}}));\n-    doc = f.makeDoc(20, {{42, 21}});\n-    f.update(11, *doc, 1, true);\n-    TEST_DO(f.checkAttrs(1, 10, {{42, 21}}));\n+    auto doc = makeDoc(10,  {{1, 11}, {2, 12}});\n+    put(10, *doc, 1);\n+    checkAttrs(1, 10, {{1, 11}, {2, 12}});\n+    doc = makeDoc(20, {{42, 21}});\n+    update(11, *doc, 1, true);\n+    checkAttrs(1, 10, {{42, 21}});\n }\n \n-TEST_MAIN()\n-{\n-    vespalib::rmdir(test_dir, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzMjgzNg=="}, "originalCommit": {"oid": "e23f73971dc3e5ec8b1b6431837941e671603338"}, "originalPosition": 1084}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2031, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}