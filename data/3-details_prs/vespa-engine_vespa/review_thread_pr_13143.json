{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyODE3Mjgw", "number": 13143, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwOTo0OTo0M1rOD466OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMDo1NDoyNFrOD48Eig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMDEyMDI0OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/features/queryterm.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwOTo0OTo0M1rOGP5g8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMTozNjozNlrOGP8hjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNDE0NA==", "bodyText": "This parameter is removed, please update", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419324144", "createdAt": "2020-05-04T09:49:43Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.h", "diffHunk": "@@ -51,10 +61,20 @@ class QueryTermFactory {\n      * @param lookupSignificance whether we should look up the significance for this term.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8a78d38165897e4c0daad243b21f5db82aa71e"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM3MzQ1Mw==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419373453", "createdAt": "2020-05-04T11:36:36Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.h", "diffHunk": "@@ -51,10 +61,20 @@ class QueryTermFactory {\n      * @param lookupSignificance whether we should look up the significance for this term.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNDE0NA=="}, "originalCommit": {"oid": "1e8a78d38165897e4c0daad243b21f5db82aa71e"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMDEyMTc1OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/features/queryterm.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwOTo1MDowOFrOGP5h6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMTozNjo0NVrOGP8h0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNDM5Mg==", "bodyText": "Consider adding class comment.", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419324392", "createdAt": "2020-05-04T09:50:08Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.h", "diffHunk": "@@ -51,10 +61,20 @@ class QueryTermFactory {\n      * @param lookupSignificance whether we should look up the significance for this term.\n      * @param lookupConnectedness whether we should look up the connectedness this term has with the previous term.\n      */\n-    static QueryTerm create(const fef::IQueryEnvironment & env,\n-                            uint32_t termIndex,\n-                            bool lookupSignificance = true,\n+    static QueryTerm create(const fef::IQueryEnvironment & env, uint32_t termIndex,\n                             bool lookupConnectedness = false);\n };\n \n+class QueryTermHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e8a78d38165897e4c0daad243b21f5db82aa71e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM3MzUyMQ==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419373521", "createdAt": "2020-05-04T11:36:45Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.h", "diffHunk": "@@ -51,10 +61,20 @@ class QueryTermFactory {\n      * @param lookupSignificance whether we should look up the significance for this term.\n      * @param lookupConnectedness whether we should look up the connectedness this term has with the previous term.\n      */\n-    static QueryTerm create(const fef::IQueryEnvironment & env,\n-                            uint32_t termIndex,\n-                            bool lookupSignificance = true,\n+    static QueryTerm create(const fef::IQueryEnvironment & env, uint32_t termIndex,\n                             bool lookupConnectedness = false);\n };\n \n+class QueryTermHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNDM5Mg=="}, "originalCommit": {"oid": "1e8a78d38165897e4c0daad243b21f5db82aa71e"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMDI3NzU0OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/features/queryterm.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMDo0Mjo0OFrOGP7D3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMTozNzoxNlrOGP8isw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0OTQ3MA==", "bodyText": "'queryvectorhelper' is a bit confusing, consider using 'querytermhelper.queryterms' instead", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419349470", "createdAt": "2020-05-04T10:42:48Z", "author": {"login": "havardpe"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.cpp", "diffHunk": "@@ -3,45 +3,66 @@\n #include \"queryterm.h\"\n #include \"utils.h\"\n \n-using namespace search::fef;\n using search::feature_t;\n+using namespace search::fef;\n \n namespace search::features {\n \n-QueryTerm::QueryTerm() :\n-    _termData(nullptr),\n-    _handle(IllegalHandle),\n-    _significance(0),\n-    _connectedness(0)\n+QueryTerm\n+QueryTermFactory::create(const IQueryEnvironment & env, uint32_t termIdx, bool lookupConnectedness)\n {\n+    const ITermData *termData = env.getTerm(termIdx);\n+    feature_t fallback = util::getSignificance(*termData);\n+    feature_t significance = features::util::lookupSignificance(env, termIdx, fallback);\n+    feature_t connectedness = 0;\n+    if (lookupConnectedness) {\n+        connectedness = util::lookupConnectedness(env, termIdx);\n+    }\n+    return QueryTerm(termData, significance, connectedness);\n }\n \n-QueryTerm::QueryTerm(const ITermData * td, feature_t sig, feature_t con) :\n-    _termData(td),\n-    _handle(IllegalHandle),\n-    _significance(sig),\n-    _connectedness(con)\n+QueryTermHelper::QueryTermHelper(const IQueryEnvironment &env)\n+        : _fallBack(),\n+          _queryTerms(lookupQueryTerms(env))\n {\n+    if (_queryTerms == nullptr) {\n+        _fallBack = createQueryTermvector(env);\n+        _queryTerms = & _fallBack;\n+    }\n }\n \n-QueryTerm\n-QueryTermFactory::create(const IQueryEnvironment & env,\n-                         uint32_t termIdx,\n-                         bool lookupSignificance,\n-                         bool lookupConnectedness)\n+namespace {\n+\n+using QueryTermVectorWrapper = AnyWrapper<QueryTermVector>;\n+const vespalib::string QUERY_TERMS_KEY(\"queryvectorhelper.queryterms\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88775899c648ecca07143542b329e460dfc45675"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM3Mzc0Nw==", "bodyText": "fixed", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419373747", "createdAt": "2020-05-04T11:37:16Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.cpp", "diffHunk": "@@ -3,45 +3,66 @@\n #include \"queryterm.h\"\n #include \"utils.h\"\n \n-using namespace search::fef;\n using search::feature_t;\n+using namespace search::fef;\n \n namespace search::features {\n \n-QueryTerm::QueryTerm() :\n-    _termData(nullptr),\n-    _handle(IllegalHandle),\n-    _significance(0),\n-    _connectedness(0)\n+QueryTerm\n+QueryTermFactory::create(const IQueryEnvironment & env, uint32_t termIdx, bool lookupConnectedness)\n {\n+    const ITermData *termData = env.getTerm(termIdx);\n+    feature_t fallback = util::getSignificance(*termData);\n+    feature_t significance = features::util::lookupSignificance(env, termIdx, fallback);\n+    feature_t connectedness = 0;\n+    if (lookupConnectedness) {\n+        connectedness = util::lookupConnectedness(env, termIdx);\n+    }\n+    return QueryTerm(termData, significance, connectedness);\n }\n \n-QueryTerm::QueryTerm(const ITermData * td, feature_t sig, feature_t con) :\n-    _termData(td),\n-    _handle(IllegalHandle),\n-    _significance(sig),\n-    _connectedness(con)\n+QueryTermHelper::QueryTermHelper(const IQueryEnvironment &env)\n+        : _fallBack(),\n+          _queryTerms(lookupQueryTerms(env))\n {\n+    if (_queryTerms == nullptr) {\n+        _fallBack = createQueryTermvector(env);\n+        _queryTerms = & _fallBack;\n+    }\n }\n \n-QueryTerm\n-QueryTermFactory::create(const IQueryEnvironment & env,\n-                         uint32_t termIdx,\n-                         bool lookupSignificance,\n-                         bool lookupConnectedness)\n+namespace {\n+\n+using QueryTermVectorWrapper = AnyWrapper<QueryTermVector>;\n+const vespalib::string QUERY_TERMS_KEY(\"queryvectorhelper.queryterms\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0OTQ3MA=="}, "originalCommit": {"oid": "88775899c648ecca07143542b329e460dfc45675"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMDI5NzQwOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/features/queryterm.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMDo0OTo1M1rOGP7QMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMTozNzozNVrOGP8jVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1MjYyNg==", "bodyText": "push_back is probably more appropriate for object copy", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419352626", "createdAt": "2020-05-04T10:49:53Z", "author": {"login": "havardpe"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.cpp", "diffHunk": "@@ -3,45 +3,66 @@\n #include \"queryterm.h\"\n #include \"utils.h\"\n \n-using namespace search::fef;\n using search::feature_t;\n+using namespace search::fef;\n \n namespace search::features {\n \n-QueryTerm::QueryTerm() :\n-    _termData(nullptr),\n-    _handle(IllegalHandle),\n-    _significance(0),\n-    _connectedness(0)\n+QueryTerm\n+QueryTermFactory::create(const IQueryEnvironment & env, uint32_t termIdx, bool lookupConnectedness)\n {\n+    const ITermData *termData = env.getTerm(termIdx);\n+    feature_t fallback = util::getSignificance(*termData);\n+    feature_t significance = features::util::lookupSignificance(env, termIdx, fallback);\n+    feature_t connectedness = 0;\n+    if (lookupConnectedness) {\n+        connectedness = util::lookupConnectedness(env, termIdx);\n+    }\n+    return QueryTerm(termData, significance, connectedness);\n }\n \n-QueryTerm::QueryTerm(const ITermData * td, feature_t sig, feature_t con) :\n-    _termData(td),\n-    _handle(IllegalHandle),\n-    _significance(sig),\n-    _connectedness(con)\n+QueryTermHelper::QueryTermHelper(const IQueryEnvironment &env)\n+        : _fallBack(),\n+          _queryTerms(lookupQueryTerms(env))\n {\n+    if (_queryTerms == nullptr) {\n+        _fallBack = createQueryTermvector(env);\n+        _queryTerms = & _fallBack;\n+    }\n }\n \n-QueryTerm\n-QueryTermFactory::create(const IQueryEnvironment & env,\n-                         uint32_t termIdx,\n-                         bool lookupSignificance,\n-                         bool lookupConnectedness)\n+namespace {\n+\n+using QueryTermVectorWrapper = AnyWrapper<QueryTermVector>;\n+const vespalib::string QUERY_TERMS_KEY(\"queryvectorhelper.queryterms\");\n+\n+}\n+const QueryTermVector &\n+QueryTermHelper::lookupAndStoreQueryTerms(const IQueryEnvironment &env, IObjectStore & store)\n {\n-    const ITermData *termData = env.getTerm(termIdx);\n-    feature_t significance = 0;\n-    if (lookupSignificance) {\n-        feature_t fallback = util::getSignificance(*termData);\n-        significance = util::lookupSignificance(env, termIdx, fallback);\n-    }\n-    feature_t connectedness = 0;\n-    if (lookupConnectedness) {\n-        connectedness = search::features::util::lookupConnectedness(env, termIdx);\n+    const Anything * obj = store.get(QUERY_TERMS_KEY);\n+    if (obj == nullptr) {\n+        store.add(QUERY_TERMS_KEY, std::make_unique<QueryTermVectorWrapper>(createQueryTermvector(env)));\n+        obj = store.get(QUERY_TERMS_KEY);\n     }\n-    return QueryTerm(termData, significance, connectedness);\n+    return static_cast<const QueryTermVectorWrapper *>(obj)->getValue();\n }\n \n+const QueryTermVector *\n+QueryTermHelper::lookupQueryTerms(const IQueryEnvironment & env)\n+{\n+    const Anything * obj = env.getObjectStore().get(QUERY_TERMS_KEY);\n+    return (obj != nullptr) ? & static_cast<const QueryTermVectorWrapper *>(obj)->getValue() : nullptr;\n+}\n+\n+QueryTermVector\n+QueryTermHelper::createQueryTermvector(const IQueryEnvironment &env) {\n+    QueryTermVector vector;\n+    vector.reserve(env.getNumTerms());\n+    for (size_t i(0); i < env.getNumTerms(); i++) {\n+        vector.emplace_back(QueryTermFactory::create(env, i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88775899c648ecca07143542b329e460dfc45675"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM3MzkxMQ==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419373911", "createdAt": "2020-05-04T11:37:35Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.cpp", "diffHunk": "@@ -3,45 +3,66 @@\n #include \"queryterm.h\"\n #include \"utils.h\"\n \n-using namespace search::fef;\n using search::feature_t;\n+using namespace search::fef;\n \n namespace search::features {\n \n-QueryTerm::QueryTerm() :\n-    _termData(nullptr),\n-    _handle(IllegalHandle),\n-    _significance(0),\n-    _connectedness(0)\n+QueryTerm\n+QueryTermFactory::create(const IQueryEnvironment & env, uint32_t termIdx, bool lookupConnectedness)\n {\n+    const ITermData *termData = env.getTerm(termIdx);\n+    feature_t fallback = util::getSignificance(*termData);\n+    feature_t significance = features::util::lookupSignificance(env, termIdx, fallback);\n+    feature_t connectedness = 0;\n+    if (lookupConnectedness) {\n+        connectedness = util::lookupConnectedness(env, termIdx);\n+    }\n+    return QueryTerm(termData, significance, connectedness);\n }\n \n-QueryTerm::QueryTerm(const ITermData * td, feature_t sig, feature_t con) :\n-    _termData(td),\n-    _handle(IllegalHandle),\n-    _significance(sig),\n-    _connectedness(con)\n+QueryTermHelper::QueryTermHelper(const IQueryEnvironment &env)\n+        : _fallBack(),\n+          _queryTerms(lookupQueryTerms(env))\n {\n+    if (_queryTerms == nullptr) {\n+        _fallBack = createQueryTermvector(env);\n+        _queryTerms = & _fallBack;\n+    }\n }\n \n-QueryTerm\n-QueryTermFactory::create(const IQueryEnvironment & env,\n-                         uint32_t termIdx,\n-                         bool lookupSignificance,\n-                         bool lookupConnectedness)\n+namespace {\n+\n+using QueryTermVectorWrapper = AnyWrapper<QueryTermVector>;\n+const vespalib::string QUERY_TERMS_KEY(\"queryvectorhelper.queryterms\");\n+\n+}\n+const QueryTermVector &\n+QueryTermHelper::lookupAndStoreQueryTerms(const IQueryEnvironment &env, IObjectStore & store)\n {\n-    const ITermData *termData = env.getTerm(termIdx);\n-    feature_t significance = 0;\n-    if (lookupSignificance) {\n-        feature_t fallback = util::getSignificance(*termData);\n-        significance = util::lookupSignificance(env, termIdx, fallback);\n-    }\n-    feature_t connectedness = 0;\n-    if (lookupConnectedness) {\n-        connectedness = search::features::util::lookupConnectedness(env, termIdx);\n+    const Anything * obj = store.get(QUERY_TERMS_KEY);\n+    if (obj == nullptr) {\n+        store.add(QUERY_TERMS_KEY, std::make_unique<QueryTermVectorWrapper>(createQueryTermvector(env)));\n+        obj = store.get(QUERY_TERMS_KEY);\n     }\n-    return QueryTerm(termData, significance, connectedness);\n+    return static_cast<const QueryTermVectorWrapper *>(obj)->getValue();\n }\n \n+const QueryTermVector *\n+QueryTermHelper::lookupQueryTerms(const IQueryEnvironment & env)\n+{\n+    const Anything * obj = env.getObjectStore().get(QUERY_TERMS_KEY);\n+    return (obj != nullptr) ? & static_cast<const QueryTermVectorWrapper *>(obj)->getValue() : nullptr;\n+}\n+\n+QueryTermVector\n+QueryTermHelper::createQueryTermvector(const IQueryEnvironment &env) {\n+    QueryTermVector vector;\n+    vector.reserve(env.getNumTerms());\n+    for (size_t i(0); i < env.getNumTerms(); i++) {\n+        vector.emplace_back(QueryTermFactory::create(env, i));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1MjYyNg=="}, "originalCommit": {"oid": "88775899c648ecca07143542b329e460dfc45675"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMDMxMDUwOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/features/queryterm.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMDo1NDoyNFrOGP7X_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMTozNzo1MlrOGP8j4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1NDYyMQ==", "bodyText": "consider adding a static convenience function to the AnyWrapper template that casts the Anything pointer to a const T reference.", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419354621", "createdAt": "2020-05-04T10:54:24Z", "author": {"login": "havardpe"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.cpp", "diffHunk": "@@ -3,45 +3,66 @@\n #include \"queryterm.h\"\n #include \"utils.h\"\n \n-using namespace search::fef;\n using search::feature_t;\n+using namespace search::fef;\n \n namespace search::features {\n \n-QueryTerm::QueryTerm() :\n-    _termData(nullptr),\n-    _handle(IllegalHandle),\n-    _significance(0),\n-    _connectedness(0)\n+QueryTerm\n+QueryTermFactory::create(const IQueryEnvironment & env, uint32_t termIdx, bool lookupConnectedness)\n {\n+    const ITermData *termData = env.getTerm(termIdx);\n+    feature_t fallback = util::getSignificance(*termData);\n+    feature_t significance = features::util::lookupSignificance(env, termIdx, fallback);\n+    feature_t connectedness = 0;\n+    if (lookupConnectedness) {\n+        connectedness = util::lookupConnectedness(env, termIdx);\n+    }\n+    return QueryTerm(termData, significance, connectedness);\n }\n \n-QueryTerm::QueryTerm(const ITermData * td, feature_t sig, feature_t con) :\n-    _termData(td),\n-    _handle(IllegalHandle),\n-    _significance(sig),\n-    _connectedness(con)\n+QueryTermHelper::QueryTermHelper(const IQueryEnvironment &env)\n+        : _fallBack(),\n+          _queryTerms(lookupQueryTerms(env))\n {\n+    if (_queryTerms == nullptr) {\n+        _fallBack = createQueryTermvector(env);\n+        _queryTerms = & _fallBack;\n+    }\n }\n \n-QueryTerm\n-QueryTermFactory::create(const IQueryEnvironment & env,\n-                         uint32_t termIdx,\n-                         bool lookupSignificance,\n-                         bool lookupConnectedness)\n+namespace {\n+\n+using QueryTermVectorWrapper = AnyWrapper<QueryTermVector>;\n+const vespalib::string QUERY_TERMS_KEY(\"queryvectorhelper.queryterms\");\n+\n+}\n+const QueryTermVector &\n+QueryTermHelper::lookupAndStoreQueryTerms(const IQueryEnvironment &env, IObjectStore & store)\n {\n-    const ITermData *termData = env.getTerm(termIdx);\n-    feature_t significance = 0;\n-    if (lookupSignificance) {\n-        feature_t fallback = util::getSignificance(*termData);\n-        significance = util::lookupSignificance(env, termIdx, fallback);\n-    }\n-    feature_t connectedness = 0;\n-    if (lookupConnectedness) {\n-        connectedness = search::features::util::lookupConnectedness(env, termIdx);\n+    const Anything * obj = store.get(QUERY_TERMS_KEY);\n+    if (obj == nullptr) {\n+        store.add(QUERY_TERMS_KEY, std::make_unique<QueryTermVectorWrapper>(createQueryTermvector(env)));\n+        obj = store.get(QUERY_TERMS_KEY);\n     }\n-    return QueryTerm(termData, significance, connectedness);\n+    return static_cast<const QueryTermVectorWrapper *>(obj)->getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88775899c648ecca07143542b329e460dfc45675"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM3NDA1MA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13143#discussion_r419374050", "createdAt": "2020-05-04T11:37:52Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/features/queryterm.cpp", "diffHunk": "@@ -3,45 +3,66 @@\n #include \"queryterm.h\"\n #include \"utils.h\"\n \n-using namespace search::fef;\n using search::feature_t;\n+using namespace search::fef;\n \n namespace search::features {\n \n-QueryTerm::QueryTerm() :\n-    _termData(nullptr),\n-    _handle(IllegalHandle),\n-    _significance(0),\n-    _connectedness(0)\n+QueryTerm\n+QueryTermFactory::create(const IQueryEnvironment & env, uint32_t termIdx, bool lookupConnectedness)\n {\n+    const ITermData *termData = env.getTerm(termIdx);\n+    feature_t fallback = util::getSignificance(*termData);\n+    feature_t significance = features::util::lookupSignificance(env, termIdx, fallback);\n+    feature_t connectedness = 0;\n+    if (lookupConnectedness) {\n+        connectedness = util::lookupConnectedness(env, termIdx);\n+    }\n+    return QueryTerm(termData, significance, connectedness);\n }\n \n-QueryTerm::QueryTerm(const ITermData * td, feature_t sig, feature_t con) :\n-    _termData(td),\n-    _handle(IllegalHandle),\n-    _significance(sig),\n-    _connectedness(con)\n+QueryTermHelper::QueryTermHelper(const IQueryEnvironment &env)\n+        : _fallBack(),\n+          _queryTerms(lookupQueryTerms(env))\n {\n+    if (_queryTerms == nullptr) {\n+        _fallBack = createQueryTermvector(env);\n+        _queryTerms = & _fallBack;\n+    }\n }\n \n-QueryTerm\n-QueryTermFactory::create(const IQueryEnvironment & env,\n-                         uint32_t termIdx,\n-                         bool lookupSignificance,\n-                         bool lookupConnectedness)\n+namespace {\n+\n+using QueryTermVectorWrapper = AnyWrapper<QueryTermVector>;\n+const vespalib::string QUERY_TERMS_KEY(\"queryvectorhelper.queryterms\");\n+\n+}\n+const QueryTermVector &\n+QueryTermHelper::lookupAndStoreQueryTerms(const IQueryEnvironment &env, IObjectStore & store)\n {\n-    const ITermData *termData = env.getTerm(termIdx);\n-    feature_t significance = 0;\n-    if (lookupSignificance) {\n-        feature_t fallback = util::getSignificance(*termData);\n-        significance = util::lookupSignificance(env, termIdx, fallback);\n-    }\n-    feature_t connectedness = 0;\n-    if (lookupConnectedness) {\n-        connectedness = search::features::util::lookupConnectedness(env, termIdx);\n+    const Anything * obj = store.get(QUERY_TERMS_KEY);\n+    if (obj == nullptr) {\n+        store.add(QUERY_TERMS_KEY, std::make_unique<QueryTermVectorWrapper>(createQueryTermvector(env)));\n+        obj = store.get(QUERY_TERMS_KEY);\n     }\n-    return QueryTerm(termData, significance, connectedness);\n+    return static_cast<const QueryTermVectorWrapper *>(obj)->getValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1NDYyMQ=="}, "originalCommit": {"oid": "88775899c648ecca07143542b329e460dfc45675"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1692, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}