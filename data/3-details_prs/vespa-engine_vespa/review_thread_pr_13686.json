{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MDkxNjQ3", "number": 13686, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxNDoyMVrOEIXDmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxNzo1MlrOEIXJWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAxODE5OnYy", "diffSide": "RIGHT", "path": "searchlib/src/tests/queryeval/filter_wrapper/filter_wrapper_test.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxNDoyMVrOGoRh7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxNDoyMVrOGoRh7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MzQzNw==", "bodyText": "Consider nullptr instead of 0", "url": "https://github.com/vespa-engine/vespa/pull/13686#discussion_r444883437", "createdAt": "2020-06-24T13:14:21Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/queryeval/filter_wrapper/filter_wrapper_test.cpp", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/testapp.h>\n+#include <vespa/searchlib/queryeval/filter_wrapper.h>\n+#include <vespa/searchlib/fef/termfieldmatchdata.h>\n+#include <vespa/searchlib/common/bitvectoriterator.h>\n+#include <vespa/searchlib/test/searchiteratorverifier.h>\n+\n+using namespace search::fef;\n+using namespace search::queryeval;\n+using search::BitVector;\n+using search::BitVectorIterator;\n+\n+struct DummyItr : public SearchIterator {\n+    static uint32_t seekCnt;\n+    static uint32_t unpackCnt;\n+    static uint32_t dtorCnt;\n+    static uint32_t _unpackedDocId;\n+    TermFieldMatchData *match;\n+\n+    DummyItr(TermFieldMatchData *m) {\n+        match = m;\n+    }\n+\n+    ~DummyItr() {\n+        ++dtorCnt;\n+    }\n+\n+    void doSeek(uint32_t docid) override {\n+        ++seekCnt;\n+        if (docid <= 10) {\n+            setDocId(10);\n+        } else if (docid <= 20) {\n+            setDocId(20);\n+        } else {\n+            setAtEnd();\n+        }\n+    }\n+\n+    void doUnpack(uint32_t docid) override {\n+        ++unpackCnt;\n+        if (match != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619a965a2f450ce863ac0022ecdecd9e9b73a439"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAyMDYzOnYy", "diffSide": "RIGHT", "path": "searchlib/src/tests/queryeval/filter_wrapper/filter_wrapper_test.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxNTowMlrOGoRjdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxNTowMlrOGoRjdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MzgyOA==", "bodyText": "Consider removing '_' prefix for consistency with the other variables.", "url": "https://github.com/vespa-engine/vespa/pull/13686#discussion_r444883828", "createdAt": "2020-06-24T13:15:02Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/queryeval/filter_wrapper/filter_wrapper_test.cpp", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/testapp.h>\n+#include <vespa/searchlib/queryeval/filter_wrapper.h>\n+#include <vespa/searchlib/fef/termfieldmatchdata.h>\n+#include <vespa/searchlib/common/bitvectoriterator.h>\n+#include <vespa/searchlib/test/searchiteratorverifier.h>\n+\n+using namespace search::fef;\n+using namespace search::queryeval;\n+using search::BitVector;\n+using search::BitVectorIterator;\n+\n+struct DummyItr : public SearchIterator {\n+    static uint32_t seekCnt;\n+    static uint32_t unpackCnt;\n+    static uint32_t dtorCnt;\n+    static uint32_t _unpackedDocId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619a965a2f450ce863ac0022ecdecd9e9b73a439"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAzMjg4OnYy", "diffSide": "RIGHT", "path": "searchlib/src/tests/queryeval/filter_wrapper/filter_wrapper_test.cpp", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxNzo1MlrOGoRq_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwODoxNjoyN1rOGowOHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4NTc1OA==", "bodyText": "I guess this is the reason for using testkit instead of gtest?", "url": "https://github.com/vespa-engine/vespa/pull/13686#discussion_r444885758", "createdAt": "2020-06-24T13:17:52Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/queryeval/filter_wrapper/filter_wrapper_test.cpp", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/testapp.h>\n+#include <vespa/searchlib/queryeval/filter_wrapper.h>\n+#include <vespa/searchlib/fef/termfieldmatchdata.h>\n+#include <vespa/searchlib/common/bitvectoriterator.h>\n+#include <vespa/searchlib/test/searchiteratorverifier.h>\n+\n+using namespace search::fef;\n+using namespace search::queryeval;\n+using search::BitVector;\n+using search::BitVectorIterator;\n+\n+struct DummyItr : public SearchIterator {\n+    static uint32_t seekCnt;\n+    static uint32_t unpackCnt;\n+    static uint32_t dtorCnt;\n+    static uint32_t _unpackedDocId;\n+    TermFieldMatchData *match;\n+\n+    DummyItr(TermFieldMatchData *m) {\n+        match = m;\n+    }\n+\n+    ~DummyItr() {\n+        ++dtorCnt;\n+    }\n+\n+    void doSeek(uint32_t docid) override {\n+        ++seekCnt;\n+        if (docid <= 10) {\n+            setDocId(10);\n+        } else if (docid <= 20) {\n+            setDocId(20);\n+        } else {\n+            setAtEnd();\n+        }\n+    }\n+\n+    void doUnpack(uint32_t docid) override {\n+        ++unpackCnt;\n+        if (match != 0) {\n+            _unpackedDocId = docid;\n+        }\n+    }\n+};\n+uint32_t DummyItr::seekCnt   = 0;\n+uint32_t DummyItr::unpackCnt = 0;\n+uint32_t DummyItr::dtorCnt   = 0;\n+uint32_t DummyItr::_unpackedDocId = 0;\n+\n+\n+TEST(\"filter wrapper forwards as expected\") {\n+    EXPECT_EQUAL(DummyItr::seekCnt, 0u);\n+    EXPECT_EQUAL(DummyItr::unpackCnt, 0u);\n+    EXPECT_EQUAL(DummyItr::dtorCnt, 0u);\n+    { // without wrapper\n+        TermFieldMatchData match;\n+        DummyItr::_unpackedDocId = 0;\n+        SearchIterator::UP search(new DummyItr(&match));\n+        search->initFullRange();\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQUAL(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 10u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQUAL(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 20u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQUAL(DummyItr::seekCnt, 3u);\n+    EXPECT_EQUAL(DummyItr::unpackCnt, 2u);\n+    EXPECT_EQUAL(DummyItr::dtorCnt, 1u);\n+    { // with wrapper\n+        TermFieldMatchData match;\n+        TermFieldMatchDataArray tfmda;\n+        tfmda.add(&match);\n+        DummyItr::_unpackedDocId = 0;\n+        auto search = std::make_unique<FilterWrapper>(1);\n+        auto to_wrap = std::make_unique<DummyItr>(search->tfmda()[0]);\n+        search->wrap(std::move(to_wrap));\n+        search->initFullRange();\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQUAL(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQUAL(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQUAL(DummyItr::seekCnt, 6u);\n+    EXPECT_EQUAL(DummyItr::unpackCnt, 2u);\n+    EXPECT_EQUAL(DummyItr::dtorCnt, 2u);\n+}\n+\n+class Verifier : public search::test::SearchIteratorVerifier {\n+public:\n+    ~Verifier();\n+    SearchIterator::UP create(bool strict) const override {\n+        auto search = std::make_unique<FilterWrapper>(1);\n+        search->wrap(createIterator(getExpectedDocIds(), strict));\n+        return search;\n+    }\n+};\n+\n+Verifier::~Verifier() {}\n+\n+TEST(\"Test that filter wrapper iterators adheres to SearchIterator requirements\") {\n+    Verifier searchIteratorVerifier;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619a965a2f450ce863ac0022ecdecd9e9b73a439"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0MDM1Mw==", "bodyText": "reason for all your comments: this is an almost-exact copy of booleanmatchiteratorwrapper unit test. i'll look at modernizing both of these tests (and maybe put them in the same file, or somehow avoid so much code duplication) soon.", "url": "https://github.com/vespa-engine/vespa/pull/13686#discussion_r445340353", "createdAt": "2020-06-25T06:45:28Z", "author": {"login": "arnej27959"}, "path": "searchlib/src/tests/queryeval/filter_wrapper/filter_wrapper_test.cpp", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/testapp.h>\n+#include <vespa/searchlib/queryeval/filter_wrapper.h>\n+#include <vespa/searchlib/fef/termfieldmatchdata.h>\n+#include <vespa/searchlib/common/bitvectoriterator.h>\n+#include <vespa/searchlib/test/searchiteratorverifier.h>\n+\n+using namespace search::fef;\n+using namespace search::queryeval;\n+using search::BitVector;\n+using search::BitVectorIterator;\n+\n+struct DummyItr : public SearchIterator {\n+    static uint32_t seekCnt;\n+    static uint32_t unpackCnt;\n+    static uint32_t dtorCnt;\n+    static uint32_t _unpackedDocId;\n+    TermFieldMatchData *match;\n+\n+    DummyItr(TermFieldMatchData *m) {\n+        match = m;\n+    }\n+\n+    ~DummyItr() {\n+        ++dtorCnt;\n+    }\n+\n+    void doSeek(uint32_t docid) override {\n+        ++seekCnt;\n+        if (docid <= 10) {\n+            setDocId(10);\n+        } else if (docid <= 20) {\n+            setDocId(20);\n+        } else {\n+            setAtEnd();\n+        }\n+    }\n+\n+    void doUnpack(uint32_t docid) override {\n+        ++unpackCnt;\n+        if (match != 0) {\n+            _unpackedDocId = docid;\n+        }\n+    }\n+};\n+uint32_t DummyItr::seekCnt   = 0;\n+uint32_t DummyItr::unpackCnt = 0;\n+uint32_t DummyItr::dtorCnt   = 0;\n+uint32_t DummyItr::_unpackedDocId = 0;\n+\n+\n+TEST(\"filter wrapper forwards as expected\") {\n+    EXPECT_EQUAL(DummyItr::seekCnt, 0u);\n+    EXPECT_EQUAL(DummyItr::unpackCnt, 0u);\n+    EXPECT_EQUAL(DummyItr::dtorCnt, 0u);\n+    { // without wrapper\n+        TermFieldMatchData match;\n+        DummyItr::_unpackedDocId = 0;\n+        SearchIterator::UP search(new DummyItr(&match));\n+        search->initFullRange();\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQUAL(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 10u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQUAL(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 20u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQUAL(DummyItr::seekCnt, 3u);\n+    EXPECT_EQUAL(DummyItr::unpackCnt, 2u);\n+    EXPECT_EQUAL(DummyItr::dtorCnt, 1u);\n+    { // with wrapper\n+        TermFieldMatchData match;\n+        TermFieldMatchDataArray tfmda;\n+        tfmda.add(&match);\n+        DummyItr::_unpackedDocId = 0;\n+        auto search = std::make_unique<FilterWrapper>(1);\n+        auto to_wrap = std::make_unique<DummyItr>(search->tfmda()[0]);\n+        search->wrap(std::move(to_wrap));\n+        search->initFullRange();\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQUAL(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQUAL(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQUAL(DummyItr::seekCnt, 6u);\n+    EXPECT_EQUAL(DummyItr::unpackCnt, 2u);\n+    EXPECT_EQUAL(DummyItr::dtorCnt, 2u);\n+}\n+\n+class Verifier : public search::test::SearchIteratorVerifier {\n+public:\n+    ~Verifier();\n+    SearchIterator::UP create(bool strict) const override {\n+        auto search = std::make_unique<FilterWrapper>(1);\n+        search->wrap(createIterator(getExpectedDocIds(), strict));\n+        return search;\n+    }\n+};\n+\n+Verifier::~Verifier() {}\n+\n+TEST(\"Test that filter wrapper iterators adheres to SearchIterator requirements\") {\n+    Verifier searchIteratorVerifier;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4NTc1OA=="}, "originalCommit": {"oid": "619a965a2f450ce863ac0022ecdecd9e9b73a439"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4NjI3MA==", "bodyText": "Sounds good \ud83d\udc4d", "url": "https://github.com/vespa-engine/vespa/pull/13686#discussion_r445386270", "createdAt": "2020-06-25T08:16:27Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/queryeval/filter_wrapper/filter_wrapper_test.cpp", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/testapp.h>\n+#include <vespa/searchlib/queryeval/filter_wrapper.h>\n+#include <vespa/searchlib/fef/termfieldmatchdata.h>\n+#include <vespa/searchlib/common/bitvectoriterator.h>\n+#include <vespa/searchlib/test/searchiteratorverifier.h>\n+\n+using namespace search::fef;\n+using namespace search::queryeval;\n+using search::BitVector;\n+using search::BitVectorIterator;\n+\n+struct DummyItr : public SearchIterator {\n+    static uint32_t seekCnt;\n+    static uint32_t unpackCnt;\n+    static uint32_t dtorCnt;\n+    static uint32_t _unpackedDocId;\n+    TermFieldMatchData *match;\n+\n+    DummyItr(TermFieldMatchData *m) {\n+        match = m;\n+    }\n+\n+    ~DummyItr() {\n+        ++dtorCnt;\n+    }\n+\n+    void doSeek(uint32_t docid) override {\n+        ++seekCnt;\n+        if (docid <= 10) {\n+            setDocId(10);\n+        } else if (docid <= 20) {\n+            setDocId(20);\n+        } else {\n+            setAtEnd();\n+        }\n+    }\n+\n+    void doUnpack(uint32_t docid) override {\n+        ++unpackCnt;\n+        if (match != 0) {\n+            _unpackedDocId = docid;\n+        }\n+    }\n+};\n+uint32_t DummyItr::seekCnt   = 0;\n+uint32_t DummyItr::unpackCnt = 0;\n+uint32_t DummyItr::dtorCnt   = 0;\n+uint32_t DummyItr::_unpackedDocId = 0;\n+\n+\n+TEST(\"filter wrapper forwards as expected\") {\n+    EXPECT_EQUAL(DummyItr::seekCnt, 0u);\n+    EXPECT_EQUAL(DummyItr::unpackCnt, 0u);\n+    EXPECT_EQUAL(DummyItr::dtorCnt, 0u);\n+    { // without wrapper\n+        TermFieldMatchData match;\n+        DummyItr::_unpackedDocId = 0;\n+        SearchIterator::UP search(new DummyItr(&match));\n+        search->initFullRange();\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQUAL(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 10u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQUAL(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 20u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQUAL(DummyItr::seekCnt, 3u);\n+    EXPECT_EQUAL(DummyItr::unpackCnt, 2u);\n+    EXPECT_EQUAL(DummyItr::dtorCnt, 1u);\n+    { // with wrapper\n+        TermFieldMatchData match;\n+        TermFieldMatchDataArray tfmda;\n+        tfmda.add(&match);\n+        DummyItr::_unpackedDocId = 0;\n+        auto search = std::make_unique<FilterWrapper>(1);\n+        auto to_wrap = std::make_unique<DummyItr>(search->tfmda()[0]);\n+        search->wrap(std::move(to_wrap));\n+        search->initFullRange();\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQUAL(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQUAL(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQUAL(DummyItr::_unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQUAL(DummyItr::seekCnt, 6u);\n+    EXPECT_EQUAL(DummyItr::unpackCnt, 2u);\n+    EXPECT_EQUAL(DummyItr::dtorCnt, 2u);\n+}\n+\n+class Verifier : public search::test::SearchIteratorVerifier {\n+public:\n+    ~Verifier();\n+    SearchIterator::UP create(bool strict) const override {\n+        auto search = std::make_unique<FilterWrapper>(1);\n+        search->wrap(createIterator(getExpectedDocIds(), strict));\n+        return search;\n+    }\n+};\n+\n+Verifier::~Verifier() {}\n+\n+TEST(\"Test that filter wrapper iterators adheres to SearchIterator requirements\") {\n+    Verifier searchIteratorVerifier;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4NTc1OA=="}, "originalCommit": {"oid": "619a965a2f450ce863ac0022ecdecd9e9b73a439"}, "originalPosition": 120}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1882, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}