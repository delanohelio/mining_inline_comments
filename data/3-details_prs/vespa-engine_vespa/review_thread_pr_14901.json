{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0MDYzMzI0", "number": 14901, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDoxOTo0OVrOEuBNUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDoxOTo0OVrOEuBNUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2Njg5NzQ2OnYy", "diffSide": "RIGHT", "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/certificate/EndpointCertificateManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDoxOTo0OVrOHiKQdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwNDo1OTo0MFrOHim_Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4MTY4Nw==", "bodyText": "What's the reason this isn't done through the ApplicationController?", "url": "https://github.com/vespa-engine/vespa/pull/14901#discussion_r505581687", "createdAt": "2020-10-15T14:19:49Z", "author": {"login": "jonmv"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/certificate/EndpointCertificateManager.java", "diffHunk": "@@ -129,76 +129,52 @@ public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n             return Optional.of(reprovisionedCertificateMetadata);\n         }\n \n-        // If feature flag set for application, look for and use refreshed certificate\n-        if (useRefreshedEndpointCertificate.with(FetchVector.Dimension.APPLICATION_ID, instance.id().serializedForm()).value()) {\n-            var latestAvailableVersion = latestVersionInSecretStore(currentCertificateMetadata.get());\n-\n-            if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > currentCertificateMetadata.get().version()) {\n-                var refreshedCertificateMetadata = currentCertificateMetadata.get().withVersion(latestAvailableVersion.getAsInt());\n-                validateEndpointCertificate(refreshedCertificateMetadata, instance, zone);\n-                curator.writeEndpointCertificateMetadata(instance.id(), refreshedCertificateMetadata);\n-                return Optional.of(refreshedCertificateMetadata);\n-            }\n+        // Look for and use refreshed certificate\n+        var latestAvailableVersion = latestVersionInSecretStore(currentCertificateMetadata.get());\n+        if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > currentCertificateMetadata.get().version()) {\n+            var refreshedCertificateMetadata = currentCertificateMetadata.get().withVersion(latestAvailableVersion.getAsInt());\n+            validateEndpointCertificate(refreshedCertificateMetadata, instance, zone);\n+            curator.writeEndpointCertificateMetadata(instance.id(), refreshedCertificateMetadata);\n+            return Optional.of(refreshedCertificateMetadata);\n         }\n \n         validateEndpointCertificate(currentCertificateMetadata.get(), instance, zone);\n         return currentCertificateMetadata;\n     }\n \n-    enum BackfillMode {\n+    enum CleanupMode {\n         DISABLE,\n         DRYRUN,\n         ENABLE\n     }\n \n-    private void backfillCertificateMetadata() {\n-        BackfillMode mode = BackfillMode.valueOf(endpointCertificateBackfill.value());\n-        if (mode == BackfillMode.DISABLE) return;\n-\n-        List<EndpointCertificateMetadata> allProviderCertificateMetadata = endpointCertificateProvider.listCertificates();\n-        Map<String, EndpointCertificateMetadata> sanToEndpointCertificate = new HashMap<>();\n-\n-        allProviderCertificateMetadata.forEach((providerMetadata -> {\n-            if (providerMetadata.request_id().isEmpty())\n-                throw new RuntimeException(\"Backfill failed - provider metadata missing request_id\");\n-            if (providerMetadata.requestedDnsSans().isEmpty())\n-                throw new RuntimeException(\"Backfill failed - provider metadata missing DNS SANs for \" + providerMetadata.request_id().get());\n-            providerMetadata.requestedDnsSans().get().forEach(san -> sanToEndpointCertificate.put(san, providerMetadata)\n-            );\n-        }));\n-\n-        Map<ApplicationId, EndpointCertificateMetadata> allEndpointCertificateMetadata = curator.readAllEndpointCertificateMetadata();\n-\n-        allEndpointCertificateMetadata.forEach((applicationId, storedMetaData) -> {\n-            if (storedMetaData.requestedDnsSans().isPresent() && storedMetaData.request_id().isPresent() && storedMetaData.issuer().isPresent())\n-                return;\n-\n-            var hashedCn = commonNameHashOf(applicationId, zoneRegistry.system()); // use as join key\n-            EndpointCertificateMetadata providerMetadata = sanToEndpointCertificate.get(hashedCn);\n-\n-            if (providerMetadata == null) {\n-                log.log(Level.INFO, \"No matching certificate provider metadata found for application \" + applicationId.serializedForm());\n-                return;\n-            }\n-\n-            EndpointCertificateMetadata backfilledMetadata =\n-                    new EndpointCertificateMetadata(\n-                            storedMetaData.keyName(),\n-                            storedMetaData.certName(),\n-                            storedMetaData.version(),\n-                            Instant.now().getEpochSecond(),\n-                            providerMetadata.request_id(),\n-                            providerMetadata.requestedDnsSans(),\n-                            providerMetadata.issuer());\n-\n-            if (mode == BackfillMode.DRYRUN) {\n-                log.log(Level.INFO, \"Would update stored metadata \" + storedMetaData + \" with data from provider: \" + backfilledMetadata);\n-            } else if (mode == BackfillMode.ENABLE) {\n-                curator.writeEndpointCertificateMetadata(applicationId, backfilledMetadata);\n+    private void deleteUnusedCertificates() {\n+        CleanupMode mode = CleanupMode.valueOf(deleteUnusedEndpointCertificates.value());\n+        if (mode == CleanupMode.DISABLE) return;\n+\n+        var oneMonthAgo = clock.instant().minus(1, ChronoUnit.MONTHS);\n+        curator.readAllEndpointCertificateMetadata().forEach((applicationId, storedMetaData) -> {\n+            var lastRequested = Instant.ofEpochSecond(storedMetaData.lastRequested());\n+            if (lastRequested.isBefore(oneMonthAgo) && hasNoDeployments(applicationId)) {\n+                log.log(LogLevel.INFO, \"Cert for app \" + applicationId.serializedForm()\n+                        + \" has not been requested in a month and app has no deployments\"\n+                        + (mode == CleanupMode.ENABLE ? \", deleting from provider and ZK\" : \"\"));\n+                if (mode == CleanupMode.ENABLE) {\n+                    endpointCertificateProvider.deleteCertificate(applicationId, storedMetaData);\n+                    curator.deleteEndpointCertificateMetadata(applicationId);\n+                }\n             }\n         });\n     }\n \n+    private boolean hasNoDeployments(ApplicationId applicationId) {\n+        var deployments = curator.readApplication(TenantAndApplicationId.from(applicationId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1MjM4Mg==", "bodyText": "Instantiating the ApplicationController for unit tests seemed like more trouble than it was worth. Maybe I should have mocked it instead?", "url": "https://github.com/vespa-engine/vespa/pull/14901#discussion_r506052382", "createdAt": "2020-10-16T04:59:40Z", "author": {"login": "andreer"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/certificate/EndpointCertificateManager.java", "diffHunk": "@@ -129,76 +129,52 @@ public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n             return Optional.of(reprovisionedCertificateMetadata);\n         }\n \n-        // If feature flag set for application, look for and use refreshed certificate\n-        if (useRefreshedEndpointCertificate.with(FetchVector.Dimension.APPLICATION_ID, instance.id().serializedForm()).value()) {\n-            var latestAvailableVersion = latestVersionInSecretStore(currentCertificateMetadata.get());\n-\n-            if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > currentCertificateMetadata.get().version()) {\n-                var refreshedCertificateMetadata = currentCertificateMetadata.get().withVersion(latestAvailableVersion.getAsInt());\n-                validateEndpointCertificate(refreshedCertificateMetadata, instance, zone);\n-                curator.writeEndpointCertificateMetadata(instance.id(), refreshedCertificateMetadata);\n-                return Optional.of(refreshedCertificateMetadata);\n-            }\n+        // Look for and use refreshed certificate\n+        var latestAvailableVersion = latestVersionInSecretStore(currentCertificateMetadata.get());\n+        if (latestAvailableVersion.isPresent() && latestAvailableVersion.getAsInt() > currentCertificateMetadata.get().version()) {\n+            var refreshedCertificateMetadata = currentCertificateMetadata.get().withVersion(latestAvailableVersion.getAsInt());\n+            validateEndpointCertificate(refreshedCertificateMetadata, instance, zone);\n+            curator.writeEndpointCertificateMetadata(instance.id(), refreshedCertificateMetadata);\n+            return Optional.of(refreshedCertificateMetadata);\n         }\n \n         validateEndpointCertificate(currentCertificateMetadata.get(), instance, zone);\n         return currentCertificateMetadata;\n     }\n \n-    enum BackfillMode {\n+    enum CleanupMode {\n         DISABLE,\n         DRYRUN,\n         ENABLE\n     }\n \n-    private void backfillCertificateMetadata() {\n-        BackfillMode mode = BackfillMode.valueOf(endpointCertificateBackfill.value());\n-        if (mode == BackfillMode.DISABLE) return;\n-\n-        List<EndpointCertificateMetadata> allProviderCertificateMetadata = endpointCertificateProvider.listCertificates();\n-        Map<String, EndpointCertificateMetadata> sanToEndpointCertificate = new HashMap<>();\n-\n-        allProviderCertificateMetadata.forEach((providerMetadata -> {\n-            if (providerMetadata.request_id().isEmpty())\n-                throw new RuntimeException(\"Backfill failed - provider metadata missing request_id\");\n-            if (providerMetadata.requestedDnsSans().isEmpty())\n-                throw new RuntimeException(\"Backfill failed - provider metadata missing DNS SANs for \" + providerMetadata.request_id().get());\n-            providerMetadata.requestedDnsSans().get().forEach(san -> sanToEndpointCertificate.put(san, providerMetadata)\n-            );\n-        }));\n-\n-        Map<ApplicationId, EndpointCertificateMetadata> allEndpointCertificateMetadata = curator.readAllEndpointCertificateMetadata();\n-\n-        allEndpointCertificateMetadata.forEach((applicationId, storedMetaData) -> {\n-            if (storedMetaData.requestedDnsSans().isPresent() && storedMetaData.request_id().isPresent() && storedMetaData.issuer().isPresent())\n-                return;\n-\n-            var hashedCn = commonNameHashOf(applicationId, zoneRegistry.system()); // use as join key\n-            EndpointCertificateMetadata providerMetadata = sanToEndpointCertificate.get(hashedCn);\n-\n-            if (providerMetadata == null) {\n-                log.log(Level.INFO, \"No matching certificate provider metadata found for application \" + applicationId.serializedForm());\n-                return;\n-            }\n-\n-            EndpointCertificateMetadata backfilledMetadata =\n-                    new EndpointCertificateMetadata(\n-                            storedMetaData.keyName(),\n-                            storedMetaData.certName(),\n-                            storedMetaData.version(),\n-                            Instant.now().getEpochSecond(),\n-                            providerMetadata.request_id(),\n-                            providerMetadata.requestedDnsSans(),\n-                            providerMetadata.issuer());\n-\n-            if (mode == BackfillMode.DRYRUN) {\n-                log.log(Level.INFO, \"Would update stored metadata \" + storedMetaData + \" with data from provider: \" + backfilledMetadata);\n-            } else if (mode == BackfillMode.ENABLE) {\n-                curator.writeEndpointCertificateMetadata(applicationId, backfilledMetadata);\n+    private void deleteUnusedCertificates() {\n+        CleanupMode mode = CleanupMode.valueOf(deleteUnusedEndpointCertificates.value());\n+        if (mode == CleanupMode.DISABLE) return;\n+\n+        var oneMonthAgo = clock.instant().minus(1, ChronoUnit.MONTHS);\n+        curator.readAllEndpointCertificateMetadata().forEach((applicationId, storedMetaData) -> {\n+            var lastRequested = Instant.ofEpochSecond(storedMetaData.lastRequested());\n+            if (lastRequested.isBefore(oneMonthAgo) && hasNoDeployments(applicationId)) {\n+                log.log(LogLevel.INFO, \"Cert for app \" + applicationId.serializedForm()\n+                        + \" has not been requested in a month and app has no deployments\"\n+                        + (mode == CleanupMode.ENABLE ? \", deleting from provider and ZK\" : \"\"));\n+                if (mode == CleanupMode.ENABLE) {\n+                    endpointCertificateProvider.deleteCertificate(applicationId, storedMetaData);\n+                    curator.deleteEndpointCertificateMetadata(applicationId);\n+                }\n             }\n         });\n     }\n \n+    private boolean hasNoDeployments(ApplicationId applicationId) {\n+        var deployments = curator.readApplication(TenantAndApplicationId.from(applicationId))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU4MTY4Nw=="}, "originalCommit": {"oid": "c6070c2eea59ba1f47a35c8c1740cb88a9c19dc1"}, "originalPosition": 169}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1184, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}