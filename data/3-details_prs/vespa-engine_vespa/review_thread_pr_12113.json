{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMzg5MjY5", "number": 12113, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjozOTozNFrODeAjyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMzoyMDoyMFrODeBJKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzkzMDM0OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/ann/remove-bm.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjozOTozNFrOFm7zFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjozOTozNFrOFm7zFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM2OTk0MA==", "bodyText": "Please update copyright year", "url": "https://github.com/vespa-engine/vespa/pull/12113#discussion_r376369940", "createdAt": "2020-02-07T12:39:34Z", "author": {"login": "geirst"}, "path": "eval/src/tests/ann/remove-bm.cpp", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55728e48cd1f1cda6aadd8afb76f532b4174c7e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzk1MDQ0OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/ann/remove-bm.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo0ODozMFrOFm7_fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo0ODozMFrOFm7_fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3MzExOQ==", "bodyText": "Do we want to keep this block?", "url": "https://github.com/vespa-engine/vespa/pull/12113#discussion_r376373119", "createdAt": "2020-02-07T12:48:30Z", "author": {"login": "geirst"}, "path": "eval/src/tests/ann/remove-bm.cpp", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/test_kit.h>\n+#include <vespa/vespalib/util/priority_queue.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+\n+#define NUM_DIMS 960\n+#define NUM_DOCS 250000\n+#define NUM_DOCS_REMOVE 50000\n+#define EFFECTIVE_DOCS (NUM_DOCS - NUM_DOCS_REMOVE)\n+#define NUM_Q 1000\n+\n+#include \"doc_vector_access.h\"\n+#include \"nns.h\"\n+#include \"for-sift-hit.h\"\n+#include \"for-sift-top-k.h\"\n+\n+std::vector<TopK> bruteforceResults;\n+std::vector<float> tmp_v(NUM_DIMS);\n+\n+struct PointVector {\n+    float v[NUM_DIMS];\n+    using ConstArr = vespalib::ConstArrayRef<float>;\n+    operator ConstArr() const { return ConstArr(v, NUM_DIMS); }\n+};\n+\n+static PointVector *aligned_alloc(size_t num) {\n+    size_t num_bytes = num * sizeof(PointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return (PointVector *)mem;\n+}\n+\n+static PointVector *generatedQueries = aligned_alloc(NUM_Q);\n+static PointVector *generatedDocs = aligned_alloc(NUM_DOCS);\n+\n+struct DocVectorAdapter : public DocVectorAccess<float>\n+{\n+    vespalib::ConstArrayRef<float> get(uint32_t docid) const override {\n+        ASSERT_TRUE(docid < NUM_DOCS);\n+        return generatedDocs[docid];\n+    }\n+};\n+\n+double computeDistance(const PointVector &query, uint32_t docid) {\n+    const PointVector &docvector = generatedDocs[docid];\n+    return l2distCalc.l2sq_dist(query, docvector, tmp_v);\n+}\n+\n+void read_queries(std::string fn) {\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    ASSERT_TRUE(fd > 0);\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u queries from %s\\n\", NUM_Q, fn.c_str());\n+    for (uint32_t qid = 0; qid < NUM_Q; ++qid) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQUAL(rv, 4u);\n+        ASSERT_EQUAL(d, NUM_DIMS);\n+        rv = read(fd, &generatedQueries[qid].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQUAL(rv, sizeof(PointVector));\n+    }\n+    close(fd);\n+}\n+\n+void read_docs(std::string fn) {\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    ASSERT_TRUE(fd > 0);\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u doc vectors from %s\\n\", NUM_DOCS, fn.c_str());\n+    for (uint32_t docid = 0; docid < NUM_DOCS; ++docid) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQUAL(rv, 4u);\n+        ASSERT_EQUAL(d, NUM_DIMS);\n+        rv = read(fd, &generatedDocs[docid].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQUAL(rv, sizeof(PointVector));\n+    }\n+    close(fd);\n+}\n+\n+using TimePoint = std::chrono::steady_clock::time_point;\n+using Duration = std::chrono::steady_clock::duration;\n+\n+double to_ms(Duration elapsed) {\n+    std::chrono::duration<double, std::milli> ms(elapsed);\n+    return ms.count();\n+}\n+\n+void read_data(std::string dir) {\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    read_queries(dir + \"/gist_query.fvecs\");\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"read queries: %.3f ms\\n\", to_ms(aft - bef));\n+    bef = std::chrono::steady_clock::now();\n+    read_docs(dir + \"/gist_base.fvecs\");\n+    aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"read docs: %.3f ms\\n\", to_ms(aft - bef));\n+}\n+\n+\n+struct BfHitComparator {\n+    bool operator() (const Hit &lhs, const Hit& rhs) const {\n+        if (lhs.distance < rhs.distance) return false;\n+        if (lhs.distance > rhs.distance) return true;\n+        return (lhs.docid > rhs.docid);\n+    }\n+};\n+\n+class BfHitHeap {\n+private:\n+    size_t _size;\n+    vespalib::PriorityQueue<Hit, BfHitComparator> _priQ;\n+public:\n+    explicit BfHitHeap(size_t maxSize) : _size(maxSize), _priQ() {\n+        _priQ.reserve(maxSize);\n+    }\n+    ~BfHitHeap() {}\n+    void maybe_use(const Hit &hit) {\n+        if (_priQ.size() < _size) {\n+            _priQ.push(hit);\n+        } else if (hit.distance < _priQ.front().distance) {\n+            _priQ.front() = hit;\n+            _priQ.adjust();\n+        }\n+    }\n+    std::vector<Hit> bestHits() {\n+        std::vector<Hit> result;\n+        size_t i = _priQ.size();\n+        result.resize(i);\n+        while (i-- > 0) {\n+            result[i] = _priQ.front();\n+            _priQ.pop_front();\n+        }\n+        return result;\n+    }\n+};\n+\n+TopK bruteforce_nns(const PointVector &query) {\n+    TopK result;\n+    BfHitHeap heap(result.K);\n+    for (uint32_t docid = 0; docid < EFFECTIVE_DOCS; ++docid) {\n+        const PointVector &docvector = generatedDocs[docid];\n+        double d = l2distCalc.l2sq_dist(query, docvector, tmp_v);\n+        Hit h(docid, d);\n+        heap.maybe_use(h);\n+    }\n+    std::vector<Hit> best = heap.bestHits();\n+    for (size_t i = 0; i < result.K; ++i) {\n+        result.hits[i] = best[i];\n+    }\n+    return result;\n+}\n+\n+void verifyBF(uint32_t qid) {\n+    const PointVector &query = generatedQueries[qid];\n+    TopK &result = bruteforceResults[qid];\n+    double min_distance = result.hits[0].distance;\n+    std::vector<double> all_c2;\n+    for (uint32_t i = 0; i < EFFECTIVE_DOCS; ++i) {\n+        double dist = computeDistance(query, i);\n+        if (dist < min_distance) {\n+            fprintf(stderr, \"WARN dist %.9g < mindist %.9g\\n\", dist, min_distance);\n+        }\n+        EXPECT_FALSE(dist+0.000001 < min_distance);\n+        if (min_distance > 0.0) all_c2.push_back(dist / min_distance);\n+    }\n+    if (all_c2.size() != EFFECTIVE_DOCS) return;\n+    std::sort(all_c2.begin(), all_c2.end());\n+    for (uint32_t idx : { 1, 3, 10, 30, 100, 300, 1000, 3000, EFFECTIVE_DOCS/2, EFFECTIVE_DOCS-1}) {\n+        fprintf(stderr, \"c2-factor[%u] = %.3f\\n\", idx, all_c2[idx]);\n+    }\n+}\n+\n+using NNS_API = NNS<float>;\n+\n+#if 1\n+TEST(\"require that HNSW via NNS api remove all works\") {\n+    DocVectorAdapter adapter;\n+    std::unique_ptr<NNS_API> nns = make_hnsw_nns(NUM_DIMS, adapter);\n+    fprintf(stderr, \"adding and removing all docs forward...\\n\");\n+    for (uint32_t i = 0; i < 1000; ++i) {\n+        nns->addDoc(i);\n+    }\n+    for (uint32_t i = 0; i < 1000; ++i) {\n+        nns->removeDoc(i);\n+    }\n+    fprintf(stderr, \"adding and removing all docs reverse...\\n\");\n+    for (uint32_t i = 1000; i < 2000; ++i) {\n+        nns->addDoc(i);\n+    }\n+    for (uint32_t i = 2000; i-- > 1000; ) {\n+        nns->removeDoc(i);\n+    }\n+}\n+#endif\n+\n+TEST(\"require that brute force works\") {\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"generating %u brute force results\\n\", NUM_Q);\n+    bruteforceResults.reserve(NUM_Q);\n+    for (uint32_t cnt = 0; cnt < NUM_Q; ++cnt) {\n+        const PointVector &query = generatedQueries[cnt];\n+        bruteforceResults.emplace_back(bruteforce_nns(query));\n+    }\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"timing for brute force: %.3f ms = %.3f ms per query\\n\",\n+            to_ms(aft - bef), to_ms(aft - bef)/NUM_Q);\n+    for (int cnt = 0; cnt < NUM_Q; cnt = (cnt+1)*2) {\n+        verifyBF(cnt);\n+    }\n+}\n+\n+bool reach_with_nns_1(NNS_API &nns, uint32_t docid) {\n+    const PointVector &qv = generatedDocs[docid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(1, query, 1);\n+    if (rv.size() != 1) {\n+        fprintf(stderr, \"Result/A from query for %u is %zu hits\\n\", docid, rv.size());\n+        return false;\n+    }\n+    if (rv[0].docid != docid) {\n+      if (rv[0].sq.distance != 0.0)\n+        fprintf(stderr, \"Expected/A to find %u but got %u with sq distance %.3f\\n\",\n+                docid, rv[0].docid, rv[0].sq.distance);\n+    }\n+    return (rv[0].docid == docid || rv[0].sq.distance == 0.0);\n+}\n+\n+bool reach_with_nns_100(NNS_API &nns, uint32_t docid) {\n+    const PointVector &qv = generatedDocs[docid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(10, query, 100);\n+    if (rv.size() != 10) {\n+        fprintf(stderr, \"Result/B from query for %u is %zu hits\\n\", docid, rv.size());\n+    }\n+    if (rv[0].docid != docid) {\n+      if (rv[0].sq.distance != 0.0)\n+        fprintf(stderr, \"Expected/B to find %u but got %u with sq distance %.3f\\n\",\n+                docid, rv[0].docid, rv[0].sq.distance);\n+    }\n+    return (rv[0].docid == docid || rv[0].sq.distance == 0.0);\n+}\n+\n+bool reach_with_nns_1k(NNS_API &nns, uint32_t docid) {\n+    const PointVector &qv = generatedDocs[docid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(10, query, 1000);\n+    if (rv.size() != 10) {\n+        fprintf(stderr, \"Result/C from query for %u is %zu hits\\n\", docid, rv.size());\n+    }\n+    if (rv[0].docid != docid) {\n+      if (rv[0].sq.distance != 0.0)\n+        fprintf(stderr, \"Expected/C to find %u but got %u with sq distance %.3f\\n\",\n+                docid, rv[0].docid, rv[0].sq.distance);\n+    }\n+    return (rv[0].docid == docid || rv[0].sq.distance == 0.0);\n+}\n+\n+TopK find_with_nns(uint32_t sk, NNS_API &nns, uint32_t qid) {\n+    TopK result;\n+    const PointVector &qv = generatedQueries[qid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(result.K, query, sk);\n+    for (size_t i = 0; i < result.K; ++i) {\n+        result.hits[i] = Hit(rv[i].docid, rv[i].sq.distance);\n+    }\n+    return result;\n+}\n+\n+void verify_nns_quality(uint32_t sk, NNS_API &nns, uint32_t qid) {\n+    TopK perfect = bruteforceResults[qid];\n+    TopK result = find_with_nns(sk, nns, qid);\n+    int recall = perfect.recall(result);\n+    EXPECT_TRUE(recall > 40);\n+    double sum_error = 0.0;\n+    double c_factor = 1.0;\n+    for (size_t i = 0; i < result.K; ++i) {\n+        double factor = (result.hits[i].distance / perfect.hits[i].distance);\n+        if (factor < 0.99 || factor > 25) {\n+            fprintf(stderr, \"hit[%zu] got distance %.3f, expected %.3f\\n\",\n+                    i, result.hits[i].distance, perfect.hits[i].distance);\n+        }\n+        sum_error += factor;\n+        c_factor = std::max(c_factor, factor);\n+    }\n+    EXPECT_TRUE(c_factor < 1.5);\n+    fprintf(stderr, \"quality sk=%u: query %u: recall %d  c2-factor %.3f  avg c2: %.3f\\n\",\n+            sk, qid, recall, c_factor, sum_error / result.K);\n+}\n+\n+void timing_nns(const char *name, NNS_API &nns, std::vector<uint32_t> sk_list) {\n+    for (uint32_t search_k : sk_list) {\n+        TimePoint bef = std::chrono::steady_clock::now();\n+        for (int cnt = 0; cnt < NUM_Q; ++cnt) {\n+            find_with_nns(search_k, nns, cnt);\n+        }\n+        TimePoint aft = std::chrono::steady_clock::now();\n+        fprintf(stderr, \"timing for %s search_k=%u: %.3f ms = %.3f ms/q\\n\",\n+                name, search_k, to_ms(aft - bef), to_ms(aft - bef)/NUM_Q);\n+    }\n+}\n+\n+void quality_nns(NNS_API &nns, std::vector<uint32_t> sk_list) {\n+    for (uint32_t search_k : sk_list) {\n+        for (int cnt = 0; cnt < NUM_Q; ++cnt) {\n+            verify_nns_quality(search_k, nns, cnt);\n+        }\n+    }\n+    uint32_t reached = 0;\n+    for (uint32_t i = 0; i < 20000; ++i) {\n+        if (reach_with_nns_1(nns, i)) ++reached;\n+    }\n+    fprintf(stderr, \"Could reach %u of 20000 first documents with k=1\\n\", reached);\n+    reached = 0;\n+    for (uint32_t i = 0; i < 20000; ++i) {\n+        if (reach_with_nns_100(nns, i)) ++reached;\n+    }\n+    fprintf(stderr, \"Could reach %u of 20000 first documents with k=100\\n\", reached);\n+    reached = 0;\n+    for (uint32_t i = 0; i < 20000; ++i) {\n+        if (reach_with_nns_1k(nns, i)) ++reached;\n+    }\n+    fprintf(stderr, \"Could reach %u of 20000 first documents with k=1000\\n\", reached);\n+}\n+\n+void benchmark_nns(const char *name, NNS_API &nns, std::vector<uint32_t> sk_list) {\n+    fprintf(stderr, \"trying %s indexing...\\n\", name);\n+\n+#if 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55728e48cd1f1cda6aadd8afb76f532b4174c7e"}, "originalPosition": 340}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzk1MDY3OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/ann/remove-bm.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo0ODozOFrOFm7_pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo0ODozOFrOFm7_pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3MzE1Nw==", "bodyText": "Do we want to keep this block?", "url": "https://github.com/vespa-engine/vespa/pull/12113#discussion_r376373157", "createdAt": "2020-02-07T12:48:38Z", "author": {"login": "geirst"}, "path": "eval/src/tests/ann/remove-bm.cpp", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/test_kit.h>\n+#include <vespa/vespalib/util/priority_queue.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+\n+#define NUM_DIMS 960\n+#define NUM_DOCS 250000\n+#define NUM_DOCS_REMOVE 50000\n+#define EFFECTIVE_DOCS (NUM_DOCS - NUM_DOCS_REMOVE)\n+#define NUM_Q 1000\n+\n+#include \"doc_vector_access.h\"\n+#include \"nns.h\"\n+#include \"for-sift-hit.h\"\n+#include \"for-sift-top-k.h\"\n+\n+std::vector<TopK> bruteforceResults;\n+std::vector<float> tmp_v(NUM_DIMS);\n+\n+struct PointVector {\n+    float v[NUM_DIMS];\n+    using ConstArr = vespalib::ConstArrayRef<float>;\n+    operator ConstArr() const { return ConstArr(v, NUM_DIMS); }\n+};\n+\n+static PointVector *aligned_alloc(size_t num) {\n+    size_t num_bytes = num * sizeof(PointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return (PointVector *)mem;\n+}\n+\n+static PointVector *generatedQueries = aligned_alloc(NUM_Q);\n+static PointVector *generatedDocs = aligned_alloc(NUM_DOCS);\n+\n+struct DocVectorAdapter : public DocVectorAccess<float>\n+{\n+    vespalib::ConstArrayRef<float> get(uint32_t docid) const override {\n+        ASSERT_TRUE(docid < NUM_DOCS);\n+        return generatedDocs[docid];\n+    }\n+};\n+\n+double computeDistance(const PointVector &query, uint32_t docid) {\n+    const PointVector &docvector = generatedDocs[docid];\n+    return l2distCalc.l2sq_dist(query, docvector, tmp_v);\n+}\n+\n+void read_queries(std::string fn) {\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    ASSERT_TRUE(fd > 0);\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u queries from %s\\n\", NUM_Q, fn.c_str());\n+    for (uint32_t qid = 0; qid < NUM_Q; ++qid) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQUAL(rv, 4u);\n+        ASSERT_EQUAL(d, NUM_DIMS);\n+        rv = read(fd, &generatedQueries[qid].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQUAL(rv, sizeof(PointVector));\n+    }\n+    close(fd);\n+}\n+\n+void read_docs(std::string fn) {\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    ASSERT_TRUE(fd > 0);\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u doc vectors from %s\\n\", NUM_DOCS, fn.c_str());\n+    for (uint32_t docid = 0; docid < NUM_DOCS; ++docid) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQUAL(rv, 4u);\n+        ASSERT_EQUAL(d, NUM_DIMS);\n+        rv = read(fd, &generatedDocs[docid].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQUAL(rv, sizeof(PointVector));\n+    }\n+    close(fd);\n+}\n+\n+using TimePoint = std::chrono::steady_clock::time_point;\n+using Duration = std::chrono::steady_clock::duration;\n+\n+double to_ms(Duration elapsed) {\n+    std::chrono::duration<double, std::milli> ms(elapsed);\n+    return ms.count();\n+}\n+\n+void read_data(std::string dir) {\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    read_queries(dir + \"/gist_query.fvecs\");\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"read queries: %.3f ms\\n\", to_ms(aft - bef));\n+    bef = std::chrono::steady_clock::now();\n+    read_docs(dir + \"/gist_base.fvecs\");\n+    aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"read docs: %.3f ms\\n\", to_ms(aft - bef));\n+}\n+\n+\n+struct BfHitComparator {\n+    bool operator() (const Hit &lhs, const Hit& rhs) const {\n+        if (lhs.distance < rhs.distance) return false;\n+        if (lhs.distance > rhs.distance) return true;\n+        return (lhs.docid > rhs.docid);\n+    }\n+};\n+\n+class BfHitHeap {\n+private:\n+    size_t _size;\n+    vespalib::PriorityQueue<Hit, BfHitComparator> _priQ;\n+public:\n+    explicit BfHitHeap(size_t maxSize) : _size(maxSize), _priQ() {\n+        _priQ.reserve(maxSize);\n+    }\n+    ~BfHitHeap() {}\n+    void maybe_use(const Hit &hit) {\n+        if (_priQ.size() < _size) {\n+            _priQ.push(hit);\n+        } else if (hit.distance < _priQ.front().distance) {\n+            _priQ.front() = hit;\n+            _priQ.adjust();\n+        }\n+    }\n+    std::vector<Hit> bestHits() {\n+        std::vector<Hit> result;\n+        size_t i = _priQ.size();\n+        result.resize(i);\n+        while (i-- > 0) {\n+            result[i] = _priQ.front();\n+            _priQ.pop_front();\n+        }\n+        return result;\n+    }\n+};\n+\n+TopK bruteforce_nns(const PointVector &query) {\n+    TopK result;\n+    BfHitHeap heap(result.K);\n+    for (uint32_t docid = 0; docid < EFFECTIVE_DOCS; ++docid) {\n+        const PointVector &docvector = generatedDocs[docid];\n+        double d = l2distCalc.l2sq_dist(query, docvector, tmp_v);\n+        Hit h(docid, d);\n+        heap.maybe_use(h);\n+    }\n+    std::vector<Hit> best = heap.bestHits();\n+    for (size_t i = 0; i < result.K; ++i) {\n+        result.hits[i] = best[i];\n+    }\n+    return result;\n+}\n+\n+void verifyBF(uint32_t qid) {\n+    const PointVector &query = generatedQueries[qid];\n+    TopK &result = bruteforceResults[qid];\n+    double min_distance = result.hits[0].distance;\n+    std::vector<double> all_c2;\n+    for (uint32_t i = 0; i < EFFECTIVE_DOCS; ++i) {\n+        double dist = computeDistance(query, i);\n+        if (dist < min_distance) {\n+            fprintf(stderr, \"WARN dist %.9g < mindist %.9g\\n\", dist, min_distance);\n+        }\n+        EXPECT_FALSE(dist+0.000001 < min_distance);\n+        if (min_distance > 0.0) all_c2.push_back(dist / min_distance);\n+    }\n+    if (all_c2.size() != EFFECTIVE_DOCS) return;\n+    std::sort(all_c2.begin(), all_c2.end());\n+    for (uint32_t idx : { 1, 3, 10, 30, 100, 300, 1000, 3000, EFFECTIVE_DOCS/2, EFFECTIVE_DOCS-1}) {\n+        fprintf(stderr, \"c2-factor[%u] = %.3f\\n\", idx, all_c2[idx]);\n+    }\n+}\n+\n+using NNS_API = NNS<float>;\n+\n+#if 1\n+TEST(\"require that HNSW via NNS api remove all works\") {\n+    DocVectorAdapter adapter;\n+    std::unique_ptr<NNS_API> nns = make_hnsw_nns(NUM_DIMS, adapter);\n+    fprintf(stderr, \"adding and removing all docs forward...\\n\");\n+    for (uint32_t i = 0; i < 1000; ++i) {\n+        nns->addDoc(i);\n+    }\n+    for (uint32_t i = 0; i < 1000; ++i) {\n+        nns->removeDoc(i);\n+    }\n+    fprintf(stderr, \"adding and removing all docs reverse...\\n\");\n+    for (uint32_t i = 1000; i < 2000; ++i) {\n+        nns->addDoc(i);\n+    }\n+    for (uint32_t i = 2000; i-- > 1000; ) {\n+        nns->removeDoc(i);\n+    }\n+}\n+#endif\n+\n+TEST(\"require that brute force works\") {\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"generating %u brute force results\\n\", NUM_Q);\n+    bruteforceResults.reserve(NUM_Q);\n+    for (uint32_t cnt = 0; cnt < NUM_Q; ++cnt) {\n+        const PointVector &query = generatedQueries[cnt];\n+        bruteforceResults.emplace_back(bruteforce_nns(query));\n+    }\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"timing for brute force: %.3f ms = %.3f ms per query\\n\",\n+            to_ms(aft - bef), to_ms(aft - bef)/NUM_Q);\n+    for (int cnt = 0; cnt < NUM_Q; cnt = (cnt+1)*2) {\n+        verifyBF(cnt);\n+    }\n+}\n+\n+bool reach_with_nns_1(NNS_API &nns, uint32_t docid) {\n+    const PointVector &qv = generatedDocs[docid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(1, query, 1);\n+    if (rv.size() != 1) {\n+        fprintf(stderr, \"Result/A from query for %u is %zu hits\\n\", docid, rv.size());\n+        return false;\n+    }\n+    if (rv[0].docid != docid) {\n+      if (rv[0].sq.distance != 0.0)\n+        fprintf(stderr, \"Expected/A to find %u but got %u with sq distance %.3f\\n\",\n+                docid, rv[0].docid, rv[0].sq.distance);\n+    }\n+    return (rv[0].docid == docid || rv[0].sq.distance == 0.0);\n+}\n+\n+bool reach_with_nns_100(NNS_API &nns, uint32_t docid) {\n+    const PointVector &qv = generatedDocs[docid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(10, query, 100);\n+    if (rv.size() != 10) {\n+        fprintf(stderr, \"Result/B from query for %u is %zu hits\\n\", docid, rv.size());\n+    }\n+    if (rv[0].docid != docid) {\n+      if (rv[0].sq.distance != 0.0)\n+        fprintf(stderr, \"Expected/B to find %u but got %u with sq distance %.3f\\n\",\n+                docid, rv[0].docid, rv[0].sq.distance);\n+    }\n+    return (rv[0].docid == docid || rv[0].sq.distance == 0.0);\n+}\n+\n+bool reach_with_nns_1k(NNS_API &nns, uint32_t docid) {\n+    const PointVector &qv = generatedDocs[docid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(10, query, 1000);\n+    if (rv.size() != 10) {\n+        fprintf(stderr, \"Result/C from query for %u is %zu hits\\n\", docid, rv.size());\n+    }\n+    if (rv[0].docid != docid) {\n+      if (rv[0].sq.distance != 0.0)\n+        fprintf(stderr, \"Expected/C to find %u but got %u with sq distance %.3f\\n\",\n+                docid, rv[0].docid, rv[0].sq.distance);\n+    }\n+    return (rv[0].docid == docid || rv[0].sq.distance == 0.0);\n+}\n+\n+TopK find_with_nns(uint32_t sk, NNS_API &nns, uint32_t qid) {\n+    TopK result;\n+    const PointVector &qv = generatedQueries[qid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(result.K, query, sk);\n+    for (size_t i = 0; i < result.K; ++i) {\n+        result.hits[i] = Hit(rv[i].docid, rv[i].sq.distance);\n+    }\n+    return result;\n+}\n+\n+void verify_nns_quality(uint32_t sk, NNS_API &nns, uint32_t qid) {\n+    TopK perfect = bruteforceResults[qid];\n+    TopK result = find_with_nns(sk, nns, qid);\n+    int recall = perfect.recall(result);\n+    EXPECT_TRUE(recall > 40);\n+    double sum_error = 0.0;\n+    double c_factor = 1.0;\n+    for (size_t i = 0; i < result.K; ++i) {\n+        double factor = (result.hits[i].distance / perfect.hits[i].distance);\n+        if (factor < 0.99 || factor > 25) {\n+            fprintf(stderr, \"hit[%zu] got distance %.3f, expected %.3f\\n\",\n+                    i, result.hits[i].distance, perfect.hits[i].distance);\n+        }\n+        sum_error += factor;\n+        c_factor = std::max(c_factor, factor);\n+    }\n+    EXPECT_TRUE(c_factor < 1.5);\n+    fprintf(stderr, \"quality sk=%u: query %u: recall %d  c2-factor %.3f  avg c2: %.3f\\n\",\n+            sk, qid, recall, c_factor, sum_error / result.K);\n+}\n+\n+void timing_nns(const char *name, NNS_API &nns, std::vector<uint32_t> sk_list) {\n+    for (uint32_t search_k : sk_list) {\n+        TimePoint bef = std::chrono::steady_clock::now();\n+        for (int cnt = 0; cnt < NUM_Q; ++cnt) {\n+            find_with_nns(search_k, nns, cnt);\n+        }\n+        TimePoint aft = std::chrono::steady_clock::now();\n+        fprintf(stderr, \"timing for %s search_k=%u: %.3f ms = %.3f ms/q\\n\",\n+                name, search_k, to_ms(aft - bef), to_ms(aft - bef)/NUM_Q);\n+    }\n+}\n+\n+void quality_nns(NNS_API &nns, std::vector<uint32_t> sk_list) {\n+    for (uint32_t search_k : sk_list) {\n+        for (int cnt = 0; cnt < NUM_Q; ++cnt) {\n+            verify_nns_quality(search_k, nns, cnt);\n+        }\n+    }\n+    uint32_t reached = 0;\n+    for (uint32_t i = 0; i < 20000; ++i) {\n+        if (reach_with_nns_1(nns, i)) ++reached;\n+    }\n+    fprintf(stderr, \"Could reach %u of 20000 first documents with k=1\\n\", reached);\n+    reached = 0;\n+    for (uint32_t i = 0; i < 20000; ++i) {\n+        if (reach_with_nns_100(nns, i)) ++reached;\n+    }\n+    fprintf(stderr, \"Could reach %u of 20000 first documents with k=100\\n\", reached);\n+    reached = 0;\n+    for (uint32_t i = 0; i < 20000; ++i) {\n+        if (reach_with_nns_1k(nns, i)) ++reached;\n+    }\n+    fprintf(stderr, \"Could reach %u of 20000 first documents with k=1000\\n\", reached);\n+}\n+\n+void benchmark_nns(const char *name, NNS_API &nns, std::vector<uint32_t> sk_list) {\n+    fprintf(stderr, \"trying %s indexing...\\n\", name);\n+\n+#if 0\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.addDoc(EFFECTIVE_DOCS + i);\n+    }\n+    for (uint32_t i = 0; i < EFFECTIVE_DOCS - NUM_DOCS_REMOVE; ++i) {\n+        nns.addDoc(i);\n+    }\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.removeDoc(EFFECTIVE_DOCS + i);\n+        nns.addDoc(EFFECTIVE_DOCS - NUM_DOCS_REMOVE + i);\n+    }\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index with %u docs: %.3f ms\\n\", name, EFFECTIVE_DOCS, to_ms(aft - bef));\n+\n+    timing_nns(name, nns, sk_list);\n+    fprintf(stderr, \"Quality for %s realistic build with %u documents:\\n\", name, EFFECTIVE_DOCS);\n+    quality_nns(nns, sk_list);\n+#endif\n+\n+#if 1\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < EFFECTIVE_DOCS; ++i) {\n+        nns.addDoc(i);\n+    }\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index with %u docs: %.3f ms\\n\", name, EFFECTIVE_DOCS, to_ms(aft - bef));\n+\n+    timing_nns(name, nns, sk_list);\n+    fprintf(stderr, \"Quality for %s clean build with %u documents:\\n\", name, EFFECTIVE_DOCS);\n+    quality_nns(nns, sk_list);\n+\n+    bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.addDoc(EFFECTIVE_DOCS + i);\n+    }\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.removeDoc(EFFECTIVE_DOCS + i);\n+    }\n+    aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index add then remove %u docs: %.3f ms\\n\",\n+            name, NUM_DOCS_REMOVE, to_ms(aft - bef));\n+\n+    timing_nns(name, nns, sk_list);\n+    fprintf(stderr, \"Quality for %s remove-damaged build with %u documents:\\n\", name, EFFECTIVE_DOCS);\n+    quality_nns(nns, sk_list);\n+#endif\n+\n+#if 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55728e48cd1f1cda6aadd8afb76f532b4174c7e"}, "originalPosition": 388}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzk1MDk2OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/ann/remove-bm.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo0ODo0NFrOFm7_zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMjo0ODo0NFrOFm7_zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM3MzE5Nw==", "bodyText": "Do we want to keep this block?", "url": "https://github.com/vespa-engine/vespa/pull/12113#discussion_r376373197", "createdAt": "2020-02-07T12:48:44Z", "author": {"login": "geirst"}, "path": "eval/src/tests/ann/remove-bm.cpp", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/test_kit.h>\n+#include <vespa/vespalib/util/priority_queue.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+\n+#define NUM_DIMS 960\n+#define NUM_DOCS 250000\n+#define NUM_DOCS_REMOVE 50000\n+#define EFFECTIVE_DOCS (NUM_DOCS - NUM_DOCS_REMOVE)\n+#define NUM_Q 1000\n+\n+#include \"doc_vector_access.h\"\n+#include \"nns.h\"\n+#include \"for-sift-hit.h\"\n+#include \"for-sift-top-k.h\"\n+\n+std::vector<TopK> bruteforceResults;\n+std::vector<float> tmp_v(NUM_DIMS);\n+\n+struct PointVector {\n+    float v[NUM_DIMS];\n+    using ConstArr = vespalib::ConstArrayRef<float>;\n+    operator ConstArr() const { return ConstArr(v, NUM_DIMS); }\n+};\n+\n+static PointVector *aligned_alloc(size_t num) {\n+    size_t num_bytes = num * sizeof(PointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return (PointVector *)mem;\n+}\n+\n+static PointVector *generatedQueries = aligned_alloc(NUM_Q);\n+static PointVector *generatedDocs = aligned_alloc(NUM_DOCS);\n+\n+struct DocVectorAdapter : public DocVectorAccess<float>\n+{\n+    vespalib::ConstArrayRef<float> get(uint32_t docid) const override {\n+        ASSERT_TRUE(docid < NUM_DOCS);\n+        return generatedDocs[docid];\n+    }\n+};\n+\n+double computeDistance(const PointVector &query, uint32_t docid) {\n+    const PointVector &docvector = generatedDocs[docid];\n+    return l2distCalc.l2sq_dist(query, docvector, tmp_v);\n+}\n+\n+void read_queries(std::string fn) {\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    ASSERT_TRUE(fd > 0);\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u queries from %s\\n\", NUM_Q, fn.c_str());\n+    for (uint32_t qid = 0; qid < NUM_Q; ++qid) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQUAL(rv, 4u);\n+        ASSERT_EQUAL(d, NUM_DIMS);\n+        rv = read(fd, &generatedQueries[qid].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQUAL(rv, sizeof(PointVector));\n+    }\n+    close(fd);\n+}\n+\n+void read_docs(std::string fn) {\n+    int fd = open(fn.c_str(), O_RDONLY);\n+    ASSERT_TRUE(fd > 0);\n+    int d;\n+    size_t rv;\n+    fprintf(stderr, \"reading %u doc vectors from %s\\n\", NUM_DOCS, fn.c_str());\n+    for (uint32_t docid = 0; docid < NUM_DOCS; ++docid) {\n+        rv = read(fd, &d, 4);\n+        ASSERT_EQUAL(rv, 4u);\n+        ASSERT_EQUAL(d, NUM_DIMS);\n+        rv = read(fd, &generatedDocs[docid].v, NUM_DIMS*sizeof(float));\n+        ASSERT_EQUAL(rv, sizeof(PointVector));\n+    }\n+    close(fd);\n+}\n+\n+using TimePoint = std::chrono::steady_clock::time_point;\n+using Duration = std::chrono::steady_clock::duration;\n+\n+double to_ms(Duration elapsed) {\n+    std::chrono::duration<double, std::milli> ms(elapsed);\n+    return ms.count();\n+}\n+\n+void read_data(std::string dir) {\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    read_queries(dir + \"/gist_query.fvecs\");\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"read queries: %.3f ms\\n\", to_ms(aft - bef));\n+    bef = std::chrono::steady_clock::now();\n+    read_docs(dir + \"/gist_base.fvecs\");\n+    aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"read docs: %.3f ms\\n\", to_ms(aft - bef));\n+}\n+\n+\n+struct BfHitComparator {\n+    bool operator() (const Hit &lhs, const Hit& rhs) const {\n+        if (lhs.distance < rhs.distance) return false;\n+        if (lhs.distance > rhs.distance) return true;\n+        return (lhs.docid > rhs.docid);\n+    }\n+};\n+\n+class BfHitHeap {\n+private:\n+    size_t _size;\n+    vespalib::PriorityQueue<Hit, BfHitComparator> _priQ;\n+public:\n+    explicit BfHitHeap(size_t maxSize) : _size(maxSize), _priQ() {\n+        _priQ.reserve(maxSize);\n+    }\n+    ~BfHitHeap() {}\n+    void maybe_use(const Hit &hit) {\n+        if (_priQ.size() < _size) {\n+            _priQ.push(hit);\n+        } else if (hit.distance < _priQ.front().distance) {\n+            _priQ.front() = hit;\n+            _priQ.adjust();\n+        }\n+    }\n+    std::vector<Hit> bestHits() {\n+        std::vector<Hit> result;\n+        size_t i = _priQ.size();\n+        result.resize(i);\n+        while (i-- > 0) {\n+            result[i] = _priQ.front();\n+            _priQ.pop_front();\n+        }\n+        return result;\n+    }\n+};\n+\n+TopK bruteforce_nns(const PointVector &query) {\n+    TopK result;\n+    BfHitHeap heap(result.K);\n+    for (uint32_t docid = 0; docid < EFFECTIVE_DOCS; ++docid) {\n+        const PointVector &docvector = generatedDocs[docid];\n+        double d = l2distCalc.l2sq_dist(query, docvector, tmp_v);\n+        Hit h(docid, d);\n+        heap.maybe_use(h);\n+    }\n+    std::vector<Hit> best = heap.bestHits();\n+    for (size_t i = 0; i < result.K; ++i) {\n+        result.hits[i] = best[i];\n+    }\n+    return result;\n+}\n+\n+void verifyBF(uint32_t qid) {\n+    const PointVector &query = generatedQueries[qid];\n+    TopK &result = bruteforceResults[qid];\n+    double min_distance = result.hits[0].distance;\n+    std::vector<double> all_c2;\n+    for (uint32_t i = 0; i < EFFECTIVE_DOCS; ++i) {\n+        double dist = computeDistance(query, i);\n+        if (dist < min_distance) {\n+            fprintf(stderr, \"WARN dist %.9g < mindist %.9g\\n\", dist, min_distance);\n+        }\n+        EXPECT_FALSE(dist+0.000001 < min_distance);\n+        if (min_distance > 0.0) all_c2.push_back(dist / min_distance);\n+    }\n+    if (all_c2.size() != EFFECTIVE_DOCS) return;\n+    std::sort(all_c2.begin(), all_c2.end());\n+    for (uint32_t idx : { 1, 3, 10, 30, 100, 300, 1000, 3000, EFFECTIVE_DOCS/2, EFFECTIVE_DOCS-1}) {\n+        fprintf(stderr, \"c2-factor[%u] = %.3f\\n\", idx, all_c2[idx]);\n+    }\n+}\n+\n+using NNS_API = NNS<float>;\n+\n+#if 1\n+TEST(\"require that HNSW via NNS api remove all works\") {\n+    DocVectorAdapter adapter;\n+    std::unique_ptr<NNS_API> nns = make_hnsw_nns(NUM_DIMS, adapter);\n+    fprintf(stderr, \"adding and removing all docs forward...\\n\");\n+    for (uint32_t i = 0; i < 1000; ++i) {\n+        nns->addDoc(i);\n+    }\n+    for (uint32_t i = 0; i < 1000; ++i) {\n+        nns->removeDoc(i);\n+    }\n+    fprintf(stderr, \"adding and removing all docs reverse...\\n\");\n+    for (uint32_t i = 1000; i < 2000; ++i) {\n+        nns->addDoc(i);\n+    }\n+    for (uint32_t i = 2000; i-- > 1000; ) {\n+        nns->removeDoc(i);\n+    }\n+}\n+#endif\n+\n+TEST(\"require that brute force works\") {\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"generating %u brute force results\\n\", NUM_Q);\n+    bruteforceResults.reserve(NUM_Q);\n+    for (uint32_t cnt = 0; cnt < NUM_Q; ++cnt) {\n+        const PointVector &query = generatedQueries[cnt];\n+        bruteforceResults.emplace_back(bruteforce_nns(query));\n+    }\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"timing for brute force: %.3f ms = %.3f ms per query\\n\",\n+            to_ms(aft - bef), to_ms(aft - bef)/NUM_Q);\n+    for (int cnt = 0; cnt < NUM_Q; cnt = (cnt+1)*2) {\n+        verifyBF(cnt);\n+    }\n+}\n+\n+bool reach_with_nns_1(NNS_API &nns, uint32_t docid) {\n+    const PointVector &qv = generatedDocs[docid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(1, query, 1);\n+    if (rv.size() != 1) {\n+        fprintf(stderr, \"Result/A from query for %u is %zu hits\\n\", docid, rv.size());\n+        return false;\n+    }\n+    if (rv[0].docid != docid) {\n+      if (rv[0].sq.distance != 0.0)\n+        fprintf(stderr, \"Expected/A to find %u but got %u with sq distance %.3f\\n\",\n+                docid, rv[0].docid, rv[0].sq.distance);\n+    }\n+    return (rv[0].docid == docid || rv[0].sq.distance == 0.0);\n+}\n+\n+bool reach_with_nns_100(NNS_API &nns, uint32_t docid) {\n+    const PointVector &qv = generatedDocs[docid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(10, query, 100);\n+    if (rv.size() != 10) {\n+        fprintf(stderr, \"Result/B from query for %u is %zu hits\\n\", docid, rv.size());\n+    }\n+    if (rv[0].docid != docid) {\n+      if (rv[0].sq.distance != 0.0)\n+        fprintf(stderr, \"Expected/B to find %u but got %u with sq distance %.3f\\n\",\n+                docid, rv[0].docid, rv[0].sq.distance);\n+    }\n+    return (rv[0].docid == docid || rv[0].sq.distance == 0.0);\n+}\n+\n+bool reach_with_nns_1k(NNS_API &nns, uint32_t docid) {\n+    const PointVector &qv = generatedDocs[docid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(10, query, 1000);\n+    if (rv.size() != 10) {\n+        fprintf(stderr, \"Result/C from query for %u is %zu hits\\n\", docid, rv.size());\n+    }\n+    if (rv[0].docid != docid) {\n+      if (rv[0].sq.distance != 0.0)\n+        fprintf(stderr, \"Expected/C to find %u but got %u with sq distance %.3f\\n\",\n+                docid, rv[0].docid, rv[0].sq.distance);\n+    }\n+    return (rv[0].docid == docid || rv[0].sq.distance == 0.0);\n+}\n+\n+TopK find_with_nns(uint32_t sk, NNS_API &nns, uint32_t qid) {\n+    TopK result;\n+    const PointVector &qv = generatedQueries[qid];\n+    vespalib::ConstArrayRef<float> query(qv.v, NUM_DIMS);\n+    auto rv = nns.topK(result.K, query, sk);\n+    for (size_t i = 0; i < result.K; ++i) {\n+        result.hits[i] = Hit(rv[i].docid, rv[i].sq.distance);\n+    }\n+    return result;\n+}\n+\n+void verify_nns_quality(uint32_t sk, NNS_API &nns, uint32_t qid) {\n+    TopK perfect = bruteforceResults[qid];\n+    TopK result = find_with_nns(sk, nns, qid);\n+    int recall = perfect.recall(result);\n+    EXPECT_TRUE(recall > 40);\n+    double sum_error = 0.0;\n+    double c_factor = 1.0;\n+    for (size_t i = 0; i < result.K; ++i) {\n+        double factor = (result.hits[i].distance / perfect.hits[i].distance);\n+        if (factor < 0.99 || factor > 25) {\n+            fprintf(stderr, \"hit[%zu] got distance %.3f, expected %.3f\\n\",\n+                    i, result.hits[i].distance, perfect.hits[i].distance);\n+        }\n+        sum_error += factor;\n+        c_factor = std::max(c_factor, factor);\n+    }\n+    EXPECT_TRUE(c_factor < 1.5);\n+    fprintf(stderr, \"quality sk=%u: query %u: recall %d  c2-factor %.3f  avg c2: %.3f\\n\",\n+            sk, qid, recall, c_factor, sum_error / result.K);\n+}\n+\n+void timing_nns(const char *name, NNS_API &nns, std::vector<uint32_t> sk_list) {\n+    for (uint32_t search_k : sk_list) {\n+        TimePoint bef = std::chrono::steady_clock::now();\n+        for (int cnt = 0; cnt < NUM_Q; ++cnt) {\n+            find_with_nns(search_k, nns, cnt);\n+        }\n+        TimePoint aft = std::chrono::steady_clock::now();\n+        fprintf(stderr, \"timing for %s search_k=%u: %.3f ms = %.3f ms/q\\n\",\n+                name, search_k, to_ms(aft - bef), to_ms(aft - bef)/NUM_Q);\n+    }\n+}\n+\n+void quality_nns(NNS_API &nns, std::vector<uint32_t> sk_list) {\n+    for (uint32_t search_k : sk_list) {\n+        for (int cnt = 0; cnt < NUM_Q; ++cnt) {\n+            verify_nns_quality(search_k, nns, cnt);\n+        }\n+    }\n+    uint32_t reached = 0;\n+    for (uint32_t i = 0; i < 20000; ++i) {\n+        if (reach_with_nns_1(nns, i)) ++reached;\n+    }\n+    fprintf(stderr, \"Could reach %u of 20000 first documents with k=1\\n\", reached);\n+    reached = 0;\n+    for (uint32_t i = 0; i < 20000; ++i) {\n+        if (reach_with_nns_100(nns, i)) ++reached;\n+    }\n+    fprintf(stderr, \"Could reach %u of 20000 first documents with k=100\\n\", reached);\n+    reached = 0;\n+    for (uint32_t i = 0; i < 20000; ++i) {\n+        if (reach_with_nns_1k(nns, i)) ++reached;\n+    }\n+    fprintf(stderr, \"Could reach %u of 20000 first documents with k=1000\\n\", reached);\n+}\n+\n+void benchmark_nns(const char *name, NNS_API &nns, std::vector<uint32_t> sk_list) {\n+    fprintf(stderr, \"trying %s indexing...\\n\", name);\n+\n+#if 0\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.addDoc(EFFECTIVE_DOCS + i);\n+    }\n+    for (uint32_t i = 0; i < EFFECTIVE_DOCS - NUM_DOCS_REMOVE; ++i) {\n+        nns.addDoc(i);\n+    }\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.removeDoc(EFFECTIVE_DOCS + i);\n+        nns.addDoc(EFFECTIVE_DOCS - NUM_DOCS_REMOVE + i);\n+    }\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index with %u docs: %.3f ms\\n\", name, EFFECTIVE_DOCS, to_ms(aft - bef));\n+\n+    timing_nns(name, nns, sk_list);\n+    fprintf(stderr, \"Quality for %s realistic build with %u documents:\\n\", name, EFFECTIVE_DOCS);\n+    quality_nns(nns, sk_list);\n+#endif\n+\n+#if 1\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < EFFECTIVE_DOCS; ++i) {\n+        nns.addDoc(i);\n+    }\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index with %u docs: %.3f ms\\n\", name, EFFECTIVE_DOCS, to_ms(aft - bef));\n+\n+    timing_nns(name, nns, sk_list);\n+    fprintf(stderr, \"Quality for %s clean build with %u documents:\\n\", name, EFFECTIVE_DOCS);\n+    quality_nns(nns, sk_list);\n+\n+    bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.addDoc(EFFECTIVE_DOCS + i);\n+    }\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.removeDoc(EFFECTIVE_DOCS + i);\n+    }\n+    aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index add then remove %u docs: %.3f ms\\n\",\n+            name, NUM_DOCS_REMOVE, to_ms(aft - bef));\n+\n+    timing_nns(name, nns, sk_list);\n+    fprintf(stderr, \"Quality for %s remove-damaged build with %u documents:\\n\", name, EFFECTIVE_DOCS);\n+    quality_nns(nns, sk_list);\n+#endif\n+\n+#if 0\n+    TimePoint bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < EFFECTIVE_DOCS; ++i) {\n+        nns.addDoc(i);\n+    }\n+    TimePoint aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index with %u docs: %.3f ms\\n\", name, EFFECTIVE_DOCS, to_ms(aft - bef));\n+\n+    timing_nns(name, nns, sk_list);\n+    fprintf(stderr, \"Quality for %s clean build with %u documents:\\n\", name, EFFECTIVE_DOCS);\n+    quality_nns(nns, sk_list);\n+\n+    bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < EFFECTIVE_DOCS; ++i) {\n+        nns.removeDoc(i);\n+    }\n+    aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index removed %u docs: %.3f ms\\n\", name, EFFECTIVE_DOCS, to_ms(aft - bef));\n+\n+    const uint32_t addFirst = NUM_DOCS - (NUM_DOCS_REMOVE * 3);\n+    const uint32_t addSecond = NUM_DOCS - (NUM_DOCS_REMOVE * 2);\n+\n+    bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < addFirst; ++i) {\n+        nns.addDoc(i);\n+    }\n+    aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index with %u docs: %.3f ms\\n\", name, addFirst, to_ms(aft - bef));\n+\n+    bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.addDoc(EFFECTIVE_DOCS + i);\n+        nns.addDoc(addFirst + i);\n+    }\n+    aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index added %u docs: %.3f ms\\n\",\n+            name, 2 * NUM_DOCS_REMOVE, to_ms(aft - bef));\n+\n+    bef = std::chrono::steady_clock::now();\n+    for (uint32_t i = 0; i < NUM_DOCS_REMOVE; ++i) {\n+        nns.removeDoc(EFFECTIVE_DOCS + i);\n+        nns.addDoc(addSecond + i);\n+    }\n+    aft = std::chrono::steady_clock::now();\n+    fprintf(stderr, \"build %s index added %u and removed %u docs: %.3f ms\\n\",\n+            name, NUM_DOCS_REMOVE, NUM_DOCS_REMOVE, to_ms(aft - bef));\n+\n+    timing_nns(name, nns, sk_list);\n+    fprintf(stderr, \"Quality for %s with %u documents some churn:\\n\", name, EFFECTIVE_DOCS);\n+    quality_nns(nns, sk_list);\n+\n+#endif\n+\n+#if 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55728e48cd1f1cda6aadd8afb76f532b4174c7e"}, "originalPosition": 441}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODAyNjAyOnYy", "diffSide": "RIGHT", "path": "eval/src/tests/ann/remove-bm.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMzoyMDoyMFrOFm8usg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMzoyMDoyMFrOFm8usg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjM4NTIwMg==", "bodyText": "Ideally we should move utils used by this and sift_benchmark.cpp to a common place. The same applies for read_docs(), to_ms(), read_data(), BfHitComparator, BfHitHeap, bruteforce_nns(), verifyBF(), etc. But that we can address in a future PR.", "url": "https://github.com/vespa-engine/vespa/pull/12113#discussion_r376385202", "createdAt": "2020-02-07T13:20:20Z", "author": {"login": "geirst"}, "path": "eval/src/tests/ann/remove-bm.cpp", "diffHunk": "@@ -0,0 +1,514 @@\n+// Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/test_kit.h>\n+#include <vespa/vespalib/util/priority_queue.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <chrono>\n+\n+#define NUM_DIMS 960\n+#define NUM_DOCS 250000\n+#define NUM_DOCS_REMOVE 50000\n+#define EFFECTIVE_DOCS (NUM_DOCS - NUM_DOCS_REMOVE)\n+#define NUM_Q 1000\n+\n+#include \"doc_vector_access.h\"\n+#include \"nns.h\"\n+#include \"for-sift-hit.h\"\n+#include \"for-sift-top-k.h\"\n+\n+std::vector<TopK> bruteforceResults;\n+std::vector<float> tmp_v(NUM_DIMS);\n+\n+struct PointVector {\n+    float v[NUM_DIMS];\n+    using ConstArr = vespalib::ConstArrayRef<float>;\n+    operator ConstArr() const { return ConstArr(v, NUM_DIMS); }\n+};\n+\n+static PointVector *aligned_alloc(size_t num) {\n+    size_t num_bytes = num * sizeof(PointVector);\n+    double mega_bytes = num_bytes / (1024.0*1024.0);\n+    fprintf(stderr, \"allocate %.2f MB of vectors\\n\", mega_bytes);\n+    char *mem = (char *)malloc(num_bytes + 512);\n+    mem += 512;\n+    size_t val = (size_t)mem;\n+    size_t unalign = val % 512;\n+    mem -= unalign;\n+    return (PointVector *)mem;\n+}\n+\n+static PointVector *generatedQueries = aligned_alloc(NUM_Q);\n+static PointVector *generatedDocs = aligned_alloc(NUM_DOCS);\n+\n+struct DocVectorAdapter : public DocVectorAccess<float>\n+{\n+    vespalib::ConstArrayRef<float> get(uint32_t docid) const override {\n+        ASSERT_TRUE(docid < NUM_DOCS);\n+        return generatedDocs[docid];\n+    }\n+};\n+\n+double computeDistance(const PointVector &query, uint32_t docid) {\n+    const PointVector &docvector = generatedDocs[docid];\n+    return l2distCalc.l2sq_dist(query, docvector, tmp_v);\n+}\n+\n+void read_queries(std::string fn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e55728e48cd1f1cda6aadd8afb76f532b4174c7e"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2457, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}