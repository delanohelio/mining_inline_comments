{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyMzkyMzYw", "number": 14528, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjo0MDowMVrOEnBgcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMToyMzowN1rOEoCOwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzU0NjExOnYy", "diffSide": "RIGHT", "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/ThreadLockInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjo0MDowMVrOHXYrYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMzowMjoxMFrOHXZjdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4MzYxOA==", "bodyText": "Is this done to track the re-entry count?", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r494283618", "createdAt": "2020-09-24T12:40:01Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/ThreadLockInfo.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.curator;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+\n+/**\n+ * This class contains process-wide statistics and information related to acquiring and releasing\n+ * {@link Lock}.  Instances of this class contain information tied to a specific thread and lock path.\n+ *\n+ * <p>Instances of this class are thread-safe as long as foreign threads (!= this.thread) avoid mutable methods.</p>\n+ */\n+public class ThreadLockInfo {\n+\n+    private static final ConcurrentHashMap<Thread, ThreadLockInfo> locks = new ConcurrentHashMap<>();\n+\n+    private static final int MAX_COMPLETED_LOCK_INFOS_SIZE = 10;\n+    private static final ConcurrentLinkedDeque<LockInfo> completedLockInfos = new ConcurrentLinkedDeque<>();\n+\n+    private static final AtomicInteger invokeAcquireCount = new AtomicInteger(0);\n+    private static final AtomicInteger inCriticalRegionCount = new AtomicInteger(0);\n+    private static final AtomicInteger acquireTimedOutCount = new AtomicInteger(0);\n+    private static final AtomicInteger lockAcquiredCount = new AtomicInteger(0);\n+    private static final AtomicInteger locksReleasedCount = new AtomicInteger(0);\n+\n+    private static final AtomicInteger failedToAcquireReentrantLockCount = new AtomicInteger(0);\n+    private static final AtomicInteger noLocksErrorCount = new AtomicInteger(0);\n+    private static final AtomicInteger timeoutOnReentrancyErrorCount = new AtomicInteger(0);\n+\n+    private final Thread thread;\n+    private final String lockPath;\n+    private final ReentrantLock lock;\n+\n+    /** The locks are reentrant so there may be more than 1 lock for this thread. */\n+    private final ConcurrentLinkedQueue<LockInfo> lockInfos = new ConcurrentLinkedQueue<>();\n+\n+    public static int invokeAcquireCount() { return invokeAcquireCount.get(); }\n+    public static int inCriticalRegionCount() { return inCriticalRegionCount.get(); }\n+    public static int acquireTimedOutCount() { return acquireTimedOutCount.get(); }\n+    public static int lockAcquiredCount() { return lockAcquiredCount.get(); }\n+    public static int locksReleasedCount() { return locksReleasedCount.get(); }\n+    public static int noLocksErrorCount() { return noLocksErrorCount.get(); }\n+    public static int failedToAcquireReentrantLockCount() { return failedToAcquireReentrantLockCount.get(); }\n+    public static int timeoutOnReentrancyErrorCount() { return timeoutOnReentrancyErrorCount.get(); }\n+    public static List<ThreadLockInfo> getThreadLockInfos() { return List.copyOf(locks.values()); }\n+\n+    /** Returns the per-thread singleton ThreadLockInfo. */\n+    static ThreadLockInfo getCurrentThreadLockInfo(String lockPath, ReentrantLock lock) {\n+        return locks.computeIfAbsent(\n+                Thread.currentThread(),\n+                currentThread -> new ThreadLockInfo(currentThread, lockPath, lock));\n+    }\n+\n+    ThreadLockInfo(Thread currentThread, String lockPath, ReentrantLock lock) {\n+        this.thread = currentThread;\n+        this.lockPath = lockPath;\n+        this.lock = lock;\n+    }\n+\n+    public String getThreadName() { return thread.getName(); }\n+    public String getLockPath() { return lockPath; }\n+    public List<LockInfo> getLockInfos() { return List.copyOf(lockInfos); }\n+\n+    /** Mutable method (see class doc) */\n+    void invokingAcquire(Duration timeout) {\n+        invokeAcquireCount.incrementAndGet();\n+        inCriticalRegionCount.incrementAndGet();\n+        lockInfos.add(LockInfo.invokingAcquire(lock.getHoldCount(), timeout));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "069716d610dbea6fa58e009cac8c5495c5e7d06d"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5Nzk3Mw==", "bodyText": "The getHoldCount() ? Yes - just to sanity-check it", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r494297973", "createdAt": "2020-09-24T13:02:10Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/ThreadLockInfo.java", "diffHunk": "@@ -0,0 +1,125 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.curator;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+\n+/**\n+ * This class contains process-wide statistics and information related to acquiring and releasing\n+ * {@link Lock}.  Instances of this class contain information tied to a specific thread and lock path.\n+ *\n+ * <p>Instances of this class are thread-safe as long as foreign threads (!= this.thread) avoid mutable methods.</p>\n+ */\n+public class ThreadLockInfo {\n+\n+    private static final ConcurrentHashMap<Thread, ThreadLockInfo> locks = new ConcurrentHashMap<>();\n+\n+    private static final int MAX_COMPLETED_LOCK_INFOS_SIZE = 10;\n+    private static final ConcurrentLinkedDeque<LockInfo> completedLockInfos = new ConcurrentLinkedDeque<>();\n+\n+    private static final AtomicInteger invokeAcquireCount = new AtomicInteger(0);\n+    private static final AtomicInteger inCriticalRegionCount = new AtomicInteger(0);\n+    private static final AtomicInteger acquireTimedOutCount = new AtomicInteger(0);\n+    private static final AtomicInteger lockAcquiredCount = new AtomicInteger(0);\n+    private static final AtomicInteger locksReleasedCount = new AtomicInteger(0);\n+\n+    private static final AtomicInteger failedToAcquireReentrantLockCount = new AtomicInteger(0);\n+    private static final AtomicInteger noLocksErrorCount = new AtomicInteger(0);\n+    private static final AtomicInteger timeoutOnReentrancyErrorCount = new AtomicInteger(0);\n+\n+    private final Thread thread;\n+    private final String lockPath;\n+    private final ReentrantLock lock;\n+\n+    /** The locks are reentrant so there may be more than 1 lock for this thread. */\n+    private final ConcurrentLinkedQueue<LockInfo> lockInfos = new ConcurrentLinkedQueue<>();\n+\n+    public static int invokeAcquireCount() { return invokeAcquireCount.get(); }\n+    public static int inCriticalRegionCount() { return inCriticalRegionCount.get(); }\n+    public static int acquireTimedOutCount() { return acquireTimedOutCount.get(); }\n+    public static int lockAcquiredCount() { return lockAcquiredCount.get(); }\n+    public static int locksReleasedCount() { return locksReleasedCount.get(); }\n+    public static int noLocksErrorCount() { return noLocksErrorCount.get(); }\n+    public static int failedToAcquireReentrantLockCount() { return failedToAcquireReentrantLockCount.get(); }\n+    public static int timeoutOnReentrancyErrorCount() { return timeoutOnReentrancyErrorCount.get(); }\n+    public static List<ThreadLockInfo> getThreadLockInfos() { return List.copyOf(locks.values()); }\n+\n+    /** Returns the per-thread singleton ThreadLockInfo. */\n+    static ThreadLockInfo getCurrentThreadLockInfo(String lockPath, ReentrantLock lock) {\n+        return locks.computeIfAbsent(\n+                Thread.currentThread(),\n+                currentThread -> new ThreadLockInfo(currentThread, lockPath, lock));\n+    }\n+\n+    ThreadLockInfo(Thread currentThread, String lockPath, ReentrantLock lock) {\n+        this.thread = currentThread;\n+        this.lockPath = lockPath;\n+        this.lock = lock;\n+    }\n+\n+    public String getThreadName() { return thread.getName(); }\n+    public String getLockPath() { return lockPath; }\n+    public List<LockInfo> getLockInfos() { return List.copyOf(lockInfos); }\n+\n+    /** Mutable method (see class doc) */\n+    void invokingAcquire(Duration timeout) {\n+        invokeAcquireCount.incrementAndGet();\n+        inCriticalRegionCount.incrementAndGet();\n+        lockInfos.add(LockInfo.invokingAcquire(lock.getHoldCount(), timeout));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4MzYxOA=="}, "originalCommit": {"oid": "069716d610dbea6fa58e009cac8c5495c5e7d06d"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzU2NzkzOnYy", "diffSide": "RIGHT", "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/LockInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjo0NTo1MVrOHXY49Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMzowNTo0N1rOHXZsPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4NzA5Mw==", "bodyText": "Maybe LockMetrics is a better name for this?", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r494287093", "createdAt": "2020-09-24T12:45:51Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/LockInfo.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.curator;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+/**\n+ * Information about a lock.\n+ *\n+ * <p>Should be mutated by a single thread.  Other threads may see an inconsistent state of this instance.</p>\n+ */\n+public class LockInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "069716d610dbea6fa58e009cac8c5495c5e7d06d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwMDIyMQ==", "bodyText": "Hm, adding a LockCounters now with all the AtomicIntegers - hold on to this thought until you see that: Perhaps that should be called LockMetrics?  Although we are also adding metrics later, and those classes tend to be named *Metrics.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r494300221", "createdAt": "2020-09-24T13:05:47Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/LockInfo.java", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.curator;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+/**\n+ * Information about a lock.\n+ *\n+ * <p>Should be mutated by a single thread.  Other threads may see an inconsistent state of this instance.</p>\n+ */\n+public class LockInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4NzA5Mw=="}, "originalCommit": {"oid": "069716d610dbea6fa58e009cac8c5495c5e7d06d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzYxNDY2OnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/restapi/LocksResponse.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjo1NjoyMFrOHXZUtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMzowNzo1NFrOHXZx4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5NDE5OA==", "bodyText": "Missing author/javadoc. Applies to some of the other classes as well.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r494294198", "createdAt": "2020-09-24T12:56:20Z", "author": {"login": "mpolden"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/restapi/LocksResponse.java", "diffHunk": "@@ -0,0 +1,73 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.restapi;\n+\n+import com.yahoo.container.jdisc.HttpResponse;\n+import com.yahoo.slime.Cursor;\n+import com.yahoo.slime.JsonFormat;\n+import com.yahoo.slime.Slime;\n+import com.yahoo.vespa.curator.LockInfo;\n+import com.yahoo.vespa.curator.ThreadLockInfo;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.time.Instant;\n+import java.util.List;\n+\n+public class LocksResponse extends HttpResponse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "069716d610dbea6fa58e009cac8c5495c5e7d06d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwMTY2NQ==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r494301665", "createdAt": "2020-09-24T13:07:54Z", "author": {"login": "hakonhall"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/restapi/LocksResponse.java", "diffHunk": "@@ -0,0 +1,73 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.hosted.provision.restapi;\n+\n+import com.yahoo.container.jdisc.HttpResponse;\n+import com.yahoo.slime.Cursor;\n+import com.yahoo.slime.JsonFormat;\n+import com.yahoo.slime.Slime;\n+import com.yahoo.vespa.curator.LockInfo;\n+import com.yahoo.vespa.curator.ThreadLockInfo;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.time.Instant;\n+import java.util.List;\n+\n+public class LocksResponse extends HttpResponse {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5NDE5OA=="}, "originalCommit": {"oid": "069716d610dbea6fa58e009cac8c5495c5e7d06d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzYxNjg5OnYy", "diffSide": "RIGHT", "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjo1Njo1NVrOHXZWKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMzowNjoyOVrOHXZuDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5NDU3MA==", "bodyText": "Unintentional reformatting?", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r494294570", "createdAt": "2020-09-24T12:56:55Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -32,12 +32,20 @@ public Lock(String lockPath, Curator curator) {\n \n     /** Take the lock with the given timeout. This may be called multiple times from the same thread - each matched by a close */\n     public void acquire(Duration timeout) throws UncheckedTimeoutException {\n+        ThreadLockInfo threadLockInfo = getThreadLockInfo();\n+        threadLockInfo.invokingAcquire(timeout);\n         try {\n-            if ( ! mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS))\n+            if ( ! mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n+                threadLockInfo.acquireTimedOut();\n+\n                 throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n-                                                    \" to acquire lock '\" + lockPath + \"'\");\n+                        \" to acquire lock '\" + lockPath + \"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "069716d610dbea6fa58e009cac8c5495c5e7d06d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwMDY4Nw==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r494300687", "createdAt": "2020-09-24T13:06:29Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -32,12 +32,20 @@ public Lock(String lockPath, Curator curator) {\n \n     /** Take the lock with the given timeout. This may be called multiple times from the same thread - each matched by a close */\n     public void acquire(Duration timeout) throws UncheckedTimeoutException {\n+        ThreadLockInfo threadLockInfo = getThreadLockInfo();\n+        threadLockInfo.invokingAcquire(timeout);\n         try {\n-            if ( ! mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS))\n+            if ( ! mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n+                threadLockInfo.acquireTimedOut();\n+\n                 throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n-                                                    \" to acquire lock '\" + lockPath + \"'\");\n+                        \" to acquire lock '\" + lockPath + \"'\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5NDU3MA=="}, "originalCommit": {"oid": "069716d610dbea6fa58e009cac8c5495c5e7d06d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDA3NzkxOnYy", "diffSide": "LEFT", "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMDo1OTo1NlrOHY4pdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoyNDo0NVrOHZIdxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NTk5MQ==", "bodyText": "Did it became redundant now or has it always been?", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495855991", "createdAt": "2020-09-28T10:59:56Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -21,51 +20,38 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "afbbe9c191ebdaf9ab8d84c727d53825f69fe64f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3MzQxMA==", "bodyText": "It was added by @jonmv in the hope it would catch issue with orphaned lock, but it has never been able to catch the problem and complicates the code as I was adding more instrumentation.  Discussed offline with Jon Marius.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495873410", "createdAt": "2020-09-28T11:35:51Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -21,51 +20,38 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NTk5MQ=="}, "originalCommit": {"oid": "afbbe9c191ebdaf9ab8d84c727d53825f69fe64f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwNjI1Mw==", "bodyText": "It did trigger a few times, but this really only verified something we already suspected \u2014\u00a0that the same Curator lock may be held by several parties simultaneously as a result of connection issues, etc..", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r496106253", "createdAt": "2020-09-28T17:08:48Z", "author": {"login": "jonmv"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -21,51 +20,38 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NTk5MQ=="}, "originalCommit": {"oid": "afbbe9c191ebdaf9ab8d84c727d53825f69fe64f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwNjUyMw==", "bodyText": "(It also would prevent this intra-JVM, of course, but not inter-JVM.)", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r496106523", "createdAt": "2020-09-28T17:09:16Z", "author": {"login": "jonmv"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -21,51 +20,38 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NTk5MQ=="}, "originalCommit": {"oid": "afbbe9c191ebdaf9ab8d84c727d53825f69fe64f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExNTE0MQ==", "bodyText": "AFAIK lock.tryLock() can only return false after a successful InterProcessMutex.acquire() if there is a ZK connection loss between two acquire(), and the respective threads would then both appear to have the lock.  I didn't know that was observed.  But yeah, the reentrant lock would only guard intra-JVM.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r496115141", "createdAt": "2020-09-28T17:24:45Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -21,51 +20,38 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NTk5MQ=="}, "originalCommit": {"oid": "afbbe9c191ebdaf9ab8d84c727d53825f69fe64f"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDA4MDc3OnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/restapi/NodesV2ApiHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTowMDo1NlrOHY4rPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTozNzoxOFrOHY5wBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NjQ0NQ==", "bodyText": "Fine for now, but I think we should extract this into a top-level /debug/ API if we intend to keep it.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495856445", "createdAt": "2020-09-28T11:00:56Z", "author": {"login": "mpolden"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/restapi/NodesV2ApiHandler.java", "diffHunk": "@@ -116,6 +116,7 @@ private HttpResponse handleGET(HttpRequest request) {\n         if (pathS.startsWith(\"/nodes/v2/state/\")) return new NodesResponse(ResponseType.nodesInStateList, request, orchestrator, nodeRepository);\n         if (pathS.startsWith(\"/nodes/v2/acl/\")) return new NodeAclResponse(request, nodeRepository);\n         if (pathS.equals(    \"/nodes/v2/command/\")) return new ResourceResponse(request.getUri(), \"restart\", \"reboot\");\n+        if (pathS.equals(    \"/nodes/v2/locks\")) return new LocksResponse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3NDA1NQ==", "bodyText": "+1", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495874055", "createdAt": "2020-09-28T11:37:18Z", "author": {"login": "hakonhall"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/restapi/NodesV2ApiHandler.java", "diffHunk": "@@ -116,6 +116,7 @@ private HttpResponse handleGET(HttpRequest request) {\n         if (pathS.startsWith(\"/nodes/v2/state/\")) return new NodesResponse(ResponseType.nodesInStateList, request, orchestrator, nodeRepository);\n         if (pathS.startsWith(\"/nodes/v2/acl/\")) return new NodeAclResponse(request, nodeRepository);\n         if (pathS.equals(    \"/nodes/v2/command/\")) return new ResourceResponse(request.getUri(), \"restart\", \"reboot\");\n+        if (pathS.equals(    \"/nodes/v2/locks\")) return new LocksResponse();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NjQ0NQ=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDA5NTk3OnYy", "diffSide": "RIGHT", "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockInfoSamplesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTowNTo0OVrOHY40cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTozNzowN1rOHY5vsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1ODgwMA==", "bodyText": "Bug in test template? Copyright should be on first line.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495858800", "createdAt": "2020-09-28T11:05:49Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockInfoSamplesTest.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package com.yahoo.vespa.curator.stats;// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3Mzk2OA==", "bodyText": "Bug in IntelliJ/have never been able to figure it out.  Fixed.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495873968", "createdAt": "2020-09-28T11:37:07Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockInfoSamplesTest.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package com.yahoo.vespa.curator.stats;// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1ODgwMA=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDA5ODYwOnYy", "diffSide": "RIGHT", "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTowNjo0NFrOHY42HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTozNzo0MFrOHY5wuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1OTIyOA==", "bodyText": "Same as above.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495859228", "createdAt": "2020-09-28T11:06:44Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package com.yahoo.vespa.curator.stats;// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3NDIzMg==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495874232", "createdAt": "2020-09-28T11:37:40Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package com.yahoo.vespa.curator.stats;// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1OTIyOA=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDEwMTUyOnYy", "diffSide": "RIGHT", "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockInfoSamplesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTowNzo0M1rOHY431Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTozODowNlrOHY5xcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1OTY2OQ==", "bodyText": "Missing @author.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495859669", "createdAt": "2020-09-28T11:07:43Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockInfoSamplesTest.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package com.yahoo.vespa.curator.stats;// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class LockInfoSamplesTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3NDQxNg==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495874416", "createdAt": "2020-09-28T11:38:06Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockInfoSamplesTest.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package com.yahoo.vespa.curator.stats;// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class LockInfoSamplesTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1OTY2OQ=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDEwMTgyOnYy", "diffSide": "RIGHT", "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTowNzo1MFrOHY44Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTozODoxMlrOHY5xnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1OTcxOA==", "bodyText": "Same as above.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495859718", "createdAt": "2020-09-28T11:07:50Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package com.yahoo.vespa.curator.stats;// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+import com.yahoo.vespa.curator.Lock;\n+import org.apache.curator.framework.recipes.locks.InterProcessLock;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class LockTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3NDQ2Mw==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495874463", "createdAt": "2020-09-28T11:38:12Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/test/java/com/yahoo/vespa/curator/stats/LockTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package com.yahoo.vespa.curator.stats;// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+import com.yahoo.vespa.curator.Lock;\n+import org.apache.curator.framework.recipes.locks.InterProcessLock;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class LockTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1OTcxOA=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDEzNzg0OnYy", "diffSide": "RIGHT", "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/stats/LockInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMToxOToyNVrOHY5N2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTo0MToxN1rOHY53WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NTMwNw==", "bodyText": "How about LockAttempt? Info is very generic.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495865307", "createdAt": "2020-09-28T11:19:25Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/stats/LockInfo.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.curator.stats;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+/**\n+ * Information about a lock.\n+ *\n+ * <p>Should be mutated by a single thread, except {@link #fillStackTrace()} which can be\n+ * invoked by any threads.  Other threads may see an inconsistent state of this instance.</p>\n+ *\n+ * @author hakon\n+ */\n+public class LockInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3NTkyOA==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495875928", "createdAt": "2020-09-28T11:41:17Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/stats/LockInfo.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.curator.stats;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+/**\n+ * Information about a lock.\n+ *\n+ * <p>Should be mutated by a single thread, except {@link #fillStackTrace()} which can be\n+ * invoked by any threads.  Other threads may see an inconsistent state of this instance.</p>\n+ *\n+ * @author hakon\n+ */\n+public class LockInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NTMwNw=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDE0MTcwOnYy", "diffSide": "RIGHT", "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/stats/ThreadLockInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMToyMDozNlrOHY5QNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMTozOToxOFrOHY5zhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NTkwOA==", "bodyText": "ThreadLockStats? Matches the javadoc.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495865908", "createdAt": "2020-09-28T11:20:36Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/stats/ThreadLockInfo.java", "diffHunk": "@@ -0,0 +1,139 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.curator.stats;\n+\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.function.Consumer;\n+\n+/**\n+ * This class contains process-wide statistics and information related to acquiring and releasing\n+ * {@link Lock}.  Instances of this class contain information tied to a specific thread and lock path.\n+ *\n+ * <p>Instances of this class are thread-safe as long as foreign threads (!= this.thread) avoid mutable methods.</p>\n+ *\n+ * @author hakon\n+ */\n+public class ThreadLockInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3NDk0OQ==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495874949", "createdAt": "2020-09-28T11:39:18Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/stats/ThreadLockInfo.java", "diffHunk": "@@ -0,0 +1,139 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.curator.stats;\n+\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.function.Consumer;\n+\n+/**\n+ * This class contains process-wide statistics and information related to acquiring and releasing\n+ * {@link Lock}.  Instances of this class contain information tied to a specific thread and lock path.\n+ *\n+ * <p>Instances of this class are thread-safe as long as foreign threads (!= this.thread) avoid mutable methods.</p>\n+ *\n+ * @author hakon\n+ */\n+public class ThreadLockInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NTkwOA=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDE1MDQwOnYy", "diffSide": "RIGHT", "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMToyMzowN1rOHY5VUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMjoyMDo1OFrOHY7FXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NzIxNg==", "bodyText": "Shouldn't this happen after the mutex.release() below?", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495867216", "createdAt": "2020-09-28T11:23:07Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -20,54 +20,50 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n+        this(lockPath, curator.createMutex(lockPath));\n+    }\n+\n+    /** Public for testing only */\n+    public Lock(String lockPath, InterProcessLock mutex) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);\n-        mutex = curator.createMutex(lockPath);\n+        this.mutex = mutex;\n     }\n \n     /** Take the lock with the given timeout. This may be called multiple times from the same thread - each matched by a close */\n     public void acquire(Duration timeout) throws UncheckedTimeoutException {\n+        ThreadLockInfo threadLockInfo = ThreadLockInfo.getCurrentThreadLockInfo();\n+        threadLockInfo.invokingAcquire(lockPath, timeout);\n+\n+        final boolean acquired;\n         try {\n-            if ( ! mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS))\n-                throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n-                                                    \" to acquire lock '\" + lockPath + \"'\");\n-            if ( ! lock.tryLock()) { // Should be available to only this thread, while holding the above mutex.\n-                release();\n-                throw new IllegalStateException(\"InterProcessMutex acquired, but guarded lock held by someone else, for lock '\" + lockPath + \"'\");\n-            }\n-        }\n-        catch (UncheckedTimeoutException | IllegalStateException e) {\n-            throw e;\n-        }\n-        catch (Exception e) {\n+            acquired = mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS);\n+        } catch (Exception e) {\n+            threadLockInfo.acquireFailed(lockPath);\n             throw new RuntimeException(\"Exception acquiring lock '\" + lockPath + \"'\", e);\n         }\n-    }\n \n-    @Override\n-    public void close() {\n-        try {\n-            lock.unlock();\n-        }\n-        finally {\n-            release();\n+        if (!acquired) {\n+            threadLockInfo.acquireTimedOut(lockPath);\n+            throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n+                    \" to acquire lock '\" + lockPath + \"'\");\n         }\n+        threadLockInfo.lockAcquired(lockPath);\n     }\n \n-    private void release() {\n+    @Override\n+    public void close() {\n+        ThreadLockInfo.getCurrentThreadLockInfo().lockReleased(lockPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg3Nzk1OA==", "bodyText": "To get any Instant.now() to include the time in release?", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495877958", "createdAt": "2020-09-28T11:45:31Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -20,54 +20,50 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n+        this(lockPath, curator.createMutex(lockPath));\n+    }\n+\n+    /** Public for testing only */\n+    public Lock(String lockPath, InterProcessLock mutex) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);\n-        mutex = curator.createMutex(lockPath);\n+        this.mutex = mutex;\n     }\n \n     /** Take the lock with the given timeout. This may be called multiple times from the same thread - each matched by a close */\n     public void acquire(Duration timeout) throws UncheckedTimeoutException {\n+        ThreadLockInfo threadLockInfo = ThreadLockInfo.getCurrentThreadLockInfo();\n+        threadLockInfo.invokingAcquire(lockPath, timeout);\n+\n+        final boolean acquired;\n         try {\n-            if ( ! mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS))\n-                throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n-                                                    \" to acquire lock '\" + lockPath + \"'\");\n-            if ( ! lock.tryLock()) { // Should be available to only this thread, while holding the above mutex.\n-                release();\n-                throw new IllegalStateException(\"InterProcessMutex acquired, but guarded lock held by someone else, for lock '\" + lockPath + \"'\");\n-            }\n-        }\n-        catch (UncheckedTimeoutException | IllegalStateException e) {\n-            throw e;\n-        }\n-        catch (Exception e) {\n+            acquired = mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS);\n+        } catch (Exception e) {\n+            threadLockInfo.acquireFailed(lockPath);\n             throw new RuntimeException(\"Exception acquiring lock '\" + lockPath + \"'\", e);\n         }\n-    }\n \n-    @Override\n-    public void close() {\n-        try {\n-            lock.unlock();\n-        }\n-        finally {\n-            release();\n+        if (!acquired) {\n+            threadLockInfo.acquireTimedOut(lockPath);\n+            throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n+                    \" to acquire lock '\" + lockPath + \"'\");\n         }\n+        threadLockInfo.lockAcquired(lockPath);\n     }\n \n-    private void release() {\n+    @Override\n+    public void close() {\n+        ThreadLockInfo.getCurrentThreadLockInfo().lockReleased(lockPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NzIxNg=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MTQzMA==", "bodyText": "No, currently if mutex.release() fails  you will still have tagged it as released in ThreadLockInfo.", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495881430", "createdAt": "2020-09-28T11:52:32Z", "author": {"login": "mpolden"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -20,54 +20,50 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n+        this(lockPath, curator.createMutex(lockPath));\n+    }\n+\n+    /** Public for testing only */\n+    public Lock(String lockPath, InterProcessLock mutex) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);\n-        mutex = curator.createMutex(lockPath);\n+        this.mutex = mutex;\n     }\n \n     /** Take the lock with the given timeout. This may be called multiple times from the same thread - each matched by a close */\n     public void acquire(Duration timeout) throws UncheckedTimeoutException {\n+        ThreadLockInfo threadLockInfo = ThreadLockInfo.getCurrentThreadLockInfo();\n+        threadLockInfo.invokingAcquire(lockPath, timeout);\n+\n+        final boolean acquired;\n         try {\n-            if ( ! mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS))\n-                throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n-                                                    \" to acquire lock '\" + lockPath + \"'\");\n-            if ( ! lock.tryLock()) { // Should be available to only this thread, while holding the above mutex.\n-                release();\n-                throw new IllegalStateException(\"InterProcessMutex acquired, but guarded lock held by someone else, for lock '\" + lockPath + \"'\");\n-            }\n-        }\n-        catch (UncheckedTimeoutException | IllegalStateException e) {\n-            throw e;\n-        }\n-        catch (Exception e) {\n+            acquired = mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS);\n+        } catch (Exception e) {\n+            threadLockInfo.acquireFailed(lockPath);\n             throw new RuntimeException(\"Exception acquiring lock '\" + lockPath + \"'\", e);\n         }\n-    }\n \n-    @Override\n-    public void close() {\n-        try {\n-            lock.unlock();\n-        }\n-        finally {\n-            release();\n+        if (!acquired) {\n+            threadLockInfo.acquireTimedOut(lockPath);\n+            throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n+                    \" to acquire lock '\" + lockPath + \"'\");\n         }\n+        threadLockInfo.lockAcquired(lockPath);\n     }\n \n-    private void release() {\n+    @Override\n+    public void close() {\n+        ThreadLockInfo.getCurrentThreadLockInfo().lockReleased(lockPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NzIxNg=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4MzAyMA==", "bodyText": "I could count an error, but the lock must be assumed to be released whether an exception is thrown or not", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495883020", "createdAt": "2020-09-28T11:55:55Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -20,54 +20,50 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n+        this(lockPath, curator.createMutex(lockPath));\n+    }\n+\n+    /** Public for testing only */\n+    public Lock(String lockPath, InterProcessLock mutex) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);\n-        mutex = curator.createMutex(lockPath);\n+        this.mutex = mutex;\n     }\n \n     /** Take the lock with the given timeout. This may be called multiple times from the same thread - each matched by a close */\n     public void acquire(Duration timeout) throws UncheckedTimeoutException {\n+        ThreadLockInfo threadLockInfo = ThreadLockInfo.getCurrentThreadLockInfo();\n+        threadLockInfo.invokingAcquire(lockPath, timeout);\n+\n+        final boolean acquired;\n         try {\n-            if ( ! mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS))\n-                throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n-                                                    \" to acquire lock '\" + lockPath + \"'\");\n-            if ( ! lock.tryLock()) { // Should be available to only this thread, while holding the above mutex.\n-                release();\n-                throw new IllegalStateException(\"InterProcessMutex acquired, but guarded lock held by someone else, for lock '\" + lockPath + \"'\");\n-            }\n-        }\n-        catch (UncheckedTimeoutException | IllegalStateException e) {\n-            throw e;\n-        }\n-        catch (Exception e) {\n+            acquired = mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS);\n+        } catch (Exception e) {\n+            threadLockInfo.acquireFailed(lockPath);\n             throw new RuntimeException(\"Exception acquiring lock '\" + lockPath + \"'\", e);\n         }\n-    }\n \n-    @Override\n-    public void close() {\n-        try {\n-            lock.unlock();\n-        }\n-        finally {\n-            release();\n+        if (!acquired) {\n+            threadLockInfo.acquireTimedOut(lockPath);\n+            throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n+                    \" to acquire lock '\" + lockPath + \"'\");\n         }\n+        threadLockInfo.lockAcquired(lockPath);\n     }\n \n-    private void release() {\n+    @Override\n+    public void close() {\n+        ThreadLockInfo.getCurrentThreadLockInfo().lockReleased(lockPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NzIxNg=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5NTkwMA==", "bodyText": "Added count", "url": "https://github.com/vespa-engine/vespa/pull/14528#discussion_r495895900", "createdAt": "2020-09-28T12:20:58Z", "author": {"login": "hakonhall"}, "path": "zkfacade/src/main/java/com/yahoo/vespa/curator/Lock.java", "diffHunk": "@@ -20,54 +20,50 @@\n  */\n public class Lock implements Mutex {\n \n-    private final ReentrantLock lock;\n     private final InterProcessLock mutex;\n     private final String lockPath;\n \n     public Lock(String lockPath, Curator curator) {\n+        this(lockPath, curator.createMutex(lockPath));\n+    }\n+\n+    /** Public for testing only */\n+    public Lock(String lockPath, InterProcessLock mutex) {\n         this.lockPath = lockPath;\n-        this.lock = new ReentrantLock(true);\n-        mutex = curator.createMutex(lockPath);\n+        this.mutex = mutex;\n     }\n \n     /** Take the lock with the given timeout. This may be called multiple times from the same thread - each matched by a close */\n     public void acquire(Duration timeout) throws UncheckedTimeoutException {\n+        ThreadLockInfo threadLockInfo = ThreadLockInfo.getCurrentThreadLockInfo();\n+        threadLockInfo.invokingAcquire(lockPath, timeout);\n+\n+        final boolean acquired;\n         try {\n-            if ( ! mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS))\n-                throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n-                                                    \" to acquire lock '\" + lockPath + \"'\");\n-            if ( ! lock.tryLock()) { // Should be available to only this thread, while holding the above mutex.\n-                release();\n-                throw new IllegalStateException(\"InterProcessMutex acquired, but guarded lock held by someone else, for lock '\" + lockPath + \"'\");\n-            }\n-        }\n-        catch (UncheckedTimeoutException | IllegalStateException e) {\n-            throw e;\n-        }\n-        catch (Exception e) {\n+            acquired = mutex.acquire(timeout.toMillis(), TimeUnit.MILLISECONDS);\n+        } catch (Exception e) {\n+            threadLockInfo.acquireFailed(lockPath);\n             throw new RuntimeException(\"Exception acquiring lock '\" + lockPath + \"'\", e);\n         }\n-    }\n \n-    @Override\n-    public void close() {\n-        try {\n-            lock.unlock();\n-        }\n-        finally {\n-            release();\n+        if (!acquired) {\n+            threadLockInfo.acquireTimedOut(lockPath);\n+            throw new UncheckedTimeoutException(\"Timed out after waiting \" + timeout +\n+                    \" to acquire lock '\" + lockPath + \"'\");\n         }\n+        threadLockInfo.lockAcquired(lockPath);\n     }\n \n-    private void release() {\n+    @Override\n+    public void close() {\n+        ThreadLockInfo.getCurrentThreadLockInfo().lockReleased(lockPath);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NzIxNg=="}, "originalCommit": {"oid": "6e284ef06a2e6dafbaeae8e486b6f68fa53d5d48"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1308, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}