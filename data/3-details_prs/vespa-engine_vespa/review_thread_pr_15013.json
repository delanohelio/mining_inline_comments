{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4Mjk5OTMx", "number": 15013, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNTozMzoyNFrOEw0y2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNjoyMzo0NVrOEw2MYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NjMyMDg4OnYy", "diffSide": "RIGHT", "path": "config-provisioning/src/main/java/com/yahoo/config/provision/Provisioner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNTozMzoyNFrOHmnuYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNTozMzoyNFrOHmnuYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1ODc4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // TODO: Remove after November 2020", "url": "https://github.com/vespa-engine/vespa/pull/15013#discussion_r510258786", "createdAt": "2020-10-22T15:33:24Z", "author": {"login": "freva"}, "path": "config-provisioning/src/main/java/com/yahoo/config/provision/Provisioner.java", "diffHunk": "@@ -58,8 +62,13 @@\n      * @param transaction Transaction with operations to commit together with any operations done within the provisioner.\n      * @param lock        A provision lock for the relevant application. This must be held when calling this.\n      */\n+    // TODO: Remove after November 2020\n     void remove(NestedTransaction transaction, ProvisionLock lock);\n \n+    /** Transactionally remove an application under lock. */\n+    // TODO: Remove after November 2020", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe20011cf8d5c534eadc79cb5695915fbd9849d7"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NjU0MzQ4OnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/Activator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNjoyMjowNlrOHmp4ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNzowNzowOFrOHmrpSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NDIxMQ==", "bodyText": "Read this once from ZK?", "url": "https://github.com/vespa-engine/vespa/pull/15013#discussion_r510294211", "createdAt": "2020-10-22T16:22:06Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/Activator.java", "diffHunk": "@@ -53,41 +57,69 @@ public void activate(Collection<HostSpec> hosts, NestedTransaction transaction,\n      * Post condition: Nodes in reserved which are present in <code>hosts</code> are moved to active.\n      * Nodes in active which are not present in <code>hosts</code> are moved to inactive.\n      *\n-     * @param transaction Transaction with operations to commit together with any operations done within the repository.\n      * @param hosts the hosts to make the set of active nodes of this\n-     * @param lock provision lock that must be held when calling this\n+     * @param generation the application config generation that is activated\n+     * @param transaction transaction with operations to commit together with any operations done within the repository,\n+     *                    while holding the node repository lock on this application\n      */\n-    private void activateNodes(Collection<HostSpec> hosts, NestedTransaction transaction, ProvisionLock lock) {\n-        ApplicationId application = lock.application();\n+    private void activateNodes(Collection<HostSpec> hosts, long generation, ApplicationTransaction transaction) {\n+        ApplicationId application = transaction.application();\n         Set<String> hostnames = hosts.stream().map(HostSpec::hostname).collect(Collectors.toSet());\n         NodeList allNodes = nodeRepository.list();\n         NodeList applicationNodes = allNodes.owner(application);\n \n         List<Node> reserved = applicationNodes.state(Node.State.reserved).asList();\n-        List<Node> reservedToActivate = retainHostsInList(hostnames, reserved);\n-        List<Node> active = applicationNodes.state(Node.State.active).asList();\n-        List<Node> continuedActive = retainHostsInList(hostnames, active);\n-        List<Node> allActive = new ArrayList<>(continuedActive);\n-        allActive.addAll(reservedToActivate);\n-        if (!containsAll(hostnames, allActive))\n+        List<Node> reservedToActivate = updatePortsFrom(hosts, retainHostsInList(hostnames, reserved));\n+        List<Node> oldActive = applicationNodes.state(Node.State.active).asList(); // All nodes active now\n+        List<Node> continuedActive = retainHostsInList(hostnames, oldActive);\n+        List<Node> newActive = updateFrom(hosts, continuedActive); // All nodes that will be active when this is committed\n+        newActive.addAll(reservedToActivate);\n+        if ( ! containsAll(hostnames, newActive))\n             throw new IllegalArgumentException(\"Activation of \" + application + \" failed. \" +\n                                                \"Could not find all requested hosts.\" +\n                                                \"\\nRequested: \" + hosts +\n                                                \"\\nReserved: \" + toHostNames(reserved) +\n-                                               \"\\nActive: \" + toHostNames(active) +\n+                                               \"\\nActive: \" + toHostNames(oldActive) +\n                                                \"\\nThis might happen if the time from reserving host to activation takes \" +\n                                                \"longer time than reservation expiry (the hosts will then no longer be reserved)\");\n \n         validateParentHosts(application, allNodes, reservedToActivate);\n \n-        List<Node> activeToRemove = removeHostsFromList(hostnames, active);\n-        activeToRemove = activeToRemove.stream().map(Node::unretire).collect(Collectors.toList()); // only active nodes can be retired\n-        nodeRepository.deactivate(activeToRemove, transaction, lock);\n-        nodeRepository.activate(updateFrom(hosts, continuedActive), transaction); // update active with any changes\n-        nodeRepository.activate(updatePortsFrom(hosts, reservedToActivate), transaction);\n+        List<Node> activeToRemove = removeHostsFromList(hostnames, oldActive);\n+        activeToRemove = activeToRemove.stream().map(Node::unretire).collect(Collectors.toList()); // only active nodes can be retired. TODO: Move this line to deactivate\n+        nodeRepository.deactivate(activeToRemove, transaction);\n+        nodeRepository.activate(newActive, transaction.nested()); // activate also continued active to update node state\n+\n+        rememberResourceChange(transaction, generation,\n+                               NodeList.copyOf(oldActive).not().retired(),\n+                               NodeList.copyOf(newActive).not().retired());\n         unreserveParentsOf(reservedToActivate);\n     }\n \n+    private void rememberResourceChange(ApplicationTransaction transaction, long generation,\n+                                        NodeList oldNodes, NodeList newNodes) {\n+        if (nodeRepository.applications().get(transaction.application()).isEmpty()) return; // infrastructure app, hopefully\n+        Application application = nodeRepository.applications().get(transaction.application()).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe20011cf8d5c534eadc79cb5695915fbd9849d7"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMxNTU1NA==", "bodyText": "This is reading it once?", "url": "https://github.com/vespa-engine/vespa/pull/15013#discussion_r510315554", "createdAt": "2020-10-22T16:55:06Z", "author": {"login": "bratseth"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/Activator.java", "diffHunk": "@@ -53,41 +57,69 @@ public void activate(Collection<HostSpec> hosts, NestedTransaction transaction,\n      * Post condition: Nodes in reserved which are present in <code>hosts</code> are moved to active.\n      * Nodes in active which are not present in <code>hosts</code> are moved to inactive.\n      *\n-     * @param transaction Transaction with operations to commit together with any operations done within the repository.\n      * @param hosts the hosts to make the set of active nodes of this\n-     * @param lock provision lock that must be held when calling this\n+     * @param generation the application config generation that is activated\n+     * @param transaction transaction with operations to commit together with any operations done within the repository,\n+     *                    while holding the node repository lock on this application\n      */\n-    private void activateNodes(Collection<HostSpec> hosts, NestedTransaction transaction, ProvisionLock lock) {\n-        ApplicationId application = lock.application();\n+    private void activateNodes(Collection<HostSpec> hosts, long generation, ApplicationTransaction transaction) {\n+        ApplicationId application = transaction.application();\n         Set<String> hostnames = hosts.stream().map(HostSpec::hostname).collect(Collectors.toSet());\n         NodeList allNodes = nodeRepository.list();\n         NodeList applicationNodes = allNodes.owner(application);\n \n         List<Node> reserved = applicationNodes.state(Node.State.reserved).asList();\n-        List<Node> reservedToActivate = retainHostsInList(hostnames, reserved);\n-        List<Node> active = applicationNodes.state(Node.State.active).asList();\n-        List<Node> continuedActive = retainHostsInList(hostnames, active);\n-        List<Node> allActive = new ArrayList<>(continuedActive);\n-        allActive.addAll(reservedToActivate);\n-        if (!containsAll(hostnames, allActive))\n+        List<Node> reservedToActivate = updatePortsFrom(hosts, retainHostsInList(hostnames, reserved));\n+        List<Node> oldActive = applicationNodes.state(Node.State.active).asList(); // All nodes active now\n+        List<Node> continuedActive = retainHostsInList(hostnames, oldActive);\n+        List<Node> newActive = updateFrom(hosts, continuedActive); // All nodes that will be active when this is committed\n+        newActive.addAll(reservedToActivate);\n+        if ( ! containsAll(hostnames, newActive))\n             throw new IllegalArgumentException(\"Activation of \" + application + \" failed. \" +\n                                                \"Could not find all requested hosts.\" +\n                                                \"\\nRequested: \" + hosts +\n                                                \"\\nReserved: \" + toHostNames(reserved) +\n-                                               \"\\nActive: \" + toHostNames(active) +\n+                                               \"\\nActive: \" + toHostNames(oldActive) +\n                                                \"\\nThis might happen if the time from reserving host to activation takes \" +\n                                                \"longer time than reservation expiry (the hosts will then no longer be reserved)\");\n \n         validateParentHosts(application, allNodes, reservedToActivate);\n \n-        List<Node> activeToRemove = removeHostsFromList(hostnames, active);\n-        activeToRemove = activeToRemove.stream().map(Node::unretire).collect(Collectors.toList()); // only active nodes can be retired\n-        nodeRepository.deactivate(activeToRemove, transaction, lock);\n-        nodeRepository.activate(updateFrom(hosts, continuedActive), transaction); // update active with any changes\n-        nodeRepository.activate(updatePortsFrom(hosts, reservedToActivate), transaction);\n+        List<Node> activeToRemove = removeHostsFromList(hostnames, oldActive);\n+        activeToRemove = activeToRemove.stream().map(Node::unretire).collect(Collectors.toList()); // only active nodes can be retired. TODO: Move this line to deactivate\n+        nodeRepository.deactivate(activeToRemove, transaction);\n+        nodeRepository.activate(newActive, transaction.nested()); // activate also continued active to update node state\n+\n+        rememberResourceChange(transaction, generation,\n+                               NodeList.copyOf(oldActive).not().retired(),\n+                               NodeList.copyOf(newActive).not().retired());\n         unreserveParentsOf(reservedToActivate);\n     }\n \n+    private void rememberResourceChange(ApplicationTransaction transaction, long generation,\n+                                        NodeList oldNodes, NodeList newNodes) {\n+        if (nodeRepository.applications().get(transaction.application()).isEmpty()) return; // infrastructure app, hopefully\n+        Application application = nodeRepository.applications().get(transaction.application()).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NDIxMQ=="}, "originalCommit": {"oid": "fe20011cf8d5c534eadc79cb5695915fbd9849d7"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMxNzU4Nw==", "bodyText": "It's reading it in the if statement above as well?", "url": "https://github.com/vespa-engine/vespa/pull/15013#discussion_r510317587", "createdAt": "2020-10-22T16:58:11Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/Activator.java", "diffHunk": "@@ -53,41 +57,69 @@ public void activate(Collection<HostSpec> hosts, NestedTransaction transaction,\n      * Post condition: Nodes in reserved which are present in <code>hosts</code> are moved to active.\n      * Nodes in active which are not present in <code>hosts</code> are moved to inactive.\n      *\n-     * @param transaction Transaction with operations to commit together with any operations done within the repository.\n      * @param hosts the hosts to make the set of active nodes of this\n-     * @param lock provision lock that must be held when calling this\n+     * @param generation the application config generation that is activated\n+     * @param transaction transaction with operations to commit together with any operations done within the repository,\n+     *                    while holding the node repository lock on this application\n      */\n-    private void activateNodes(Collection<HostSpec> hosts, NestedTransaction transaction, ProvisionLock lock) {\n-        ApplicationId application = lock.application();\n+    private void activateNodes(Collection<HostSpec> hosts, long generation, ApplicationTransaction transaction) {\n+        ApplicationId application = transaction.application();\n         Set<String> hostnames = hosts.stream().map(HostSpec::hostname).collect(Collectors.toSet());\n         NodeList allNodes = nodeRepository.list();\n         NodeList applicationNodes = allNodes.owner(application);\n \n         List<Node> reserved = applicationNodes.state(Node.State.reserved).asList();\n-        List<Node> reservedToActivate = retainHostsInList(hostnames, reserved);\n-        List<Node> active = applicationNodes.state(Node.State.active).asList();\n-        List<Node> continuedActive = retainHostsInList(hostnames, active);\n-        List<Node> allActive = new ArrayList<>(continuedActive);\n-        allActive.addAll(reservedToActivate);\n-        if (!containsAll(hostnames, allActive))\n+        List<Node> reservedToActivate = updatePortsFrom(hosts, retainHostsInList(hostnames, reserved));\n+        List<Node> oldActive = applicationNodes.state(Node.State.active).asList(); // All nodes active now\n+        List<Node> continuedActive = retainHostsInList(hostnames, oldActive);\n+        List<Node> newActive = updateFrom(hosts, continuedActive); // All nodes that will be active when this is committed\n+        newActive.addAll(reservedToActivate);\n+        if ( ! containsAll(hostnames, newActive))\n             throw new IllegalArgumentException(\"Activation of \" + application + \" failed. \" +\n                                                \"Could not find all requested hosts.\" +\n                                                \"\\nRequested: \" + hosts +\n                                                \"\\nReserved: \" + toHostNames(reserved) +\n-                                               \"\\nActive: \" + toHostNames(active) +\n+                                               \"\\nActive: \" + toHostNames(oldActive) +\n                                                \"\\nThis might happen if the time from reserving host to activation takes \" +\n                                                \"longer time than reservation expiry (the hosts will then no longer be reserved)\");\n \n         validateParentHosts(application, allNodes, reservedToActivate);\n \n-        List<Node> activeToRemove = removeHostsFromList(hostnames, active);\n-        activeToRemove = activeToRemove.stream().map(Node::unretire).collect(Collectors.toList()); // only active nodes can be retired\n-        nodeRepository.deactivate(activeToRemove, transaction, lock);\n-        nodeRepository.activate(updateFrom(hosts, continuedActive), transaction); // update active with any changes\n-        nodeRepository.activate(updatePortsFrom(hosts, reservedToActivate), transaction);\n+        List<Node> activeToRemove = removeHostsFromList(hostnames, oldActive);\n+        activeToRemove = activeToRemove.stream().map(Node::unretire).collect(Collectors.toList()); // only active nodes can be retired. TODO: Move this line to deactivate\n+        nodeRepository.deactivate(activeToRemove, transaction);\n+        nodeRepository.activate(newActive, transaction.nested()); // activate also continued active to update node state\n+\n+        rememberResourceChange(transaction, generation,\n+                               NodeList.copyOf(oldActive).not().retired(),\n+                               NodeList.copyOf(newActive).not().retired());\n         unreserveParentsOf(reservedToActivate);\n     }\n \n+    private void rememberResourceChange(ApplicationTransaction transaction, long generation,\n+                                        NodeList oldNodes, NodeList newNodes) {\n+        if (nodeRepository.applications().get(transaction.application()).isEmpty()) return; // infrastructure app, hopefully\n+        Application application = nodeRepository.applications().get(transaction.application()).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NDIxMQ=="}, "originalCommit": {"oid": "fe20011cf8d5c534eadc79cb5695915fbd9849d7"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMyMzAxNg==", "bodyText": "That is true. Changed.", "url": "https://github.com/vespa-engine/vespa/pull/15013#discussion_r510323016", "createdAt": "2020-10-22T17:07:08Z", "author": {"login": "bratseth"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/Activator.java", "diffHunk": "@@ -53,41 +57,69 @@ public void activate(Collection<HostSpec> hosts, NestedTransaction transaction,\n      * Post condition: Nodes in reserved which are present in <code>hosts</code> are moved to active.\n      * Nodes in active which are not present in <code>hosts</code> are moved to inactive.\n      *\n-     * @param transaction Transaction with operations to commit together with any operations done within the repository.\n      * @param hosts the hosts to make the set of active nodes of this\n-     * @param lock provision lock that must be held when calling this\n+     * @param generation the application config generation that is activated\n+     * @param transaction transaction with operations to commit together with any operations done within the repository,\n+     *                    while holding the node repository lock on this application\n      */\n-    private void activateNodes(Collection<HostSpec> hosts, NestedTransaction transaction, ProvisionLock lock) {\n-        ApplicationId application = lock.application();\n+    private void activateNodes(Collection<HostSpec> hosts, long generation, ApplicationTransaction transaction) {\n+        ApplicationId application = transaction.application();\n         Set<String> hostnames = hosts.stream().map(HostSpec::hostname).collect(Collectors.toSet());\n         NodeList allNodes = nodeRepository.list();\n         NodeList applicationNodes = allNodes.owner(application);\n \n         List<Node> reserved = applicationNodes.state(Node.State.reserved).asList();\n-        List<Node> reservedToActivate = retainHostsInList(hostnames, reserved);\n-        List<Node> active = applicationNodes.state(Node.State.active).asList();\n-        List<Node> continuedActive = retainHostsInList(hostnames, active);\n-        List<Node> allActive = new ArrayList<>(continuedActive);\n-        allActive.addAll(reservedToActivate);\n-        if (!containsAll(hostnames, allActive))\n+        List<Node> reservedToActivate = updatePortsFrom(hosts, retainHostsInList(hostnames, reserved));\n+        List<Node> oldActive = applicationNodes.state(Node.State.active).asList(); // All nodes active now\n+        List<Node> continuedActive = retainHostsInList(hostnames, oldActive);\n+        List<Node> newActive = updateFrom(hosts, continuedActive); // All nodes that will be active when this is committed\n+        newActive.addAll(reservedToActivate);\n+        if ( ! containsAll(hostnames, newActive))\n             throw new IllegalArgumentException(\"Activation of \" + application + \" failed. \" +\n                                                \"Could not find all requested hosts.\" +\n                                                \"\\nRequested: \" + hosts +\n                                                \"\\nReserved: \" + toHostNames(reserved) +\n-                                               \"\\nActive: \" + toHostNames(active) +\n+                                               \"\\nActive: \" + toHostNames(oldActive) +\n                                                \"\\nThis might happen if the time from reserving host to activation takes \" +\n                                                \"longer time than reservation expiry (the hosts will then no longer be reserved)\");\n \n         validateParentHosts(application, allNodes, reservedToActivate);\n \n-        List<Node> activeToRemove = removeHostsFromList(hostnames, active);\n-        activeToRemove = activeToRemove.stream().map(Node::unretire).collect(Collectors.toList()); // only active nodes can be retired\n-        nodeRepository.deactivate(activeToRemove, transaction, lock);\n-        nodeRepository.activate(updateFrom(hosts, continuedActive), transaction); // update active with any changes\n-        nodeRepository.activate(updatePortsFrom(hosts, reservedToActivate), transaction);\n+        List<Node> activeToRemove = removeHostsFromList(hostnames, oldActive);\n+        activeToRemove = activeToRemove.stream().map(Node::unretire).collect(Collectors.toList()); // only active nodes can be retired. TODO: Move this line to deactivate\n+        nodeRepository.deactivate(activeToRemove, transaction);\n+        nodeRepository.activate(newActive, transaction.nested()); // activate also continued active to update node state\n+\n+        rememberResourceChange(transaction, generation,\n+                               NodeList.copyOf(oldActive).not().retired(),\n+                               NodeList.copyOf(newActive).not().retired());\n         unreserveParentsOf(reservedToActivate);\n     }\n \n+    private void rememberResourceChange(ApplicationTransaction transaction, long generation,\n+                                        NodeList oldNodes, NodeList newNodes) {\n+        if (nodeRepository.applications().get(transaction.application()).isEmpty()) return; // infrastructure app, hopefully\n+        Application application = nodeRepository.applications().get(transaction.application()).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NDIxMQ=="}, "originalCommit": {"oid": "fe20011cf8d5c534eadc79cb5695915fbd9849d7"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5NjU1MDExOnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/NodeList.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNjoyMzo0NVrOHmp9Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxNzowMDoxMVrOHmrY5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NTMwMg==", "bodyText": "Shouldn't there be a map to to group id here?", "url": "https://github.com/vespa-engine/vespa/pull/15013#discussion_r510295302", "createdAt": "2020-10-22T16:23:45Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/NodeList.java", "diffHunk": "@@ -179,6 +180,13 @@ public NodeList group(int index) {\n                                                        .findFirst());\n     }\n \n+    public ClusterResources toResources() {\n+        if (isEmpty()) return new ClusterResources(0, 0, NodeResources.unspecified());\n+        return new ClusterResources(size(),\n+                                    (int)stream().distinct().count(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe20011cf8d5c534eadc79cb5695915fbd9849d7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMxODgyMg==", "bodyText": "Yes, thanks!", "url": "https://github.com/vespa-engine/vespa/pull/15013#discussion_r510318822", "createdAt": "2020-10-22T17:00:11Z", "author": {"login": "bratseth"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/NodeList.java", "diffHunk": "@@ -179,6 +180,13 @@ public NodeList group(int index) {\n                                                        .findFirst());\n     }\n \n+    public ClusterResources toResources() {\n+        if (isEmpty()) return new ClusterResources(0, 0, NodeResources.unspecified());\n+        return new ClusterResources(size(),\n+                                    (int)stream().distinct().count(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI5NTMwMg=="}, "originalCommit": {"oid": "fe20011cf8d5c534eadc79cb5695915fbd9849d7"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1120, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}