{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NTQ1NDc4", "number": 14284, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDoyNzoxNlrOEgVKLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDozMjo1OVrOEgVQuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzM2NTU5OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDoyNzoxNlrOHNIZ-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDozODoxNVrOHNIs7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMTI1OQ==", "bodyText": "PRId64 is the correct format string for position.", "url": "https://github.com/vespa-engine/vespa/pull/14284#discussion_r483531259", "createdAt": "2020-09-04T10:27:16Z", "author": {"login": "toregge"}, "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "diffHunk": "@@ -527,121 +516,84 @@ DomainPart::visit(SerialNumRange &r, Packet &packet)\n bool\n DomainPart::visit(FastOS_FileInterface &file, SerialNumRange &r, Packet &packet)\n {\n-    bool retval(true);\n-    if ( ! file.IsOpened() ) {\n-        retval = openAndFind(file, r.from() + 1);\n+    if ( ! file.IsOpened() && ! openAndFind(file, r.from() + 1)) {\n+        return false;\n     }\n-    if (retval) {\n-        Packet newPacket;\n-        Alloc buf;\n-        for (bool full(false);!full && retval && (r.from() < r.to());) {\n-            Packet::Entry e;\n-            int64_t fPos = file.GetPosition();\n-            retval = read(file, e, buf, false);\n-            if (retval &&\n-                e.valid() &&\n-                (r.from() < e.serial()) &&\n-                (e.serial() <= r.to())) {\n-                try {\n-                    full = addPacket(newPacket, e);\n-                } catch (const std::exception & ex) {\n-                    throw runtime_error(make_string(\"%s : Failed creating packet for visit %s(%\" PRIu64 \") at pos(%\" PRIu64 \", %\" PRIu64 \")\",\n-                                                    ex.what(), file.GetFileName(), file.GetSize(), fPos, file.GetPosition()));\n-                }\n-                if ( !full ) {\n-                    r.from(e.serial());\n-                } else {\n-                    if ( ! file.SetPosition(fPos) ) {\n-                        throw runtime_error(make_string(\"Failed setting read position for file '%s' of size %\" PRId64 \" from %\" PRId64 \" to %\" PRId64 \".\",\n-                                                        file.GetFileName(), file.GetSize(), file.GetPosition(), fPos));\n-                    }\n-                }\n-            }\n-        }\n-        packet = newPacket;\n+\n+    packet = readPacket(file, r, TARGET_PACKET_SIZE, false);\n+    if (!packet.empty()) {\n+        r.from(packet.range().to());\n     }\n \n-    return retval;\n+    return ! packet.empty();\n }\n \n void\n-DomainPart::write(FastOS_FileInterface &file, const Packet::Entry &entry)\n+DomainPart::write(FastOS_FileInterface &file, const IChunk & chunk)\n {\n-    int64_t lastKnownGoodPos(byteSize());\n-    int32_t crc(0);\n-    uint32_t len(entry.serializedSize() + sizeof(crc));\n     nbostream os;\n-    os << static_cast<uint8_t>(_encoding.getRaw());\n-    os << len;\n-    size_t start(os.size());\n-    entry.serialize(os);\n-    size_t end(os.size());\n-    crc = calcCrc(_encoding.getCrc(), os.data() + start, end - start);\n-    os << crc;\n-    size_t osSize = os.size();\n-    assert(osSize == len + sizeof(len) + sizeof(uint8_t));\n-\n+    size_t begin = os.wp();\n+    os << _encoding.getRaw();\n+    os << uint32_t(0);\n+    Encoding realEncoding = chunk.encode(os);\n+    size_t end = os.wp();\n+    os.wp(0);\n+    os << realEncoding.getRaw();\n+    os << uint32_t(end - (begin + sizeof(uint32_t) + sizeof(uint8_t)));\n+    os.wp(end);\n+    int64_t lastKnownGoodPos(file.GetPosition());\n     LockGuard guard(_writeLock);\n-    if ( ! file.CheckedWrite(os.data(), osSize) ) {\n-        throw runtime_error(handleWriteError(\"Failed writing the entry.\", file, lastKnownGoodPos, SerialNumRange(entry.serial(), entry.serial()), end - start));\n+    if ( ! file.CheckedWrite(os.data(), os.size()) ) {\n+        throw runtime_error(handleWriteError(\"Failed writing the entry.\", file, lastKnownGoodPos, chunk.range(), os.size()));\n     }\n-    _writtenSerial = entry.serial();\n-    _byteSize.store(lastKnownGoodPos + osSize, std::memory_order_release);\n+    _writtenSerial = chunk.range().to();\n+    _byteSize.store(lastKnownGoodPos + os.size(), std::memory_order_release);\n }\n \n bool\n-DomainPart::read(FastOS_FileInterface &file,\n-                 Packet::Entry &entry,\n-                 Alloc & buf,\n-                 bool allowTruncate)\n+DomainPart::read(FastOS_FileInterface &file, IChunk::UP & chunk, Alloc & buf, bool allowTruncate)\n {\n-    bool retval(true);\n     char tmp[5];\n     int64_t lastKnownGoodPos(file.GetPosition());\n     size_t rlen = file.Read(tmp, sizeof(tmp));\n     nbostream his(tmp, sizeof(tmp));\n-    uint8_t version(-1);\n+    uint8_t encoding(-1);\n     uint32_t len(0);\n-    his >> version >> len;\n-    if ((retval = (rlen == sizeof(tmp)))) {\n-        if ( ! (retval = (version == Encoding::Crc::ccitt_crc32) || version == Encoding::Crc::xxh64)) {\n-            string msg(make_string(\"Version mismatch. Expected 'ccitt_crc32=1' or 'xxh64=2',\"\n-                                   \" got %d from '%s' at position %\" PRId64,\n-                                   version, file.GetFileName(), lastKnownGoodPos));\n-            if ((version == 0) && (len == 0) && tailOfFileIsZero(file, lastKnownGoodPos)) {\n-                LOG(warning, \"%s\", msg.c_str());\n-                return handleReadError(\"packet version\", file, sizeof(tmp), rlen, lastKnownGoodPos, allowTruncate);\n-            } else {\n-                throw runtime_error(msg);\n-            }\n-        }\n-        if (len > buf.size()) {\n-            Alloc::alloc(len).swap(buf);\n-        }\n-        rlen = file.Read(buf.get(), len);\n-        retval = rlen == len;\n-        if (!retval) {\n-            retval = handleReadError(\"packet blob\", file, len, rlen, lastKnownGoodPos, allowTruncate);\n-        } else {\n-            nbostream_longlivedbuf is(buf.get(), len);\n-            entry.deserialize(is);\n-            int32_t crc(0);\n-            is >> crc;\n-            int32_t crcVerify(calcCrc(Encoding(version).getCrc(), buf.get(), len - sizeof(crc)));\n-            if (crc != crcVerify) {\n-                throw runtime_error(make_string(\"Got bad crc for packet from '%s' (len pos=%\" PRId64 \", len=%d) : crcVerify = %d, expected %d\",\n-                                                file.GetFileName(), file.GetPosition() - len - sizeof(len),\n-                                                static_cast<int>(len), static_cast<int>(crcVerify), static_cast<int>(crc)));\n-            }\n-        }\n-    } else {\n-        if (rlen == 0) {\n-           // Eof\n+    his >> encoding >> len;\n+    if (rlen != sizeof(tmp)) {\n+        return (rlen == 0)\n+               ? true\n+               : handleReadError(\"packet length\", file, sizeof(len), rlen, lastKnownGoodPos, allowTruncate);\n+    }\n+\n+    try {\n+        chunk = IChunk::create(encoding);\n+    } catch (const std::exception & e) {\n+        string msg(make_string(\"Version mismatch. Expected 'ccitt_crc32=1' or 'xxh64=2',\"\n+                               \" got %d from '%s' at position %ld\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aedee2e6d2656164310ec8d0384eb3c3c152cbda"}, "originalPosition": 353}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzNjEwOQ==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14284#discussion_r483536109", "createdAt": "2020-09-04T10:38:15Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "diffHunk": "@@ -527,121 +516,84 @@ DomainPart::visit(SerialNumRange &r, Packet &packet)\n bool\n DomainPart::visit(FastOS_FileInterface &file, SerialNumRange &r, Packet &packet)\n {\n-    bool retval(true);\n-    if ( ! file.IsOpened() ) {\n-        retval = openAndFind(file, r.from() + 1);\n+    if ( ! file.IsOpened() && ! openAndFind(file, r.from() + 1)) {\n+        return false;\n     }\n-    if (retval) {\n-        Packet newPacket;\n-        Alloc buf;\n-        for (bool full(false);!full && retval && (r.from() < r.to());) {\n-            Packet::Entry e;\n-            int64_t fPos = file.GetPosition();\n-            retval = read(file, e, buf, false);\n-            if (retval &&\n-                e.valid() &&\n-                (r.from() < e.serial()) &&\n-                (e.serial() <= r.to())) {\n-                try {\n-                    full = addPacket(newPacket, e);\n-                } catch (const std::exception & ex) {\n-                    throw runtime_error(make_string(\"%s : Failed creating packet for visit %s(%\" PRIu64 \") at pos(%\" PRIu64 \", %\" PRIu64 \")\",\n-                                                    ex.what(), file.GetFileName(), file.GetSize(), fPos, file.GetPosition()));\n-                }\n-                if ( !full ) {\n-                    r.from(e.serial());\n-                } else {\n-                    if ( ! file.SetPosition(fPos) ) {\n-                        throw runtime_error(make_string(\"Failed setting read position for file '%s' of size %\" PRId64 \" from %\" PRId64 \" to %\" PRId64 \".\",\n-                                                        file.GetFileName(), file.GetSize(), file.GetPosition(), fPos));\n-                    }\n-                }\n-            }\n-        }\n-        packet = newPacket;\n+\n+    packet = readPacket(file, r, TARGET_PACKET_SIZE, false);\n+    if (!packet.empty()) {\n+        r.from(packet.range().to());\n     }\n \n-    return retval;\n+    return ! packet.empty();\n }\n \n void\n-DomainPart::write(FastOS_FileInterface &file, const Packet::Entry &entry)\n+DomainPart::write(FastOS_FileInterface &file, const IChunk & chunk)\n {\n-    int64_t lastKnownGoodPos(byteSize());\n-    int32_t crc(0);\n-    uint32_t len(entry.serializedSize() + sizeof(crc));\n     nbostream os;\n-    os << static_cast<uint8_t>(_encoding.getRaw());\n-    os << len;\n-    size_t start(os.size());\n-    entry.serialize(os);\n-    size_t end(os.size());\n-    crc = calcCrc(_encoding.getCrc(), os.data() + start, end - start);\n-    os << crc;\n-    size_t osSize = os.size();\n-    assert(osSize == len + sizeof(len) + sizeof(uint8_t));\n-\n+    size_t begin = os.wp();\n+    os << _encoding.getRaw();\n+    os << uint32_t(0);\n+    Encoding realEncoding = chunk.encode(os);\n+    size_t end = os.wp();\n+    os.wp(0);\n+    os << realEncoding.getRaw();\n+    os << uint32_t(end - (begin + sizeof(uint32_t) + sizeof(uint8_t)));\n+    os.wp(end);\n+    int64_t lastKnownGoodPos(file.GetPosition());\n     LockGuard guard(_writeLock);\n-    if ( ! file.CheckedWrite(os.data(), osSize) ) {\n-        throw runtime_error(handleWriteError(\"Failed writing the entry.\", file, lastKnownGoodPos, SerialNumRange(entry.serial(), entry.serial()), end - start));\n+    if ( ! file.CheckedWrite(os.data(), os.size()) ) {\n+        throw runtime_error(handleWriteError(\"Failed writing the entry.\", file, lastKnownGoodPos, chunk.range(), os.size()));\n     }\n-    _writtenSerial = entry.serial();\n-    _byteSize.store(lastKnownGoodPos + osSize, std::memory_order_release);\n+    _writtenSerial = chunk.range().to();\n+    _byteSize.store(lastKnownGoodPos + os.size(), std::memory_order_release);\n }\n \n bool\n-DomainPart::read(FastOS_FileInterface &file,\n-                 Packet::Entry &entry,\n-                 Alloc & buf,\n-                 bool allowTruncate)\n+DomainPart::read(FastOS_FileInterface &file, IChunk::UP & chunk, Alloc & buf, bool allowTruncate)\n {\n-    bool retval(true);\n     char tmp[5];\n     int64_t lastKnownGoodPos(file.GetPosition());\n     size_t rlen = file.Read(tmp, sizeof(tmp));\n     nbostream his(tmp, sizeof(tmp));\n-    uint8_t version(-1);\n+    uint8_t encoding(-1);\n     uint32_t len(0);\n-    his >> version >> len;\n-    if ((retval = (rlen == sizeof(tmp)))) {\n-        if ( ! (retval = (version == Encoding::Crc::ccitt_crc32) || version == Encoding::Crc::xxh64)) {\n-            string msg(make_string(\"Version mismatch. Expected 'ccitt_crc32=1' or 'xxh64=2',\"\n-                                   \" got %d from '%s' at position %\" PRId64,\n-                                   version, file.GetFileName(), lastKnownGoodPos));\n-            if ((version == 0) && (len == 0) && tailOfFileIsZero(file, lastKnownGoodPos)) {\n-                LOG(warning, \"%s\", msg.c_str());\n-                return handleReadError(\"packet version\", file, sizeof(tmp), rlen, lastKnownGoodPos, allowTruncate);\n-            } else {\n-                throw runtime_error(msg);\n-            }\n-        }\n-        if (len > buf.size()) {\n-            Alloc::alloc(len).swap(buf);\n-        }\n-        rlen = file.Read(buf.get(), len);\n-        retval = rlen == len;\n-        if (!retval) {\n-            retval = handleReadError(\"packet blob\", file, len, rlen, lastKnownGoodPos, allowTruncate);\n-        } else {\n-            nbostream_longlivedbuf is(buf.get(), len);\n-            entry.deserialize(is);\n-            int32_t crc(0);\n-            is >> crc;\n-            int32_t crcVerify(calcCrc(Encoding(version).getCrc(), buf.get(), len - sizeof(crc)));\n-            if (crc != crcVerify) {\n-                throw runtime_error(make_string(\"Got bad crc for packet from '%s' (len pos=%\" PRId64 \", len=%d) : crcVerify = %d, expected %d\",\n-                                                file.GetFileName(), file.GetPosition() - len - sizeof(len),\n-                                                static_cast<int>(len), static_cast<int>(crcVerify), static_cast<int>(crc)));\n-            }\n-        }\n-    } else {\n-        if (rlen == 0) {\n-           // Eof\n+    his >> encoding >> len;\n+    if (rlen != sizeof(tmp)) {\n+        return (rlen == 0)\n+               ? true\n+               : handleReadError(\"packet length\", file, sizeof(len), rlen, lastKnownGoodPos, allowTruncate);\n+    }\n+\n+    try {\n+        chunk = IChunk::create(encoding);\n+    } catch (const std::exception & e) {\n+        string msg(make_string(\"Version mismatch. Expected 'ccitt_crc32=1' or 'xxh64=2',\"\n+                               \" got %d from '%s' at position %ld\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMTI1OQ=="}, "originalCommit": {"oid": "aedee2e6d2656164310ec8d0384eb3c3c152cbda"}, "originalPosition": 353}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzM3MDAwOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDoyODo1N1rOHNIc0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDozODoyOVrOHNItRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMTk4Nw==", "bodyText": "len pos ?", "url": "https://github.com/vespa-engine/vespa/pull/14284#discussion_r483531987", "createdAt": "2020-09-04T10:28:57Z", "author": {"login": "toregge"}, "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "diffHunk": "@@ -527,121 +516,84 @@ DomainPart::visit(SerialNumRange &r, Packet &packet)\n bool\n DomainPart::visit(FastOS_FileInterface &file, SerialNumRange &r, Packet &packet)\n {\n-    bool retval(true);\n-    if ( ! file.IsOpened() ) {\n-        retval = openAndFind(file, r.from() + 1);\n+    if ( ! file.IsOpened() && ! openAndFind(file, r.from() + 1)) {\n+        return false;\n     }\n-    if (retval) {\n-        Packet newPacket;\n-        Alloc buf;\n-        for (bool full(false);!full && retval && (r.from() < r.to());) {\n-            Packet::Entry e;\n-            int64_t fPos = file.GetPosition();\n-            retval = read(file, e, buf, false);\n-            if (retval &&\n-                e.valid() &&\n-                (r.from() < e.serial()) &&\n-                (e.serial() <= r.to())) {\n-                try {\n-                    full = addPacket(newPacket, e);\n-                } catch (const std::exception & ex) {\n-                    throw runtime_error(make_string(\"%s : Failed creating packet for visit %s(%\" PRIu64 \") at pos(%\" PRIu64 \", %\" PRIu64 \")\",\n-                                                    ex.what(), file.GetFileName(), file.GetSize(), fPos, file.GetPosition()));\n-                }\n-                if ( !full ) {\n-                    r.from(e.serial());\n-                } else {\n-                    if ( ! file.SetPosition(fPos) ) {\n-                        throw runtime_error(make_string(\"Failed setting read position for file '%s' of size %\" PRId64 \" from %\" PRId64 \" to %\" PRId64 \".\",\n-                                                        file.GetFileName(), file.GetSize(), file.GetPosition(), fPos));\n-                    }\n-                }\n-            }\n-        }\n-        packet = newPacket;\n+\n+    packet = readPacket(file, r, TARGET_PACKET_SIZE, false);\n+    if (!packet.empty()) {\n+        r.from(packet.range().to());\n     }\n \n-    return retval;\n+    return ! packet.empty();\n }\n \n void\n-DomainPart::write(FastOS_FileInterface &file, const Packet::Entry &entry)\n+DomainPart::write(FastOS_FileInterface &file, const IChunk & chunk)\n {\n-    int64_t lastKnownGoodPos(byteSize());\n-    int32_t crc(0);\n-    uint32_t len(entry.serializedSize() + sizeof(crc));\n     nbostream os;\n-    os << static_cast<uint8_t>(_encoding.getRaw());\n-    os << len;\n-    size_t start(os.size());\n-    entry.serialize(os);\n-    size_t end(os.size());\n-    crc = calcCrc(_encoding.getCrc(), os.data() + start, end - start);\n-    os << crc;\n-    size_t osSize = os.size();\n-    assert(osSize == len + sizeof(len) + sizeof(uint8_t));\n-\n+    size_t begin = os.wp();\n+    os << _encoding.getRaw();\n+    os << uint32_t(0);\n+    Encoding realEncoding = chunk.encode(os);\n+    size_t end = os.wp();\n+    os.wp(0);\n+    os << realEncoding.getRaw();\n+    os << uint32_t(end - (begin + sizeof(uint32_t) + sizeof(uint8_t)));\n+    os.wp(end);\n+    int64_t lastKnownGoodPos(file.GetPosition());\n     LockGuard guard(_writeLock);\n-    if ( ! file.CheckedWrite(os.data(), osSize) ) {\n-        throw runtime_error(handleWriteError(\"Failed writing the entry.\", file, lastKnownGoodPos, SerialNumRange(entry.serial(), entry.serial()), end - start));\n+    if ( ! file.CheckedWrite(os.data(), os.size()) ) {\n+        throw runtime_error(handleWriteError(\"Failed writing the entry.\", file, lastKnownGoodPos, chunk.range(), os.size()));\n     }\n-    _writtenSerial = entry.serial();\n-    _byteSize.store(lastKnownGoodPos + osSize, std::memory_order_release);\n+    _writtenSerial = chunk.range().to();\n+    _byteSize.store(lastKnownGoodPos + os.size(), std::memory_order_release);\n }\n \n bool\n-DomainPart::read(FastOS_FileInterface &file,\n-                 Packet::Entry &entry,\n-                 Alloc & buf,\n-                 bool allowTruncate)\n+DomainPart::read(FastOS_FileInterface &file, IChunk::UP & chunk, Alloc & buf, bool allowTruncate)\n {\n-    bool retval(true);\n     char tmp[5];\n     int64_t lastKnownGoodPos(file.GetPosition());\n     size_t rlen = file.Read(tmp, sizeof(tmp));\n     nbostream his(tmp, sizeof(tmp));\n-    uint8_t version(-1);\n+    uint8_t encoding(-1);\n     uint32_t len(0);\n-    his >> version >> len;\n-    if ((retval = (rlen == sizeof(tmp)))) {\n-        if ( ! (retval = (version == Encoding::Crc::ccitt_crc32) || version == Encoding::Crc::xxh64)) {\n-            string msg(make_string(\"Version mismatch. Expected 'ccitt_crc32=1' or 'xxh64=2',\"\n-                                   \" got %d from '%s' at position %\" PRId64,\n-                                   version, file.GetFileName(), lastKnownGoodPos));\n-            if ((version == 0) && (len == 0) && tailOfFileIsZero(file, lastKnownGoodPos)) {\n-                LOG(warning, \"%s\", msg.c_str());\n-                return handleReadError(\"packet version\", file, sizeof(tmp), rlen, lastKnownGoodPos, allowTruncate);\n-            } else {\n-                throw runtime_error(msg);\n-            }\n-        }\n-        if (len > buf.size()) {\n-            Alloc::alloc(len).swap(buf);\n-        }\n-        rlen = file.Read(buf.get(), len);\n-        retval = rlen == len;\n-        if (!retval) {\n-            retval = handleReadError(\"packet blob\", file, len, rlen, lastKnownGoodPos, allowTruncate);\n-        } else {\n-            nbostream_longlivedbuf is(buf.get(), len);\n-            entry.deserialize(is);\n-            int32_t crc(0);\n-            is >> crc;\n-            int32_t crcVerify(calcCrc(Encoding(version).getCrc(), buf.get(), len - sizeof(crc)));\n-            if (crc != crcVerify) {\n-                throw runtime_error(make_string(\"Got bad crc for packet from '%s' (len pos=%\" PRId64 \", len=%d) : crcVerify = %d, expected %d\",\n-                                                file.GetFileName(), file.GetPosition() - len - sizeof(len),\n-                                                static_cast<int>(len), static_cast<int>(crcVerify), static_cast<int>(crc)));\n-            }\n-        }\n-    } else {\n-        if (rlen == 0) {\n-           // Eof\n+    his >> encoding >> len;\n+    if (rlen != sizeof(tmp)) {\n+        return (rlen == 0)\n+               ? true\n+               : handleReadError(\"packet length\", file, sizeof(len), rlen, lastKnownGoodPos, allowTruncate);\n+    }\n+\n+    try {\n+        chunk = IChunk::create(encoding);\n+    } catch (const std::exception & e) {\n+        string msg(make_string(\"Version mismatch. Expected 'ccitt_crc32=1' or 'xxh64=2',\"\n+                               \" got %d from '%s' at position %ld\",\n+                               encoding, file.GetFileName(), lastKnownGoodPos));\n+        if ((encoding == 0) && (len == 0) && tailOfFileIsZero(file, lastKnownGoodPos)) {\n+            LOG(warning, \"%s\", msg.c_str());\n+            return handleReadError(\"packet version\", file, sizeof(tmp), rlen, lastKnownGoodPos, allowTruncate);\n         } else {\n-           retval = handleReadError(\"packet length\", file, sizeof(len), rlen, lastKnownGoodPos, allowTruncate);\n+            throw runtime_error(msg);\n         }\n     }\n-    return retval;\n+    if (len > buf.size()) {\n+        Alloc::alloc(len).swap(buf);\n+    }\n+    rlen = file.Read(buf.get(), len);\n+    if (rlen != len) {\n+        return handleReadError(\"packet blob\", file, len, rlen, lastKnownGoodPos, allowTruncate);\n+    }\n+    try {\n+        nbostream_longlivedbuf is(buf.get(), len);\n+        chunk->decode(is);\n+    } catch (const std::exception & e) {\n+        throw runtime_error(make_string(\"Got exception during decoding of packet '%s' from file '%s' (len pos=%\" PRId64 \", len=%d)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aedee2e6d2656164310ec8d0384eb3c3c152cbda"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzNjE5Ng==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14284#discussion_r483536196", "createdAt": "2020-09-04T10:38:29Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "diffHunk": "@@ -527,121 +516,84 @@ DomainPart::visit(SerialNumRange &r, Packet &packet)\n bool\n DomainPart::visit(FastOS_FileInterface &file, SerialNumRange &r, Packet &packet)\n {\n-    bool retval(true);\n-    if ( ! file.IsOpened() ) {\n-        retval = openAndFind(file, r.from() + 1);\n+    if ( ! file.IsOpened() && ! openAndFind(file, r.from() + 1)) {\n+        return false;\n     }\n-    if (retval) {\n-        Packet newPacket;\n-        Alloc buf;\n-        for (bool full(false);!full && retval && (r.from() < r.to());) {\n-            Packet::Entry e;\n-            int64_t fPos = file.GetPosition();\n-            retval = read(file, e, buf, false);\n-            if (retval &&\n-                e.valid() &&\n-                (r.from() < e.serial()) &&\n-                (e.serial() <= r.to())) {\n-                try {\n-                    full = addPacket(newPacket, e);\n-                } catch (const std::exception & ex) {\n-                    throw runtime_error(make_string(\"%s : Failed creating packet for visit %s(%\" PRIu64 \") at pos(%\" PRIu64 \", %\" PRIu64 \")\",\n-                                                    ex.what(), file.GetFileName(), file.GetSize(), fPos, file.GetPosition()));\n-                }\n-                if ( !full ) {\n-                    r.from(e.serial());\n-                } else {\n-                    if ( ! file.SetPosition(fPos) ) {\n-                        throw runtime_error(make_string(\"Failed setting read position for file '%s' of size %\" PRId64 \" from %\" PRId64 \" to %\" PRId64 \".\",\n-                                                        file.GetFileName(), file.GetSize(), file.GetPosition(), fPos));\n-                    }\n-                }\n-            }\n-        }\n-        packet = newPacket;\n+\n+    packet = readPacket(file, r, TARGET_PACKET_SIZE, false);\n+    if (!packet.empty()) {\n+        r.from(packet.range().to());\n     }\n \n-    return retval;\n+    return ! packet.empty();\n }\n \n void\n-DomainPart::write(FastOS_FileInterface &file, const Packet::Entry &entry)\n+DomainPart::write(FastOS_FileInterface &file, const IChunk & chunk)\n {\n-    int64_t lastKnownGoodPos(byteSize());\n-    int32_t crc(0);\n-    uint32_t len(entry.serializedSize() + sizeof(crc));\n     nbostream os;\n-    os << static_cast<uint8_t>(_encoding.getRaw());\n-    os << len;\n-    size_t start(os.size());\n-    entry.serialize(os);\n-    size_t end(os.size());\n-    crc = calcCrc(_encoding.getCrc(), os.data() + start, end - start);\n-    os << crc;\n-    size_t osSize = os.size();\n-    assert(osSize == len + sizeof(len) + sizeof(uint8_t));\n-\n+    size_t begin = os.wp();\n+    os << _encoding.getRaw();\n+    os << uint32_t(0);\n+    Encoding realEncoding = chunk.encode(os);\n+    size_t end = os.wp();\n+    os.wp(0);\n+    os << realEncoding.getRaw();\n+    os << uint32_t(end - (begin + sizeof(uint32_t) + sizeof(uint8_t)));\n+    os.wp(end);\n+    int64_t lastKnownGoodPos(file.GetPosition());\n     LockGuard guard(_writeLock);\n-    if ( ! file.CheckedWrite(os.data(), osSize) ) {\n-        throw runtime_error(handleWriteError(\"Failed writing the entry.\", file, lastKnownGoodPos, SerialNumRange(entry.serial(), entry.serial()), end - start));\n+    if ( ! file.CheckedWrite(os.data(), os.size()) ) {\n+        throw runtime_error(handleWriteError(\"Failed writing the entry.\", file, lastKnownGoodPos, chunk.range(), os.size()));\n     }\n-    _writtenSerial = entry.serial();\n-    _byteSize.store(lastKnownGoodPos + osSize, std::memory_order_release);\n+    _writtenSerial = chunk.range().to();\n+    _byteSize.store(lastKnownGoodPos + os.size(), std::memory_order_release);\n }\n \n bool\n-DomainPart::read(FastOS_FileInterface &file,\n-                 Packet::Entry &entry,\n-                 Alloc & buf,\n-                 bool allowTruncate)\n+DomainPart::read(FastOS_FileInterface &file, IChunk::UP & chunk, Alloc & buf, bool allowTruncate)\n {\n-    bool retval(true);\n     char tmp[5];\n     int64_t lastKnownGoodPos(file.GetPosition());\n     size_t rlen = file.Read(tmp, sizeof(tmp));\n     nbostream his(tmp, sizeof(tmp));\n-    uint8_t version(-1);\n+    uint8_t encoding(-1);\n     uint32_t len(0);\n-    his >> version >> len;\n-    if ((retval = (rlen == sizeof(tmp)))) {\n-        if ( ! (retval = (version == Encoding::Crc::ccitt_crc32) || version == Encoding::Crc::xxh64)) {\n-            string msg(make_string(\"Version mismatch. Expected 'ccitt_crc32=1' or 'xxh64=2',\"\n-                                   \" got %d from '%s' at position %\" PRId64,\n-                                   version, file.GetFileName(), lastKnownGoodPos));\n-            if ((version == 0) && (len == 0) && tailOfFileIsZero(file, lastKnownGoodPos)) {\n-                LOG(warning, \"%s\", msg.c_str());\n-                return handleReadError(\"packet version\", file, sizeof(tmp), rlen, lastKnownGoodPos, allowTruncate);\n-            } else {\n-                throw runtime_error(msg);\n-            }\n-        }\n-        if (len > buf.size()) {\n-            Alloc::alloc(len).swap(buf);\n-        }\n-        rlen = file.Read(buf.get(), len);\n-        retval = rlen == len;\n-        if (!retval) {\n-            retval = handleReadError(\"packet blob\", file, len, rlen, lastKnownGoodPos, allowTruncate);\n-        } else {\n-            nbostream_longlivedbuf is(buf.get(), len);\n-            entry.deserialize(is);\n-            int32_t crc(0);\n-            is >> crc;\n-            int32_t crcVerify(calcCrc(Encoding(version).getCrc(), buf.get(), len - sizeof(crc)));\n-            if (crc != crcVerify) {\n-                throw runtime_error(make_string(\"Got bad crc for packet from '%s' (len pos=%\" PRId64 \", len=%d) : crcVerify = %d, expected %d\",\n-                                                file.GetFileName(), file.GetPosition() - len - sizeof(len),\n-                                                static_cast<int>(len), static_cast<int>(crcVerify), static_cast<int>(crc)));\n-            }\n-        }\n-    } else {\n-        if (rlen == 0) {\n-           // Eof\n+    his >> encoding >> len;\n+    if (rlen != sizeof(tmp)) {\n+        return (rlen == 0)\n+               ? true\n+               : handleReadError(\"packet length\", file, sizeof(len), rlen, lastKnownGoodPos, allowTruncate);\n+    }\n+\n+    try {\n+        chunk = IChunk::create(encoding);\n+    } catch (const std::exception & e) {\n+        string msg(make_string(\"Version mismatch. Expected 'ccitt_crc32=1' or 'xxh64=2',\"\n+                               \" got %d from '%s' at position %ld\",\n+                               encoding, file.GetFileName(), lastKnownGoodPos));\n+        if ((encoding == 0) && (len == 0) && tailOfFileIsZero(file, lastKnownGoodPos)) {\n+            LOG(warning, \"%s\", msg.c_str());\n+            return handleReadError(\"packet version\", file, sizeof(tmp), rlen, lastKnownGoodPos, allowTruncate);\n         } else {\n-           retval = handleReadError(\"packet length\", file, sizeof(len), rlen, lastKnownGoodPos, allowTruncate);\n+            throw runtime_error(msg);\n         }\n     }\n-    return retval;\n+    if (len > buf.size()) {\n+        Alloc::alloc(len).swap(buf);\n+    }\n+    rlen = file.Read(buf.get(), len);\n+    if (rlen != len) {\n+        return handleReadError(\"packet blob\", file, len, rlen, lastKnownGoodPos, allowTruncate);\n+    }\n+    try {\n+        nbostream_longlivedbuf is(buf.get(), len);\n+        chunk->decode(is);\n+    } catch (const std::exception & e) {\n+        throw runtime_error(make_string(\"Got exception during decoding of packet '%s' from file '%s' (len pos=%\" PRId64 \", len=%d)\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMTk4Nw=="}, "originalCommit": {"oid": "aedee2e6d2656164310ec8d0384eb3c3c152cbda"}, "originalPosition": 375}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzM4MDk4OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDozMjoyN1rOHNIjRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDo0MDo1NVrOHNIxhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMzYzNw==", "bodyText": "Consider adding comment about patching up header of serialized chunk.", "url": "https://github.com/vespa-engine/vespa/pull/14284#discussion_r483533637", "createdAt": "2020-09-04T10:32:27Z", "author": {"login": "toregge"}, "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "diffHunk": "@@ -527,121 +516,84 @@ DomainPart::visit(SerialNumRange &r, Packet &packet)\n bool\n DomainPart::visit(FastOS_FileInterface &file, SerialNumRange &r, Packet &packet)\n {\n-    bool retval(true);\n-    if ( ! file.IsOpened() ) {\n-        retval = openAndFind(file, r.from() + 1);\n+    if ( ! file.IsOpened() && ! openAndFind(file, r.from() + 1)) {\n+        return false;\n     }\n-    if (retval) {\n-        Packet newPacket;\n-        Alloc buf;\n-        for (bool full(false);!full && retval && (r.from() < r.to());) {\n-            Packet::Entry e;\n-            int64_t fPos = file.GetPosition();\n-            retval = read(file, e, buf, false);\n-            if (retval &&\n-                e.valid() &&\n-                (r.from() < e.serial()) &&\n-                (e.serial() <= r.to())) {\n-                try {\n-                    full = addPacket(newPacket, e);\n-                } catch (const std::exception & ex) {\n-                    throw runtime_error(make_string(\"%s : Failed creating packet for visit %s(%\" PRIu64 \") at pos(%\" PRIu64 \", %\" PRIu64 \")\",\n-                                                    ex.what(), file.GetFileName(), file.GetSize(), fPos, file.GetPosition()));\n-                }\n-                if ( !full ) {\n-                    r.from(e.serial());\n-                } else {\n-                    if ( ! file.SetPosition(fPos) ) {\n-                        throw runtime_error(make_string(\"Failed setting read position for file '%s' of size %\" PRId64 \" from %\" PRId64 \" to %\" PRId64 \".\",\n-                                                        file.GetFileName(), file.GetSize(), file.GetPosition(), fPos));\n-                    }\n-                }\n-            }\n-        }\n-        packet = newPacket;\n+\n+    packet = readPacket(file, r, TARGET_PACKET_SIZE, false);\n+    if (!packet.empty()) {\n+        r.from(packet.range().to());\n     }\n \n-    return retval;\n+    return ! packet.empty();\n }\n \n void\n-DomainPart::write(FastOS_FileInterface &file, const Packet::Entry &entry)\n+DomainPart::write(FastOS_FileInterface &file, const IChunk & chunk)\n {\n-    int64_t lastKnownGoodPos(byteSize());\n-    int32_t crc(0);\n-    uint32_t len(entry.serializedSize() + sizeof(crc));\n     nbostream os;\n-    os << static_cast<uint8_t>(_encoding.getRaw());\n-    os << len;\n-    size_t start(os.size());\n-    entry.serialize(os);\n-    size_t end(os.size());\n-    crc = calcCrc(_encoding.getCrc(), os.data() + start, end - start);\n-    os << crc;\n-    size_t osSize = os.size();\n-    assert(osSize == len + sizeof(len) + sizeof(uint8_t));\n-\n+    size_t begin = os.wp();\n+    os << _encoding.getRaw();\n+    os << uint32_t(0);\n+    Encoding realEncoding = chunk.encode(os);\n+    size_t end = os.wp();\n+    os.wp(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aedee2e6d2656164310ec8d0384eb3c3c152cbda"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzNzI4NA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14284#discussion_r483537284", "createdAt": "2020-09-04T10:40:55Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "diffHunk": "@@ -527,121 +516,84 @@ DomainPart::visit(SerialNumRange &r, Packet &packet)\n bool\n DomainPart::visit(FastOS_FileInterface &file, SerialNumRange &r, Packet &packet)\n {\n-    bool retval(true);\n-    if ( ! file.IsOpened() ) {\n-        retval = openAndFind(file, r.from() + 1);\n+    if ( ! file.IsOpened() && ! openAndFind(file, r.from() + 1)) {\n+        return false;\n     }\n-    if (retval) {\n-        Packet newPacket;\n-        Alloc buf;\n-        for (bool full(false);!full && retval && (r.from() < r.to());) {\n-            Packet::Entry e;\n-            int64_t fPos = file.GetPosition();\n-            retval = read(file, e, buf, false);\n-            if (retval &&\n-                e.valid() &&\n-                (r.from() < e.serial()) &&\n-                (e.serial() <= r.to())) {\n-                try {\n-                    full = addPacket(newPacket, e);\n-                } catch (const std::exception & ex) {\n-                    throw runtime_error(make_string(\"%s : Failed creating packet for visit %s(%\" PRIu64 \") at pos(%\" PRIu64 \", %\" PRIu64 \")\",\n-                                                    ex.what(), file.GetFileName(), file.GetSize(), fPos, file.GetPosition()));\n-                }\n-                if ( !full ) {\n-                    r.from(e.serial());\n-                } else {\n-                    if ( ! file.SetPosition(fPos) ) {\n-                        throw runtime_error(make_string(\"Failed setting read position for file '%s' of size %\" PRId64 \" from %\" PRId64 \" to %\" PRId64 \".\",\n-                                                        file.GetFileName(), file.GetSize(), file.GetPosition(), fPos));\n-                    }\n-                }\n-            }\n-        }\n-        packet = newPacket;\n+\n+    packet = readPacket(file, r, TARGET_PACKET_SIZE, false);\n+    if (!packet.empty()) {\n+        r.from(packet.range().to());\n     }\n \n-    return retval;\n+    return ! packet.empty();\n }\n \n void\n-DomainPart::write(FastOS_FileInterface &file, const Packet::Entry &entry)\n+DomainPart::write(FastOS_FileInterface &file, const IChunk & chunk)\n {\n-    int64_t lastKnownGoodPos(byteSize());\n-    int32_t crc(0);\n-    uint32_t len(entry.serializedSize() + sizeof(crc));\n     nbostream os;\n-    os << static_cast<uint8_t>(_encoding.getRaw());\n-    os << len;\n-    size_t start(os.size());\n-    entry.serialize(os);\n-    size_t end(os.size());\n-    crc = calcCrc(_encoding.getCrc(), os.data() + start, end - start);\n-    os << crc;\n-    size_t osSize = os.size();\n-    assert(osSize == len + sizeof(len) + sizeof(uint8_t));\n-\n+    size_t begin = os.wp();\n+    os << _encoding.getRaw();\n+    os << uint32_t(0);\n+    Encoding realEncoding = chunk.encode(os);\n+    size_t end = os.wp();\n+    os.wp(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMzYzNw=="}, "originalCommit": {"oid": "aedee2e6d2656164310ec8d0384eb3c3c152cbda"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzM4MjM1OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDozMjo1OVrOHNIkHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMDo0MTowNVrOHNIxyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMzg1Mw==", "bodyText": "Consider adding comment about this being a placeholder value, to be patched up later.", "url": "https://github.com/vespa-engine/vespa/pull/14284#discussion_r483533853", "createdAt": "2020-09-04T10:32:59Z", "author": {"login": "toregge"}, "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "diffHunk": "@@ -527,121 +516,84 @@ DomainPart::visit(SerialNumRange &r, Packet &packet)\n bool\n DomainPart::visit(FastOS_FileInterface &file, SerialNumRange &r, Packet &packet)\n {\n-    bool retval(true);\n-    if ( ! file.IsOpened() ) {\n-        retval = openAndFind(file, r.from() + 1);\n+    if ( ! file.IsOpened() && ! openAndFind(file, r.from() + 1)) {\n+        return false;\n     }\n-    if (retval) {\n-        Packet newPacket;\n-        Alloc buf;\n-        for (bool full(false);!full && retval && (r.from() < r.to());) {\n-            Packet::Entry e;\n-            int64_t fPos = file.GetPosition();\n-            retval = read(file, e, buf, false);\n-            if (retval &&\n-                e.valid() &&\n-                (r.from() < e.serial()) &&\n-                (e.serial() <= r.to())) {\n-                try {\n-                    full = addPacket(newPacket, e);\n-                } catch (const std::exception & ex) {\n-                    throw runtime_error(make_string(\"%s : Failed creating packet for visit %s(%\" PRIu64 \") at pos(%\" PRIu64 \", %\" PRIu64 \")\",\n-                                                    ex.what(), file.GetFileName(), file.GetSize(), fPos, file.GetPosition()));\n-                }\n-                if ( !full ) {\n-                    r.from(e.serial());\n-                } else {\n-                    if ( ! file.SetPosition(fPos) ) {\n-                        throw runtime_error(make_string(\"Failed setting read position for file '%s' of size %\" PRId64 \" from %\" PRId64 \" to %\" PRId64 \".\",\n-                                                        file.GetFileName(), file.GetSize(), file.GetPosition(), fPos));\n-                    }\n-                }\n-            }\n-        }\n-        packet = newPacket;\n+\n+    packet = readPacket(file, r, TARGET_PACKET_SIZE, false);\n+    if (!packet.empty()) {\n+        r.from(packet.range().to());\n     }\n \n-    return retval;\n+    return ! packet.empty();\n }\n \n void\n-DomainPart::write(FastOS_FileInterface &file, const Packet::Entry &entry)\n+DomainPart::write(FastOS_FileInterface &file, const IChunk & chunk)\n {\n-    int64_t lastKnownGoodPos(byteSize());\n-    int32_t crc(0);\n-    uint32_t len(entry.serializedSize() + sizeof(crc));\n     nbostream os;\n-    os << static_cast<uint8_t>(_encoding.getRaw());\n-    os << len;\n-    size_t start(os.size());\n-    entry.serialize(os);\n-    size_t end(os.size());\n-    crc = calcCrc(_encoding.getCrc(), os.data() + start, end - start);\n-    os << crc;\n-    size_t osSize = os.size();\n-    assert(osSize == len + sizeof(len) + sizeof(uint8_t));\n-\n+    size_t begin = os.wp();\n+    os << _encoding.getRaw();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aedee2e6d2656164310ec8d0384eb3c3c152cbda"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzNzM1NA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14284#discussion_r483537354", "createdAt": "2020-09-04T10:41:05Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/transactionlog/domainpart.cpp", "diffHunk": "@@ -527,121 +516,84 @@ DomainPart::visit(SerialNumRange &r, Packet &packet)\n bool\n DomainPart::visit(FastOS_FileInterface &file, SerialNumRange &r, Packet &packet)\n {\n-    bool retval(true);\n-    if ( ! file.IsOpened() ) {\n-        retval = openAndFind(file, r.from() + 1);\n+    if ( ! file.IsOpened() && ! openAndFind(file, r.from() + 1)) {\n+        return false;\n     }\n-    if (retval) {\n-        Packet newPacket;\n-        Alloc buf;\n-        for (bool full(false);!full && retval && (r.from() < r.to());) {\n-            Packet::Entry e;\n-            int64_t fPos = file.GetPosition();\n-            retval = read(file, e, buf, false);\n-            if (retval &&\n-                e.valid() &&\n-                (r.from() < e.serial()) &&\n-                (e.serial() <= r.to())) {\n-                try {\n-                    full = addPacket(newPacket, e);\n-                } catch (const std::exception & ex) {\n-                    throw runtime_error(make_string(\"%s : Failed creating packet for visit %s(%\" PRIu64 \") at pos(%\" PRIu64 \", %\" PRIu64 \")\",\n-                                                    ex.what(), file.GetFileName(), file.GetSize(), fPos, file.GetPosition()));\n-                }\n-                if ( !full ) {\n-                    r.from(e.serial());\n-                } else {\n-                    if ( ! file.SetPosition(fPos) ) {\n-                        throw runtime_error(make_string(\"Failed setting read position for file '%s' of size %\" PRId64 \" from %\" PRId64 \" to %\" PRId64 \".\",\n-                                                        file.GetFileName(), file.GetSize(), file.GetPosition(), fPos));\n-                    }\n-                }\n-            }\n-        }\n-        packet = newPacket;\n+\n+    packet = readPacket(file, r, TARGET_PACKET_SIZE, false);\n+    if (!packet.empty()) {\n+        r.from(packet.range().to());\n     }\n \n-    return retval;\n+    return ! packet.empty();\n }\n \n void\n-DomainPart::write(FastOS_FileInterface &file, const Packet::Entry &entry)\n+DomainPart::write(FastOS_FileInterface &file, const IChunk & chunk)\n {\n-    int64_t lastKnownGoodPos(byteSize());\n-    int32_t crc(0);\n-    uint32_t len(entry.serializedSize() + sizeof(crc));\n     nbostream os;\n-    os << static_cast<uint8_t>(_encoding.getRaw());\n-    os << len;\n-    size_t start(os.size());\n-    entry.serialize(os);\n-    size_t end(os.size());\n-    crc = calcCrc(_encoding.getCrc(), os.data() + start, end - start);\n-    os << crc;\n-    size_t osSize = os.size();\n-    assert(osSize == len + sizeof(len) + sizeof(uint8_t));\n-\n+    size_t begin = os.wp();\n+    os << _encoding.getRaw();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMzg1Mw=="}, "originalCommit": {"oid": "aedee2e6d2656164310ec8d0384eb3c3c152cbda"}, "originalPosition": 271}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1375, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}