{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMzIxNjg3", "number": 13734, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMjoxNjozM1rOEJoWfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMjoxNjozM1rOEJoWfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NTMzNzU5OnYy", "diffSide": "RIGHT", "path": "searchlib/src/tests/queryeval/wrappers/wrappers_test.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxMjoxNjozM1rOGqOHtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNjo0NTozOFrOGqt_hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNDcyNg==", "bodyText": "How is the interaction between this app using gtest and SearchIteratorVerifier which uses legacy test macros? Consider using the functionality added in #13728.", "url": "https://github.com/vespa-engine/vespa/pull/13734#discussion_r446924726", "createdAt": "2020-06-29T12:16:33Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/queryeval/wrappers/wrappers_test.cpp", "diffHunk": "@@ -0,0 +1,195 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/searchlib/queryeval/filter_wrapper.h>\n+#include <vespa/searchlib/queryeval/booleanmatchiteratorwrapper.h>\n+#include <vespa/searchlib/fef/termfieldmatchdata.h>\n+#include <vespa/searchlib/test/searchiteratorverifier.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+\n+using namespace search::fef;\n+using namespace search::queryeval;\n+\n+struct ObservedData {\n+    uint32_t seekCnt;\n+    uint32_t unpackCnt;\n+    uint32_t dtorCnt;\n+    uint32_t unpackedDocId;\n+};\n+\n+class WrapperTest : public ::testing::Test {\n+public:\n+    class DummyItr : public SearchIterator {\n+    private:\n+        ObservedData &_data;\n+        TermFieldMatchData *_match;\n+    public:\n+        DummyItr(ObservedData &data, TermFieldMatchData *m) : _data(data), _match(m) {}\n+        ~DummyItr() {\n+            ++_data.dtorCnt;\n+        }\n+        void doSeek(uint32_t docid) override {\n+            ++_data.seekCnt;\n+            if (docid <= 10) {\n+                setDocId(10);\n+            } else if (docid <= 20) {\n+                setDocId(20);\n+            } else {\n+                setAtEnd();\n+            }\n+        }\n+        void doUnpack(uint32_t docid) override {\n+            ++_data.unpackCnt;\n+            if (_match != 0) {\n+                _data.unpackedDocId = docid;\n+            }\n+        }\n+    };\n+    WrapperTest() : _data{0,0,0,0} {}\n+protected:\n+    ObservedData _data;\n+\n+    void verify_unwrapped() {\n+        EXPECT_EQ(_data.seekCnt, 0u);\n+        EXPECT_EQ(_data.unpackCnt, 0u);\n+        EXPECT_EQ(_data.dtorCnt, 0u);\n+\n+        // without wrapper\n+        TermFieldMatchData match;\n+        _data.unpackedDocId = 0;\n+        auto search = std::make_unique<DummyItr>(_data, &match);\n+        search->initFullRange();\n+        EXPECT_EQ(_data.unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQ(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQ(_data.unpackedDocId, 10u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQ(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQ(_data.unpackedDocId, 20u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+\n+        search.reset(nullptr);\n+        EXPECT_EQ(_data.seekCnt, 3u);\n+        EXPECT_EQ(_data.unpackCnt, 2u);\n+        EXPECT_EQ(_data.dtorCnt, 1u);\n+    }\n+};\n+\n+TEST_F(WrapperTest, filter_wrapper)\n+{\n+    verify_unwrapped();\n+\n+    // with FilterWrapper\n+    TermFieldMatchData match;\n+    TermFieldMatchDataArray tfmda;\n+    tfmda.add(&match);\n+    _data.unpackedDocId = 0;\n+    auto search = std::make_unique<FilterWrapper>(1);\n+search->wrap(std::make_unique<DummyItr>(_data, search->tfmda()[0]));\n+    search->initFullRange();\n+    EXPECT_EQ(_data.unpackedDocId, 0u);\n+    EXPECT_TRUE(!search->seek(1u));\n+    EXPECT_EQ(search->getDocId(), 10u);\n+    EXPECT_TRUE(search->seek(10));\n+    search->unpack(10);\n+    EXPECT_EQ(_data.unpackedDocId, 0u);\n+    EXPECT_TRUE(!search->seek(15));\n+    EXPECT_EQ(search->getDocId(), 20u);\n+    EXPECT_TRUE(search->seek(20));\n+    search->unpack(20);\n+    EXPECT_EQ(_data.unpackedDocId, 0u);\n+    EXPECT_TRUE(!search->seek(25));\n+    EXPECT_TRUE(search->isAtEnd());\n+\n+    search.reset(nullptr);\n+    EXPECT_EQ(_data.seekCnt, 6u);\n+    EXPECT_EQ(_data.unpackCnt, 2u);\n+    EXPECT_EQ(_data.dtorCnt, 2u);\n+}\n+\n+TEST_F(WrapperTest, boolean_match_iterator_wrapper)\n+{\n+    verify_unwrapped();\n+    { // with wrapper\n+        TermFieldMatchData match;\n+        TermFieldMatchDataArray tfmda;\n+        tfmda.add(&match);\n+        _data.unpackedDocId = 0;\n+        auto to_wrap = std::make_unique<DummyItr>(_data, &match);\n+        auto search = std::make_unique<BooleanMatchIteratorWrapper>(std::move(to_wrap), tfmda);\n+        search->initFullRange();\n+        EXPECT_EQ(_data.unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQ(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQ(_data.unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQ(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQ(_data.unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQ(_data.seekCnt, 6u);\n+    EXPECT_EQ(_data.unpackCnt, 2u);\n+    EXPECT_EQ(_data.dtorCnt, 2u);\n+    { // with wrapper, without match data\n+\n+        auto to_wrap = std::make_unique<DummyItr>(_data, nullptr);\n+        auto search = std::make_unique<BooleanMatchIteratorWrapper>(std::move(to_wrap), TermFieldMatchDataArray());\n+        search->initFullRange();\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQ(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQ(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQ(_data.seekCnt, 9u);\n+    EXPECT_EQ(_data.unpackCnt, 2u);\n+    EXPECT_EQ(_data.dtorCnt, 3u);\n+}\n+\n+class FilterWrapperVerifier : public search::test::SearchIteratorVerifier {\n+public:\n+    ~FilterWrapperVerifier() {}\n+    SearchIterator::UP create(bool strict) const override {\n+        auto search = std::make_unique<FilterWrapper>(1);\n+        search->wrap(createIterator(getExpectedDocIds(), strict));\n+        return search;\n+    }\n+};\n+\n+TEST(FilterWrapperTest, adheres_to_search_iterator_requirements)\n+{\n+    FilterWrapperVerifier verifier;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e63d84fc2a54686b24757d1b1f3df1cdba4a471a"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0NjkxNw==", "bodyText": "enabled gtest version now.", "url": "https://github.com/vespa-engine/vespa/pull/13734#discussion_r447446917", "createdAt": "2020-06-30T06:45:38Z", "author": {"login": "arnej27959"}, "path": "searchlib/src/tests/queryeval/wrappers/wrappers_test.cpp", "diffHunk": "@@ -0,0 +1,195 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/searchlib/queryeval/filter_wrapper.h>\n+#include <vespa/searchlib/queryeval/booleanmatchiteratorwrapper.h>\n+#include <vespa/searchlib/fef/termfieldmatchdata.h>\n+#include <vespa/searchlib/test/searchiteratorverifier.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+\n+using namespace search::fef;\n+using namespace search::queryeval;\n+\n+struct ObservedData {\n+    uint32_t seekCnt;\n+    uint32_t unpackCnt;\n+    uint32_t dtorCnt;\n+    uint32_t unpackedDocId;\n+};\n+\n+class WrapperTest : public ::testing::Test {\n+public:\n+    class DummyItr : public SearchIterator {\n+    private:\n+        ObservedData &_data;\n+        TermFieldMatchData *_match;\n+    public:\n+        DummyItr(ObservedData &data, TermFieldMatchData *m) : _data(data), _match(m) {}\n+        ~DummyItr() {\n+            ++_data.dtorCnt;\n+        }\n+        void doSeek(uint32_t docid) override {\n+            ++_data.seekCnt;\n+            if (docid <= 10) {\n+                setDocId(10);\n+            } else if (docid <= 20) {\n+                setDocId(20);\n+            } else {\n+                setAtEnd();\n+            }\n+        }\n+        void doUnpack(uint32_t docid) override {\n+            ++_data.unpackCnt;\n+            if (_match != 0) {\n+                _data.unpackedDocId = docid;\n+            }\n+        }\n+    };\n+    WrapperTest() : _data{0,0,0,0} {}\n+protected:\n+    ObservedData _data;\n+\n+    void verify_unwrapped() {\n+        EXPECT_EQ(_data.seekCnt, 0u);\n+        EXPECT_EQ(_data.unpackCnt, 0u);\n+        EXPECT_EQ(_data.dtorCnt, 0u);\n+\n+        // without wrapper\n+        TermFieldMatchData match;\n+        _data.unpackedDocId = 0;\n+        auto search = std::make_unique<DummyItr>(_data, &match);\n+        search->initFullRange();\n+        EXPECT_EQ(_data.unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQ(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQ(_data.unpackedDocId, 10u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQ(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQ(_data.unpackedDocId, 20u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+\n+        search.reset(nullptr);\n+        EXPECT_EQ(_data.seekCnt, 3u);\n+        EXPECT_EQ(_data.unpackCnt, 2u);\n+        EXPECT_EQ(_data.dtorCnt, 1u);\n+    }\n+};\n+\n+TEST_F(WrapperTest, filter_wrapper)\n+{\n+    verify_unwrapped();\n+\n+    // with FilterWrapper\n+    TermFieldMatchData match;\n+    TermFieldMatchDataArray tfmda;\n+    tfmda.add(&match);\n+    _data.unpackedDocId = 0;\n+    auto search = std::make_unique<FilterWrapper>(1);\n+search->wrap(std::make_unique<DummyItr>(_data, search->tfmda()[0]));\n+    search->initFullRange();\n+    EXPECT_EQ(_data.unpackedDocId, 0u);\n+    EXPECT_TRUE(!search->seek(1u));\n+    EXPECT_EQ(search->getDocId(), 10u);\n+    EXPECT_TRUE(search->seek(10));\n+    search->unpack(10);\n+    EXPECT_EQ(_data.unpackedDocId, 0u);\n+    EXPECT_TRUE(!search->seek(15));\n+    EXPECT_EQ(search->getDocId(), 20u);\n+    EXPECT_TRUE(search->seek(20));\n+    search->unpack(20);\n+    EXPECT_EQ(_data.unpackedDocId, 0u);\n+    EXPECT_TRUE(!search->seek(25));\n+    EXPECT_TRUE(search->isAtEnd());\n+\n+    search.reset(nullptr);\n+    EXPECT_EQ(_data.seekCnt, 6u);\n+    EXPECT_EQ(_data.unpackCnt, 2u);\n+    EXPECT_EQ(_data.dtorCnt, 2u);\n+}\n+\n+TEST_F(WrapperTest, boolean_match_iterator_wrapper)\n+{\n+    verify_unwrapped();\n+    { // with wrapper\n+        TermFieldMatchData match;\n+        TermFieldMatchDataArray tfmda;\n+        tfmda.add(&match);\n+        _data.unpackedDocId = 0;\n+        auto to_wrap = std::make_unique<DummyItr>(_data, &match);\n+        auto search = std::make_unique<BooleanMatchIteratorWrapper>(std::move(to_wrap), tfmda);\n+        search->initFullRange();\n+        EXPECT_EQ(_data.unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQ(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_EQ(_data.unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQ(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_EQ(_data.unpackedDocId, 0u);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQ(_data.seekCnt, 6u);\n+    EXPECT_EQ(_data.unpackCnt, 2u);\n+    EXPECT_EQ(_data.dtorCnt, 2u);\n+    { // with wrapper, without match data\n+\n+        auto to_wrap = std::make_unique<DummyItr>(_data, nullptr);\n+        auto search = std::make_unique<BooleanMatchIteratorWrapper>(std::move(to_wrap), TermFieldMatchDataArray());\n+        search->initFullRange();\n+        EXPECT_TRUE(!search->seek(1u));\n+        EXPECT_EQ(search->getDocId(), 10u);\n+        EXPECT_TRUE(search->seek(10));\n+        search->unpack(10);\n+        EXPECT_TRUE(!search->seek(15));\n+        EXPECT_EQ(search->getDocId(), 20u);\n+        EXPECT_TRUE(search->seek(20));\n+        search->unpack(20);\n+        EXPECT_TRUE(!search->seek(25));\n+        EXPECT_TRUE(search->isAtEnd());\n+    }\n+    EXPECT_EQ(_data.seekCnt, 9u);\n+    EXPECT_EQ(_data.unpackCnt, 2u);\n+    EXPECT_EQ(_data.dtorCnt, 3u);\n+}\n+\n+class FilterWrapperVerifier : public search::test::SearchIteratorVerifier {\n+public:\n+    ~FilterWrapperVerifier() {}\n+    SearchIterator::UP create(bool strict) const override {\n+        auto search = std::make_unique<FilterWrapper>(1);\n+        search->wrap(createIterator(getExpectedDocIds(), strict));\n+        return search;\n+    }\n+};\n+\n+TEST(FilterWrapperTest, adheres_to_search_iterator_requirements)\n+{\n+    FilterWrapperVerifier verifier;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNDcyNg=="}, "originalCommit": {"oid": "e63d84fc2a54686b24757d1b1f3df1cdba4a471a"}, "originalPosition": 175}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1916, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}