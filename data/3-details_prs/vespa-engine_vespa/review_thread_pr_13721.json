{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNTMzMzIx", "number": 13721, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjo1Nzo0NlrOEJH4fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzowMTozMVrOEJH9Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDAxNzkwOnYy", "diffSide": "RIGHT", "path": "searchlib/src/tests/tensor/distance_functions/distance_functions_test.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjo1Nzo0NlrOGpf5bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMjo1Nzo0NlrOGpf5bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2NzQwNQ==", "bodyText": "Consider creating one test function per distance function. Makes it easier to read the tests.", "url": "https://github.com/vespa-engine/vespa/pull/13721#discussion_r446167405", "createdAt": "2020-06-26T12:57:46Z", "author": {"login": "geirst"}, "path": "searchlib/src/tests/tensor/distance_functions/distance_functions_test.cpp", "diffHunk": "@@ -37,6 +37,7 @@ TEST(DistanceFunctionsTest, gives_expected_score)\n \n     auto euclid = make_distance_function(DistanceMetric::Euclidean, ct);\n     auto angular = make_distance_function(DistanceMetric::Angular, ct);\n+    auto innerproduct = make_distance_function(DistanceMetric::InnerProduct, ct);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e273894fc49c215764c9beb4270ea206038af5f"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MDAyOTkxOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/tensor/distance_functions.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzowMTozMVrOGpgBGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzowMTozMVrOGpgBGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2OTM2OQ==", "bodyText": "Consider using 'inner product' in description.", "url": "https://github.com/vespa-engine/vespa/pull/13721#discussion_r446169369", "createdAt": "2020-06-26T13:01:31Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/distance_functions.h", "diffHunk": "@@ -54,14 +54,55 @@ template class SquaredEuclideanDistance<float>;\n template class SquaredEuclideanDistance<double>;\n \n /**\n- * Calculates angular distance between vectors with assumed norm 1.\n+ * Calculates angular distance between vectors\n  */\n template <typename FloatType>\n class AngularDistance : public DistanceFunction {\n public:\n     AngularDistance()\n         : _computer(vespalib::hwaccelrated::IAccelrated::getAccelerator())\n     {}\n+    double calc(const vespalib::tensor::TypedCells& lhs, const vespalib::tensor::TypedCells& rhs) const override {\n+        auto lhs_vector = lhs.typify<FloatType>();\n+        auto rhs_vector = rhs.typify<FloatType>();\n+        size_t sz = lhs_vector.size();\n+        assert(sz == rhs_vector.size());\n+        auto a = &lhs_vector[0];\n+        auto b = &rhs_vector[0];\n+        double a_norm_sq = _computer.dotProduct(a, a, sz);\n+        double b_norm_sq = _computer.dotProduct(b, b, sz);\n+        double dot_product = _computer.dotProduct(a, b, sz);\n+        double div = sqrt(a_norm_sq * b_norm_sq);\n+        double cosine_similarity = (div > 0) ? (dot_product / div) : 0.0; // [-1, 1]\n+        double score = (1.0 - cosine_similarity) * 0.5; // [1, 0]\n+        return score;\n+    }\n+    double to_rawscore(double distance) const override {\n+        double score = 1.0 - distance;\n+        return score;\n+    }\n+    double calc_with_limit(const vespalib::tensor::TypedCells& lhs,\n+                           const vespalib::tensor::TypedCells& rhs,\n+                           double /*limit*/) const override\n+    {\n+        return calc(lhs, rhs);\n+    }\n+\n+    const vespalib::hwaccelrated::IAccelrated & _computer;\n+};\n+\n+template class AngularDistance<float>;\n+template class AngularDistance<double>;\n+\n+/**\n+ * Calculates angular distance between vectors with assumed norm 1.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e273894fc49c215764c9beb4270ea206038af5f"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1908, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}