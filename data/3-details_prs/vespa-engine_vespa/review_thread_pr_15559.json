{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwMjQyNzU1", "number": 15559, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0NzozM1rOE_IoCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0OToxOVrOE_IqaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM3MDY2OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0NzozM1rOH8rDlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo0ODo1MlrOH8tV9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjAzOA==", "bodyText": "use TensorSpec::from_expr here", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533382038", "createdAt": "2020-12-01T12:47:33Z", "author": {"login": "havardpe"}, "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -77,14 +78,14 @@ void verify_impl(const vespalib::string &expr, const vespalib::string &expect) {\n     verify_impl<T>(expr, expect, [](const T*){});\n }\n \n-void verify_generic(const vespalib::string &expr, const vespalib::string &expect,\n-                    EvalMode expect_eval_mode)\n-{\n-    verify_impl<DenseLambdaFunction>(expr, expect,\n-                                     [&](const DenseLambdaFunction *info)\n-                                     {\n-                                         EXPECT_EQUAL(info->eval_mode(), expect_eval_mode);\n-                                     });\n+void verify_not_optimized(const vespalib::string &expr, const vespalib::string &expect) {\n+    EvalFixture fixture(prod_factory, expr, param_repo, true);\n+    EvalFixture simple_factory_fixture(simple_factory, expr, param_repo, false);\n+    EXPECT_EQUAL(fixture.result(), simple_factory_fixture.result());\n+    EXPECT_EQUAL(fixture.result(), EvalFixture::ref(expr, param_repo));\n+    EXPECT_EQUAL(fixture.result(), EvalFixture::ref(expect, param_repo));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c85fa192079701624b2f763a61bb17821fa7594a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxOTUwOQ==", "bodyText": "some of the \"expect\" expressions reference the param_repo, so that didn't work.", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533419509", "createdAt": "2020-12-01T13:48:52Z", "author": {"login": "arnej27959"}, "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -77,14 +78,14 @@ void verify_impl(const vespalib::string &expr, const vespalib::string &expect) {\n     verify_impl<T>(expr, expect, [](const T*){});\n }\n \n-void verify_generic(const vespalib::string &expr, const vespalib::string &expect,\n-                    EvalMode expect_eval_mode)\n-{\n-    verify_impl<DenseLambdaFunction>(expr, expect,\n-                                     [&](const DenseLambdaFunction *info)\n-                                     {\n-                                         EXPECT_EQUAL(info->eval_mode(), expect_eval_mode);\n-                                     });\n+void verify_not_optimized(const vespalib::string &expr, const vespalib::string &expect) {\n+    EvalFixture fixture(prod_factory, expr, param_repo, true);\n+    EvalFixture simple_factory_fixture(simple_factory, expr, param_repo, false);\n+    EXPECT_EQUAL(fixture.result(), simple_factory_fixture.result());\n+    EXPECT_EQUAL(fixture.result(), EvalFixture::ref(expr, param_repo));\n+    EXPECT_EQUAL(fixture.result(), EvalFixture::ref(expect, param_repo));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjAzOA=="}, "originalCommit": {"oid": "c85fa192079701624b2f763a61bb17821fa7594a"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM3NTc2OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0OTowNFrOH8rGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo0OTowNFrOH8tWgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4Mjg1NQ==", "bodyText": "I like the verify_generic name better here", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533382855", "createdAt": "2020-12-01T12:49:04Z", "author": {"login": "havardpe"}, "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -77,14 +78,14 @@ void verify_impl(const vespalib::string &expr, const vespalib::string &expect) {\n     verify_impl<T>(expr, expect, [](const T*){});\n }\n \n-void verify_generic(const vespalib::string &expr, const vespalib::string &expect,\n-                    EvalMode expect_eval_mode)\n-{\n-    verify_impl<DenseLambdaFunction>(expr, expect,\n-                                     [&](const DenseLambdaFunction *info)\n-                                     {\n-                                         EXPECT_EQUAL(info->eval_mode(), expect_eval_mode);\n-                                     });\n+void verify_not_optimized(const vespalib::string &expr, const vespalib::string &expect) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c85fa192079701624b2f763a61bb17821fa7594a"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxOTY0OA==", "bodyText": "done.", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533419648", "createdAt": "2020-12-01T13:49:04Z", "author": {"login": "arnej27959"}, "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -77,14 +78,14 @@ void verify_impl(const vespalib::string &expr, const vespalib::string &expect) {\n     verify_impl<T>(expr, expect, [](const T*){});\n }\n \n-void verify_generic(const vespalib::string &expr, const vespalib::string &expect,\n-                    EvalMode expect_eval_mode)\n-{\n-    verify_impl<DenseLambdaFunction>(expr, expect,\n-                                     [&](const DenseLambdaFunction *info)\n-                                     {\n-                                         EXPECT_EQUAL(info->eval_mode(), expect_eval_mode);\n-                                     });\n+void verify_not_optimized(const vespalib::string &expr, const vespalib::string &expect) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4Mjg1NQ=="}, "originalCommit": {"oid": "c85fa192079701624b2f763a61bb17821fa7594a"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjM3NjcyOnYy", "diffSide": "RIGHT", "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjo0OToxOVrOH8rHXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo0OToxNFrOH8tW9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzAwNA==", "bodyText": "feel free to just remove this now", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533383004", "createdAt": "2020-12-01T12:49:19Z", "author": {"login": "havardpe"}, "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -184,13 +157,92 @@ TEST(\"require that non-continuous cell extraction is optimized\") {\n     TEST_DO(verify_idx_fun(\"tensor<float>(x[3])(x3y5f{x:(x),y:2})\", \"x3y5f{y:2}\", \"f(x)((floor(x)*5)+2)\"));\n }\n \n+TEST(\"require that simple dynamic tensor lambda works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x+a)\", \"tensor(x[3]):[1,2,3]\"));\n+}\n+\n+TEST(\"require that compiled multi-dimensional multi-param dynamic tensor lambda works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3],y[2])((b-a)+x+y)\", \"tensor(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+    TEST_DO(verify_not_optimized(\"tensor<float>(x[3],y[2])((b-a)+x+y)\", \"tensor<float>(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+}\n+\n+TEST(\"require that interpreted multi-dimensional multi-param dynamic tensor lambda works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3],y[2])((x3{x:(a)}-a)+x+y)\", \"tensor(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+    TEST_DO(verify_not_optimized(\"tensor<float>(x[3],y[2])((x3{x:(a)}-a)+x+y)\", \"tensor<float>(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+}\n+\n+TEST(\"require that tensor lambda can be used for tensor slicing\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(x3{x:(x+a)})\", \"tensor(x[2]):[2,3]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(a+x3{x:(x)})\", \"tensor(x[2]):[2,3]\"));\n+}\n+\n+TEST(\"require that tensor lambda can be used to convert from sparse to dense tensors\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3m{x:(x)})\", \"tensor(x[3]):[1,2,3]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(x3m{x:(x)})\", \"tensor(x[2]):[1,2]\"));\n+}\n+\n+TEST(\"require that dynamic nested tensor lambda using tensor peek works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(tensor(y[2])((x+y)+a){y:(x)})\", \"tensor(x[2]):[1,3]\"));\n+}\n+\n+TEST(\"require that out-of-bounds cell extraction is not optimized\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:1,y:(x+3)})\", \"tensor(x[3]):[9,10,0]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:1,y:(x-1)})\", \"tensor(x[3]):[0,6,7]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:(x+1),y:(x)})\", \"tensor(x[3]):[6,12,0]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:(x-1),y:(x)})\", \"tensor(x[3]):[0,2,8]\"));\n+}\n+\n+//---------------------------------------------------------------------------\n+// to be removed when DefaultTensorEngine is removed:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c85fa192079701624b2f763a61bb17821fa7594a"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxOTc2NQ==", "bodyText": "done.", "url": "https://github.com/vespa-engine/vespa/pull/15559#discussion_r533419765", "createdAt": "2020-12-01T13:49:14Z", "author": {"login": "arnej27959"}, "path": "eval/src/tests/eval/tensor_lambda/tensor_lambda_test.cpp", "diffHunk": "@@ -184,13 +157,92 @@ TEST(\"require that non-continuous cell extraction is optimized\") {\n     TEST_DO(verify_idx_fun(\"tensor<float>(x[3])(x3y5f{x:(x),y:2})\", \"x3y5f{y:2}\", \"f(x)((floor(x)*5)+2)\"));\n }\n \n+TEST(\"require that simple dynamic tensor lambda works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x+a)\", \"tensor(x[3]):[1,2,3]\"));\n+}\n+\n+TEST(\"require that compiled multi-dimensional multi-param dynamic tensor lambda works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3],y[2])((b-a)+x+y)\", \"tensor(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+    TEST_DO(verify_not_optimized(\"tensor<float>(x[3],y[2])((b-a)+x+y)\", \"tensor<float>(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+}\n+\n+TEST(\"require that interpreted multi-dimensional multi-param dynamic tensor lambda works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3],y[2])((x3{x:(a)}-a)+x+y)\", \"tensor(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+    TEST_DO(verify_not_optimized(\"tensor<float>(x[3],y[2])((x3{x:(a)}-a)+x+y)\", \"tensor<float>(x[3],y[2]):[[1,2],[2,3],[3,4]]\"));\n+}\n+\n+TEST(\"require that tensor lambda can be used for tensor slicing\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(x3{x:(x+a)})\", \"tensor(x[2]):[2,3]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(a+x3{x:(x)})\", \"tensor(x[2]):[2,3]\"));\n+}\n+\n+TEST(\"require that tensor lambda can be used to convert from sparse to dense tensors\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3m{x:(x)})\", \"tensor(x[3]):[1,2,3]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(x3m{x:(x)})\", \"tensor(x[2]):[1,2]\"));\n+}\n+\n+TEST(\"require that dynamic nested tensor lambda using tensor peek works\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[2])(tensor(y[2])((x+y)+a){y:(x)})\", \"tensor(x[2]):[1,3]\"));\n+}\n+\n+TEST(\"require that out-of-bounds cell extraction is not optimized\") {\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:1,y:(x+3)})\", \"tensor(x[3]):[9,10,0]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:1,y:(x-1)})\", \"tensor(x[3]):[0,6,7]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:(x+1),y:(x)})\", \"tensor(x[3]):[6,12,0]\"));\n+    TEST_DO(verify_not_optimized(\"tensor(x[3])(x3y5{x:(x-1),y:(x)})\", \"tensor(x[3]):[0,2,8]\"));\n+}\n+\n+//---------------------------------------------------------------------------\n+// to be removed when DefaultTensorEngine is removed:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzAwNA=="}, "originalCommit": {"oid": "c85fa192079701624b2f763a61bb17821fa7594a"}, "originalPosition": 115}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 752, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}