{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2ODUyNjEy", "number": 14677, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjozODo1NlrOEpzGfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjo0MzoyM1rOEpzL1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjY0MzE5OnYy", "diffSide": "RIGHT", "path": "searchcore/src/apps/vespa-feed-bm/bm_message_bus.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjozODo1NlrOHbsBfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjozODo1NlrOHbsBfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NDg3Nw==", "bodyText": "= default ?", "url": "https://github.com/vespa-engine/vespa/pull/14677#discussion_r498794877", "createdAt": "2020-10-02T12:38:56Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/apps/vespa-feed-bm/bm_message_bus.cpp", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"bm_message_bus.h\"\n+#include \"pending_tracker_hash.h\"\n+#include \"pending_tracker.h\"\n+#include \"storage_reply_error_checker.h\"\n+#include <vespa/messagebus/emptyreply.h>\n+#include <vespa/messagebus/network/rpcnetworkparams.h>\n+#include <vespa/messagebus/rpcmessagebus.h>\n+#include <vespa/messagebus/ireplyhandler.h>\n+#include <vespa/documentapi/messagebus/documentprotocol.h>\n+#include <vespa/documentapi/messagebus/messages/documentmessage.h>\n+#include <vespa/storageapi/mbusprot/storageprotocol.h>\n+#include <vespa/storageapi/mbusprot/storagereply.h>\n+#include <vespa/vespalib/stllike/asciistream.h>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".bm_message_bus\");\n+\n+using documentapi::DocumentProtocol;\n+using mbus::RPCMessageBus;\n+using mbus::Reply;\n+using mbus::SourceSession;\n+using storage::mbusprot::StorageProtocol;\n+using storage::mbusprot::StorageReply;\n+\n+namespace feedbm {\n+\n+namespace {\n+\n+std::atomic<uint64_t> bm_message_bus_msg_id(0u);\n+\n+vespalib::string reply_as_string(Reply &reply) {\n+    vespalib::asciistream os;\n+    if (reply.getType() == 0) {\n+        os << \"empty reply\";\n+    } else {\n+        os << \"reply=\" << reply.toString() << \", protocol=\" << reply.getProtocol();\n+    }\n+    os << \", \";\n+    auto message = reply.getMessage();\n+    if (message) {\n+        os << \"message=\" << message->toString();\n+        os << \", protocol=\" << message->getProtocol();\n+    } else {\n+        os << \"no message\";\n+    }\n+    reply.setMessage(std::move(message));\n+    os << \", \";\n+    if (reply.hasErrors()) {\n+        os << \"errors=[\";\n+        for (uint32_t i = 0; i < reply.getNumErrors(); ++i) {\n+            auto &error = reply.getError(i);\n+            if (i > 0) {\n+                os << \", \";\n+            }\n+            os << mbus::ErrorCode::getName(error.getCode()) << \": \" << error.getMessage() << \" (from \" << error.getService() << \")\";\n+        }\n+        os << \"]\";\n+    } else {\n+        os << \"no errors\";\n+    }\n+    return os.str();\n+}\n+\n+}\n+\n+class BmMessageBus::ReplyHandler : public mbus::IReplyHandler,\n+                                   public StorageReplyErrorChecker\n+{\n+    PendingTrackerHash _pending_hash;\n+public:\n+    ReplyHandler();\n+    ~ReplyHandler() override;\n+    void handleReply(std::unique_ptr<Reply> reply) override;\n+    void retain(uint64_t msg_id, PendingTracker &tracker) { _pending_hash.retain(msg_id, tracker); }\n+    void message_aborted(uint64_t msg_id);\n+};\n+\n+BmMessageBus::ReplyHandler::ReplyHandler()\n+    : mbus::IReplyHandler(),\n+      StorageReplyErrorChecker(),\n+      _pending_hash()\n+{\n+}\n+\n+BmMessageBus::ReplyHandler::~ReplyHandler()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3df7eb2b1c78d0a180df55f6749d356499d86b7b"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjY0ODE2OnYy", "diffSide": "RIGHT", "path": "searchcore/src/apps/vespa-feed-bm/bm_message_bus.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjo0MDozOFrOHbsEqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjo0MDozOFrOHbsEqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NTY4OQ==", "bodyText": "Won't = default achieve the same.", "url": "https://github.com/vespa-engine/vespa/pull/14677#discussion_r498795689", "createdAt": "2020-10-02T12:40:38Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/apps/vespa-feed-bm/bm_message_bus.cpp", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"bm_message_bus.h\"\n+#include \"pending_tracker_hash.h\"\n+#include \"pending_tracker.h\"\n+#include \"storage_reply_error_checker.h\"\n+#include <vespa/messagebus/emptyreply.h>\n+#include <vespa/messagebus/network/rpcnetworkparams.h>\n+#include <vespa/messagebus/rpcmessagebus.h>\n+#include <vespa/messagebus/ireplyhandler.h>\n+#include <vespa/documentapi/messagebus/documentprotocol.h>\n+#include <vespa/documentapi/messagebus/messages/documentmessage.h>\n+#include <vespa/storageapi/mbusprot/storageprotocol.h>\n+#include <vespa/storageapi/mbusprot/storagereply.h>\n+#include <vespa/vespalib/stllike/asciistream.h>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".bm_message_bus\");\n+\n+using documentapi::DocumentProtocol;\n+using mbus::RPCMessageBus;\n+using mbus::Reply;\n+using mbus::SourceSession;\n+using storage::mbusprot::StorageProtocol;\n+using storage::mbusprot::StorageReply;\n+\n+namespace feedbm {\n+\n+namespace {\n+\n+std::atomic<uint64_t> bm_message_bus_msg_id(0u);\n+\n+vespalib::string reply_as_string(Reply &reply) {\n+    vespalib::asciistream os;\n+    if (reply.getType() == 0) {\n+        os << \"empty reply\";\n+    } else {\n+        os << \"reply=\" << reply.toString() << \", protocol=\" << reply.getProtocol();\n+    }\n+    os << \", \";\n+    auto message = reply.getMessage();\n+    if (message) {\n+        os << \"message=\" << message->toString();\n+        os << \", protocol=\" << message->getProtocol();\n+    } else {\n+        os << \"no message\";\n+    }\n+    reply.setMessage(std::move(message));\n+    os << \", \";\n+    if (reply.hasErrors()) {\n+        os << \"errors=[\";\n+        for (uint32_t i = 0; i < reply.getNumErrors(); ++i) {\n+            auto &error = reply.getError(i);\n+            if (i > 0) {\n+                os << \", \";\n+            }\n+            os << mbus::ErrorCode::getName(error.getCode()) << \": \" << error.getMessage() << \" (from \" << error.getService() << \")\";\n+        }\n+        os << \"]\";\n+    } else {\n+        os << \"no errors\";\n+    }\n+    return os.str();\n+}\n+\n+}\n+\n+class BmMessageBus::ReplyHandler : public mbus::IReplyHandler,\n+                                   public StorageReplyErrorChecker\n+{\n+    PendingTrackerHash _pending_hash;\n+public:\n+    ReplyHandler();\n+    ~ReplyHandler() override;\n+    void handleReply(std::unique_ptr<Reply> reply) override;\n+    void retain(uint64_t msg_id, PendingTracker &tracker) { _pending_hash.retain(msg_id, tracker); }\n+    void message_aborted(uint64_t msg_id);\n+};\n+\n+BmMessageBus::ReplyHandler::ReplyHandler()\n+    : mbus::IReplyHandler(),\n+      StorageReplyErrorChecker(),\n+      _pending_hash()\n+{\n+}\n+\n+BmMessageBus::ReplyHandler::~ReplyHandler()\n+{\n+}\n+\n+void\n+BmMessageBus::ReplyHandler::handleReply(std::unique_ptr<Reply> reply)\n+{\n+    auto msg_id = reply->getContext().value.UINT64;\n+    auto tracker = _pending_hash.release(msg_id);\n+    if (tracker != nullptr) {\n+        bool failed = false;\n+        if (reply->getType() == 0 || reply->hasErrors()) {\n+            failed = true; // empty reply or error\n+        } else {\n+            auto protocol = reply->getProtocol();\n+            if (protocol == DocumentProtocol::NAME) {\n+            } else if (protocol == StorageProtocol::NAME) {\n+                auto sreply = dynamic_cast<storage::mbusprot::StorageReply *>(reply.get());\n+                if (sreply != nullptr) {\n+                    check_error(*sreply->getReply());\n+                } else {\n+                    failed = true; // unexpected message type\n+                }\n+            } else {\n+                failed = true; // unexpected protocol\n+            }\n+        }\n+        if (failed) {\n+            ++_errors;\n+            LOG(error, \"Unexpected %s\", reply_as_string(*reply).c_str());\n+        }\n+        tracker->release();\n+    } else {\n+        ++_errors;\n+        LOG(error, \"Untracked %s\", reply_as_string(*reply).c_str());\n+    }\n+}\n+\n+void\n+BmMessageBus::ReplyHandler::message_aborted(uint64_t msg_id)\n+{\n+    ++_errors;\n+    auto tracker = _pending_hash.release(msg_id);\n+    tracker->release();\n+}\n+\n+BmMessageBus::BmMessageBus(const config::ConfigUri& config_uri,\n+                           std::shared_ptr<const document::DocumentTypeRepo> document_type_repo,\n+                           const documentapi::LoadTypeSet& load_types)\n+    : _reply_handler(std::make_unique<ReplyHandler>()),\n+      _message_bus(),\n+      _session()\n+{\n+    mbus::RPCNetworkParams params(config_uri);\n+    mbus::ProtocolSet protocol_set;\n+    protocol_set.add(std::make_shared<DocumentProtocol>(load_types, document_type_repo));\n+    protocol_set.add(std::make_shared<StorageProtocol>(document_type_repo, load_types));\n+    params.setIdentity(mbus::Identity(\"vespa-bm-client\"));\n+    _message_bus = std::make_unique<mbus::RPCMessageBus>(\n+            protocol_set,\n+            params,\n+            config_uri);\n+    mbus::SourceSessionParams srcParams;\n+    srcParams.setThrottlePolicy(mbus::IThrottlePolicy::SP());\n+    srcParams.setReplyHandler(*_reply_handler);\n+    _session = _message_bus->getMessageBus().createSourceSession(srcParams);\n+}\n+\n+BmMessageBus::~BmMessageBus()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3df7eb2b1c78d0a180df55f6749d356499d86b7b"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjY1Njg1OnYy", "diffSide": "RIGHT", "path": "searchcore/src/apps/vespa-feed-bm/document_api_message_bus_bm_feed_handler.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjo0MzoyM1rOHbsKEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjo0MzoyM1rOHbsKEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NzA3NQ==", "bodyText": "Is it not better to just drop the naming the variables as they are named in the interface. Keeping them does not add any value.", "url": "https://github.com/vespa-engine/vespa/pull/14677#discussion_r498797075", "createdAt": "2020-10-02T12:43:23Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/apps/vespa-feed-bm/document_api_message_bus_bm_feed_handler.cpp", "diffHunk": "@@ -0,0 +1,88 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"document_api_message_bus_bm_feed_handler.h\"\n+#include \"bm_message_bus.h\"\n+#include \"pending_tracker.h\"\n+#include <vespa/document/fieldvalue/document.h>\n+#include <vespa/document/update/documentupdate.h>\n+#include <vespa/documentapi/messagebus/messages/putdocumentmessage.h>\n+#include <vespa/documentapi/messagebus/messages/removedocumentmessage.h>\n+#include <vespa/documentapi/messagebus/messages/updatedocumentmessage.h>\n+#include <vespa/storageapi/messageapi/storagemessage.h>\n+\n+using document::Document;\n+using document::DocumentId;\n+using document::DocumentUpdate;\n+using storage::api::StorageMessageAddress;\n+using storage::lib::NodeType;\n+\n+namespace feedbm {\n+\n+DocumentApiMessageBusBmFeedHandler::DocumentApiMessageBusBmFeedHandler(BmMessageBus &message_bus)\n+    : IBmFeedHandler(),\n+      _name(vespalib::string(\"DocumentApiMessageBusBmFeedHandler(distributor)\")),\n+      _storage_address(std::make_unique<StorageMessageAddress>(\"storage\", NodeType::DISTRIBUTOR, 0)),\n+      _message_bus(message_bus)\n+{\n+}\n+\n+DocumentApiMessageBusBmFeedHandler::~DocumentApiMessageBusBmFeedHandler() = default;\n+\n+void\n+DocumentApiMessageBusBmFeedHandler::send_msg(std::unique_ptr<documentapi::DocumentMessage> msg, PendingTracker& pending_tracker)\n+{\n+    _message_bus.send_msg(std::move(msg), _storage_address->getRoute(), pending_tracker);\n+}\n+\n+void\n+DocumentApiMessageBusBmFeedHandler::put(const document::Bucket& bucket, std::unique_ptr<Document> document, uint64_t timestamp, PendingTracker& tracker)\n+{\n+    (void) bucket;\n+    (void) timestamp;\n+    auto msg = std::make_unique<documentapi::PutDocumentMessage>(std::move(document));\n+    send_msg(std::move(msg), tracker);\n+}\n+\n+void\n+DocumentApiMessageBusBmFeedHandler::update(const document::Bucket& bucket, std::unique_ptr<DocumentUpdate> document_update, uint64_t timestamp, PendingTracker& tracker)\n+{\n+    (void) bucket;\n+    (void) timestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3df7eb2b1c78d0a180df55f6749d356499d86b7b"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1290, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}