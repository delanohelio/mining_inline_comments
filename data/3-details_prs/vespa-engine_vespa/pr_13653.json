{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3NzQzNTQw", "number": 13653, "title": "Tgm/application package", "bodyText": "This PR contains:\n\nCode and unit tests to create application package files (package.py and test_package.py)\nJinja 2 templates for schema.sd, hosts.xml and services.xml\nJupyter notebook showing a full working example of creating a package and deploying it locally from python.\nVespa Cloud deployment will be addressed in a future sprint.\nImplemented json serialization for every python object to be able to save and load the application from python.\n\nI confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.", "createdAt": "2020-06-22T07:33:16Z", "url": "https://github.com/vespa-engine/vespa/pull/13653", "merged": true, "mergeCommit": {"oid": "01608842ffabc5e9dd79101f26ec41fa096bb2ab"}, "closed": true, "closedAt": "2020-07-07T18:41:03Z", "author": {"login": "thigm85"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABctrfPfgH2gAyNDM3NzQzNTQwOjkxZjc5NjBkYzAxODVkYjdlNmE1OWQxMTMxODdhOWY3YzIwZGRiY2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcykErJgFqTQ0Mzc5Nzk1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "91f7960dc0185db7e6a59d113187a9f7c20ddbcb", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/91f7960dc0185db7e6a59d113187a9f7c20ddbcb", "committedDate": "2020-06-22T07:12:43Z", "message": "include application package page"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e7a2f2ebfc0d7a84706145f32d5b375d9f7e15b", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/3e7a2f2ebfc0d7a84706145f32d5b375d9f7e15b", "committedDate": "2020-06-22T07:12:59Z", "message": "include docker library dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f738a456d43288b033ab69463dbf6d66b1426d5", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/2f738a456d43288b033ab69463dbf6d66b1426d5", "committedDate": "2020-06-22T07:13:52Z", "message": "include ApplicationPackage code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd6b49e6c3a396b201fb0505181e840f323970ea", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/fd6b49e6c3a396b201fb0505181e840f323970ea", "committedDate": "2020-06-25T13:15:13Z", "message": "add class for serialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0702e5fba074ebd9bf0033acba60c35aa07b33c3", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/0702e5fba074ebd9bf0033acba60c35aa07b33c3", "committedDate": "2020-06-25T13:16:15Z", "message": "add code to deploy locally and start to implement the api to create application package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "492a2a614d59c3eed7eeaf4118e805421e2cfaa6", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/492a2a614d59c3eed7eeaf4118e805421e2cfaa6", "committedDate": "2020-06-25T13:16:39Z", "message": "start to unit test the code to create application package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a210d61d3be04397c814795f292d755d28d4017", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/9a210d61d3be04397c814795f292d755d28d4017", "committedDate": "2020-06-27T20:49:33Z", "message": "implement document and field set"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c51c4daace20e42d9bdc5fda2c62bc117c4bf392", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/c51c4daace20e42d9bdc5fda2c62bc117c4bf392", "committedDate": "2020-06-29T12:22:31Z", "message": "implement rank profile and schema"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2800e149a2cdcb3ec90ed6725ccbddc9ee5bdd4a", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/2800e149a2cdcb3ec90ed6725ccbddc9ee5bdd4a", "committedDate": "2020-07-02T10:42:47Z", "message": "add jinja 2 dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08db10b5950570373dd13851bebedae0f76f95dc", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/08db10b5950570373dd13851bebedae0f76f95dc", "committedDate": "2020-07-02T10:43:29Z", "message": "add application package serialization code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49edbc6ebb6baac6eb1c402b6bcbec5136d95092", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/49edbc6ebb6baac6eb1c402b6bcbec5136d95092", "committedDate": "2020-07-02T10:43:40Z", "message": "schema template"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddd7cd7c804261993f04d8a4cabe5720f5cec605", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/ddd7cd7c804261993f04d8a4cabe5720f5cec605", "committedDate": "2020-07-02T12:39:24Z", "message": "add hosts and services template"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1409de59e3b549424c7226c622e2b31a271e276a", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/1409de59e3b549424c7226c622e2b31a271e276a", "committedDate": "2020-07-02T12:39:46Z", "message": "hosts and services template files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "018520297d97b9573aeaf482b133abf98c86a0eb", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/018520297d97b9573aeaf482b133abf98c86a0eb", "committedDate": "2020-07-02T20:18:28Z", "message": "write application files before local deployment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff656a5b6a9eaf0314731cafbd16e9069302820b", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/ff656a5b6a9eaf0314731cafbd16e9069302820b", "committedDate": "2020-07-03T07:13:32Z", "message": "application package notebook"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51f219bc4ddb0d9999bff9fcc7738db275298b0c", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/51f219bc4ddb0d9999bff9fcc7738db275298b0c", "committedDate": "2020-07-03T07:18:59Z", "message": "update disk path"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5", "committedDate": "2020-07-03T07:36:45Z", "message": "set deploy code to text"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTA2MzQy", "url": "https://github.com/vespa-engine/vespa/pull/13653#pullrequestreview-442906342", "createdAt": "2020-07-06T09:13:51Z", "commit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxMzo1MVrOGtPTjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOTozOToxNlrOGtQK5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4OTg3MA==", "bodyText": "I think list() here is redundant.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450089870", "createdAt": "2020-07-06T09:13:51Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MjM0Ng==", "bodyText": "I would avoid \\n in __repr__. It's better to have it on one line. __repr__ should attempt to look like a Python expressions while __str__ is for informal string representation. See https://docs.python.org/3/reference/datamodel.html#object.__repr__.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450092346", "createdAt": "2020-07-06T09:18:07Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MjY3OQ==", "bodyText": "See __repr__ comment below.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450092679", "createdAt": "2020-07-06T09:18:43Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MjgwMg==", "bodyText": "See __repr__ comment above.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450092802", "createdAt": "2020-07-06T09:18:57Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5NTcwMQ==", "bodyText": "Just a different style, it might not be more clear: self.fields = [] if not fields else fields.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450095701", "createdAt": "2020-07-06T09:24:13Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5NjYyMw==", "bodyText": "See __repr__ above.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450096623", "createdAt": "2020-07-06T09:25:47Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5NzgzNA==", "bodyText": "Why .update() instead of just self.rank_profiles[rank_profile.name] = rank_profile?", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450097834", "createdAt": "2020-07-06T09:27:54Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5ODAyMw==", "bodyText": "See __repr__ above.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450098023", "createdAt": "2020-07-06T09:28:14Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Schema\":\n+        return Schema(\n+            name=mapping[\"name\"],\n+            document=FromJson.map(mapping[\"document\"]),\n+            fieldsets=[FromJson.map(fieldset) for fieldset in mapping[\"fieldsets\"]],\n+            rank_profiles=[\n+                FromJson.map(rank_profile) for rank_profile in mapping[\"rank_profiles\"]\n+            ],\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\n+            \"name\": self.name,\n+            \"document\": self.document.to_envelope,\n+            \"fieldsets\": [\n+                self.fieldsets[name].to_envelope for name in self.fieldsets.keys()\n+            ],\n+            \"rank_profiles\": [\n+                self.rank_profiles[name].to_envelope\n+                for name in self.rank_profiles.keys()\n+            ],\n+        }\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.document == other.document\n+            and self.fieldsets == other.fieldsets\n+            and self.rank_profiles == other.rank_profiles\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5OTczNA==", "bodyText": "There are a few methods in this class that related to running the application. I would pull those out into a separate class or just have them as regular functions outside a class. Then it would be easier to have VespaCloud.run(app) and VespaDocker.run(app) and ApplicationPackage just becomes a data container.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450099734", "createdAt": "2020-07-06T09:31:13Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Schema\":\n+        return Schema(\n+            name=mapping[\"name\"],\n+            document=FromJson.map(mapping[\"document\"]),\n+            fieldsets=[FromJson.map(fieldset) for fieldset in mapping[\"fieldsets\"]],\n+            rank_profiles=[\n+                FromJson.map(rank_profile) for rank_profile in mapping[\"rank_profiles\"]\n+            ],\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\n+            \"name\": self.name,\n+            \"document\": self.document.to_envelope,\n+            \"fieldsets\": [\n+                self.fieldsets[name].to_envelope for name in self.fieldsets.keys()\n+            ],\n+            \"rank_profiles\": [\n+                self.rank_profiles[name].to_envelope\n+                for name in self.rank_profiles.keys()\n+            ],\n+        }\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.document == other.document\n+            and self.fieldsets == other.fieldsets\n+            and self.rank_profiles == other.rank_profiles\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class ApplicationPackage(ToJson, FromJson[\"ApplicationPackage\"]):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwMzg4Mw==", "bodyText": "I don't think this is necessary. The indexing docproc cluster is implicitly there.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450103883", "createdAt": "2020-07-06T09:39:00Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/templates/services.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<services version=\"1.0\">\n+    <container id=\"{{ application_name }}_container\" version=\"1.0\">\n+        <search></search>\n+        <document-processing></document-processing>\n+        <document-api></document-api>\n+    </container>\n+    <content id=\"{{ application_name }}_content\" version=\"1.0\">\n+        <redundancy reply-after=\"1\">1</redundancy>\n+        <documents>\n+            <document type=\"{{ document_name }}\" mode=\"index\"></document>\n+            <document-processing cluster=\"{{ application_name }}_container\"></document-processing>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwNDAzNw==", "bodyText": "Unless you are adding document processors, you don't need this either.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450104037", "createdAt": "2020-07-06T09:39:16Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/templates/services.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<services version=\"1.0\">\n+    <container id=\"{{ application_name }}_container\" version=\"1.0\">\n+        <search></search>\n+        <document-processing></document-processing>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9eecc937cdc2dc4925904c1f0e986efcb016269", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/e9eecc937cdc2dc4925904c1f0e986efcb016269", "committedDate": "2020-07-07T08:20:05Z", "message": "remove redundant list"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab41b91f89a450e657bd1a14592bb9c17333fbfb", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/ab41b91f89a450e657bd1a14592bb9c17333fbfb", "committedDate": "2020-07-07T08:27:09Z", "message": "more compact expression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7c5ab66c1ef1fb38d321848627e66954ac5c64a", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/b7c5ab66c1ef1fb38d321848627e66954ac5c64a", "committedDate": "2020-07-07T08:28:49Z", "message": "remove unnecessary update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4825ad2f4f874f4675b35c86c19ca4bf96ff241", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/b4825ad2f4f874f4675b35c86c19ca4bf96ff241", "committedDate": "2020-07-07T08:52:53Z", "message": "refactor __repr__ as a python expression"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07ccf914050178ad743dbe3d3f3ebb304a28deb8", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/07ccf914050178ad743dbe3d3f3ebb304a28deb8", "committedDate": "2020-07-07T09:13:49Z", "message": "Create VespaDocker class to encapsulate docker deployment code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd671e9aabad05ba83277182f2721af689ef1a45", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/cd671e9aabad05ba83277182f2721af689ef1a45", "committedDate": "2020-07-07T09:14:47Z", "message": "update application package notebook"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5bc1f9dfffecc55fd89053117ac4c4d067c89f9", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/f5bc1f9dfffecc55fd89053117ac4c4d067c89f9", "committedDate": "2020-07-07T09:16:49Z", "message": "remove unnecessary document-processing tags"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84fa57da76f6392fc6c1873e68f9076cd8b155f9", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/84fa57da76f6392fc6c1873e68f9076cd8b155f9", "committedDate": "2020-07-07T09:19:43Z", "message": "fix unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzc5Mzgz", "url": "https://github.com/vespa-engine/vespa/pull/13653#pullrequestreview-443779383", "createdAt": "2020-07-07T10:54:10Z", "commit": {"oid": "b4825ad2f4f874f4675b35c86c19ca4bf96ff241"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1NDoxMVrOGt5UJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1NDoxMVrOGt5UJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3ODE0OA==", "bodyText": "You should probably call repr() on these.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450778148", "createdAt": "2020-07-07T10:54:11Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -65,7 +65,13 @@ def __eq__(self, other):\n         )\n \n     def __repr__(self):\n-        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+        return \"{0}({1}, {2}, {3}, {4})\".format(\n+            self.__class__.__name__,\n+            str(self.name),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4825ad2f4f874f4675b35c86c19ca4bf96ff241"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b77cd04441b47a479386b5337f1699c2ec98870b", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/b77cd04441b47a479386b5337f1699c2ec98870b", "committedDate": "2020-07-07T11:13:31Z", "message": "used repr on the class members"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzk3OTUy", "url": "https://github.com/vespa-engine/vespa/pull/13653#pullrequestreview-443797952", "createdAt": "2020-07-07T11:23:59Z", "commit": {"oid": "b77cd04441b47a479386b5337f1699c2ec98870b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3667, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}