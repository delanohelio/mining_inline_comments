{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3OTI3NjA3", "number": 15479, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzoyNTo1NlrOE9ooAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzoyNTo1NlrOE9ooAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMDY0MTkzOnYy", "diffSide": "RIGHT", "path": "security-utils/src/test/java/com/yahoo/security/tls/authz/PeerAuthorizerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzoyNTo1NlrOH6bXBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzoyNTo1NlrOH6bXBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAyNzcxOQ==", "bodyText": "Consider adding a test of SAN URI mismatching as well", "url": "https://github.com/vespa-engine/vespa/pull/15479#discussion_r531027719", "createdAt": "2020-11-26T13:25:56Z", "author": {"login": "vekterli"}, "path": "security-utils/src/test/java/com/yahoo/security/tls/authz/PeerAuthorizerTest.java", "diffHunk": "@@ -91,12 +96,24 @@ public void must_match_all_cn_and_san_patterns() {\n         PeerAuthorizer peerAuthorizer = createPeerAuthorizer(\n                 createPolicy(POLICY_1, emptySet(), cnSuffixRequirement, cnPrefixRequirement, sanPrefixRequirement, sanSuffixRequirement));\n \n-        assertAuthorized(peerAuthorizer.authorizePeer(createCertificate(\"matching.prefix.matching.suffix.cn\", \"matching.prefix.matching.suffix.san\")));\n-        assertUnauthorized(peerAuthorizer.authorizePeer(createCertificate(\"matching.prefix.matching.suffix.cn\", \"matching.prefix.invalid.suffix.san\")));\n-        assertUnauthorized(peerAuthorizer.authorizePeer(createCertificate(\"invalid.prefix.matching.suffix.cn\", \"matching.prefix.matching.suffix.san\")));\n+        assertAuthorized(peerAuthorizer.authorizePeer(createCertificate(\"matching.prefix.matching.suffix.cn\", singletonList(\"matching.prefix.matching.suffix.san\"), emptyList())));\n+        assertUnauthorized(peerAuthorizer.authorizePeer(createCertificate(\"matching.prefix.matching.suffix.cn\", singletonList(\"matching.prefix.invalid.suffix.san\"), emptyList())));\n+        assertUnauthorized(peerAuthorizer.authorizePeer(createCertificate(\"invalid.prefix.matching.suffix.cn\", singletonList(\"matching.prefix.matching.suffix.san\"), emptyList())));\n     }\n \n-    private static X509Certificate createCertificate(String subjectCn, String... sanCns) {\n+    @Test\n+    public void can_exact_match_policy_with_san_uri_pattern() {\n+        RequiredPeerCredential cnRequirement = createRequiredCredential(CN, \"*.matching.cn\");\n+        RequiredPeerCredential sanUriRequirement = createRequiredCredential(SAN_URI, \"myscheme://my/exact/uri\");\n+        PeerAuthorizer authorizer = createPeerAuthorizer(createPolicy(POLICY_1, createRoles(ROLE_1), cnRequirement, sanUriRequirement));\n+\n+        AuthorizationResult result = authorizer.authorizePeer(createCertificate(\"foo.matching.cn\", singletonList(\"foo.irrelevant.san\"), singletonList(\"myscheme://my/exact/uri\")));\n+        assertAuthorized(result);\n+        assertThat(result.assumedRoles()).extracting(Role::name).containsOnly(ROLE_1);\n+        assertThat(result.matchedPolicies()).containsOnly(POLICY_1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3488082ed378f300c40328891e0ce8dcdd8c4475"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 818, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}