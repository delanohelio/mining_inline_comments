{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNDQ4MzEw", "number": 15574, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoxNjoxOFrOE_R5fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoyMTowNVrOE_SA7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Nzg4OTkwOnYy", "diffSide": "RIGHT", "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoxNjoxOFrOH85wRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoxNjoxOFrOH85wRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMjg1Mw==", "bodyText": "Neat.", "url": "https://github.com/vespa-engine/vespa/pull/15574#discussion_r533622853", "createdAt": "2020-12-01T18:16:18Z", "author": {"login": "jonmv"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.config.server.application;\n+\n+import ai.vespa.util.http.VespaAsyncHttpClientBuilder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.yahoo.concurrent.CompletableFutures;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.config.model.api.PortInfo;\n+import com.yahoo.config.model.api.ServiceInfo;\n+import com.yahoo.vespa.applicationmodel.ClusterId;\n+import com.yahoo.vespa.config.server.modelfactory.ModelResult;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\n+import org.apache.hc.client5.http.config.RequestConfig;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.HttpStatus;\n+import org.apache.hc.core5.reactor.IOReactorConfig;\n+import org.apache.hc.core5.util.Timeout;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.config.model.api.container.ContainerServiceType.CLUSTERCONTROLLER_CONTAINER;\n+import static com.yahoo.yolean.Exceptions.throwUnchecked;\n+import static com.yahoo.yolean.Exceptions.uncheck;\n+\n+/**\n+ * Retrieves reindexing status from cluster controllers over HTTP\n+ *\n+ * @author bjorncs\n+ */\n+public class DefaultClusterReindexingStatusClient implements ClusterReindexingStatusClient {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final Executor executor =\n+            Executors.newSingleThreadExecutor(new DaemonThreadFactory(\"cluster-controller-reindexing-client-\"));\n+    private final CloseableHttpAsyncClient httpClient = createHttpClient();\n+\n+    public DefaultClusterReindexingStatusClient() {\n+        httpClient.start();\n+    }\n+\n+    @Override\n+    public Map<String, ClusterReindexing> getReindexingStatus(ModelResult application) throws IOException {\n+        Map<ClusterId, List<ServiceInfo>> clusters = clusterControllerClusters(application);\n+        Map<ClusterId, CompletableFuture<ClusterReindexing>> futureStatusPerCluster = new HashMap<>();\n+        clusters.forEach((clusterId, clusterNodes) -> {\n+            var parallelRequests = clusterNodes.stream()\n+                    .map(this::getReindexingStatus)\n+                    .collect(Collectors.toList());\n+            CompletableFuture<ClusterReindexing> combinedRequest = CompletableFutures.firstOf(parallelRequests);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26429fb170a455760a20e2a9b8a20371c4962f54"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzkwMzA4OnYy", "diffSide": "RIGHT", "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoxOTozNlrOH854WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoxOTozNlrOH854WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNDkyMA==", "bodyText": "Perhaps we could return status from first successful, if the first to return a response is non-200?", "url": "https://github.com/vespa-engine/vespa/pull/15574#discussion_r533624920", "createdAt": "2020-12-01T18:19:36Z", "author": {"login": "jonmv"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.config.server.application;\n+\n+import ai.vespa.util.http.VespaAsyncHttpClientBuilder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.yahoo.concurrent.CompletableFutures;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.config.model.api.PortInfo;\n+import com.yahoo.config.model.api.ServiceInfo;\n+import com.yahoo.vespa.applicationmodel.ClusterId;\n+import com.yahoo.vespa.config.server.modelfactory.ModelResult;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\n+import org.apache.hc.client5.http.config.RequestConfig;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.HttpStatus;\n+import org.apache.hc.core5.reactor.IOReactorConfig;\n+import org.apache.hc.core5.util.Timeout;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.config.model.api.container.ContainerServiceType.CLUSTERCONTROLLER_CONTAINER;\n+import static com.yahoo.yolean.Exceptions.throwUnchecked;\n+import static com.yahoo.yolean.Exceptions.uncheck;\n+\n+/**\n+ * Retrieves reindexing status from cluster controllers over HTTP\n+ *\n+ * @author bjorncs\n+ */\n+public class DefaultClusterReindexingStatusClient implements ClusterReindexingStatusClient {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final Executor executor =\n+            Executors.newSingleThreadExecutor(new DaemonThreadFactory(\"cluster-controller-reindexing-client-\"));\n+    private final CloseableHttpAsyncClient httpClient = createHttpClient();\n+\n+    public DefaultClusterReindexingStatusClient() {\n+        httpClient.start();\n+    }\n+\n+    @Override\n+    public Map<String, ClusterReindexing> getReindexingStatus(ModelResult application) throws IOException {\n+        Map<ClusterId, List<ServiceInfo>> clusters = clusterControllerClusters(application);\n+        Map<ClusterId, CompletableFuture<ClusterReindexing>> futureStatusPerCluster = new HashMap<>();\n+        clusters.forEach((clusterId, clusterNodes) -> {\n+            var parallelRequests = clusterNodes.stream()\n+                    .map(this::getReindexingStatus)\n+                    .collect(Collectors.toList());\n+            CompletableFuture<ClusterReindexing> combinedRequest = CompletableFutures.firstOf(parallelRequests);\n+            futureStatusPerCluster.put(clusterId, combinedRequest);\n+        });\n+\n+        try {\n+            Map<String, ClusterReindexing> statusPerCluster = new HashMap<>();\n+            futureStatusPerCluster.forEach((clusterId, futureStatus) -> {\n+                statusPerCluster.put(clusterId.s(), futureStatus.join());\n+            });\n+            return statusPerCluster;\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to get reindexing status from cluster controllers: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override public void close() { uncheck(() -> httpClient.close()); }\n+\n+    private CompletableFuture<ClusterReindexing> getReindexingStatus(ServiceInfo service) {\n+        URI uri = URI.create(String.format(\"http://%s:%d/reindexing/v1/status\", service.getHostName(), getStatePort(service)));\n+        CompletableFuture<SimpleHttpResponse> responsePromise = new CompletableFuture<>();\n+        httpClient.execute(SimpleHttpRequests.get(uri), new FutureCallback<>() {\n+            @Override public void completed(SimpleHttpResponse result) { responsePromise.complete(result); }\n+            @Override public void failed(Exception ex) { responsePromise.completeExceptionally(ex); }\n+            @Override public void cancelled() { responsePromise.cancel(false); }\n+        });\n+        return responsePromise.handleAsync((response, error) ->  {\n+            if (response != null) {\n+                return uncheck(() -> toClusterReindexing(response));\n+            } else {\n+                throw throwUnchecked(new IOException(String.format(\"For '%s': %s\", uri, error.getMessage()), error));\n+            }\n+        }, executor);\n+    }\n+\n+    private static ClusterReindexing toClusterReindexing(SimpleHttpResponse response) throws IOException {\n+        if (response.getCode() != HttpStatus.SC_OK) throw new IOException(\"Expected status code 200, got \" + response.getCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26429fb170a455760a20e2a9b8a20371c4962f54"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NzkwODk1OnYy", "diffSide": "RIGHT", "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoyMTowNVrOH858BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoyMTowNVrOH858BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNTg2MA==", "bodyText": "Whenever I see property and name in the same sentence I get really excited :)))", "url": "https://github.com/vespa-engine/vespa/pull/15574#discussion_r533625860", "createdAt": "2020-12-01T18:21:05Z", "author": {"login": "jonmv"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.config.server.application;\n+\n+import ai.vespa.util.http.VespaAsyncHttpClientBuilder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.yahoo.concurrent.CompletableFutures;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.config.model.api.PortInfo;\n+import com.yahoo.config.model.api.ServiceInfo;\n+import com.yahoo.vespa.applicationmodel.ClusterId;\n+import com.yahoo.vespa.config.server.modelfactory.ModelResult;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\n+import org.apache.hc.client5.http.config.RequestConfig;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.HttpStatus;\n+import org.apache.hc.core5.reactor.IOReactorConfig;\n+import org.apache.hc.core5.util.Timeout;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.config.model.api.container.ContainerServiceType.CLUSTERCONTROLLER_CONTAINER;\n+import static com.yahoo.yolean.Exceptions.throwUnchecked;\n+import static com.yahoo.yolean.Exceptions.uncheck;\n+\n+/**\n+ * Retrieves reindexing status from cluster controllers over HTTP\n+ *\n+ * @author bjorncs\n+ */\n+public class DefaultClusterReindexingStatusClient implements ClusterReindexingStatusClient {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final Executor executor =\n+            Executors.newSingleThreadExecutor(new DaemonThreadFactory(\"cluster-controller-reindexing-client-\"));\n+    private final CloseableHttpAsyncClient httpClient = createHttpClient();\n+\n+    public DefaultClusterReindexingStatusClient() {\n+        httpClient.start();\n+    }\n+\n+    @Override\n+    public Map<String, ClusterReindexing> getReindexingStatus(ModelResult application) throws IOException {\n+        Map<ClusterId, List<ServiceInfo>> clusters = clusterControllerClusters(application);\n+        Map<ClusterId, CompletableFuture<ClusterReindexing>> futureStatusPerCluster = new HashMap<>();\n+        clusters.forEach((clusterId, clusterNodes) -> {\n+            var parallelRequests = clusterNodes.stream()\n+                    .map(this::getReindexingStatus)\n+                    .collect(Collectors.toList());\n+            CompletableFuture<ClusterReindexing> combinedRequest = CompletableFutures.firstOf(parallelRequests);\n+            futureStatusPerCluster.put(clusterId, combinedRequest);\n+        });\n+\n+        try {\n+            Map<String, ClusterReindexing> statusPerCluster = new HashMap<>();\n+            futureStatusPerCluster.forEach((clusterId, futureStatus) -> {\n+                statusPerCluster.put(clusterId.s(), futureStatus.join());\n+            });\n+            return statusPerCluster;\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to get reindexing status from cluster controllers: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override public void close() { uncheck(() -> httpClient.close()); }\n+\n+    private CompletableFuture<ClusterReindexing> getReindexingStatus(ServiceInfo service) {\n+        URI uri = URI.create(String.format(\"http://%s:%d/reindexing/v1/status\", service.getHostName(), getStatePort(service)));\n+        CompletableFuture<SimpleHttpResponse> responsePromise = new CompletableFuture<>();\n+        httpClient.execute(SimpleHttpRequests.get(uri), new FutureCallback<>() {\n+            @Override public void completed(SimpleHttpResponse result) { responsePromise.complete(result); }\n+            @Override public void failed(Exception ex) { responsePromise.completeExceptionally(ex); }\n+            @Override public void cancelled() { responsePromise.cancel(false); }\n+        });\n+        return responsePromise.handleAsync((response, error) ->  {\n+            if (response != null) {\n+                return uncheck(() -> toClusterReindexing(response));\n+            } else {\n+                throw throwUnchecked(new IOException(String.format(\"For '%s': %s\", uri, error.getMessage()), error));\n+            }\n+        }, executor);\n+    }\n+\n+    private static ClusterReindexing toClusterReindexing(SimpleHttpResponse response) throws IOException {\n+        if (response.getCode() != HttpStatus.SC_OK) throw new IOException(\"Expected status code 200, got \" + response.getCode());\n+        if (response.getBody() == null) throw new IOException(\"Response has no content\");\n+        return toClusterReindexing(response.getBodyBytes());\n+    }\n+\n+    private static ClusterReindexing toClusterReindexing(byte[] requestBody) throws IOException {\n+        JsonNode jsonNode = mapper.readTree(requestBody);\n+        Map<String, ClusterReindexing.Status> documentStatuses = new HashMap<>();\n+        for (JsonNode statusJson : jsonNode.get(\"status\")) {\n+            String type = statusJson.get(\"type\").textValue();\n+            Instant startedMillis = Instant.ofEpochMilli(statusJson.get(\"startedMillis\").longValue());\n+            Instant endedMillis = Instant.ofEpochMilli(statusJson.get(\"endedMillis\").longValue());\n+            String progressToken = statusJson.get(\"progress\").textValue();\n+            ClusterReindexing.State state = ClusterReindexing.State.fromString(statusJson.get(\"state\").textValue());\n+            String message = statusJson.get(\"message\").textValue();\n+            documentStatuses.put(type, new ClusterReindexing.Status(startedMillis, endedMillis, state, message, progressToken));\n+        }\n+        return new ClusterReindexing(documentStatuses);\n+    }\n+\n+    private static int getStatePort(ServiceInfo service) {\n+        return service.getPorts().stream()\n+                .filter(port -> port.getTags().contains(\"state\"))\n+                .map(PortInfo::getPort)\n+                .findAny()\n+                .orElseThrow(() -> new IllegalStateException(\"Cluster controller container has no container port\"));\n+    }\n+\n+    private static Map<ClusterId, List<ServiceInfo>> clusterControllerClusters(ModelResult application) {\n+        return application.getModel().getHosts().stream()\n+                .flatMap(host -> host.getServices().stream())\n+                .filter(service -> service.getServiceType().equals(CLUSTERCONTROLLER_CONTAINER.serviceName))\n+                .collect(Collectors.groupingBy(service -> new ClusterId(service.getProperty(\"clustername\").get())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26429fb170a455760a20e2a9b8a20371c4962f54"}, "originalPosition": 129}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 762, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}