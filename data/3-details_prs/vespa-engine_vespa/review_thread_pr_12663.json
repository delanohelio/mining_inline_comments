{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyMjQ0NzQ4", "number": 12663, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTozMjo0M1rODqTBNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTozMjo0M1rODqTBNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Njc4Mzg5OnYy", "diffSide": "RIGHT", "path": "vespalib/src/tests/stllike/lookup_benchmark.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTozMjo0M1rOF59KJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTo0NDoxMlrOF59ltg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNTE3NQ==", "bodyText": "Since all these benchmarks are the same aside from the evaluation call, could consider factoring out as template argument to a generic benchmark loop function.", "url": "https://github.com/vespa-engine/vespa/pull/12663#discussion_r396315175", "createdAt": "2020-03-23T09:32:43Z", "author": {"login": "vekterli"}, "path": "vespalib/src/tests/stllike/lookup_benchmark.cpp", "diffHunk": "@@ -95,6 +95,41 @@ size_t benchHashMapVespaLib2(size_t sz, size_t numLookups)\n     return benchM(set, sz, numLookups);\n }\n \n+std::unique_ptr<char []> createData(size_t sz) {\n+    auto data = std::make_unique<char []>(sz);\n+    for (size_t i(0); i < sz; i++) {\n+        data.get()[i] = i + '0';\n+    }\n+    return data;\n+}\n+\n+size_t benchXXHash32(size_t sz, size_t numLookups) {\n+    auto data = createData(sz);\n+    size_t sum(0);\n+    for (size_t i(0); i < numLookups; i++) {\n+        sum += XXH32(data.get(), sz, 0);\n+    }\n+    return sum;\n+}\n+\n+size_t benchXXHash64(size_t sz, size_t numLookups) {\n+    auto data = createData(sz);\n+    size_t sum(0);\n+    for (size_t i(0); i < numLookups; i++) {\n+        sum += XXH64(data.get(), sz, 0);\n+    }\n+    return sum;\n+}\n+\n+size_t benchLegacyHash(size_t sz, size_t numLookups) {\n+    auto data = createData(sz);\n+    size_t sum(0);\n+    for (size_t i(0); i < numLookups; i++) {\n+        sum += vespalib::hashValue(data.get(), sz);\n+    }\n+    return sum;\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff6595075b5c6b47bef9297b29e99351341ad38"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyMjIzMA==", "bodyText": "Yes, I will make one more round.", "url": "https://github.com/vespa-engine/vespa/pull/12663#discussion_r396322230", "createdAt": "2020-03-23T09:44:12Z", "author": {"login": "baldersheim"}, "path": "vespalib/src/tests/stllike/lookup_benchmark.cpp", "diffHunk": "@@ -95,6 +95,41 @@ size_t benchHashMapVespaLib2(size_t sz, size_t numLookups)\n     return benchM(set, sz, numLookups);\n }\n \n+std::unique_ptr<char []> createData(size_t sz) {\n+    auto data = std::make_unique<char []>(sz);\n+    for (size_t i(0); i < sz; i++) {\n+        data.get()[i] = i + '0';\n+    }\n+    return data;\n+}\n+\n+size_t benchXXHash32(size_t sz, size_t numLookups) {\n+    auto data = createData(sz);\n+    size_t sum(0);\n+    for (size_t i(0); i < numLookups; i++) {\n+        sum += XXH32(data.get(), sz, 0);\n+    }\n+    return sum;\n+}\n+\n+size_t benchXXHash64(size_t sz, size_t numLookups) {\n+    auto data = createData(sz);\n+    size_t sum(0);\n+    for (size_t i(0); i < numLookups; i++) {\n+        sum += XXH64(data.get(), sz, 0);\n+    }\n+    return sum;\n+}\n+\n+size_t benchLegacyHash(size_t sz, size_t numLookups) {\n+    auto data = createData(sz);\n+    size_t sum(0);\n+    for (size_t i(0); i < numLookups; i++) {\n+        sum += vespalib::hashValue(data.get(), sz);\n+    }\n+    return sum;\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNTE3NQ=="}, "originalCommit": {"oid": "dff6595075b5c6b47bef9297b29e99351341ad38"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2201, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}