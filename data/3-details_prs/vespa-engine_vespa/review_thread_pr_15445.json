{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2NDg1MDA0", "number": 15445, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowMjo1N1rOE8w2eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwOTo0Mjo1OVrOE9JKbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTUwMzkzOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/cell_type.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowMjo1N1rOH5FBAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowMjo1N1rOH5FBAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMzA1OQ==", "bodyText": "these should be owned by the value codec. (including id_of and type_of functions)", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529613059", "createdAt": "2020-11-24T15:02:57Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/cell_type.h", "diffHunk": "@@ -25,14 +25,68 @@ template <typename CT> inline CellType get_cell_type();\n template <> inline CellType get_cell_type<double>() { return CellType::DOUBLE; }\n template <> inline CellType get_cell_type<float>() { return CellType::FLOAT; }\n \n+struct CellTypeUtils {\n+    template <typename CT> static constexpr bool check(CellType type);\n+    template <typename CT> static constexpr CellType get_type();\n+\n+    static constexpr uint32_t DOUBLE_ID = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTUxNjY4OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/cell_type.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowNTozOVrOH5FJCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowNTozOVrOH5FJCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxNTExNQ==", "bodyText": "check/get should be left as is", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529615115", "createdAt": "2020-11-24T15:05:39Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/cell_type.h", "diffHunk": "@@ -25,14 +25,68 @@ template <typename CT> inline CellType get_cell_type();\n template <> inline CellType get_cell_type<double>() { return CellType::DOUBLE; }\n template <> inline CellType get_cell_type<float>() { return CellType::FLOAT; }\n \n+struct CellTypeUtils {\n+    template <typename CT> static constexpr bool check(CellType type);\n+    template <typename CT> static constexpr CellType get_type();\n+\n+    static constexpr uint32_t DOUBLE_ID = 0;\n+    static constexpr uint32_t FLOAT_ID = 1;\n+\n+    static constexpr uint32_t id_of(CellType cell_type) {\n+        switch (cell_type) {\n+        case CellType::DOUBLE: return DOUBLE_ID;\n+        case CellType::FLOAT: return FLOAT_ID;\n+        }\n+        bad_argument((uint32_t)cell_type);\n+    }\n+\n+    static constexpr CellType type_of(uint32_t id) {\n+        switch (id) {\n+        case DOUBLE_ID: return CellType::DOUBLE;\n+        case FLOAT_ID: return CellType::FLOAT;\n+        }\n+        bad_argument(id);\n+    }\n+\n+    static void bad_argument [[ noreturn ]] (uint32_t id);\n+\n+    static constexpr uint32_t alignment(CellType cell_type) {\n+        switch (cell_type) {\n+        case CellType::DOUBLE: return sizeof(double);\n+        case CellType::FLOAT: return sizeof(float);\n+        }\n+        bad_argument((uint32_t)cell_type);\n+    }\n+\n+    static constexpr size_t mem_size(CellType cell_type, size_t sz) {\n+        switch (cell_type) {\n+        case CellType::DOUBLE: return sz * sizeof(double);\n+        case CellType::FLOAT:  return sz * sizeof(float);\n+        }\n+        bad_argument((uint32_t)cell_type);\n+    }\n+};\n+\n+template <> constexpr bool ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTUyNjcwOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowNzozNlrOH5FPJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTowNzozNlrOH5FPJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxNjY3Nw==", "bodyText": "what about the other memory?", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529616677", "createdAt": "2020-11-24T15:07:36Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value.cpp", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"streamed_value.h\"\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".vespalib.eval.streamed.streamed_value\");\n+\n+namespace vespalib::eval {\n+\n+template <typename T>\n+StreamedValue<T>::~StreamedValue() = default;\n+\n+template <typename T>\n+MemoryUsage\n+StreamedValue<T>::get_memory_usage() const\n+{\n+    return self_memory_usage<StreamedValue<T>>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTU4Mjc0OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_builder.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToxODo0MFrOH5Fxvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToxODo0MFrOH5Fxvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyNTUzNQ==", "bodyText": "do we need this?", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529625535", "createdAt": "2020-11-24T15:18:40Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_builder.h", "diffHunk": "@@ -0,0 +1,64 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"streamed_value.h\"\n+#include <vespa/vespalib/objects/nbostream.h>\n+\n+namespace vespalib::eval {\n+\n+ /**\n+  *  Builder for StreamedValue objects.\n+  **/\n+template <typename T>\n+class StreamedValueBuilder : public ValueBuilder<T>\n+{\n+private:\n+    ValueType _type;\n+    size_t _dsss;\n+    std::vector<T> _cells;\n+    size_t _num_subspaces;\n+    nbostream _labels;\n+public:\n+    StreamedValueBuilder(const ValueType &type,\n+                         size_t num_mapped_in,\n+                         size_t subspace_size_in,\n+                         size_t expected_subspaces)\n+      : _type(type),\n+        _dsss(subspace_size_in),\n+        _cells(),\n+        _num_subspaces(0),\n+        _labels()\n+    {\n+        _cells.reserve(subspace_size_in * expected_subspaces);\n+        // assume small sized label strings:\n+        _labels.reserve(num_mapped_in * expected_subspaces * 3);\n+    };\n+\n+    ~StreamedValueBuilder();\n+\n+    ArrayRef<T> add_subspace(ConstArrayRef<vespalib::stringref> addr) override {\n+        for (auto label : addr) {\n+            _labels.writeSmallString(label);\n+        }\n+        size_t old_sz = _cells.size();\n+        _cells.resize(old_sz + _dsss);\n+        _num_subspaces++;\n+        return ArrayRef<T>(&_cells[old_sz], _dsss);\n+    }\n+\n+    std::unique_ptr<Value> build(std::unique_ptr<ValueBuilder<T>>) override {\n+        if (_num_subspaces == 0 && _type.count_mapped_dimensions() == 0) {\n+            // add required dense subspace\n+            add_subspace({});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTYxMTk0OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_view.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToyNDoyNFrOH5GDzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToyNDoyNFrOH5GDzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzMDE1OA==", "bodyText": "why is this not an assert?", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529630158", "createdAt": "2020-11-24T15:24:24Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_view.h", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value_type.h>\n+#include <vespa/eval/eval/value.h>\n+#include \"streamed_value_index.h\"\n+\n+namespace vespalib::eval {\n+\n+ /**\n+  *  Same characteristics as StreamedValue, but does not\n+  *  own its data - refers to type, cells and serialized\n+  *  labels that must be kept outside the Value.\n+  **/\n+class StreamedValueView : public Value\n+{\n+private:\n+    const ValueType &_type;\n+    TypedCells _cells_ref;\n+    StreamedValueIndex _my_index;\n+\n+public:\n+    StreamedValueView(const ValueType &type, TypedCells cells,\n+                      size_t num_ss, ConstArrayRef<char> labels_buf)\n+      : _type(type),\n+        _cells_ref(cells),\n+        _my_index(_type.count_mapped_dimensions(), num_ss, labels_buf)\n+    {\n+        if (num_ss * _type.dense_subspace_size() != _cells_ref.size) abort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTYyODUwOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_index.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToyNjo0MFrOH5GOiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToyNjo0MFrOH5GOiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzMjkwNw==", "bodyText": "this name is a bit misleading, since you do not actually serialize anything", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529632907", "createdAt": "2020-11-24T15:26:40Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_index.h", "diffHunk": "@@ -0,0 +1,36 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::eval {\n+\n+ /**\n+  *  Implements Value::Index by reading a stream of serialized\n+  *  labels.\n+  **/\n+class StreamedValueIndex : public Value::Index\n+{\n+public:\n+    struct SerializedForm {\n+        uint32_t num_mapped_dims;\n+        uint32_t num_subspaces;\n+        ConstArrayRef<char> labels_buffer;\n+    };\n+    StreamedValueIndex(uint32_t num_mapped_dims, uint32_t num_subspaces, ConstArrayRef<char> labels_buf)\n+      : _data{num_mapped_dims, num_subspaces, labels_buf}\n+    {}\n+\n+    // index API:\n+    size_t size() const override { return _data.num_subspaces; }\n+    std::unique_ptr<View> create_view(const std::vector<size_t> &dims) const override;\n+\n+    SerializedForm serialize() const { return _data; }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTY1MzMwOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_index.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToyOTozN1rOH5GfTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNToyOTozN1rOH5GfTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzNzE5OA==", "bodyText": "this assert is a bit late", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529637198", "createdAt": "2020-11-24T15:29:37Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_index.cpp", "diffHunk": "@@ -0,0 +1,103 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"streamed_value_index.h\"\n+#include \"streamed_value_utils.h\"\n+\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_index\");\n+\n+namespace vespalib::eval {\n+\n+namespace {\n+\n+struct StreamedFilterView : Value::Index::View\n+{\n+    LabelBlockStream label_blocks;\n+    std::vector<size_t> view_dims;\n+    std::vector<vespalib::stringref> to_match;\n+\n+    StreamedFilterView(LabelBlockStream labels, std::vector<size_t> view_dims_in)\n+      : label_blocks(std::move(labels)),\n+        view_dims(std::move(view_dims_in)),\n+        to_match()\n+    {\n+        to_match.reserve(view_dims.size());\n+    }\n+\n+    void lookup(ConstArrayRef<const vespalib::stringref*> addr) override {\n+        label_blocks.reset();\n+        to_match.clear();\n+        for (auto ptr : addr) {\n+            to_match.push_back(*ptr);\n+        }\n+        assert(view_dims.size() == to_match.size());\n+    }\n+\n+    bool next_result(ConstArrayRef<vespalib::stringref*> addr_out, size_t &idx_out) override {\n+        while (const auto block = label_blocks.next_block()) {\n+            idx_out = block.ss_idx;\n+            bool matches = true;\n+            size_t out_idx = 0;\n+            size_t vdm_idx = 0;\n+            for (size_t dim = 0; dim < block.address.size(); ++dim) {\n+                if (vdm_idx < view_dims.size() && (view_dims[vdm_idx] == dim)) {\n+                    if (block.address[dim] != to_match[vdm_idx]) {\n+                        matches = false;\n+                    }\n+                    ++vdm_idx;\n+                } else {\n+                    *addr_out[out_idx++] = block.address[dim];\n+                }\n+            }\n+            assert(out_idx == addr_out.size());\n+            assert(vdm_idx == view_dims.size());\n+            if (matches) return true;\n+        }\n+        return false;\n+    }\n+};\n+\n+struct StreamedIterationView : Value::Index::View\n+{\n+    LabelBlockStream label_blocks;\n+\n+    StreamedIterationView(LabelBlockStream labels)\n+      : label_blocks(std::move(labels))\n+    {}\n+\n+    void lookup(ConstArrayRef<const vespalib::stringref*> addr) override {\n+        label_blocks.reset();\n+        assert(addr.size() == 0);\n+    }\n+\n+    bool next_result(ConstArrayRef<vespalib::stringref*> addr_out, size_t &idx_out) override {\n+        if (auto block = label_blocks.next_block()) {\n+            idx_out = block.ss_idx;\n+            size_t i = 0;\n+            for (auto ptr : addr_out) {\n+                *ptr = block.address[i++];\n+            }\n+            assert(i == block.address.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTY4MjYxOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_index.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTozMzoxNFrOH5Gygw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTozMzoxNFrOH5Gygw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0MjExNQ==", "bodyText": "consider matches &= ...", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529642115", "createdAt": "2020-11-24T15:33:14Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_index.cpp", "diffHunk": "@@ -0,0 +1,103 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"streamed_value_index.h\"\n+#include \"streamed_value_utils.h\"\n+\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_index\");\n+\n+namespace vespalib::eval {\n+\n+namespace {\n+\n+struct StreamedFilterView : Value::Index::View\n+{\n+    LabelBlockStream label_blocks;\n+    std::vector<size_t> view_dims;\n+    std::vector<vespalib::stringref> to_match;\n+\n+    StreamedFilterView(LabelBlockStream labels, std::vector<size_t> view_dims_in)\n+      : label_blocks(std::move(labels)),\n+        view_dims(std::move(view_dims_in)),\n+        to_match()\n+    {\n+        to_match.reserve(view_dims.size());\n+    }\n+\n+    void lookup(ConstArrayRef<const vespalib::stringref*> addr) override {\n+        label_blocks.reset();\n+        to_match.clear();\n+        for (auto ptr : addr) {\n+            to_match.push_back(*ptr);\n+        }\n+        assert(view_dims.size() == to_match.size());\n+    }\n+\n+    bool next_result(ConstArrayRef<vespalib::stringref*> addr_out, size_t &idx_out) override {\n+        while (const auto block = label_blocks.next_block()) {\n+            idx_out = block.ss_idx;\n+            bool matches = true;\n+            size_t out_idx = 0;\n+            size_t vdm_idx = 0;\n+            for (size_t dim = 0; dim < block.address.size(); ++dim) {\n+                if (vdm_idx < view_dims.size() && (view_dims[vdm_idx] == dim)) {\n+                    if (block.address[dim] != to_match[vdm_idx]) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTcxOTAwOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_builder_factory.cpp", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTozNzoyN1rOH5HKhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTozNzoyN1rOH5HKhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0ODI2Mg==", "bodyText": "consider using explicit parameters", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529648262", "createdAt": "2020-11-24T15:37:27Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_builder_factory.cpp", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"streamed_value_builder_factory.h\"\n+#include \"streamed_value_builder.h\"\n+\n+namespace vespalib::eval {\n+\n+struct SelectStreamedValueBuilder {\n+    template <typename T, typename ...Args>\n+    static std::unique_ptr<ValueBuilderBase> invoke(const ValueType &type, Args &&...args)\n+    {\n+        assert(check_cell_type<T>(type.cell_type()));\n+        return std::make_unique<StreamedValueBuilder<T>>(type, std::forward<Args>(args)...);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTc0Nzg5OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo0MDo0NlrOH5HdHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo0MDo0NlrOH5HdHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1MzAyMg==", "bodyText": "only use longlived if you really need it and are ready for the consequences...", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529653022", "createdAt": "2020-11-24T15:40:46Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/vespalib/objects/nbostream.h>\n+\n+namespace vespalib::eval {\n+\n+/**\n+ *  Reads a stream of serialized labels.\n+ *  Reading more labels than available will\n+ *  throw an exception.\n+ **/\n+struct LabelStream {\n+    nbostream_longlivedbuf source;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTc3OTgyOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo0NDozMFrOH5HyNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo0NDozMFrOH5HyNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1ODQyMQ==", "bodyText": "npos?", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r529658421", "createdAt": "2020-11-24T15:44:30Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/vespalib/objects/nbostream.h>\n+\n+namespace vespalib::eval {\n+\n+/**\n+ *  Reads a stream of serialized labels.\n+ *  Reading more labels than available will\n+ *  throw an exception.\n+ **/\n+struct LabelStream {\n+    nbostream_longlivedbuf source;\n+    LabelStream(ConstArrayRef<char> data) : source(data.begin(), data.size()) {}\n+    vespalib::stringref next_label() {\n+        size_t str_size = source.getInt1_4Bytes();\n+        vespalib::stringref label(source.peek(), str_size);\n+        source.adjustReadPos(str_size);\n+        return label;\n+    }\n+    void reset() { source.rp(0); }\n+};\n+\n+/**\n+ *  Represents an address (set of labels) mapping to a subspace index\n+ **/\n+struct LabelBlock {\n+    static constexpr size_t npos = -1;\n+    size_t ss_idx;\n+    ConstArrayRef<vespalib::stringref> address;\n+    operator bool() const { return ss_idx != npos; }\n+};\n+\n+/**\n+ * Utility for reading a buffer with serialized labels\n+ * as a stream of LabelBlock objects.\n+ **/\n+class LabelBlockStream {\n+private:\n+    size_t _num_subspaces;\n+    LabelStream _labels;\n+    size_t _subspace_index;\n+    std::vector<vespalib::stringref> _current_address;\n+public:\n+    LabelBlock next_block() {\n+        if (_subspace_index < _num_subspaces) {\n+            for (auto & label : _current_address) {\n+                label = _labels.next_label();\n+            }\n+            return LabelBlock{_subspace_index++, _current_address};\n+        } else {\n+            return LabelBlock{LabelBlock::npos, {}};\n+        }\n+    }\n+\n+    void reset() {\n+        _subspace_index = 0;\n+        _labels.reset();\n+    }\n+\n+    LabelBlockStream(uint32_t num_subspaces,\n+                     ConstArrayRef<char> label_buf,\n+                     uint32_t num_mapped_dims)\n+      : _num_subspaces(num_subspaces),\n+        _labels(label_buf),\n+        _subspace_index(-1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d73cb9413b0b39943395a717ec20ce6cd89fa47f"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNTQ0MjYyOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_builder.h", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwOTozMjozMFrOH5qhsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwOTozMjozMFrOH5qhsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIyNzYzMw==", "bodyText": "consider putting the assert here instead of the value constructor", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530227633", "createdAt": "2020-11-25T09:32:30Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_builder.h", "diffHunk": "@@ -42,18 +44,18 @@ class StreamedValueBuilder : public ValueBuilder<T>\n             _labels.writeSmallString(label);\n         }\n         size_t old_sz = _cells.size();\n-        _cells.resize(old_sz + _dsss);\n+        _cells.resize(old_sz + _dense_subspace_size);\n         _num_subspaces++;\n-        return ArrayRef<T>(&_cells[old_sz], _dsss);\n+        return ArrayRef<T>(&_cells[old_sz], _dense_subspace_size);\n     }\n \n     std::unique_ptr<Value> build(std::unique_ptr<ValueBuilder<T>>) override {\n-        if (_num_subspaces == 0 && _type.count_mapped_dimensions() == 0) {\n-            // add required dense subspace\n-            add_subspace({});\n+        if (_num_mapped_dimensions == 0) {\n+            assert(_num_subspaces == 1);\n         }\n-        // note: _num_subspaces * _dsss == _cells.size()\n+        // note: _num_subspaces * _dense_subspace_size == _cells.size()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "107fd58a5aabe35ce4c3ed1ff9ebcc1ea786d2a1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNTQ3MjMxOnYy", "diffSide": "LEFT", "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwOTozOToyOVrOH5q0LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMDozNDo0NFrOH5tGQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzMjM2NA==", "bodyText": "I thought about using a common npos since one is defined in the LabelBlock, but since you are index based, 'num_spubspaces' would be appropriate here (equivalent with 'end()')", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530232364", "createdAt": "2020-11-25T09:39:29Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "diffHunk": "@@ -66,7 +66,7 @@ class LabelBlockStream {\n                      uint32_t num_mapped_dims)\n       : _num_subspaces(num_subspaces),\n         _labels(label_buf),\n-        _subspace_index(-1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3723c0bbba1296507dfe3ce4357e3c179ec3fdd1"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2OTc2Mw==", "bodyText": "good idea, thanks", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530269763", "createdAt": "2020-11-25T10:34:44Z", "author": {"login": "arnej27959"}, "path": "eval/src/vespa/eval/streamed/streamed_value_utils.h", "diffHunk": "@@ -66,7 +66,7 @@ class LabelBlockStream {\n                      uint32_t num_mapped_dims)\n       : _num_subspaces(num_subspaces),\n         _labels(label_buf),\n-        _subspace_index(-1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzMjM2NA=="}, "originalCommit": {"oid": "3723c0bbba1296507dfe3ce4357e3c179ec3fdd1"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNTQ4NzE3OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/streamed/streamed_value_view.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwOTo0Mjo1OVrOH5q9hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMDozNTowM1rOH5tHDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzNDc1OQ==", "bodyText": "I still think these should get a more descriptive name", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530234759", "createdAt": "2020-11-25T09:42:59Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/streamed/streamed_value_view.h", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value_type.h>\n+#include <vespa/eval/eval/value.h>\n+#include \"streamed_value_index.h\"\n+\n+namespace vespalib::eval {\n+\n+ /**\n+  *  Same characteristics as StreamedValue, but does not\n+  *  own its data - refers to type, cells and serialized\n+  *  labels that must be kept outside the Value.\n+  **/\n+class StreamedValueView : public Value\n+{\n+private:\n+    const ValueType &_type;\n+    TypedCells _cells_ref;\n+    StreamedValueIndex _my_index;\n+\n+public:\n+    StreamedValueView(const ValueType &type, TypedCells cells,\n+                      size_t num_ss, ConstArrayRef<char> labels_buf)\n+      : _type(type),\n+        _cells_ref(cells),\n+        _my_index(_type.count_mapped_dimensions(), num_ss, labels_buf)\n+    {\n+        if (num_ss * _type.dense_subspace_size() != _cells_ref.size) abort();\n+    }\n+\n+    ~StreamedValueView();\n+    const ValueType &type() const final override { return _type; }\n+    TypedCells cells() const final override { return _cells_ref; }\n+    const Value::Index &index() const override { return _my_index; }\n+    MemoryUsage get_memory_usage() const final override {\n+        return self_memory_usage<StreamedValueView>();\n+    }\n+    auto serialize_index() const { return _my_index.serialize(); }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1b6c4e09c4c16667b9c609b171a86556f067cc1"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2OTk2NQ==", "bodyText": "yes, sorry about that, fixed now", "url": "https://github.com/vespa-engine/vespa/pull/15445#discussion_r530269965", "createdAt": "2020-11-25T10:35:03Z", "author": {"login": "arnej27959"}, "path": "eval/src/vespa/eval/streamed/streamed_value_view.h", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value_type.h>\n+#include <vespa/eval/eval/value.h>\n+#include \"streamed_value_index.h\"\n+\n+namespace vespalib::eval {\n+\n+ /**\n+  *  Same characteristics as StreamedValue, but does not\n+  *  own its data - refers to type, cells and serialized\n+  *  labels that must be kept outside the Value.\n+  **/\n+class StreamedValueView : public Value\n+{\n+private:\n+    const ValueType &_type;\n+    TypedCells _cells_ref;\n+    StreamedValueIndex _my_index;\n+\n+public:\n+    StreamedValueView(const ValueType &type, TypedCells cells,\n+                      size_t num_ss, ConstArrayRef<char> labels_buf)\n+      : _type(type),\n+        _cells_ref(cells),\n+        _my_index(_type.count_mapped_dimensions(), num_ss, labels_buf)\n+    {\n+        if (num_ss * _type.dense_subspace_size() != _cells_ref.size) abort();\n+    }\n+\n+    ~StreamedValueView();\n+    const ValueType &type() const final override { return _type; }\n+    TypedCells cells() const final override { return _cells_ref; }\n+    const Value::Index &index() const override { return _my_index; }\n+    MemoryUsage get_memory_usage() const final override {\n+        return self_memory_usage<StreamedValueView>();\n+    }\n+    auto serialize_index() const { return _my_index.serialize(); }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzNDc1OQ=="}, "originalCommit": {"oid": "f1b6c4e09c4c16667b9c609b171a86556f067cc1"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 793, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}