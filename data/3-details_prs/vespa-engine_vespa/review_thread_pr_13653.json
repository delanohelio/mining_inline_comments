{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3NzQzNTQw", "number": 13653, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxMzo1MVrOELmxDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1NDoxMVrOEMBmRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjA0OTQwOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxMzo1MVrOGtPTjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxMzo1MVrOGtPTjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4OTg3MA==", "bodyText": "I think list() here is redundant.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450089870", "createdAt": "2020-07-06T09:13:51Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjA2NDk1OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxODowN1rOGtPdOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxODowN1rOGtPdOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MjM0Ng==", "bodyText": "I would avoid \\n in __repr__. It's better to have it on one line. __repr__ should attempt to look like a Python expressions while __str__ is for informal string representation. See https://docs.python.org/3/reference/datamodel.html#object.__repr__.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450092346", "createdAt": "2020-07-06T09:18:07Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjA2NzAwOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxODo0M1rOGtPehw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxODo0M1rOGtPehw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MjY3OQ==", "bodyText": "See __repr__ comment below.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450092679", "createdAt": "2020-07-06T09:18:43Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjA2NzcwOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxODo1N1rOGtPfAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToxODo1N1rOGtPfAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5MjgwMg==", "bodyText": "See __repr__ comment above.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450092802", "createdAt": "2020-07-06T09:18:57Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjA4NjQ5OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToyNDoxM1rOGtPqVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToyNDoxM1rOGtPqVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5NTcwMQ==", "bodyText": "Just a different style, it might not be more clear: self.fields = [] if not fields else fields.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450095701", "createdAt": "2020-07-06T09:24:13Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjA5MjMyOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToyNTo0N1rOGtPt7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToyNTo0N1rOGtPt7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5NjYyMw==", "bodyText": "See __repr__ above.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450096623", "createdAt": "2020-07-06T09:25:47Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjEwMDAxOnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToyNzo1NFrOGtPyqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToyNzo1NFrOGtPyqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5NzgzNA==", "bodyText": "Why .update() instead of just self.rank_profiles[rank_profile.name] = rank_profile?", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450097834", "createdAt": "2020-07-06T09:27:54Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjEwMTM0OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToyODoxNFrOGtPzZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOToyODoxNFrOGtPzZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5ODAyMw==", "bodyText": "See __repr__ above.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450098023", "createdAt": "2020-07-06T09:28:14Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Schema\":\n+        return Schema(\n+            name=mapping[\"name\"],\n+            document=FromJson.map(mapping[\"document\"]),\n+            fieldsets=[FromJson.map(fieldset) for fieldset in mapping[\"fieldsets\"]],\n+            rank_profiles=[\n+                FromJson.map(rank_profile) for rank_profile in mapping[\"rank_profiles\"]\n+            ],\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\n+            \"name\": self.name,\n+            \"document\": self.document.to_envelope,\n+            \"fieldsets\": [\n+                self.fieldsets[name].to_envelope for name in self.fieldsets.keys()\n+            ],\n+            \"rank_profiles\": [\n+                self.rank_profiles[name].to_envelope\n+                for name in self.rank_profiles.keys()\n+            ],\n+        }\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.document == other.document\n+            and self.fieldsets == other.fieldsets\n+            and self.rank_profiles == other.rank_profiles\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjExMjE4OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOTozMToxM1rOGtP6Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwOToxNTowM1rOGt195g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5OTczNA==", "bodyText": "There are a few methods in this class that related to running the application. I would pull those out into a separate class or just have them as regular functions outside a class. Then it would be easier to have VespaCloud.run(app) and VespaDocker.run(app) and ApplicationPackage just becomes a data container.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450099734", "createdAt": "2020-07-06T09:31:13Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Schema\":\n+        return Schema(\n+            name=mapping[\"name\"],\n+            document=FromJson.map(mapping[\"document\"]),\n+            fieldsets=[FromJson.map(fieldset) for fieldset in mapping[\"fieldsets\"]],\n+            rank_profiles=[\n+                FromJson.map(rank_profile) for rank_profile in mapping[\"rank_profiles\"]\n+            ],\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\n+            \"name\": self.name,\n+            \"document\": self.document.to_envelope,\n+            \"fieldsets\": [\n+                self.fieldsets[name].to_envelope for name in self.fieldsets.keys()\n+            ],\n+            \"rank_profiles\": [\n+                self.rank_profiles[name].to_envelope\n+                for name in self.rank_profiles.keys()\n+            ],\n+        }\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.document == other.document\n+            and self.fieldsets == other.fieldsets\n+            and self.rank_profiles == other.rank_profiles\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class ApplicationPackage(ToJson, FromJson[\"ApplicationPackage\"]):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcyMzMwMg==", "bodyText": "Good point.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450723302", "createdAt": "2020-07-07T09:15:03Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -0,0 +1,412 @@\n+import os\n+from time import sleep\n+from typing import List, Mapping, Optional\n+from tempfile import TemporaryDirectory\n+from pathlib import Path\n+\n+from jinja2 import Environment, PackageLoader, select_autoescape\n+import docker\n+\n+from vespa.json_serialization import ToJson, FromJson\n+\n+\n+class Field(ToJson, FromJson[\"Field\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        type: str,\n+        indexing: Optional[List[str]] = None,\n+        index: Optional[str] = None,\n+    ) -> None:\n+        \"\"\"\n+        Object representing a Vespa document field.\n+\n+        :param name: Field name.\n+        :param type: Field data type.\n+        :param indexing: Configures how to process data of a field during indexing.\n+        :param index: Sets index parameters. Content in fields with index are normalized and tokenized by default.\n+        \"\"\"\n+        self.name = name\n+        self.type = type\n+        self.indexing = indexing\n+        self.index = index\n+\n+    @property\n+    def indexing_to_text(self) -> Optional[str]:\n+        if self.indexing is not None:\n+            return \" | \".join(self.indexing)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Field\":\n+        return Field(\n+            name=mapping[\"name\"],\n+            type=mapping[\"type\"],\n+            indexing=mapping.get(\"indexing\", None),\n+            index=mapping.get(\"index\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"type\": self.type}\n+        if self.indexing is not None:\n+            map.update(indexing=self.indexing)\n+        if self.index is not None:\n+            map.update(index=self.index)\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.type == other.type\n+            and self.indexing == other.indexing\n+            and self.index == other.index\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Document(ToJson, FromJson[\"Document\"]):\n+    def __init__(self, fields: Optional[List[Field]] = None) -> None:\n+        \"\"\"\n+        Object representing a Vespa document.\n+\n+        \"\"\"\n+        if not fields:\n+            fields = []\n+\n+        self.fields = fields\n+\n+    def add_fields(self, *fields: Field):\n+        \"\"\"\n+        Add Fields to the document.\n+\n+        :param fields: fields to be added\n+        :return:\n+        \"\"\"\n+        self.fields.extend(list(fields))\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Document\":\n+        return Document(fields=[FromJson.map(field) for field in mapping.get(\"fields\")])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"fields\": [field.to_envelope for field in self.fields]}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class FieldSet(ToJson, FromJson[\"FieldSet\"]):\n+    def __init__(self, name: str, fields: List[str]) -> None:\n+        \"\"\"\n+        A fieldset groups fields together for searching.\n+\n+        :param name: Name of the fieldset\n+        :param fields: Field names to be included in the fieldset.\n+        \"\"\"\n+        self.name = name\n+        self.fields = fields\n+\n+    @property\n+    def fields_to_text(self):\n+        if self.fields is not None:\n+            return \", \".join(self.fields)\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"FieldSet\":\n+        return FieldSet(name=mapping[\"name\"], fields=mapping[\"fields\"])\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"fields\": self.fields}\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return self.name == other.name and self.fields == other.fields\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class RankProfile(ToJson, FromJson[\"RankProfile\"]):\n+    def __init__(\n+        self, name: str, first_phase: str, inherits: Optional[str] = None\n+    ) -> None:\n+        \"\"\"\n+        Define a Vespa rank profile\n+\n+        :param name: Rank profile name.\n+        :param first_phase: First phase ranking expression.\n+        \"\"\"\n+        self.name = name\n+        self.first_phase = first_phase\n+        self.inherits = inherits\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"RankProfile\":\n+        return RankProfile(\n+            name=mapping[\"name\"],\n+            first_phase=mapping[\"first_phase\"],\n+            inherits=mapping.get(\"inherits\", None),\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\"name\": self.name, \"first_phase\": self.first_phase}\n+        if self.inherits is not None:\n+            map.update({\"inherits\": self.inherits})\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.first_phase == other.first_phase\n+            and self.inherits == other.inherits\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class Schema(ToJson, FromJson[\"Schema\"]):\n+    def __init__(\n+        self,\n+        name: str,\n+        document: Document,\n+        fieldsets: Optional[List[FieldSet]] = None,\n+        rank_profiles: Optional[List[RankProfile]] = None,\n+    ) -> None:\n+        \"\"\"\n+        Create a Vespa Schema.\n+\n+        :param name: Schema name.\n+        :param document: Vespa document associated with the Schema.\n+        :param fieldsets: A list of `FieldSet` associated with the Schema.\n+        :param rank_profiles: A list of `RankProfile` associated with the Schema.\n+        \"\"\"\n+        self.name = name\n+        self.document = document\n+\n+        self.fieldsets = {}\n+        if fieldsets is not None:\n+            self.fieldsets = {fieldset.name: fieldset for fieldset in fieldsets}\n+\n+        self.rank_profiles = {}\n+        if rank_profiles is not None:\n+            self.rank_profiles = {\n+                rank_profile.name: rank_profile for rank_profile in rank_profiles\n+            }\n+\n+    def add_rank_profile(self, rank_profile: RankProfile) -> None:\n+        \"\"\"\n+        Add a `RankProfile` to the `Schema`.\n+        :param rank_profile: `RankProfile` to be added.\n+        :return: None.\n+        \"\"\"\n+        self.rank_profiles.update({rank_profile.name: rank_profile})\n+\n+    @staticmethod\n+    def from_dict(mapping: Mapping) -> \"Schema\":\n+        return Schema(\n+            name=mapping[\"name\"],\n+            document=FromJson.map(mapping[\"document\"]),\n+            fieldsets=[FromJson.map(fieldset) for fieldset in mapping[\"fieldsets\"]],\n+            rank_profiles=[\n+                FromJson.map(rank_profile) for rank_profile in mapping[\"rank_profiles\"]\n+            ],\n+        )\n+\n+    @property\n+    def to_dict(self) -> Mapping:\n+        map = {\n+            \"name\": self.name,\n+            \"document\": self.document.to_envelope,\n+            \"fieldsets\": [\n+                self.fieldsets[name].to_envelope for name in self.fieldsets.keys()\n+            ],\n+            \"rank_profiles\": [\n+                self.rank_profiles[name].to_envelope\n+                for name in self.rank_profiles.keys()\n+            ],\n+        }\n+        return map\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, self.__class__):\n+            return False\n+        return (\n+            self.name == other.name\n+            and self.document == other.document\n+            and self.fieldsets == other.fieldsets\n+            and self.rank_profiles == other.rank_profiles\n+        )\n+\n+    def __repr__(self):\n+        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+\n+\n+class ApplicationPackage(ToJson, FromJson[\"ApplicationPackage\"]):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA5OTczNA=="}, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjEzNzg3OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/templates/services.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOTozOTowMFrOGtQKSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOTozOTowMFrOGtQKSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwMzg4Mw==", "bodyText": "I don't think this is necessary. The indexing docproc cluster is implicitly there.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450103883", "createdAt": "2020-07-06T09:39:00Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/templates/services.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<services version=\"1.0\">\n+    <container id=\"{{ application_name }}_container\" version=\"1.0\">\n+        <search></search>\n+        <document-processing></document-processing>\n+        <document-api></document-api>\n+    </container>\n+    <content id=\"{{ application_name }}_content\" version=\"1.0\">\n+        <redundancy reply-after=\"1\">1</redundancy>\n+        <documents>\n+            <document type=\"{{ document_name }}\" mode=\"index\"></document>\n+            <document-processing cluster=\"{{ application_name }}_container\"></document-processing>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNjEzODg0OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/templates/services.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOTozOToxNlrOGtQK5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwOTozOToxNlrOGtQK5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEwNDAzNw==", "bodyText": "Unless you are adding document processors, you don't need this either.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450104037", "createdAt": "2020-07-06T09:39:16Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/templates/services.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<services version=\"1.0\">\n+    <container id=\"{{ application_name }}_container\" version=\"1.0\">\n+        <search></search>\n+        <document-processing></document-processing>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ca9b9fbbcfbf61eae4681438fb81c9c0b0d66a5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDQ0NTQ4OnYy", "diffSide": "RIGHT", "path": "python/vespa/vespa/package.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1NDoxMVrOGt5UJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMDo1NDoxMVrOGt5UJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3ODE0OA==", "bodyText": "You should probably call repr() on these.", "url": "https://github.com/vespa-engine/vespa/pull/13653#discussion_r450778148", "createdAt": "2020-07-07T10:54:11Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -65,7 +65,13 @@ def __eq__(self, other):\n         )\n \n     def __repr__(self):\n-        return \"{0}\\n{1}\".format(self.__class__.__name__, str(self.to_dict))\n+        return \"{0}({1}, {2}, {3}, {4})\".format(\n+            self.__class__.__name__,\n+            str(self.name),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4825ad2f4f874f4675b35c86c19ca4bf96ff241"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1968, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}