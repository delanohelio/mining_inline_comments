{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyMTc0OTA2", "number": 14141, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzo1Nzo0N1rOEcFP1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDozOTozOFrOEdKbPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3ODgxNTU4OnYy", "diffSide": "RIGHT", "path": "build_settings.cmake", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMzo1Nzo0N1rOHGZY3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjoxNDozOFrOHGfjKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2OTQ2OA==", "bodyText": "Consider reverting the above change.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r476469468", "createdAt": "2020-08-25T13:57:47Z", "author": {"login": "toregge"}, "path": "build_settings.cmake", "diffHunk": "@@ -73,7 +73,7 @@ else()\n endif()\n \n # C and C++ compiler flags\n-set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -g -O3 -fno-omit-frame-pointer ${C_WARN_OPTS} -fPIC ${VESPA_CXX_ABI_FLAGS} ${VESPA_XXHASH_DEFINE} -DBOOST_DISABLE_ASSERTS ${VESPA_CPU_ARCH_FLAGS} ${EXTRA_C_FLAGS}\")\n+set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -g -O0 -fno-omit-frame-pointer ${C_WARN_OPTS} -fPIC ${VESPA_CXX_ABI_FLAGS} ${VESPA_XXHASH_DEFINE} -DBOOST_DISABLE_ASSERTS ${VESPA_CPU_ARCH_FLAGS} ${EXTRA_C_FLAGS}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f2cbc87ff807ef4ae22db020ccbf2e49f735e23"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3MDQxMQ==", "bodyText": "Consider is a bit on the weak side :)", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r476570411", "createdAt": "2020-08-25T16:14:38Z", "author": {"login": "baldersheim"}, "path": "build_settings.cmake", "diffHunk": "@@ -73,7 +73,7 @@ else()\n endif()\n \n # C and C++ compiler flags\n-set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -g -O3 -fno-omit-frame-pointer ${C_WARN_OPTS} -fPIC ${VESPA_CXX_ABI_FLAGS} ${VESPA_XXHASH_DEFINE} -DBOOST_DISABLE_ASSERTS ${VESPA_CPU_ARCH_FLAGS} ${EXTRA_C_FLAGS}\")\n+set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -g -O0 -fno-omit-frame-pointer ${C_WARN_OPTS} -fPIC ${VESPA_CXX_ABI_FLAGS} ${VESPA_XXHASH_DEFINE} -DBOOST_DISABLE_ASSERTS ${VESPA_CPU_ARCH_FLAGS} ${EXTRA_C_FLAGS}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2OTQ2OA=="}, "originalCommit": {"oid": "0f2cbc87ff807ef4ae22db020ccbf2e49f735e23"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzYwNjI0OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTo1MTo0MFrOHHId5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMjowMjo1NlrOHHI1Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0MDgwNQ==", "bodyText": "Newline is missing at end of file.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r477240805", "createdAt": "2020-08-26T11:51:40Z", "author": {"login": "toregge"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.cpp", "diffHunk": "@@ -58,12 +90,137 @@ PendingLidTracker::consume(uint32_t lid) {\n     }\n }\n \n+ILidCommitState::State\n+PendingLidTracker::waitFor(MonitorGuard & guard, State state, uint32_t lid) const {\n+    for (auto found = _pending.find(lid); found != _pending.end(); found = _pending.find(lid)) {\n+        if (state == State::NEED_COMMIT) {\n+            return State::WAITING;\n+        }\n+        _cond.wait(guard);\n+    }\n+    return State::COMPLETED;\n+}\n+\n+PendingLidTrackerBase::Snapshot\n+PendingLidTracker::produceSnapshot() {\n+    return Snapshot();\n+}\n+\n+ILidCommitState::LidList\n+PendingLidTracker::pendingLids() const {\n+    MonitorGuard guard(_mutex);\n+    LidList lids;\n+    lids.reserve(_pending.size());\n+    for (const auto & entry : _pending) {\n+        lids.push_back(entry.first);\n+    }\n+    return lids;\n+}\n+\n+TwoPhasePendingLidTracker::TwoPhasePendingLidTracker() = default;\n+\n+TwoPhasePendingLidTracker::~TwoPhasePendingLidTracker() {\n+    assert(_pending.empty());\n+}\n+\n+IPendingLidTracker::Token\n+TwoPhasePendingLidTracker::produce(uint32_t lid) {\n+    std::lock_guard guard(_mutex);\n+    _pending[lid].inflight_feed++;\n+    return Token(lid, *this);\n+}\n void\n-PendingLidTracker::waitForConsumedLid(uint32_t lid) {\n-    std::unique_lock<std::mutex> guard(_mutex);\n-    while (_pending.find(lid) != _pending.end()) {\n+TwoPhasePendingLidTracker::consume(uint32_t lid) {\n+    std::lock_guard guard(_mutex);\n+    auto found = _pending.find(lid);\n+    assert (found != _pending.end());\n+    assert (found->second.inflight_feed > 0);\n+    found->second.inflight_feed--;\n+    found->second.need_commit = true;\n+}\n+\n+ILidCommitState::State\n+TwoPhasePendingLidTracker::waitFor(MonitorGuard & guard, State state, uint32_t lid) const {\n+    for (auto found = _pending.find(lid); found != _pending.end(); found = _pending.find(lid)) {\n+        if (state == State::NEED_COMMIT) {\n+            if ((found->second.inflight_feed > 0) || found->second.need_commit) {\n+                return State::NEED_COMMIT;\n+            }\n+            return State::WAITING;\n+        }\n         _cond.wait(guard);\n     }\n+    return State::COMPLETED;\n }\n \n+void\n+TwoPhasePendingLidTracker::consumeSnapshot(LidList committed) {\n+    MonitorGuard guard(_mutex);\n+    for (const auto & lid : committed) {\n+        auto found = _pending.find(lid);\n+        assert(found != _pending.end());\n+        assert(found->second.inflight_commit >= 1);\n+        found->second.inflight_commit --;\n+        if (found->second.empty()) {\n+            _pending.erase(found);\n+        }\n+    }\n+    _cond.notify_all();\n+}\n+\n+ILidCommitState::LidList\n+TwoPhasePendingLidTracker::pendingLids() const {\n+    MonitorGuard guard(_mutex);\n+    LidList lids;\n+    lids.reserve(_pending.size());\n+    for (const auto & entry : _pending) {\n+        lids.push_back(entry.first);\n+    }\n+    return lids;\n }\n+\n+namespace common::internal {\n+\n+class CommitList : public PendingLidTrackerBase::Payload {\n+public:\n+    using LidList = ILidCommitState::LidList;\n+    CommitList(LidList lids, TwoPhasePendingLidTracker & tracker)\n+        : _tracker(&tracker),\n+          _lids(std::move(lids))\n+    { }\n+    CommitList(const CommitList &) = delete;\n+    CommitList & operator = (const CommitList &) = delete;\n+    CommitList & operator = (CommitList &&) = delete;\n+    CommitList(CommitList && rhs) noexcept\n+        : _tracker(rhs._tracker),\n+          _lids(std::move(rhs._lids))\n+    {\n+        rhs._tracker = nullptr;\n+    }\n+    ~CommitList() override {\n+        if (_tracker != nullptr) {\n+            _tracker->consumeSnapshot(std::move(_lids));\n+        }\n+    }\n+private:\n+    TwoPhasePendingLidTracker * _tracker;\n+    LidList                     _lids;\n+};\n+\n+}\n+\n+PendingLidTrackerBase::Snapshot\n+TwoPhasePendingLidTracker::produceSnapshot() {\n+    LidList toCommit;\n+    MonitorGuard guard(_mutex);\n+    for (auto & entry : _pending) {\n+        if (entry.second.need_commit) {\n+            toCommit.emplace_back(entry.first);\n+            entry.second.inflight_commit ++;\n+            entry.second.need_commit = false;\n+        }\n+    }\n+    return std::make_unique<common::internal::CommitList>(std::move(toCommit), *this);\n+}\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b2248ed030d2427443712e80569857016cb858e"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0NjcyNg==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r477246726", "createdAt": "2020-08-26T12:02:56Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.cpp", "diffHunk": "@@ -58,12 +90,137 @@ PendingLidTracker::consume(uint32_t lid) {\n     }\n }\n \n+ILidCommitState::State\n+PendingLidTracker::waitFor(MonitorGuard & guard, State state, uint32_t lid) const {\n+    for (auto found = _pending.find(lid); found != _pending.end(); found = _pending.find(lid)) {\n+        if (state == State::NEED_COMMIT) {\n+            return State::WAITING;\n+        }\n+        _cond.wait(guard);\n+    }\n+    return State::COMPLETED;\n+}\n+\n+PendingLidTrackerBase::Snapshot\n+PendingLidTracker::produceSnapshot() {\n+    return Snapshot();\n+}\n+\n+ILidCommitState::LidList\n+PendingLidTracker::pendingLids() const {\n+    MonitorGuard guard(_mutex);\n+    LidList lids;\n+    lids.reserve(_pending.size());\n+    for (const auto & entry : _pending) {\n+        lids.push_back(entry.first);\n+    }\n+    return lids;\n+}\n+\n+TwoPhasePendingLidTracker::TwoPhasePendingLidTracker() = default;\n+\n+TwoPhasePendingLidTracker::~TwoPhasePendingLidTracker() {\n+    assert(_pending.empty());\n+}\n+\n+IPendingLidTracker::Token\n+TwoPhasePendingLidTracker::produce(uint32_t lid) {\n+    std::lock_guard guard(_mutex);\n+    _pending[lid].inflight_feed++;\n+    return Token(lid, *this);\n+}\n void\n-PendingLidTracker::waitForConsumedLid(uint32_t lid) {\n-    std::unique_lock<std::mutex> guard(_mutex);\n-    while (_pending.find(lid) != _pending.end()) {\n+TwoPhasePendingLidTracker::consume(uint32_t lid) {\n+    std::lock_guard guard(_mutex);\n+    auto found = _pending.find(lid);\n+    assert (found != _pending.end());\n+    assert (found->second.inflight_feed > 0);\n+    found->second.inflight_feed--;\n+    found->second.need_commit = true;\n+}\n+\n+ILidCommitState::State\n+TwoPhasePendingLidTracker::waitFor(MonitorGuard & guard, State state, uint32_t lid) const {\n+    for (auto found = _pending.find(lid); found != _pending.end(); found = _pending.find(lid)) {\n+        if (state == State::NEED_COMMIT) {\n+            if ((found->second.inflight_feed > 0) || found->second.need_commit) {\n+                return State::NEED_COMMIT;\n+            }\n+            return State::WAITING;\n+        }\n         _cond.wait(guard);\n     }\n+    return State::COMPLETED;\n }\n \n+void\n+TwoPhasePendingLidTracker::consumeSnapshot(LidList committed) {\n+    MonitorGuard guard(_mutex);\n+    for (const auto & lid : committed) {\n+        auto found = _pending.find(lid);\n+        assert(found != _pending.end());\n+        assert(found->second.inflight_commit >= 1);\n+        found->second.inflight_commit --;\n+        if (found->second.empty()) {\n+            _pending.erase(found);\n+        }\n+    }\n+    _cond.notify_all();\n+}\n+\n+ILidCommitState::LidList\n+TwoPhasePendingLidTracker::pendingLids() const {\n+    MonitorGuard guard(_mutex);\n+    LidList lids;\n+    lids.reserve(_pending.size());\n+    for (const auto & entry : _pending) {\n+        lids.push_back(entry.first);\n+    }\n+    return lids;\n }\n+\n+namespace common::internal {\n+\n+class CommitList : public PendingLidTrackerBase::Payload {\n+public:\n+    using LidList = ILidCommitState::LidList;\n+    CommitList(LidList lids, TwoPhasePendingLidTracker & tracker)\n+        : _tracker(&tracker),\n+          _lids(std::move(lids))\n+    { }\n+    CommitList(const CommitList &) = delete;\n+    CommitList & operator = (const CommitList &) = delete;\n+    CommitList & operator = (CommitList &&) = delete;\n+    CommitList(CommitList && rhs) noexcept\n+        : _tracker(rhs._tracker),\n+          _lids(std::move(rhs._lids))\n+    {\n+        rhs._tracker = nullptr;\n+    }\n+    ~CommitList() override {\n+        if (_tracker != nullptr) {\n+            _tracker->consumeSnapshot(std::move(_lids));\n+        }\n+    }\n+private:\n+    TwoPhasePendingLidTracker * _tracker;\n+    LidList                     _lids;\n+};\n+\n+}\n+\n+PendingLidTrackerBase::Snapshot\n+TwoPhasePendingLidTracker::produceSnapshot() {\n+    LidList toCommit;\n+    MonitorGuard guard(_mutex);\n+    for (auto & entry : _pending) {\n+        if (entry.second.need_commit) {\n+            toCommit.emplace_back(entry.first);\n+            entry.second.inflight_commit ++;\n+            entry.second.need_commit = false;\n+        }\n+    }\n+    return std::make_unique<common::internal::CommitList>(std::move(toCommit), *this);\n+}\n+\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0MDgwNQ=="}, "originalCommit": {"oid": "5b2248ed030d2427443712e80569857016cb858e"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTczMjc5OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODo0NzoyNFrOHIGkCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoyODozMFrOHIKJdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1ODE4NQ==", "bodyText": "Some more details on the various states and transitions would be nice.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478258185", "createdAt": "2020-08-27T08:47:24Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -30,33 +32,102 @@ class IPendingLidTracker {\n     };\n     virtual ~IPendingLidTracker() = default;\n     virtual Token produce(uint32_t lid) = 0;\n-    virtual void waitForConsumedLid(uint32_t lid) = 0;\n private:\n     virtual void consume(uint32_t lid) = 0;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n-    vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n-class NoopLidTracker : public IPendingLidTracker {\n+/**\n+ * This is an interface for checking/waiting the state of a lid in the feedpipeline", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxNjkxOA==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478316918", "createdAt": "2020-08-27T10:28:30Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -30,33 +32,102 @@ class IPendingLidTracker {\n     };\n     virtual ~IPendingLidTracker() = default;\n     virtual Token produce(uint32_t lid) = 0;\n-    virtual void waitForConsumedLid(uint32_t lid) = 0;\n private:\n     virtual void consume(uint32_t lid) = 0;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n-    vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n-class NoopLidTracker : public IPendingLidTracker {\n+/**\n+ * This is an interface for checking/waiting the state of a lid in the feedpipeline", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1ODE4NQ=="}, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTczNTE5OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODo0ODowM1rOHIGljQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoyODoyMFrOHIKJFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1ODU3Mw==", "bodyText": "Don't think this comment is up to date as it also is used as base class for PendingLidTracker.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478258573", "createdAt": "2020-08-27T08:48:03Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -30,33 +32,102 @@ class IPendingLidTracker {\n     };\n     virtual ~IPendingLidTracker() = default;\n     virtual Token produce(uint32_t lid) = 0;\n-    virtual void waitForConsumedLid(uint32_t lid) = 0;\n private:\n     virtual void consume(uint32_t lid) = 0;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n-    vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n-class NoopLidTracker : public IPendingLidTracker {\n+/**\n+ * This is an interface for checking/waiting the state of a lid in the feedpipeline\n+ */\n+class ILidCommitState {\n public:\n-    Token produce(uint32_t lid) override;\n-    void waitForConsumedLid(uint32_t ) override { }\n+    enum class State {NEED_COMMIT, WAITING, COMPLETED};\n+    using LidList = std::vector<uint32_t>;\n+    virtual ~ILidCommitState() = default;\n+    State getState() const { return waitState(State::NEED_COMMIT); }\n+    State getState(uint32_t lid) const { return waitState(State::NEED_COMMIT, lid); }\n+    State getState(const LidList & lids) const { return waitState(State::NEED_COMMIT, lids); }\n+    void waitComplete(uint32_t lid) const;\n+    void waitComplete(const LidList & lids) const;\n+    void waitComplete() const;\n private:\n-    void consume(uint32_t ) override { }\n+    virtual State waitState(State state, uint32_t lid) const = 0;\n+    virtual State waitState(State state, const LidList & lids) const = 0;\n+    virtual State waitState(State state) const = 0;\n+};\n+\n+/**\n+ * Base class for doing 2 phase lidtracking.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI2ODE3Nw==", "bodyText": "Also describe the difference between a Token and a Snapshot.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478268177", "createdAt": "2020-08-27T09:03:59Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -30,33 +32,102 @@ class IPendingLidTracker {\n     };\n     virtual ~IPendingLidTracker() = default;\n     virtual Token produce(uint32_t lid) = 0;\n-    virtual void waitForConsumedLid(uint32_t lid) = 0;\n private:\n     virtual void consume(uint32_t lid) = 0;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n-    vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n-class NoopLidTracker : public IPendingLidTracker {\n+/**\n+ * This is an interface for checking/waiting the state of a lid in the feedpipeline\n+ */\n+class ILidCommitState {\n public:\n-    Token produce(uint32_t lid) override;\n-    void waitForConsumedLid(uint32_t ) override { }\n+    enum class State {NEED_COMMIT, WAITING, COMPLETED};\n+    using LidList = std::vector<uint32_t>;\n+    virtual ~ILidCommitState() = default;\n+    State getState() const { return waitState(State::NEED_COMMIT); }\n+    State getState(uint32_t lid) const { return waitState(State::NEED_COMMIT, lid); }\n+    State getState(const LidList & lids) const { return waitState(State::NEED_COMMIT, lids); }\n+    void waitComplete(uint32_t lid) const;\n+    void waitComplete(const LidList & lids) const;\n+    void waitComplete() const;\n private:\n-    void consume(uint32_t ) override { }\n+    virtual State waitState(State state, uint32_t lid) const = 0;\n+    virtual State waitState(State state, const LidList & lids) const = 0;\n+    virtual State waitState(State state) const = 0;\n+};\n+\n+/**\n+ * Base class for doing 2 phase lidtracking.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1ODU3Mw=="}, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxNjgyMg==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478316822", "createdAt": "2020-08-27T10:28:20Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -30,33 +32,102 @@ class IPendingLidTracker {\n     };\n     virtual ~IPendingLidTracker() = default;\n     virtual Token produce(uint32_t lid) = 0;\n-    virtual void waitForConsumedLid(uint32_t lid) = 0;\n private:\n     virtual void consume(uint32_t lid) = 0;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n-    vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n-class NoopLidTracker : public IPendingLidTracker {\n+/**\n+ * This is an interface for checking/waiting the state of a lid in the feedpipeline\n+ */\n+class ILidCommitState {\n public:\n-    Token produce(uint32_t lid) override;\n-    void waitForConsumedLid(uint32_t ) override { }\n+    enum class State {NEED_COMMIT, WAITING, COMPLETED};\n+    using LidList = std::vector<uint32_t>;\n+    virtual ~ILidCommitState() = default;\n+    State getState() const { return waitState(State::NEED_COMMIT); }\n+    State getState(uint32_t lid) const { return waitState(State::NEED_COMMIT, lid); }\n+    State getState(const LidList & lids) const { return waitState(State::NEED_COMMIT, lids); }\n+    void waitComplete(uint32_t lid) const;\n+    void waitComplete(const LidList & lids) const;\n+    void waitComplete() const;\n private:\n-    void consume(uint32_t ) override { }\n+    virtual State waitState(State state, uint32_t lid) const = 0;\n+    virtual State waitState(State state, const LidList & lids) const = 0;\n+    virtual State waitState(State state) const = 0;\n+};\n+\n+/**\n+ * Base class for doing 2 phase lidtracking.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1ODU3Mw=="}, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTczNTc2OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODo0ODoxMVrOHIGl4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoyODoxMFrOHIKIvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1ODY1Ng==", "bodyText": "Some more details on how this works would be nice.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478258656", "createdAt": "2020-08-27T08:48:11Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -30,33 +32,102 @@ class IPendingLidTracker {\n     };\n     virtual ~IPendingLidTracker() = default;\n     virtual Token produce(uint32_t lid) = 0;\n-    virtual void waitForConsumedLid(uint32_t lid) = 0;\n private:\n     virtual void consume(uint32_t lid) = 0;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n-    vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n-class NoopLidTracker : public IPendingLidTracker {\n+/**\n+ * This is an interface for checking/waiting the state of a lid in the feedpipeline\n+ */\n+class ILidCommitState {\n public:\n-    Token produce(uint32_t lid) override;\n-    void waitForConsumedLid(uint32_t ) override { }\n+    enum class State {NEED_COMMIT, WAITING, COMPLETED};\n+    using LidList = std::vector<uint32_t>;\n+    virtual ~ILidCommitState() = default;\n+    State getState() const { return waitState(State::NEED_COMMIT); }\n+    State getState(uint32_t lid) const { return waitState(State::NEED_COMMIT, lid); }\n+    State getState(const LidList & lids) const { return waitState(State::NEED_COMMIT, lids); }\n+    void waitComplete(uint32_t lid) const;\n+    void waitComplete(const LidList & lids) const;\n+    void waitComplete() const;\n private:\n-    void consume(uint32_t ) override { }\n+    virtual State waitState(State state, uint32_t lid) const = 0;\n+    virtual State waitState(State state, const LidList & lids) const = 0;\n+    virtual State waitState(State state) const = 0;\n+};\n+\n+/**\n+ * Base class for doing 2 phase lidtracking.\n+ */\n+class PendingLidTrackerBase : public IPendingLidTracker,\n+                              public ILidCommitState\n+{\n+public:\n+    ~PendingLidTrackerBase();\n+    struct Payload {\n+        virtual ~Payload() = default;\n+    };\n+    using Snapshot = std::unique_ptr<Payload>;\n+    virtual Snapshot produceSnapshot() = 0;\n+\n+    State waitState(State state) const override;\n+    State waitState(State state, uint32_t lid) const override;\n+    State waitState(State state, const LidList & lids) const override;\n+protected:\n+    using MonitorGuard = std::unique_lock<std::mutex>;\n+    PendingLidTrackerBase();\n+    virtual LidList pendingLids() const = 0;\n+    virtual State waitFor(MonitorGuard & guard, State state, uint32_t lid) const = 0;\n+    MonitorGuard getGuard() { return MonitorGuard(_mutex); }\n+    mutable std::mutex                     _mutex;\n+    mutable std::condition_variable        _cond;\n };\n \n-class PendingLidTracker : public IPendingLidTracker {\n+/**\n+ * Use for tracking lids in a single phase.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxNjczNA==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478316734", "createdAt": "2020-08-27T10:28:10Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -30,33 +32,102 @@ class IPendingLidTracker {\n     };\n     virtual ~IPendingLidTracker() = default;\n     virtual Token produce(uint32_t lid) = 0;\n-    virtual void waitForConsumedLid(uint32_t lid) = 0;\n private:\n     virtual void consume(uint32_t lid) = 0;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n-    vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n-class NoopLidTracker : public IPendingLidTracker {\n+/**\n+ * This is an interface for checking/waiting the state of a lid in the feedpipeline\n+ */\n+class ILidCommitState {\n public:\n-    Token produce(uint32_t lid) override;\n-    void waitForConsumedLid(uint32_t ) override { }\n+    enum class State {NEED_COMMIT, WAITING, COMPLETED};\n+    using LidList = std::vector<uint32_t>;\n+    virtual ~ILidCommitState() = default;\n+    State getState() const { return waitState(State::NEED_COMMIT); }\n+    State getState(uint32_t lid) const { return waitState(State::NEED_COMMIT, lid); }\n+    State getState(const LidList & lids) const { return waitState(State::NEED_COMMIT, lids); }\n+    void waitComplete(uint32_t lid) const;\n+    void waitComplete(const LidList & lids) const;\n+    void waitComplete() const;\n private:\n-    void consume(uint32_t ) override { }\n+    virtual State waitState(State state, uint32_t lid) const = 0;\n+    virtual State waitState(State state, const LidList & lids) const = 0;\n+    virtual State waitState(State state) const = 0;\n+};\n+\n+/**\n+ * Base class for doing 2 phase lidtracking.\n+ */\n+class PendingLidTrackerBase : public IPendingLidTracker,\n+                              public ILidCommitState\n+{\n+public:\n+    ~PendingLidTrackerBase();\n+    struct Payload {\n+        virtual ~Payload() = default;\n+    };\n+    using Snapshot = std::unique_ptr<Payload>;\n+    virtual Snapshot produceSnapshot() = 0;\n+\n+    State waitState(State state) const override;\n+    State waitState(State state, uint32_t lid) const override;\n+    State waitState(State state, const LidList & lids) const override;\n+protected:\n+    using MonitorGuard = std::unique_lock<std::mutex>;\n+    PendingLidTrackerBase();\n+    virtual LidList pendingLids() const = 0;\n+    virtual State waitFor(MonitorGuard & guard, State state, uint32_t lid) const = 0;\n+    MonitorGuard getGuard() { return MonitorGuard(_mutex); }\n+    mutable std::mutex                     _mutex;\n+    mutable std::condition_variable        _cond;\n };\n \n-class PendingLidTracker : public IPendingLidTracker {\n+/**\n+ * Use for tracking lids in a single phase.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1ODY1Ng=="}, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTczNzQwOnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODo0ODo0MVrOHIGm-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoyODowMFrOHIKIfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1ODkzNg==", "bodyText": "Some more details on how this works would be nice.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478258936", "createdAt": "2020-08-27T08:48:41Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -30,33 +32,102 @@ class IPendingLidTracker {\n     };\n     virtual ~IPendingLidTracker() = default;\n     virtual Token produce(uint32_t lid) = 0;\n-    virtual void waitForConsumedLid(uint32_t lid) = 0;\n private:\n     virtual void consume(uint32_t lid) = 0;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n-    vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n-class NoopLidTracker : public IPendingLidTracker {\n+/**\n+ * This is an interface for checking/waiting the state of a lid in the feedpipeline\n+ */\n+class ILidCommitState {\n public:\n-    Token produce(uint32_t lid) override;\n-    void waitForConsumedLid(uint32_t ) override { }\n+    enum class State {NEED_COMMIT, WAITING, COMPLETED};\n+    using LidList = std::vector<uint32_t>;\n+    virtual ~ILidCommitState() = default;\n+    State getState() const { return waitState(State::NEED_COMMIT); }\n+    State getState(uint32_t lid) const { return waitState(State::NEED_COMMIT, lid); }\n+    State getState(const LidList & lids) const { return waitState(State::NEED_COMMIT, lids); }\n+    void waitComplete(uint32_t lid) const;\n+    void waitComplete(const LidList & lids) const;\n+    void waitComplete() const;\n private:\n-    void consume(uint32_t ) override { }\n+    virtual State waitState(State state, uint32_t lid) const = 0;\n+    virtual State waitState(State state, const LidList & lids) const = 0;\n+    virtual State waitState(State state) const = 0;\n+};\n+\n+/**\n+ * Base class for doing 2 phase lidtracking.\n+ */\n+class PendingLidTrackerBase : public IPendingLidTracker,\n+                              public ILidCommitState\n+{\n+public:\n+    ~PendingLidTrackerBase();\n+    struct Payload {\n+        virtual ~Payload() = default;\n+    };\n+    using Snapshot = std::unique_ptr<Payload>;\n+    virtual Snapshot produceSnapshot() = 0;\n+\n+    State waitState(State state) const override;\n+    State waitState(State state, uint32_t lid) const override;\n+    State waitState(State state, const LidList & lids) const override;\n+protected:\n+    using MonitorGuard = std::unique_lock<std::mutex>;\n+    PendingLidTrackerBase();\n+    virtual LidList pendingLids() const = 0;\n+    virtual State waitFor(MonitorGuard & guard, State state, uint32_t lid) const = 0;\n+    MonitorGuard getGuard() { return MonitorGuard(_mutex); }\n+    mutable std::mutex                     _mutex;\n+    mutable std::condition_variable        _cond;\n };\n \n-class PendingLidTracker : public IPendingLidTracker {\n+/**\n+ * Use for tracking lids in a single phase.\n+ */\n+class PendingLidTracker : public PendingLidTrackerBase\n+{\n public:\n     PendingLidTracker();\n     ~PendingLidTracker() override;\n     Token produce(uint32_t lid) override;\n-    void waitForConsumedLid(uint32_t lid) override;\n+    Snapshot produceSnapshot() override;\n private:\n+    LidList pendingLids() const override;\n     void consume(uint32_t lid) override;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n+    State waitFor(MonitorGuard & guard, State state, uint32_t lid) const override;\n+\n     vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n+namespace common::internal {\n+    class CommitList;\n+}\n+/**\n+ * Use for tracking lids in 2 phases.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxNjY2OA==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478316668", "createdAt": "2020-08-27T10:28:00Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -30,33 +32,102 @@ class IPendingLidTracker {\n     };\n     virtual ~IPendingLidTracker() = default;\n     virtual Token produce(uint32_t lid) = 0;\n-    virtual void waitForConsumedLid(uint32_t lid) = 0;\n private:\n     virtual void consume(uint32_t lid) = 0;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n-    vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n-class NoopLidTracker : public IPendingLidTracker {\n+/**\n+ * This is an interface for checking/waiting the state of a lid in the feedpipeline\n+ */\n+class ILidCommitState {\n public:\n-    Token produce(uint32_t lid) override;\n-    void waitForConsumedLid(uint32_t ) override { }\n+    enum class State {NEED_COMMIT, WAITING, COMPLETED};\n+    using LidList = std::vector<uint32_t>;\n+    virtual ~ILidCommitState() = default;\n+    State getState() const { return waitState(State::NEED_COMMIT); }\n+    State getState(uint32_t lid) const { return waitState(State::NEED_COMMIT, lid); }\n+    State getState(const LidList & lids) const { return waitState(State::NEED_COMMIT, lids); }\n+    void waitComplete(uint32_t lid) const;\n+    void waitComplete(const LidList & lids) const;\n+    void waitComplete() const;\n private:\n-    void consume(uint32_t ) override { }\n+    virtual State waitState(State state, uint32_t lid) const = 0;\n+    virtual State waitState(State state, const LidList & lids) const = 0;\n+    virtual State waitState(State state) const = 0;\n+};\n+\n+/**\n+ * Base class for doing 2 phase lidtracking.\n+ */\n+class PendingLidTrackerBase : public IPendingLidTracker,\n+                              public ILidCommitState\n+{\n+public:\n+    ~PendingLidTrackerBase();\n+    struct Payload {\n+        virtual ~Payload() = default;\n+    };\n+    using Snapshot = std::unique_ptr<Payload>;\n+    virtual Snapshot produceSnapshot() = 0;\n+\n+    State waitState(State state) const override;\n+    State waitState(State state, uint32_t lid) const override;\n+    State waitState(State state, const LidList & lids) const override;\n+protected:\n+    using MonitorGuard = std::unique_lock<std::mutex>;\n+    PendingLidTrackerBase();\n+    virtual LidList pendingLids() const = 0;\n+    virtual State waitFor(MonitorGuard & guard, State state, uint32_t lid) const = 0;\n+    MonitorGuard getGuard() { return MonitorGuard(_mutex); }\n+    mutable std::mutex                     _mutex;\n+    mutable std::condition_variable        _cond;\n };\n \n-class PendingLidTracker : public IPendingLidTracker {\n+/**\n+ * Use for tracking lids in a single phase.\n+ */\n+class PendingLidTracker : public PendingLidTrackerBase\n+{\n public:\n     PendingLidTracker();\n     ~PendingLidTracker() override;\n     Token produce(uint32_t lid) override;\n-    void waitForConsumedLid(uint32_t lid) override;\n+    Snapshot produceSnapshot() override;\n private:\n+    LidList pendingLids() const override;\n     void consume(uint32_t lid) override;\n-    std::mutex _mutex;\n-    std::condition_variable _cond;\n+    State waitFor(MonitorGuard & guard, State state, uint32_t lid) const override;\n+\n     vespalib::hash_map<uint32_t, uint32_t> _pending;\n };\n \n+namespace common::internal {\n+    class CommitList;\n+}\n+/**\n+ * Use for tracking lids in 2 phases.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1ODkzNg=="}, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTc2MzEzOnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODo1NTowOVrOHIG2eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoyNzo0N1rOHIKINQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI2MjkwNQ==", "bodyText": "I would like to see some more details on how this interface is used. What is a pending lid, what the Token class represents, and the relationship between produce() and consume().", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478262905", "createdAt": "2020-08-27T08:55:09Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -5,9 +5,11 @@\n #include <vespa/vespalib/stllike/hash_map.h>\n #include <mutex>\n #include <condition_variable>\n+#include <vector>\n \n namespace proton {\n \n+/** Interface for tracking lids in the feed pipeline */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxNjU5Nw==", "bodyText": "Done", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478316597", "createdAt": "2020-08-27T10:27:47Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -5,9 +5,11 @@\n #include <vespa/vespalib/stllike/hash_map.h>\n #include <mutex>\n #include <condition_variable>\n+#include <vector>\n \n namespace proton {\n \n+/** Interface for tracking lids in the feed pipeline */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI2MjkwNQ=="}, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTgyMjAyOnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/server/storeonlyfeedview.cpp", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwOToxMDo1MVrOHIHa9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDoyNzoyOVrOHIKHiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3MjI0NA==", "bodyText": "This is named commitToken other places in this file. Any reason we use another name here? If not, consider consolidating.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478272244", "createdAt": "2020-08-27T09:10:51Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/server/storeonlyfeedview.cpp", "diffHunk": "@@ -585,19 +605,20 @@ StoreOnlyFeedView::internalRemove(FeedToken token, const RemoveOperationWithDocI\n          rmOp.getSubDbId(), rmOp.getLid(), rmOp.getPrevSubDbId(), rmOp.getPrevLid(), _params._subDbId);\n \n     PendingNotifyRemoveDone pendingNotifyRemoveDone = adjustMetaStore(rmOp, docId.getGlobalId(), docId);\n+    auto uncommitted = _pendingLidsForCommit->produce(rmOp.getLid());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3MjU2Mg==", "bodyText": "Note, there are more places we use uncomitted in this file.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478272562", "createdAt": "2020-08-27T09:11:29Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/server/storeonlyfeedview.cpp", "diffHunk": "@@ -585,19 +605,20 @@ StoreOnlyFeedView::internalRemove(FeedToken token, const RemoveOperationWithDocI\n          rmOp.getSubDbId(), rmOp.getLid(), rmOp.getPrevSubDbId(), rmOp.getPrevLid(), _params._subDbId);\n \n     PendingNotifyRemoveDone pendingNotifyRemoveDone = adjustMetaStore(rmOp, docId.getGlobalId(), docId);\n+    auto uncommitted = _pendingLidsForCommit->produce(rmOp.getLid());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3MjI0NA=="}, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxNjQyNw==", "bodyText": "Unified on uncommitted.", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478316427", "createdAt": "2020-08-27T10:27:29Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/server/storeonlyfeedview.cpp", "diffHunk": "@@ -585,19 +605,20 @@ StoreOnlyFeedView::internalRemove(FeedToken token, const RemoveOperationWithDocI\n          rmOp.getSubDbId(), rmOp.getLid(), rmOp.getPrevSubDbId(), rmOp.getPrevLid(), _params._subDbId);\n \n     PendingNotifyRemoveDone pendingNotifyRemoveDone = adjustMetaStore(rmOp, docId.getGlobalId(), docId);\n+    auto uncommitted = _pendingLidsForCommit->produce(rmOp.getLid());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3MjI0NA=="}, "originalCommit": {"oid": "dc2b32f81cc58c2ca03ee67a25526bab03a12d63"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDE0NzA0OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDozODo0MVrOHIKe5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDo1NjozOFrOHIK_rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMyMjQwNg==", "bodyText": "whenn -> when", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478322406", "createdAt": "2020-08-27T10:38:41Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -84,7 +97,8 @@ class PendingLidTrackerBase : public IPendingLidTracker,\n };\n \n /**\n- * Use for tracking lids in a single phase.\n+ * Use for tracking lids whenn visibility-delay is zero and commit is implicit.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a31dd20690d94bbdb12e9f6b1e94b2517fa4c5a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzMDc5OA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478330798", "createdAt": "2020-08-27T10:56:38Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/common/pendinglidtracker.h", "diffHunk": "@@ -84,7 +97,8 @@ class PendingLidTrackerBase : public IPendingLidTracker,\n };\n \n /**\n- * Use for tracking lids in a single phase.\n+ * Use for tracking lids whenn visibility-delay is zero and commit is implicit.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMyMjQwNg=="}, "originalCommit": {"oid": "6a31dd20690d94bbdb12e9f6b1e94b2517fa4c5a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDE0OTc1OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/server/storeonlyfeedview.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDozOTozOFrOHIKggg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDo1NzowMlrOHILAbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMyMjgxOA==", "bodyText": "unconmitted -> uncommitted", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478322818", "createdAt": "2020-08-27T10:39:38Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/server/storeonlyfeedview.cpp", "diffHunk": "@@ -318,7 +318,7 @@ StoreOnlyFeedView::internalPut(FeedToken token, const PutOperation &putOp)\n          _params._subDbId, doc->toString(true).size(), doc->toString(true).c_str());\n \n     PendingNotifyRemoveDone pendingNotifyRemoveDone = adjustMetaStore(putOp, docId.getGlobalId(), docId);\n-    auto commitToken = _pendingLidsForCommit->produce(putOp.getLid());\n+    auto unconmitted = _pendingLidsForCommit->produce(putOp.getLid());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a31dd20690d94bbdb12e9f6b1e94b2517fa4c5a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzMDk5MQ==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/14141#discussion_r478330991", "createdAt": "2020-08-27T10:57:02Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/server/storeonlyfeedview.cpp", "diffHunk": "@@ -318,7 +318,7 @@ StoreOnlyFeedView::internalPut(FeedToken token, const PutOperation &putOp)\n          _params._subDbId, doc->toString(true).size(), doc->toString(true).c_str());\n \n     PendingNotifyRemoveDone pendingNotifyRemoveDone = adjustMetaStore(putOp, docId.getGlobalId(), docId);\n-    auto commitToken = _pendingLidsForCommit->produce(putOp.getLid());\n+    auto unconmitted = _pendingLidsForCommit->produce(putOp.getLid());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMyMjgxOA=="}, "originalCommit": {"oid": "6a31dd20690d94bbdb12e9f6b1e94b2517fa4c5a"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1490, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}