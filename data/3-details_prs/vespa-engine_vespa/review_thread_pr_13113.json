{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwNzQzNzgx", "number": 13113, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDoyODozMlrOD3p0_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTowOToxNFrOD3_y2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjgzNTgzOnYy", "diffSide": "RIGHT", "path": "persistence/src/vespa/persistence/spi/operationcomplete.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDoyODozMlrOGOBmTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo0NzowOFrOGOno-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM1OTQzOQ==", "bodyText": "Should use new VZM copyright comment", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417359439", "createdAt": "2020-04-29T14:28:32Z", "author": {"login": "vekterli"}, "path": "persistence/src/vespa/persistence/spi/operationcomplete.h", "diffHunk": "@@ -0,0 +1,22 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MjcxMg==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417982712", "createdAt": "2020-04-30T12:47:08Z", "author": {"login": "baldersheim"}, "path": "persistence/src/vespa/persistence/spi/operationcomplete.h", "diffHunk": "@@ -0,0 +1,22 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM1OTQzOQ=="}, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5Njg4NTg2OnYy", "diffSide": "RIGHT", "path": "persistence/src/vespa/persistence/spi/persistenceprovider.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDozODoyNlrOGOCFSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo0OTozMlrOGOnuZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM2NzM3MA==", "bodyText": "The naming of this function might be a bit confusing. It can be read as \"wait for result\" (i.e. result is ready when function returns) rather than \"(future) result of waiting\". Maybe call it future_result or similar?", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417367370", "createdAt": "2020-04-29T14:38:26Z", "author": {"login": "vekterli"}, "path": "persistence/src/vespa/persistence/spi/persistenceprovider.cpp", "diffHunk": "@@ -1,9 +1,35 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n #include \"persistenceprovider.h\"\n+#include <future>\n \n namespace storage::spi {\n \n PersistenceProvider::~PersistenceProvider() = default;\n \n+class CatchResult : public OperationComplete {\n+public:\n+    std::future<Result::UP> waitResult() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4NDEwMw==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417984103", "createdAt": "2020-04-30T12:49:32Z", "author": {"login": "baldersheim"}, "path": "persistence/src/vespa/persistence/spi/persistenceprovider.cpp", "diffHunk": "@@ -1,9 +1,35 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n #include \"persistenceprovider.h\"\n+#include <future>\n \n namespace storage::spi {\n \n PersistenceProvider::~PersistenceProvider() = default;\n \n+class CatchResult : public OperationComplete {\n+public:\n+    std::future<Result::UP> waitResult() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM2NzM3MA=="}, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTcxNzEyOnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/common/feedtoken.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNzo0MDoyNFrOGOdc_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjozOTo0MVrOGOnYdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxNTgwNg==", "bodyText": "Consider adding class description.", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417815806", "createdAt": "2020-04-30T07:40:24Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/common/feedtoken.h", "diffHunk": "@@ -15,36 +15,53 @@ typedef std::unique_ptr<storage::spi::Result> ResultUP;\n  * instance of this class is passed to every invokation of the IFeedHandler.\n  */\n namespace feedtoken {\n-    class ITransport {\n-    public:\n-        virtual ~ITransport() { }\n-        virtual void send(ResultUP result, bool documentWasFound) = 0;\n-    };\n-\n-    class State : public search::IDestructorCallback {\n-    public:\n-        State(const State &) = delete;\n-        State & operator = (const State &) = delete;\n-        State(ITransport & transport);\n-        ~State() override;\n-        void fail();\n-        void setResult(ResultUP result, bool documentWasFound) {\n-            _documentWasFound = documentWasFound;\n-            _result = std::move(result);\n-        }\n-        const storage::spi::Result &getResult() { return *_result; }\n-    private:\n-        void ack();\n-        ITransport           &_transport;\n-        ResultUP              _result;\n-        bool                  _documentWasFound;\n-        std::atomic<bool>     _alreadySent;\n-    };\n-\n-    inline std::shared_ptr<State>\n-    make(ITransport & latch) {\n-        return std::make_shared<State>(latch);\n+\n+class ITransport {\n+public:\n+    virtual ~ITransport() { }\n+    virtual void send(ResultUP result, bool documentWasFound) = 0;\n+};\n+\n+class State : public search::IDestructorCallback {\n+public:\n+    State(const State &) = delete;\n+    State & operator = (const State &) = delete;\n+    State(ITransport & transport);\n+    ~State() override;\n+    void fail();\n+    void setResult(ResultUP result, bool documentWasFound) {\n+        _documentWasFound = documentWasFound;\n+        _result = std::move(result);\n     }\n+    const storage::spi::Result &getResult() { return *_result; }\n+protected:\n+    void ack();\n+private:\n+    ITransport           &_transport;\n+    ResultUP              _result;\n+    bool                  _documentWasFound;\n+    std::atomic<bool>     _alreadySent;\n+};\n+class OwningState : public State {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk3ODQ4Ng==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417978486", "createdAt": "2020-04-30T12:39:41Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/common/feedtoken.h", "diffHunk": "@@ -15,36 +15,53 @@ typedef std::unique_ptr<storage::spi::Result> ResultUP;\n  * instance of this class is passed to every invokation of the IFeedHandler.\n  */\n namespace feedtoken {\n-    class ITransport {\n-    public:\n-        virtual ~ITransport() { }\n-        virtual void send(ResultUP result, bool documentWasFound) = 0;\n-    };\n-\n-    class State : public search::IDestructorCallback {\n-    public:\n-        State(const State &) = delete;\n-        State & operator = (const State &) = delete;\n-        State(ITransport & transport);\n-        ~State() override;\n-        void fail();\n-        void setResult(ResultUP result, bool documentWasFound) {\n-            _documentWasFound = documentWasFound;\n-            _result = std::move(result);\n-        }\n-        const storage::spi::Result &getResult() { return *_result; }\n-    private:\n-        void ack();\n-        ITransport           &_transport;\n-        ResultUP              _result;\n-        bool                  _documentWasFound;\n-        std::atomic<bool>     _alreadySent;\n-    };\n-\n-    inline std::shared_ptr<State>\n-    make(ITransport & latch) {\n-        return std::make_shared<State>(latch);\n+\n+class ITransport {\n+public:\n+    virtual ~ITransport() { }\n+    virtual void send(ResultUP result, bool documentWasFound) = 0;\n+};\n+\n+class State : public search::IDestructorCallback {\n+public:\n+    State(const State &) = delete;\n+    State & operator = (const State &) = delete;\n+    State(ITransport & transport);\n+    ~State() override;\n+    void fail();\n+    void setResult(ResultUP result, bool documentWasFound) {\n+        _documentWasFound = documentWasFound;\n+        _result = std::move(result);\n     }\n+    const storage::spi::Result &getResult() { return *_result; }\n+protected:\n+    void ack();\n+private:\n+    ITransport           &_transport;\n+    ResultUP              _result;\n+    bool                  _documentWasFound;\n+    std::atomic<bool>     _alreadySent;\n+};\n+class OwningState : public State {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxNTgwNg=="}, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTczMjk5OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/transport_latch.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNzo0NToxMlrOGOdnBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo0NDoyM1rOGOni_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxODM3Mg==", "bodyText": "Consider adding a reference to the lock to ensure that we don't call this when the lock is not taken.", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417818372", "createdAt": "2020-04-30T07:45:12Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/transport_latch.cpp", "diffHunk": "@@ -8,10 +8,50 @@ using storage::spi::Result;\n \n namespace proton {\n \n+std::unique_ptr<std::mutex> createOptionalLock(bool needLocking) {\n+    return needLocking\n+        ? std::make_unique<std::mutex>()\n+        : std::unique_ptr<std::mutex>();\n+}\n+TransportMerger::TransportMerger(bool needLocking)\n+    : _result(),\n+      _lock(createOptionalLock(needLocking))\n+{\n+}\n+TransportMerger::~TransportMerger() = default;\n+\n+void\n+TransportMerger::mergeResult(ResultUP result, bool documentWasFound) {\n+    if (_lock) {\n+        std::lock_guard<std::mutex> guard(*_lock);\n+        mergeWithLock(std::move(result), documentWasFound);\n+    } else {\n+        mergeWithLock(std::move(result), documentWasFound);\n+    }\n+}\n+\n+void\n+TransportMerger::mergeWithLock(ResultUP result, bool documentWasFound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MTE4MA==", "bodyText": "I did not do that sine the lock is optional.", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417981180", "createdAt": "2020-04-30T12:44:23Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/transport_latch.cpp", "diffHunk": "@@ -8,10 +8,50 @@ using storage::spi::Result;\n \n namespace proton {\n \n+std::unique_ptr<std::mutex> createOptionalLock(bool needLocking) {\n+    return needLocking\n+        ? std::make_unique<std::mutex>()\n+        : std::unique_ptr<std::mutex>();\n+}\n+TransportMerger::TransportMerger(bool needLocking)\n+    : _result(),\n+      _lock(createOptionalLock(needLocking))\n+{\n+}\n+TransportMerger::~TransportMerger() = default;\n+\n+void\n+TransportMerger::mergeResult(ResultUP result, bool documentWasFound) {\n+    if (_lock) {\n+        std::lock_guard<std::mutex> guard(*_lock);\n+        mergeWithLock(std::move(result), documentWasFound);\n+    } else {\n+        mergeWithLock(std::move(result), documentWasFound);\n+    }\n+}\n+\n+void\n+TransportMerger::mergeWithLock(ResultUP result, bool documentWasFound) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxODM3Mg=="}, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTczNjI5OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/transport_latch.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNzo0NjoxNlrOGOdpMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo0MzowM1rOGOngBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxODkzMQ==", "bodyText": "Is class comment still correct?", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417818931", "createdAt": "2020-04-30T07:46:16Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/transport_latch.h", "diffHunk": "@@ -13,18 +13,33 @@ namespace proton {\n  * Implementation of FeedToken::ITransport for handling the async reply for an operation.\n  * Uses an internal count down latch to keep track the number of outstanding replies.\n  */\n-class TransportLatch : public feedtoken::ITransport {\n-private:\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MDQyMg==", "bodyText": "Now it is.", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417980422", "createdAt": "2020-04-30T12:43:03Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/transport_latch.h", "diffHunk": "@@ -13,18 +13,33 @@ namespace proton {\n  * Implementation of FeedToken::ITransport for handling the async reply for an operation.\n  * Uses an internal count down latch to keep track the number of outstanding replies.\n  */\n-class TransportLatch : public feedtoken::ITransport {\n-private:\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxODkzMQ=="}, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTc0MDA0OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/transport_latch.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNzo0NzoyN1rOGOdrsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo0Mjo0OVrOGOnfbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxOTU2OQ==", "bodyText": "Please add class comment.", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417819569", "createdAt": "2020-04-30T07:47:27Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/transport_latch.h", "diffHunk": "@@ -13,18 +13,33 @@ namespace proton {\n  * Implementation of FeedToken::ITransport for handling the async reply for an operation.\n  * Uses an internal count down latch to keep track the number of outstanding replies.\n  */\n-class TransportLatch : public feedtoken::ITransport {\n-private:\n+\n+class TransportMerger : public feedtoken::ITransport {\n+public:\n     using Result = storage::spi::Result;\n+    static Result mergeErrorResults(const Result &lhs, const Result &rhs);\n+protected:\n+    TransportMerger(bool needLocking);\n+    ~TransportMerger() override;\n+    void mergeResult(ResultUP result, bool documentWasFound);\n+    virtual void completeIfDone() { } // Called with lock held if necessary on every merge\n+    ResultUP  _result;\n+\n+private:\n+    void mergeWithLock(ResultUP result, bool documentWasFound);\n+    std::unique_ptr<std::mutex> _lock;\n+};\n+class TransportLatch : public TransportMerger {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MDI3MA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417980270", "createdAt": "2020-04-30T12:42:49Z", "author": {"login": "baldersheim"}, "path": "searchcore/src/vespa/searchcore/proton/persistenceengine/transport_latch.h", "diffHunk": "@@ -13,18 +13,33 @@ namespace proton {\n  * Implementation of FeedToken::ITransport for handling the async reply for an operation.\n  * Uses an internal count down latch to keep track the number of outstanding replies.\n  */\n-class TransportLatch : public feedtoken::ITransport {\n-private:\n+\n+class TransportMerger : public feedtoken::ITransport {\n+public:\n     using Result = storage::spi::Result;\n+    static Result mergeErrorResults(const Result &lhs, const Result &rhs);\n+protected:\n+    TransportMerger(bool needLocking);\n+    ~TransportMerger() override;\n+    void mergeResult(ResultUP result, bool documentWasFound);\n+    virtual void completeIfDone() { } // Called with lock held if necessary on every merge\n+    ResultUP  _result;\n+\n+private:\n+    void mergeWithLock(ResultUP result, bool documentWasFound);\n+    std::unique_ptr<std::mutex> _lock;\n+};\n+class TransportLatch : public TransportMerger {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxOTU2OQ=="}, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDQyNzY2OnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/persistence/persistenceutil.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTowNjo0OFrOGOkgKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzozMjozNFrOGOparA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzMTMwNQ==", "bodyText": "Is it valid behavior with the current code that a tracker still has a reply upon destruction? If not, when is the latency metric updated? Should it be moved to sendReply()?", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417931305", "createdAt": "2020-04-30T11:06:48Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistenceutil.cpp", "diffHunk": "@@ -14,22 +14,69 @@ namespace {\n         ost << \"PersistenceUtil(\" << p << \")\";\n         return ost.str();\n     }\n+\n+    bool isBatchable(api::MessageType::Id id)\n+    {\n+        return (id == api::MessageType::PUT_ID ||\n+                id == api::MessageType::REMOVE_ID ||\n+                id == api::MessageType::UPDATE_ID ||\n+                id == api::MessageType::REVERT_ID);\n+    }\n+\n+    bool hasBucketInfo(api::MessageType::Id id)\n+    {\n+        return (isBatchable(id) ||\n+                (id == api::MessageType::REMOVELOCATION_ID ||\n+                 id == api::MessageType::JOINBUCKETS_ID));\n+    }\n+\n }\n \n-MessageTracker::MessageTracker(FileStorThreadMetrics::Op& metric,\n-                               framework::Clock& clock)\n+MessageTracker::MessageTracker(PersistenceUtil & env,\n+                               FileStorHandler::BucketLockInterface::SP bucketLock,\n+                               api::StorageMessage::SP msg)\n     : _sendReply(true),\n-      _metric(metric),\n+      _updateBucketInfo(hasBucketInfo(msg->getType().getId())),\n+      _bucketLock(std::move(bucketLock)),\n+      _msg(std::move(msg)),\n+      _context(_msg->getLoadType(), _msg->getPriority(), _msg->getTrace().getLevel()),\n+      _env(env),\n+      _metric(nullptr),\n       _result(api::ReturnCode::OK),\n-      _timer(clock)\n-{\n-    _metric.count.inc();\n+      _timer(_env._component.getClock())\n+{ }\n+\n+void\n+MessageTracker::setMetric(FileStorThreadMetrics::Op& metric) {\n+    metric.count.inc();\n+    _metric = &metric;\n }\n \n MessageTracker::~MessageTracker()\n {\n     if (_reply.get() && _reply->getResult().success()) {\n-        _metric.latency.addValue(_timer.getElapsedTimeAsDouble());\n+        _metric->latency.addValue(_timer.getElapsedTimeAsDouble());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxMTgyMA==", "bodyText": "That is entirely correct. Good catch.", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r418011820", "createdAt": "2020-04-30T13:32:34Z", "author": {"login": "baldersheim"}, "path": "storage/src/vespa/storage/persistence/persistenceutil.cpp", "diffHunk": "@@ -14,22 +14,69 @@ namespace {\n         ost << \"PersistenceUtil(\" << p << \")\";\n         return ost.str();\n     }\n+\n+    bool isBatchable(api::MessageType::Id id)\n+    {\n+        return (id == api::MessageType::PUT_ID ||\n+                id == api::MessageType::REMOVE_ID ||\n+                id == api::MessageType::UPDATE_ID ||\n+                id == api::MessageType::REVERT_ID);\n+    }\n+\n+    bool hasBucketInfo(api::MessageType::Id id)\n+    {\n+        return (isBatchable(id) ||\n+                (id == api::MessageType::REMOVELOCATION_ID ||\n+                 id == api::MessageType::JOINBUCKETS_ID));\n+    }\n+\n }\n \n-MessageTracker::MessageTracker(FileStorThreadMetrics::Op& metric,\n-                               framework::Clock& clock)\n+MessageTracker::MessageTracker(PersistenceUtil & env,\n+                               FileStorHandler::BucketLockInterface::SP bucketLock,\n+                               api::StorageMessage::SP msg)\n     : _sendReply(true),\n-      _metric(metric),\n+      _updateBucketInfo(hasBucketInfo(msg->getType().getId())),\n+      _bucketLock(std::move(bucketLock)),\n+      _msg(std::move(msg)),\n+      _context(_msg->getLoadType(), _msg->getPriority(), _msg->getTrace().getLevel()),\n+      _env(env),\n+      _metric(nullptr),\n       _result(api::ReturnCode::OK),\n-      _timer(clock)\n-{\n-    _metric.count.inc();\n+      _timer(_env._component.getClock())\n+{ }\n+\n+void\n+MessageTracker::setMetric(FileStorThreadMetrics::Op& metric) {\n+    metric.count.inc();\n+    _metric = &metric;\n }\n \n MessageTracker::~MessageTracker()\n {\n     if (_reply.get() && _reply->getResult().success()) {\n-        _metric.latency.addValue(_timer.getElapsedTimeAsDouble());\n+        _metric->latency.addValue(_timer.getElapsedTimeAsDouble());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzMTMwNQ=="}, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDQzNDgyOnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/persistence/persistenceutil.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMTowOToxNFrOGOkklw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo1MToyMFrOGOny1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzMjQzOQ==", "bodyText": "Does it make sense to append a trace to a message that has no reply associated with it?", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417932439", "createdAt": "2020-04-30T11:09:14Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/persistence/persistenceutil.cpp", "diffHunk": "@@ -14,22 +14,69 @@ namespace {\n         ost << \"PersistenceUtil(\" << p << \")\";\n         return ost.str();\n     }\n+\n+    bool isBatchable(api::MessageType::Id id)\n+    {\n+        return (id == api::MessageType::PUT_ID ||\n+                id == api::MessageType::REMOVE_ID ||\n+                id == api::MessageType::UPDATE_ID ||\n+                id == api::MessageType::REVERT_ID);\n+    }\n+\n+    bool hasBucketInfo(api::MessageType::Id id)\n+    {\n+        return (isBatchable(id) ||\n+                (id == api::MessageType::REMOVELOCATION_ID ||\n+                 id == api::MessageType::JOINBUCKETS_ID));\n+    }\n+\n }\n \n-MessageTracker::MessageTracker(FileStorThreadMetrics::Op& metric,\n-                               framework::Clock& clock)\n+MessageTracker::MessageTracker(PersistenceUtil & env,\n+                               FileStorHandler::BucketLockInterface::SP bucketLock,\n+                               api::StorageMessage::SP msg)\n     : _sendReply(true),\n-      _metric(metric),\n+      _updateBucketInfo(hasBucketInfo(msg->getType().getId())),\n+      _bucketLock(std::move(bucketLock)),\n+      _msg(std::move(msg)),\n+      _context(_msg->getLoadType(), _msg->getPriority(), _msg->getTrace().getLevel()),\n+      _env(env),\n+      _metric(nullptr),\n       _result(api::ReturnCode::OK),\n-      _timer(clock)\n-{\n-    _metric.count.inc();\n+      _timer(_env._component.getClock())\n+{ }\n+\n+void\n+MessageTracker::setMetric(FileStorThreadMetrics::Op& metric) {\n+    metric.count.inc();\n+    _metric = &metric;\n }\n \n MessageTracker::~MessageTracker()\n {\n     if (_reply.get() && _reply->getResult().success()) {\n-        _metric.latency.addValue(_timer.getElapsedTimeAsDouble());\n+        _metric->latency.addValue(_timer.getElapsedTimeAsDouble());\n+    }\n+}\n+\n+void\n+MessageTracker::sendReply() {\n+    if (hasReply()) {\n+        if ( ! _context.getTrace().getRoot().isEmpty()) {\n+            getReply().getTrace().getRoot().addChild(_context.getTrace().getRoot());\n+        }\n+        if (_updateBucketInfo) {\n+            if (getReply().getResult().success()) {\n+                _env.setBucketInfo(*this, _bucketLock->getBucket());\n+            }\n+        }\n+        LOG(spam, \"Sending reply up: %s %\" PRIu64,\n+            getReply().toString().c_str(), getReply().getMsgId());\n+        _env._fileStorHandler.sendReply(std::move(_reply));\n+    } else {\n+        if ( ! _context.getTrace().getRoot().isEmpty()) {\n+            _msg->getTrace().getRoot().addChild(_context.getTrace().getRoot());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4NTIzOQ==", "bodyText": "I do not know, I just tried to preserve current behavior.", "url": "https://github.com/vespa-engine/vespa/pull/13113#discussion_r417985239", "createdAt": "2020-04-30T12:51:20Z", "author": {"login": "baldersheim"}, "path": "storage/src/vespa/storage/persistence/persistenceutil.cpp", "diffHunk": "@@ -14,22 +14,69 @@ namespace {\n         ost << \"PersistenceUtil(\" << p << \")\";\n         return ost.str();\n     }\n+\n+    bool isBatchable(api::MessageType::Id id)\n+    {\n+        return (id == api::MessageType::PUT_ID ||\n+                id == api::MessageType::REMOVE_ID ||\n+                id == api::MessageType::UPDATE_ID ||\n+                id == api::MessageType::REVERT_ID);\n+    }\n+\n+    bool hasBucketInfo(api::MessageType::Id id)\n+    {\n+        return (isBatchable(id) ||\n+                (id == api::MessageType::REMOVELOCATION_ID ||\n+                 id == api::MessageType::JOINBUCKETS_ID));\n+    }\n+\n }\n \n-MessageTracker::MessageTracker(FileStorThreadMetrics::Op& metric,\n-                               framework::Clock& clock)\n+MessageTracker::MessageTracker(PersistenceUtil & env,\n+                               FileStorHandler::BucketLockInterface::SP bucketLock,\n+                               api::StorageMessage::SP msg)\n     : _sendReply(true),\n-      _metric(metric),\n+      _updateBucketInfo(hasBucketInfo(msg->getType().getId())),\n+      _bucketLock(std::move(bucketLock)),\n+      _msg(std::move(msg)),\n+      _context(_msg->getLoadType(), _msg->getPriority(), _msg->getTrace().getLevel()),\n+      _env(env),\n+      _metric(nullptr),\n       _result(api::ReturnCode::OK),\n-      _timer(clock)\n-{\n-    _metric.count.inc();\n+      _timer(_env._component.getClock())\n+{ }\n+\n+void\n+MessageTracker::setMetric(FileStorThreadMetrics::Op& metric) {\n+    metric.count.inc();\n+    _metric = &metric;\n }\n \n MessageTracker::~MessageTracker()\n {\n     if (_reply.get() && _reply->getResult().success()) {\n-        _metric.latency.addValue(_timer.getElapsedTimeAsDouble());\n+        _metric->latency.addValue(_timer.getElapsedTimeAsDouble());\n+    }\n+}\n+\n+void\n+MessageTracker::sendReply() {\n+    if (hasReply()) {\n+        if ( ! _context.getTrace().getRoot().isEmpty()) {\n+            getReply().getTrace().getRoot().addChild(_context.getTrace().getRoot());\n+        }\n+        if (_updateBucketInfo) {\n+            if (getReply().getResult().success()) {\n+                _env.setBucketInfo(*this, _bucketLock->getBucket());\n+            }\n+        }\n+        LOG(spam, \"Sending reply up: %s %\" PRIu64,\n+            getReply().toString().c_str(), getReply().getMsgId());\n+        _env._fileStorHandler.sendReply(std::move(_reply));\n+    } else {\n+        if ( ! _context.getTrace().getRoot().isEmpty()) {\n+            _msg->getTrace().getRoot().addChild(_context.getTrace().getRoot());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzMjQzOQ=="}, "originalCommit": {"oid": "eb7b71781ca079b5577a13b300beafee388bc1ce"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1685, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}