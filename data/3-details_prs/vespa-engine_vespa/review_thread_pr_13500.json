{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMwODI1ODQ5", "number": 13500, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODo0NzozM1rOEDxaog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODo0OTo0MVrOEDxd-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzkwODE4OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODo0NzozM1rOGg_Crw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTozNDozNFrOGhBLwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MDQ5NQ==", "bodyText": "I think the magic should be done outside the update call and the update call just forward to the appropriate function.", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437240495", "createdAt": "2020-06-09T08:47:33Z", "author": {"login": "havardpe"}, "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,91 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(Children children) : MultiBitVectorIteratorBase(std::move(children)) { }\n+    explicit MultiBitVectorIterator(Children children)\n+        : MultiBitVectorIteratorBase(std::move(children)),\n+          _update(),\n+          _accel(IAccelrated::getAccelerator()),\n+          _lastWords()\n+    {\n+        static_assert(sizeof(_lastWords) == 64, \"Latswords should have 64 byte size\");\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    const IAccelrated & _accel;\n+    alignas(64) Word    _lastWords[8];\n };\n \n template<typename Update>\n class MultiBitVectorIteratorStrict : public MultiBitVectorIterator<Update>\n {\n public:\n-    MultiBitVectorIteratorStrict(MultiSearch::Children children) : MultiBitVectorIterator<Update>(std::move(children)) { }\n+    explicit MultiBitVectorIteratorStrict(MultiSearch::Children  children)\n+        : MultiBitVectorIterator<Update>(std::move(children))\n+    { }\n private:\n     void doSeek(uint32_t docId) override { this->strictSeek(docId); }\n     Trinary is_strict() const override { return Trinary::True; }\n };\n \n+struct And {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {\n+        accel.and64(offset*sizeof(uint64_t), src, dest);\n+    }\n+    static bool isAnd() { return true; }\n+};\n+\n+struct Or {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {\n+        accel.or64(offset*sizeof(uint64_t), src, dest);\n+    }\n+    static bool isAnd() { return false; }\n+};\n+\n template<typename Update>\n void MultiBitVectorIterator<Update>::updateLastValue(uint32_t docId)\n {\n     if (docId >= _lastMaxDocIdLimit) {\n-        if (__builtin_expect(docId < _numDocs, true)) {\n-            const uint32_t index(wordNum(docId));\n-            _lastValue = _bvs[0][index];\n-            for(uint32_t i(1); i < _bvs.size(); i++) {\n-                _lastValue = _update(_lastValue, _bvs[i][index]);\n-            }\n-            _lastMaxDocIdLimit = (index + 1) * WordLen;\n-        } else {\n+        if (__builtin_expect(docId >= _numDocs, false)) {\n             setAtEnd();\n+            return;\n+        }\n+        const uint32_t index(wordNum(docId));\n+        if (docId >= _lastMaxDocIdLimitRequireFetch) {\n+            uint32_t baseIndex = index & ~(sizeof(_lastWords)/sizeof(Word) - 1);\n+            _update(_accel, baseIndex, _bvs, _lastWords);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bebe03c7b970744d09eb26f7383da4f8c1244a36"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTU4NA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437275584", "createdAt": "2020-06-09T09:34:34Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,91 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(Children children) : MultiBitVectorIteratorBase(std::move(children)) { }\n+    explicit MultiBitVectorIterator(Children children)\n+        : MultiBitVectorIteratorBase(std::move(children)),\n+          _update(),\n+          _accel(IAccelrated::getAccelerator()),\n+          _lastWords()\n+    {\n+        static_assert(sizeof(_lastWords) == 64, \"Latswords should have 64 byte size\");\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    const IAccelrated & _accel;\n+    alignas(64) Word    _lastWords[8];\n };\n \n template<typename Update>\n class MultiBitVectorIteratorStrict : public MultiBitVectorIterator<Update>\n {\n public:\n-    MultiBitVectorIteratorStrict(MultiSearch::Children children) : MultiBitVectorIterator<Update>(std::move(children)) { }\n+    explicit MultiBitVectorIteratorStrict(MultiSearch::Children  children)\n+        : MultiBitVectorIterator<Update>(std::move(children))\n+    { }\n private:\n     void doSeek(uint32_t docId) override { this->strictSeek(docId); }\n     Trinary is_strict() const override { return Trinary::True; }\n };\n \n+struct And {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {\n+        accel.and64(offset*sizeof(uint64_t), src, dest);\n+    }\n+    static bool isAnd() { return true; }\n+};\n+\n+struct Or {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {\n+        accel.or64(offset*sizeof(uint64_t), src, dest);\n+    }\n+    static bool isAnd() { return false; }\n+};\n+\n template<typename Update>\n void MultiBitVectorIterator<Update>::updateLastValue(uint32_t docId)\n {\n     if (docId >= _lastMaxDocIdLimit) {\n-        if (__builtin_expect(docId < _numDocs, true)) {\n-            const uint32_t index(wordNum(docId));\n-            _lastValue = _bvs[0][index];\n-            for(uint32_t i(1); i < _bvs.size(); i++) {\n-                _lastValue = _update(_lastValue, _bvs[i][index]);\n-            }\n-            _lastMaxDocIdLimit = (index + 1) * WordLen;\n-        } else {\n+        if (__builtin_expect(docId >= _numDocs, false)) {\n             setAtEnd();\n+            return;\n+        }\n+        const uint32_t index(wordNum(docId));\n+        if (docId >= _lastMaxDocIdLimitRequireFetch) {\n+            uint32_t baseIndex = index & ~(sizeof(_lastWords)/sizeof(Word) - 1);\n+            _update(_accel, baseIndex, _bvs, _lastWords);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MDQ5NQ=="}, "originalCommit": {"oid": "bebe03c7b970744d09eb26f7383da4f8c1244a36"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzkxMzA3OnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODo0ODo0NVrOGg_F2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTozNDowNVrOGhBKjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MTMwNQ==", "bodyText": "offset should already be bytes here, and destination void.", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437241305", "createdAt": "2020-06-09T08:48:45Z", "author": {"login": "havardpe"}, "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,91 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(Children children) : MultiBitVectorIteratorBase(std::move(children)) { }\n+    explicit MultiBitVectorIterator(Children children)\n+        : MultiBitVectorIteratorBase(std::move(children)),\n+          _update(),\n+          _accel(IAccelrated::getAccelerator()),\n+          _lastWords()\n+    {\n+        static_assert(sizeof(_lastWords) == 64, \"Latswords should have 64 byte size\");\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    const IAccelrated & _accel;\n+    alignas(64) Word    _lastWords[8];\n };\n \n template<typename Update>\n class MultiBitVectorIteratorStrict : public MultiBitVectorIterator<Update>\n {\n public:\n-    MultiBitVectorIteratorStrict(MultiSearch::Children children) : MultiBitVectorIterator<Update>(std::move(children)) { }\n+    explicit MultiBitVectorIteratorStrict(MultiSearch::Children  children)\n+        : MultiBitVectorIterator<Update>(std::move(children))\n+    { }\n private:\n     void doSeek(uint32_t docId) override { this->strictSeek(docId); }\n     Trinary is_strict() const override { return Trinary::True; }\n };\n \n+struct And {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bebe03c7b970744d09eb26f7383da4f8c1244a36"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTI3Nw==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437275277", "createdAt": "2020-06-09T09:34:05Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,91 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(Children children) : MultiBitVectorIteratorBase(std::move(children)) { }\n+    explicit MultiBitVectorIterator(Children children)\n+        : MultiBitVectorIteratorBase(std::move(children)),\n+          _update(),\n+          _accel(IAccelrated::getAccelerator()),\n+          _lastWords()\n+    {\n+        static_assert(sizeof(_lastWords) == 64, \"Latswords should have 64 byte size\");\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    const IAccelrated & _accel;\n+    alignas(64) Word    _lastWords[8];\n };\n \n template<typename Update>\n class MultiBitVectorIteratorStrict : public MultiBitVectorIterator<Update>\n {\n public:\n-    MultiBitVectorIteratorStrict(MultiSearch::Children children) : MultiBitVectorIterator<Update>(std::move(children)) { }\n+    explicit MultiBitVectorIteratorStrict(MultiSearch::Children  children)\n+        : MultiBitVectorIterator<Update>(std::move(children))\n+    { }\n private:\n     void doSeek(uint32_t docId) override { this->strictSeek(docId); }\n     Trinary is_strict() const override { return Trinary::True; }\n };\n \n+struct And {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MTMwNQ=="}, "originalCommit": {"oid": "bebe03c7b970744d09eb26f7383da4f8c1244a36"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzkxNjczOnYy", "diffSide": "RIGHT", "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwODo0OTo0MVrOGg_ILA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTozMzo1MlrOGhBJ9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MTkwMA==", "bodyText": "offset is probably in Words and not in uint64_t, but I think this magic should be done together with the other magic anyways.", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437241900", "createdAt": "2020-06-09T08:49:41Z", "author": {"login": "havardpe"}, "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,91 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(Children children) : MultiBitVectorIteratorBase(std::move(children)) { }\n+    explicit MultiBitVectorIterator(Children children)\n+        : MultiBitVectorIteratorBase(std::move(children)),\n+          _update(),\n+          _accel(IAccelrated::getAccelerator()),\n+          _lastWords()\n+    {\n+        static_assert(sizeof(_lastWords) == 64, \"Latswords should have 64 byte size\");\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    const IAccelrated & _accel;\n+    alignas(64) Word    _lastWords[8];\n };\n \n template<typename Update>\n class MultiBitVectorIteratorStrict : public MultiBitVectorIterator<Update>\n {\n public:\n-    MultiBitVectorIteratorStrict(MultiSearch::Children children) : MultiBitVectorIterator<Update>(std::move(children)) { }\n+    explicit MultiBitVectorIteratorStrict(MultiSearch::Children  children)\n+        : MultiBitVectorIterator<Update>(std::move(children))\n+    { }\n private:\n     void doSeek(uint32_t docId) override { this->strictSeek(docId); }\n     Trinary is_strict() const override { return Trinary::True; }\n };\n \n+struct And {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {\n+        accel.and64(offset*sizeof(uint64_t), src, dest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bebe03c7b970744d09eb26f7383da4f8c1244a36"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NTEyNQ==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13500#discussion_r437275125", "createdAt": "2020-06-09T09:33:52Z", "author": {"login": "baldersheim"}, "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,91 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(Children children) : MultiBitVectorIteratorBase(std::move(children)) { }\n+    explicit MultiBitVectorIterator(Children children)\n+        : MultiBitVectorIteratorBase(std::move(children)),\n+          _update(),\n+          _accel(IAccelrated::getAccelerator()),\n+          _lastWords()\n+    {\n+        static_assert(sizeof(_lastWords) == 64, \"Latswords should have 64 byte size\");\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    const IAccelrated & _accel;\n+    alignas(64) Word    _lastWords[8];\n };\n \n template<typename Update>\n class MultiBitVectorIteratorStrict : public MultiBitVectorIterator<Update>\n {\n public:\n-    MultiBitVectorIteratorStrict(MultiSearch::Children children) : MultiBitVectorIterator<Update>(std::move(children)) { }\n+    explicit MultiBitVectorIteratorStrict(MultiSearch::Children  children)\n+        : MultiBitVectorIterator<Update>(std::move(children))\n+    { }\n private:\n     void doSeek(uint32_t docId) override { this->strictSeek(docId); }\n     Trinary is_strict() const override { return Trinary::True; }\n };\n \n+struct And {\n+    using Word = BitWord::Word;\n+    void operator () (const IAccelrated & accel, size_t offset, const std::vector<std::pair<const void *, bool>> & src, Word *dest) {\n+        accel.and64(offset*sizeof(uint64_t), src, dest);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MTkwMA=="}, "originalCommit": {"oid": "bebe03c7b970744d09eb26f7383da4f8c1244a36"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1994, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}