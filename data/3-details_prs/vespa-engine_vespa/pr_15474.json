{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTgzMDMy", "number": 15474, "title": "shared string repo -- WIP", "bodyText": "I confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.\n@arnej27959 please review", "createdAt": "2020-11-25T17:01:43Z", "url": "https://github.com/vespa-engine/vespa/pull/15474", "merged": true, "mergeCommit": {"oid": "c4e7e04c88782b7eac14ba48f8504c1748827045"}, "closed": true, "closedAt": "2020-11-26T11:34:11Z", "author": {"login": "havardpe"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgBUrPAH2gAyNTI3NTgzMDMyOmE1Nzg4MDMxNTk3NmRjNDliZTdmMzJmMTczNjU3MTg0NTY1OWVkMGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdgRUocAFqTUzOTIzNDY3MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a57880315976dc49be7f32f1736571845659ed0a", "author": {"user": {"login": "havardpe", "name": "H\u00e5vard Pettersen"}}, "url": "https://github.com/vespa-engine/vespa/commit/a57880315976dc49be7f32f1736571845659ed0a", "committedDate": "2020-11-25T16:55:18Z", "message": "shared string repo -- WIP"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NzU1NTA1", "url": "https://github.com/vespa-engine/vespa/pull/15474#pullrequestreview-538755505", "createdAt": "2020-11-25T18:24:55Z", "commit": {"oid": "a57880315976dc49be7f32f1736571845659ed0a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Nzk3MDE4", "url": "https://github.com/vespa-engine/vespa/pull/15474#pullrequestreview-538797018", "createdAt": "2020-11-25T19:35:00Z", "commit": {"oid": "a57880315976dc49be7f32f1736571845659ed0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTozNTowMFrOH6BZNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTozNTowMFrOH6BZNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwMjI5Mg==", "bodyText": "don't you need to check for id == 0 here?", "url": "https://github.com/vespa-engine/vespa/pull/15474#discussion_r530602292", "createdAt": "2020-11-25T19:35:00Z", "author": {"login": "arnej27959"}, "path": "vespalib/src/vespa/vespalib/util/shared_string_repo.h", "diffHunk": "@@ -0,0 +1,193 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"spin_lock.h\"\n+#include <vespa/vespalib/stllike/string.h>\n+#include <vespa/vespalib/stllike/hash_set.hpp>\n+#include <xxhash.h>\n+#include <mutex>\n+#include <vector>\n+\n+namespace vespalib {\n+\n+/**\n+ * This class implements application-wide in-memory string\n+ * interning. Each string stored in the repo will be assigned a unique\n+ * 32-bit id that can be used by the application to check for\n+ * equality. The repo can never be shrunk in size, but ids can be\n+ * re-used when the corresponding strings are evicted from the\n+ * repo. Strong handles are used to track which strings are in\n+ * use. Weak handles are used as a cheap alternative to strong handles\n+ * when you also have a strong handle that ensures the string will not\n+ * be evicted. For example, an efficient sparse tensor attribute could\n+ * have a pool of strong handles to all strings used\n+ * internally. Individual tensor indexes could then contain only weak\n+ * handles, making string comparison as cheap as possible.\n+ **/\n+class SharedStringRepo {\n+private:\n+    static constexpr int NUM_PARTS = 64;\n+    static constexpr int PART_BITS = 6;\n+    static constexpr int PART_MASK = 0x3f;\n+\n+    struct AltKey {\n+        vespalib::stringref str;\n+        uint32_t hash;\n+    };\n+\n+    class Partition {\n+    public:\n+        struct Entry {\n+            uint32_t hash;\n+            uint32_t ref_cnt;\n+            vespalib::string str;\n+            Entry(const AltKey &key) noexcept : hash(key.hash), ref_cnt(1), str(key.str) {}\n+            void reset() {\n+                str.reset();\n+            }\n+            void reuse(const AltKey &key) {\n+                hash = key.hash;\n+                ref_cnt = 1;\n+                str = key.str;\n+            }\n+        };\n+        struct Key {\n+            uint32_t idx;\n+            uint32_t hash;\n+        };\n+        struct Hash {\n+            uint32_t operator()(const Key &key) const { return key.hash; }\n+            uint32_t operator()(const AltKey &key) const { return key.hash; }\n+        };\n+        struct Equal {\n+            const std::vector<Entry> &entries;\n+            Equal(const std::vector<Entry> &entries_in) : entries(entries_in) {}\n+            Equal(const Equal &rhs) = default;\n+            bool operator()(const Key &a, const Key &b) const { return (a.idx == b.idx); }\n+            bool operator()(const Key &a, const AltKey &b) const { return ((a.hash == b.hash) && (entries[a.idx].str == b.str)); }\n+        };\n+        using HashType = vespalib::hash_set<Key,Hash,Equal>;\n+\n+    private:\n+        SpinLock              _lock;\n+        std::vector<Entry>    _entries;\n+        std::vector<uint32_t> _free;\n+        HashType              _hash;\n+\n+        uint32_t make_entry(const AltKey &alt_key) {\n+            if (_free.empty()) {\n+                uint32_t idx = _entries.size();\n+                _entries.emplace_back(alt_key);\n+                return idx;\n+            } else {\n+                uint32_t idx = _free.back();\n+                _free.pop_back();\n+                _entries[idx].reuse(alt_key);\n+                return idx;\n+            }\n+        }\n+\n+    public:\n+        Partition()\n+            : _lock(), _entries(), _free(), _hash(0, Hash(), Equal(_entries)) {}\n+        ~Partition();\n+\n+        uint32_t resolve(const AltKey &alt_key) {\n+            std::lock_guard guard(_lock);\n+            auto pos = _hash.find(alt_key);\n+            if (pos != _hash.end()) {\n+                ++_entries[pos->idx].ref_cnt;\n+                return pos->idx;\n+            } else {\n+                uint32_t idx = make_entry(alt_key);\n+                _hash.insert(Key{idx, alt_key.hash});\n+                return idx;\n+            }\n+        }\n+\n+        vespalib::string get(uint32_t idx) {\n+            std::lock_guard guard(_lock);\n+            return _entries[idx].str;\n+        }\n+\n+        void copy(uint32_t idx) {\n+            std::lock_guard guard(_lock);\n+            ++_entries[idx].ref_cnt;\n+        }\n+\n+        void reclaim(uint32_t idx) {\n+            std::lock_guard guard(_lock);\n+            Entry &entry = _entries[idx];\n+            if (--entry.ref_cnt == 0) {\n+                _hash.erase(Key{idx, entry.hash});\n+                entry.reset();\n+                _free.push_back(idx);\n+            }\n+        }\n+    };\n+\n+    static std::array<Partition,NUM_PARTS> _partitions;\n+\n+    static uint32_t resolve(vespalib::stringref str) {\n+        if (!str.empty()) {\n+            uint64_t full_hash = XXH3_64bits(str.data(), str.size());\n+            uint32_t part = full_hash & PART_MASK;\n+            uint32_t local_hash = full_hash >> PART_BITS;\n+            uint32_t local_idx = _partitions[part].resolve(AltKey{str, local_hash});\n+            return (((local_idx << PART_BITS) | part) + 1);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    static vespalib::string get(uint32_t id) {\n+        uint32_t part = (id - 1) & PART_MASK;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a57880315976dc49be7f32f1736571845659ed0a"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a553f4feb65d4f026d334a8a9ab792a6671d6bd0", "author": {"user": {"login": "havardpe", "name": "H\u00e5vard Pettersen"}}, "url": "https://github.com/vespa-engine/vespa/commit/a553f4feb65d4f026d334a8a9ab792a6671d6bd0", "committedDate": "2020-11-26T10:29:04Z", "message": "check for 0 id more places\n\nalso cut some documentation, since we only have one handle type for\nnow."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84e9a5330a98a02aab4c498ed643603589970d8c", "author": {"user": {"login": "havardpe", "name": "H\u00e5vard Pettersen"}}, "url": "https://github.com/vespa-engine/vespa/commit/84e9a5330a98a02aab4c498ed643603589970d8c", "committedDate": "2020-11-26T10:52:30Z", "message": "improve and clean up unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MjA3MjIw", "url": "https://github.com/vespa-engine/vespa/pull/15474#pullrequestreview-539207220", "createdAt": "2020-11-26T10:55:32Z", "commit": {"oid": "84e9a5330a98a02aab4c498ed643603589970d8c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3da9b933cca405ae71a3fac8a00b803d123c5121", "author": {"user": {"login": "havardpe", "name": "H\u00e5vard Pettersen"}}, "url": "https://github.com/vespa-engine/vespa/commit/3da9b933cca405ae71a3fac8a00b803d123c5121", "committedDate": "2020-11-26T11:23:59Z", "message": "use singleton object instead of static members\n\nthis is to avoid having to create a repo when it is not used"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5MjM0Njcw", "url": "https://github.com/vespa-engine/vespa/pull/15474#pullrequestreview-539234670", "createdAt": "2020-11-26T11:33:44Z", "commit": {"oid": "3da9b933cca405ae71a3fac8a00b803d123c5121"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1887, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}