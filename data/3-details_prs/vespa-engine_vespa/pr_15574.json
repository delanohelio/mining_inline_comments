{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNDQ4MzEw", "number": 15574, "title": "Bjorncs/cluster controller reindexing status", "bodyText": "I confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.", "createdAt": "2020-12-01T17:06:26Z", "url": "https://github.com/vespa-engine/vespa/pull/15574", "merged": true, "mergeCommit": {"oid": "eb8cd5f40955ea584ad2bb90aea8d518436608d5"}, "closed": true, "closedAt": "2020-12-01T18:22:13Z", "author": {"login": "bjorncs"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdh81ZlAH2gAyNTMwNDQ4MzEwOmYyNTk5MjgwODQ2MDczYjE0NGM0MDY1YmYyNTQ3ODEzOGNjMzhiNjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdh-KNUAFqTU0MjE3MjIyNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f2599280846073b144c4065bf25478138cc38b67", "author": {"user": {"login": "bjorncs", "name": "Bj\u00f8rn Christian Seime"}}, "url": "https://github.com/vespa-engine/vespa/commit/f2599280846073b144c4065bf25478138cc38b67", "committedDate": "2020-12-01T16:49:22Z", "message": "Add helper for combining multiple completable futures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b8d21fe0c915057e6c88cab1b2e988d60c5a16f", "author": {"user": {"login": "bjorncs", "name": "Bj\u00f8rn Christian Seime"}}, "url": "https://github.com/vespa-engine/vespa/commit/0b8d21fe0c915057e6c88cab1b2e988d60c5a16f", "committedDate": "2020-12-01T16:49:22Z", "message": "Add helper method to rethrow checked as unchecked"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ed17bd76ac1acb51b6d1e13b3f2414d36aa2aff", "author": {"user": {"login": "bjorncs", "name": "Bj\u00f8rn Christian Seime"}}, "url": "https://github.com/vespa-engine/vespa/commit/8ed17bd76ac1acb51b6d1e13b3f2414d36aa2aff", "committedDate": "2020-12-01T16:49:22Z", "message": "Move serialized value definition to State enum"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26429fb170a455760a20e2a9b8a20371c4962f54", "author": {"user": {"login": "bjorncs", "name": "Bj\u00f8rn Christian Seime"}}, "url": "https://github.com/vespa-engine/vespa/commit/26429fb170a455760a20e2a9b8a20371c4962f54", "committedDate": "2020-12-01T17:05:41Z", "message": "Fetch cluster reindexing status from cluster controllers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMTcyMjI1", "url": "https://github.com/vespa-engine/vespa/pull/15574#pullrequestreview-542172225", "createdAt": "2020-12-01T18:16:18Z", "commit": {"oid": "26429fb170a455760a20e2a9b8a20371c4962f54"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoxNjoxOFrOH85wRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODoyMTowNVrOH858BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMjg1Mw==", "bodyText": "Neat.", "url": "https://github.com/vespa-engine/vespa/pull/15574#discussion_r533622853", "createdAt": "2020-12-01T18:16:18Z", "author": {"login": "jonmv"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.config.server.application;\n+\n+import ai.vespa.util.http.VespaAsyncHttpClientBuilder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.yahoo.concurrent.CompletableFutures;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.config.model.api.PortInfo;\n+import com.yahoo.config.model.api.ServiceInfo;\n+import com.yahoo.vespa.applicationmodel.ClusterId;\n+import com.yahoo.vespa.config.server.modelfactory.ModelResult;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\n+import org.apache.hc.client5.http.config.RequestConfig;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.HttpStatus;\n+import org.apache.hc.core5.reactor.IOReactorConfig;\n+import org.apache.hc.core5.util.Timeout;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.config.model.api.container.ContainerServiceType.CLUSTERCONTROLLER_CONTAINER;\n+import static com.yahoo.yolean.Exceptions.throwUnchecked;\n+import static com.yahoo.yolean.Exceptions.uncheck;\n+\n+/**\n+ * Retrieves reindexing status from cluster controllers over HTTP\n+ *\n+ * @author bjorncs\n+ */\n+public class DefaultClusterReindexingStatusClient implements ClusterReindexingStatusClient {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final Executor executor =\n+            Executors.newSingleThreadExecutor(new DaemonThreadFactory(\"cluster-controller-reindexing-client-\"));\n+    private final CloseableHttpAsyncClient httpClient = createHttpClient();\n+\n+    public DefaultClusterReindexingStatusClient() {\n+        httpClient.start();\n+    }\n+\n+    @Override\n+    public Map<String, ClusterReindexing> getReindexingStatus(ModelResult application) throws IOException {\n+        Map<ClusterId, List<ServiceInfo>> clusters = clusterControllerClusters(application);\n+        Map<ClusterId, CompletableFuture<ClusterReindexing>> futureStatusPerCluster = new HashMap<>();\n+        clusters.forEach((clusterId, clusterNodes) -> {\n+            var parallelRequests = clusterNodes.stream()\n+                    .map(this::getReindexingStatus)\n+                    .collect(Collectors.toList());\n+            CompletableFuture<ClusterReindexing> combinedRequest = CompletableFutures.firstOf(parallelRequests);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26429fb170a455760a20e2a9b8a20371c4962f54"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNDkyMA==", "bodyText": "Perhaps we could return status from first successful, if the first to return a response is non-200?", "url": "https://github.com/vespa-engine/vespa/pull/15574#discussion_r533624920", "createdAt": "2020-12-01T18:19:36Z", "author": {"login": "jonmv"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.config.server.application;\n+\n+import ai.vespa.util.http.VespaAsyncHttpClientBuilder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.yahoo.concurrent.CompletableFutures;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.config.model.api.PortInfo;\n+import com.yahoo.config.model.api.ServiceInfo;\n+import com.yahoo.vespa.applicationmodel.ClusterId;\n+import com.yahoo.vespa.config.server.modelfactory.ModelResult;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\n+import org.apache.hc.client5.http.config.RequestConfig;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.HttpStatus;\n+import org.apache.hc.core5.reactor.IOReactorConfig;\n+import org.apache.hc.core5.util.Timeout;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.config.model.api.container.ContainerServiceType.CLUSTERCONTROLLER_CONTAINER;\n+import static com.yahoo.yolean.Exceptions.throwUnchecked;\n+import static com.yahoo.yolean.Exceptions.uncheck;\n+\n+/**\n+ * Retrieves reindexing status from cluster controllers over HTTP\n+ *\n+ * @author bjorncs\n+ */\n+public class DefaultClusterReindexingStatusClient implements ClusterReindexingStatusClient {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final Executor executor =\n+            Executors.newSingleThreadExecutor(new DaemonThreadFactory(\"cluster-controller-reindexing-client-\"));\n+    private final CloseableHttpAsyncClient httpClient = createHttpClient();\n+\n+    public DefaultClusterReindexingStatusClient() {\n+        httpClient.start();\n+    }\n+\n+    @Override\n+    public Map<String, ClusterReindexing> getReindexingStatus(ModelResult application) throws IOException {\n+        Map<ClusterId, List<ServiceInfo>> clusters = clusterControllerClusters(application);\n+        Map<ClusterId, CompletableFuture<ClusterReindexing>> futureStatusPerCluster = new HashMap<>();\n+        clusters.forEach((clusterId, clusterNodes) -> {\n+            var parallelRequests = clusterNodes.stream()\n+                    .map(this::getReindexingStatus)\n+                    .collect(Collectors.toList());\n+            CompletableFuture<ClusterReindexing> combinedRequest = CompletableFutures.firstOf(parallelRequests);\n+            futureStatusPerCluster.put(clusterId, combinedRequest);\n+        });\n+\n+        try {\n+            Map<String, ClusterReindexing> statusPerCluster = new HashMap<>();\n+            futureStatusPerCluster.forEach((clusterId, futureStatus) -> {\n+                statusPerCluster.put(clusterId.s(), futureStatus.join());\n+            });\n+            return statusPerCluster;\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to get reindexing status from cluster controllers: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override public void close() { uncheck(() -> httpClient.close()); }\n+\n+    private CompletableFuture<ClusterReindexing> getReindexingStatus(ServiceInfo service) {\n+        URI uri = URI.create(String.format(\"http://%s:%d/reindexing/v1/status\", service.getHostName(), getStatePort(service)));\n+        CompletableFuture<SimpleHttpResponse> responsePromise = new CompletableFuture<>();\n+        httpClient.execute(SimpleHttpRequests.get(uri), new FutureCallback<>() {\n+            @Override public void completed(SimpleHttpResponse result) { responsePromise.complete(result); }\n+            @Override public void failed(Exception ex) { responsePromise.completeExceptionally(ex); }\n+            @Override public void cancelled() { responsePromise.cancel(false); }\n+        });\n+        return responsePromise.handleAsync((response, error) ->  {\n+            if (response != null) {\n+                return uncheck(() -> toClusterReindexing(response));\n+            } else {\n+                throw throwUnchecked(new IOException(String.format(\"For '%s': %s\", uri, error.getMessage()), error));\n+            }\n+        }, executor);\n+    }\n+\n+    private static ClusterReindexing toClusterReindexing(SimpleHttpResponse response) throws IOException {\n+        if (response.getCode() != HttpStatus.SC_OK) throw new IOException(\"Expected status code 200, got \" + response.getCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26429fb170a455760a20e2a9b8a20371c4962f54"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNTg2MA==", "bodyText": "Whenever I see property and name in the same sentence I get really excited :)))", "url": "https://github.com/vespa-engine/vespa/pull/15574#discussion_r533625860", "createdAt": "2020-12-01T18:21:05Z", "author": {"login": "jonmv"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/DefaultClusterReindexingStatusClient.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.config.server.application;\n+\n+import ai.vespa.util.http.VespaAsyncHttpClientBuilder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.yahoo.concurrent.CompletableFutures;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.config.model.api.PortInfo;\n+import com.yahoo.config.model.api.ServiceInfo;\n+import com.yahoo.vespa.applicationmodel.ClusterId;\n+import com.yahoo.vespa.config.server.modelfactory.ModelResult;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpRequests;\n+import org.apache.hc.client5.http.async.methods.SimpleHttpResponse;\n+import org.apache.hc.client5.http.config.RequestConfig;\n+import org.apache.hc.client5.http.impl.async.CloseableHttpAsyncClient;\n+import org.apache.hc.core5.concurrent.FutureCallback;\n+import org.apache.hc.core5.http.HttpStatus;\n+import org.apache.hc.core5.reactor.IOReactorConfig;\n+import org.apache.hc.core5.util.Timeout;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.config.model.api.container.ContainerServiceType.CLUSTERCONTROLLER_CONTAINER;\n+import static com.yahoo.yolean.Exceptions.throwUnchecked;\n+import static com.yahoo.yolean.Exceptions.uncheck;\n+\n+/**\n+ * Retrieves reindexing status from cluster controllers over HTTP\n+ *\n+ * @author bjorncs\n+ */\n+public class DefaultClusterReindexingStatusClient implements ClusterReindexingStatusClient {\n+\n+    private static final ObjectMapper mapper = new ObjectMapper();\n+\n+    private final Executor executor =\n+            Executors.newSingleThreadExecutor(new DaemonThreadFactory(\"cluster-controller-reindexing-client-\"));\n+    private final CloseableHttpAsyncClient httpClient = createHttpClient();\n+\n+    public DefaultClusterReindexingStatusClient() {\n+        httpClient.start();\n+    }\n+\n+    @Override\n+    public Map<String, ClusterReindexing> getReindexingStatus(ModelResult application) throws IOException {\n+        Map<ClusterId, List<ServiceInfo>> clusters = clusterControllerClusters(application);\n+        Map<ClusterId, CompletableFuture<ClusterReindexing>> futureStatusPerCluster = new HashMap<>();\n+        clusters.forEach((clusterId, clusterNodes) -> {\n+            var parallelRequests = clusterNodes.stream()\n+                    .map(this::getReindexingStatus)\n+                    .collect(Collectors.toList());\n+            CompletableFuture<ClusterReindexing> combinedRequest = CompletableFutures.firstOf(parallelRequests);\n+            futureStatusPerCluster.put(clusterId, combinedRequest);\n+        });\n+\n+        try {\n+            Map<String, ClusterReindexing> statusPerCluster = new HashMap<>();\n+            futureStatusPerCluster.forEach((clusterId, futureStatus) -> {\n+                statusPerCluster.put(clusterId.s(), futureStatus.join());\n+            });\n+            return statusPerCluster;\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to get reindexing status from cluster controllers: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override public void close() { uncheck(() -> httpClient.close()); }\n+\n+    private CompletableFuture<ClusterReindexing> getReindexingStatus(ServiceInfo service) {\n+        URI uri = URI.create(String.format(\"http://%s:%d/reindexing/v1/status\", service.getHostName(), getStatePort(service)));\n+        CompletableFuture<SimpleHttpResponse> responsePromise = new CompletableFuture<>();\n+        httpClient.execute(SimpleHttpRequests.get(uri), new FutureCallback<>() {\n+            @Override public void completed(SimpleHttpResponse result) { responsePromise.complete(result); }\n+            @Override public void failed(Exception ex) { responsePromise.completeExceptionally(ex); }\n+            @Override public void cancelled() { responsePromise.cancel(false); }\n+        });\n+        return responsePromise.handleAsync((response, error) ->  {\n+            if (response != null) {\n+                return uncheck(() -> toClusterReindexing(response));\n+            } else {\n+                throw throwUnchecked(new IOException(String.format(\"For '%s': %s\", uri, error.getMessage()), error));\n+            }\n+        }, executor);\n+    }\n+\n+    private static ClusterReindexing toClusterReindexing(SimpleHttpResponse response) throws IOException {\n+        if (response.getCode() != HttpStatus.SC_OK) throw new IOException(\"Expected status code 200, got \" + response.getCode());\n+        if (response.getBody() == null) throw new IOException(\"Response has no content\");\n+        return toClusterReindexing(response.getBodyBytes());\n+    }\n+\n+    private static ClusterReindexing toClusterReindexing(byte[] requestBody) throws IOException {\n+        JsonNode jsonNode = mapper.readTree(requestBody);\n+        Map<String, ClusterReindexing.Status> documentStatuses = new HashMap<>();\n+        for (JsonNode statusJson : jsonNode.get(\"status\")) {\n+            String type = statusJson.get(\"type\").textValue();\n+            Instant startedMillis = Instant.ofEpochMilli(statusJson.get(\"startedMillis\").longValue());\n+            Instant endedMillis = Instant.ofEpochMilli(statusJson.get(\"endedMillis\").longValue());\n+            String progressToken = statusJson.get(\"progress\").textValue();\n+            ClusterReindexing.State state = ClusterReindexing.State.fromString(statusJson.get(\"state\").textValue());\n+            String message = statusJson.get(\"message\").textValue();\n+            documentStatuses.put(type, new ClusterReindexing.Status(startedMillis, endedMillis, state, message, progressToken));\n+        }\n+        return new ClusterReindexing(documentStatuses);\n+    }\n+\n+    private static int getStatePort(ServiceInfo service) {\n+        return service.getPorts().stream()\n+                .filter(port -> port.getTags().contains(\"state\"))\n+                .map(PortInfo::getPort)\n+                .findAny()\n+                .orElseThrow(() -> new IllegalStateException(\"Cluster controller container has no container port\"));\n+    }\n+\n+    private static Map<ClusterId, List<ServiceInfo>> clusterControllerClusters(ModelResult application) {\n+        return application.getModel().getHosts().stream()\n+                .flatMap(host -> host.getServices().stream())\n+                .filter(service -> service.getServiceType().equals(CLUSTERCONTROLLER_CONTAINER.serviceName))\n+                .collect(Collectors.groupingBy(service -> new ClusterId(service.getProperty(\"clustername\").get())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26429fb170a455760a20e2a9b8a20371c4962f54"}, "originalPosition": 129}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1828, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}