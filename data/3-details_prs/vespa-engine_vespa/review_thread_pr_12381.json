{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNDI0MDAz", "number": 12381, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo1ODo1NVrODj3P4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjowOTowNVrODkPmRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTMxOTM5OnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/tests/singleexecutor/singleexecutor_test.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo1ODo1NVrOFv59og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo1ODo1NVrOFv59og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3NzA1OA==", "bodyText": "std::this_thread::yield() (or _mm_pause()) instead of burning CPU for these wait-loops?", "url": "https://github.com/vespa-engine/vespa/pull/12381#discussion_r385777058", "createdAt": "2020-02-28T15:58:55Z", "author": {"login": "vekterli"}, "path": "staging_vespalib/src/tests/singleexecutor/singleexecutor_test.cpp", "diffHunk": "@@ -0,0 +1,80 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/testkit/testapp.h>\n+\n+#include <vespa/vespalib/util/singleexecutor.h>\n+#include <vespa/vespalib/util/lambdatask.h>\n+#include <atomic>\n+\n+using namespace vespalib;\n+\n+TEST(\"test that all tasks are executed\") {\n+\n+    std::atomic<uint64_t> counter(0);\n+    SingleExecutor executor(10);\n+\n+    for (uint64_t i(0); i < 10; i++) {\n+        executor.execute(makeLambdaTask([&counter] {counter++;}));\n+    }\n+    executor.sync();\n+    EXPECT_EQUAL(10u, counter);\n+\n+    counter = 0;\n+    for (uint64_t i(0); i < 10000; i++) {\n+        executor.execute(makeLambdaTask([&counter] {counter++;}));\n+    }\n+    executor.sync();\n+    EXPECT_EQUAL(10000u, counter);\n+}\n+\n+void verifyResizeTaskLimit(bool up) {\n+    Monitor lock;\n+    std::atomic<uint64_t> started(0);\n+    std::atomic<uint64_t> allowed(0);\n+    SingleExecutor executor(10);\n+\n+    uint32_t targetTaskLimit = up ? 20 : 5;\n+    uint32_t roundedTaskLimit = roundUp2inN(targetTaskLimit);\n+    EXPECT_NOT_EQUAL(16u, roundedTaskLimit);\n+\n+    for (uint64_t i(0); i < 10; i++) {\n+        executor.execute(makeLambdaTask([&lock, &started, &allowed] {\n+            started++;\n+            MonitorGuard guard(lock);\n+            while (allowed < started) {\n+                guard.wait(1ms);\n+            }\n+        }));\n+    }\n+    while (started < 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1908db5022dad66bdf14ea3377a5459eac5534e7"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzIwNDYzOnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTozMDo0OVrOFwcUIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTo1MToxNlrOFwc2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzOTg3NA==", "bodyText": "It seems the write thread might observe tasks as run before they are actually run", "url": "https://github.com/vespa-engine/vespa/pull/12381#discussion_r386339874", "createdAt": "2020-03-02T11:30:49Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.h", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/vespalib/util/threadexecutor.h>\n+#include <vespa/vespalib/util/thread.h>\n+#include <thread>\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * Has a single thread consuming tasks from a fixed size ringbuffer.\n+ * Made for throughput where the producer has no interaction with the consumer and\n+ * it is hence very cheap to produce a task. High and low watermark at 25%/75% is used\n+ * to reduce ping-pong.\n+ */\n+class SingleExecutor final : public vespalib::SyncableThreadExecutor, vespalib::Runnable {\n+public:\n+    explicit SingleExecutor(uint32_t taskLimit);\n+    ~SingleExecutor() override;\n+    Task::UP execute(Task::UP task) override;\n+    void setTaskLimit(uint32_t taskLimit) override;\n+    SingleExecutor & sync() override;\n+    size_t getNumThreads() const override;\n+    uint32_t getTaskLimit() const { return _taskLimit.load(std::memory_order_relaxed); }\n+    Stats getStats() override;\n+private:\n+    uint64_t addTask(Task::UP task);\n+    void run() override;\n+    void drain_tasks();\n+    void run_tasks_till(uint64_t available);\n+    void wait_for_room(MonitorGuard & guard);\n+    uint64_t index(uint64_t counter) const {\n+        return counter & (_taskLimit.load(std::memory_order_relaxed) - 1);\n+    }\n+\n+    uint64_t numTasks() const {\n+        return _wp.load(std::memory_order_relaxed) - _rp.load(std::memory_order_relaxed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1908db5022dad66bdf14ea3377a5459eac5534e7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0ODU5OA==", "bodyText": "Agreed, fixed.", "url": "https://github.com/vespa-engine/vespa/pull/12381#discussion_r386348598", "createdAt": "2020-03-02T11:51:16Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.h", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/vespalib/util/threadexecutor.h>\n+#include <vespa/vespalib/util/thread.h>\n+#include <thread>\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * Has a single thread consuming tasks from a fixed size ringbuffer.\n+ * Made for throughput where the producer has no interaction with the consumer and\n+ * it is hence very cheap to produce a task. High and low watermark at 25%/75% is used\n+ * to reduce ping-pong.\n+ */\n+class SingleExecutor final : public vespalib::SyncableThreadExecutor, vespalib::Runnable {\n+public:\n+    explicit SingleExecutor(uint32_t taskLimit);\n+    ~SingleExecutor() override;\n+    Task::UP execute(Task::UP task) override;\n+    void setTaskLimit(uint32_t taskLimit) override;\n+    SingleExecutor & sync() override;\n+    size_t getNumThreads() const override;\n+    uint32_t getTaskLimit() const { return _taskLimit.load(std::memory_order_relaxed); }\n+    Stats getStats() override;\n+private:\n+    uint64_t addTask(Task::UP task);\n+    void run() override;\n+    void drain_tasks();\n+    void run_tasks_till(uint64_t available);\n+    void wait_for_room(MonitorGuard & guard);\n+    uint64_t index(uint64_t counter) const {\n+        return counter & (_taskLimit.load(std::memory_order_relaxed) - 1);\n+    }\n+\n+    uint64_t numTasks() const {\n+        return _wp.load(std::memory_order_relaxed) - _rp.load(std::memory_order_relaxed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzOTg3NA=="}, "originalCommit": {"oid": "1908db5022dad66bdf14ea3377a5459eac5534e7"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzIxMTE2OnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTozMzowNVrOFwcYFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMTo1MjoyOVrOFwc4EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MDg4NQ==", "bodyText": "not thread safe. minor consequences", "url": "https://github.com/vespa-engine/vespa/pull/12381#discussion_r386340885", "createdAt": "2020-03-02T11:33:05Z", "author": {"login": "havardpe"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -0,0 +1,131 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"singleexecutor.h\"\n+#include <vespa/vespalib/util/time.h>\n+\n+namespace vespalib {\n+\n+SingleExecutor::SingleExecutor(uint32_t taskLimit)\n+    : _taskLimit(vespalib::roundUp2inN(taskLimit)),\n+      _wantedTaskLimit(_taskLimit.load()),\n+      _rp(0),\n+      _tasks(std::make_unique<Task::UP[]>(_taskLimit)),\n+      _consumerMonitor(),\n+      _producerMonitor(),\n+      _thread(*this),\n+      _lastAccepted(0),\n+      _maxPending(0),\n+      _wakeupConsumerAt(0),\n+      _producerNeedWakeup(false),\n+      _wp(0)\n+{\n+    _thread.start();\n+}\n+SingleExecutor::~SingleExecutor() {\n+    sync();\n+    _thread.stop().join();\n+}\n+\n+size_t\n+SingleExecutor::getNumThreads() const {\n+    return 1;\n+}\n+\n+uint64_t\n+SingleExecutor::addTask(Task::UP task) {\n+    MonitorGuard guard(_producerMonitor);\n+    wait_for_room(guard);\n+    uint64_t wp = _wp.load(std::memory_order_relaxed);\n+    _tasks[index(wp)] = std::move(task);\n+    _wp.store(wp + 1, std::memory_order_release);\n+    return wp;\n+}\n+\n+Executor::Task::UP\n+SingleExecutor::execute(Task::UP task) {\n+    uint64_t wp = addTask(std::move(task));\n+    if (wp == _wakeupConsumerAt.load(std::memory_order_relaxed)) {\n+        MonitorGuard guard(_consumerMonitor);\n+        guard.signal();\n+    }\n+    return task;\n+}\n+\n+void\n+SingleExecutor::setTaskLimit(uint32_t taskLimit) {\n+    _wantedTaskLimit = vespalib::roundUp2inN(taskLimit);\n+}\n+\n+SingleExecutor &\n+SingleExecutor::sync() {\n+    uint64_t wp = _wp.load(std::memory_order_relaxed);\n+    while (wp > _rp.load(std::memory_order_relaxed)) {\n+        std::this_thread::sleep_for(1ms);\n+    }\n+    return *this;\n+}\n+\n+void\n+SingleExecutor::run() {\n+    while (!_thread.stopped()) {\n+        drain_tasks();\n+        _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n+        MonitorGuard guard(_consumerMonitor);\n+        guard.wait(10ms);\n+        _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+    }\n+}\n+\n+void\n+SingleExecutor::drain_tasks() {\n+    while (numTasks() > 0) {\n+        run_tasks_till(_wp.load(std::memory_order_acquire));\n+    }\n+}\n+\n+void\n+SingleExecutor::run_tasks_till(uint64_t available) {\n+    uint64_t consumed = _rp.load(std::memory_order_relaxed);\n+    uint64_t left = available - consumed;\n+    if (_maxPending.load(std::memory_order_relaxed) < left) {\n+        _maxPending.store(left, std::memory_order_relaxed);\n+    }\n+    uint64_t wakeupLimit = _producerNeedWakeup.load(std::memory_order_relaxed)\n+            ? (available - (left >> 2))\n+            : 0;\n+    while (consumed  < available) {\n+        Task::UP task = std::move(_tasks[index(consumed)]);\n+        task->run();\n+        _rp.store(++consumed, std::memory_order_relaxed);\n+        if (wakeupLimit == consumed) {\n+            MonitorGuard guard(_producerMonitor);\n+            guard.broadcast();\n+        }\n+    }\n+}\n+\n+void\n+SingleExecutor::wait_for_room(MonitorGuard & producerGuard) {\n+    if (_taskLimit.load(std::memory_order_relaxed) != _wantedTaskLimit.load(std::memory_order_relaxed)) {\n+        sync();\n+        _tasks = std::make_unique<Task::UP[]>(_wantedTaskLimit);\n+        _taskLimit = _wantedTaskLimit.load();\n+    }\n+    while (numTasks() >= _taskLimit.load(std::memory_order_relaxed)) {\n+        _producerNeedWakeup.store(true, std::memory_order_relaxed);\n+        producerGuard.wait(10ms);\n+        _producerNeedWakeup.store(false, std::memory_order_relaxed);\n+    }\n+}\n+\n+ThreadExecutor::Stats\n+SingleExecutor::getStats() {\n+    uint64_t accepted = _wp.load(std::memory_order_relaxed);\n+    Stats stats(_maxPending, (accepted - _lastAccepted), 0);\n+    _lastAccepted = accepted;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1908db5022dad66bdf14ea3377a5459eac5534e7"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTA3Mg==", "bodyText": "Correct, but usage is always thread safe. Will reconsider after field testing and some maturing.", "url": "https://github.com/vespa-engine/vespa/pull/12381#discussion_r386349072", "createdAt": "2020-03-02T11:52:29Z", "author": {"login": "baldersheim"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -0,0 +1,131 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"singleexecutor.h\"\n+#include <vespa/vespalib/util/time.h>\n+\n+namespace vespalib {\n+\n+SingleExecutor::SingleExecutor(uint32_t taskLimit)\n+    : _taskLimit(vespalib::roundUp2inN(taskLimit)),\n+      _wantedTaskLimit(_taskLimit.load()),\n+      _rp(0),\n+      _tasks(std::make_unique<Task::UP[]>(_taskLimit)),\n+      _consumerMonitor(),\n+      _producerMonitor(),\n+      _thread(*this),\n+      _lastAccepted(0),\n+      _maxPending(0),\n+      _wakeupConsumerAt(0),\n+      _producerNeedWakeup(false),\n+      _wp(0)\n+{\n+    _thread.start();\n+}\n+SingleExecutor::~SingleExecutor() {\n+    sync();\n+    _thread.stop().join();\n+}\n+\n+size_t\n+SingleExecutor::getNumThreads() const {\n+    return 1;\n+}\n+\n+uint64_t\n+SingleExecutor::addTask(Task::UP task) {\n+    MonitorGuard guard(_producerMonitor);\n+    wait_for_room(guard);\n+    uint64_t wp = _wp.load(std::memory_order_relaxed);\n+    _tasks[index(wp)] = std::move(task);\n+    _wp.store(wp + 1, std::memory_order_release);\n+    return wp;\n+}\n+\n+Executor::Task::UP\n+SingleExecutor::execute(Task::UP task) {\n+    uint64_t wp = addTask(std::move(task));\n+    if (wp == _wakeupConsumerAt.load(std::memory_order_relaxed)) {\n+        MonitorGuard guard(_consumerMonitor);\n+        guard.signal();\n+    }\n+    return task;\n+}\n+\n+void\n+SingleExecutor::setTaskLimit(uint32_t taskLimit) {\n+    _wantedTaskLimit = vespalib::roundUp2inN(taskLimit);\n+}\n+\n+SingleExecutor &\n+SingleExecutor::sync() {\n+    uint64_t wp = _wp.load(std::memory_order_relaxed);\n+    while (wp > _rp.load(std::memory_order_relaxed)) {\n+        std::this_thread::sleep_for(1ms);\n+    }\n+    return *this;\n+}\n+\n+void\n+SingleExecutor::run() {\n+    while (!_thread.stopped()) {\n+        drain_tasks();\n+        _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);\n+        MonitorGuard guard(_consumerMonitor);\n+        guard.wait(10ms);\n+        _wakeupConsumerAt.store(0, std::memory_order_relaxed);\n+    }\n+}\n+\n+void\n+SingleExecutor::drain_tasks() {\n+    while (numTasks() > 0) {\n+        run_tasks_till(_wp.load(std::memory_order_acquire));\n+    }\n+}\n+\n+void\n+SingleExecutor::run_tasks_till(uint64_t available) {\n+    uint64_t consumed = _rp.load(std::memory_order_relaxed);\n+    uint64_t left = available - consumed;\n+    if (_maxPending.load(std::memory_order_relaxed) < left) {\n+        _maxPending.store(left, std::memory_order_relaxed);\n+    }\n+    uint64_t wakeupLimit = _producerNeedWakeup.load(std::memory_order_relaxed)\n+            ? (available - (left >> 2))\n+            : 0;\n+    while (consumed  < available) {\n+        Task::UP task = std::move(_tasks[index(consumed)]);\n+        task->run();\n+        _rp.store(++consumed, std::memory_order_relaxed);\n+        if (wakeupLimit == consumed) {\n+            MonitorGuard guard(_producerMonitor);\n+            guard.broadcast();\n+        }\n+    }\n+}\n+\n+void\n+SingleExecutor::wait_for_room(MonitorGuard & producerGuard) {\n+    if (_taskLimit.load(std::memory_order_relaxed) != _wantedTaskLimit.load(std::memory_order_relaxed)) {\n+        sync();\n+        _tasks = std::make_unique<Task::UP[]>(_wantedTaskLimit);\n+        _taskLimit = _wantedTaskLimit.load();\n+    }\n+    while (numTasks() >= _taskLimit.load(std::memory_order_relaxed)) {\n+        _producerNeedWakeup.store(true, std::memory_order_relaxed);\n+        producerGuard.wait(10ms);\n+        _producerNeedWakeup.store(false, std::memory_order_relaxed);\n+    }\n+}\n+\n+ThreadExecutor::Stats\n+SingleExecutor::getStats() {\n+    uint64_t accepted = _wp.load(std::memory_order_relaxed);\n+    Stats stats(_maxPending, (accepted - _lastAccepted), 0);\n+    _lastAccepted = accepted;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MDg4NQ=="}, "originalCommit": {"oid": "1908db5022dad66bdf14ea3377a5459eac5534e7"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MzMwODg3OnYy", "diffSide": "RIGHT", "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjowOTowNVrOFwdSsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxMjowOTowNVrOFwdSsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1NTg4OA==", "bodyText": "For readability, consider just  / 4 instead of  >> 2. Compiler will figure it out anyway.", "url": "https://github.com/vespa-engine/vespa/pull/12381#discussion_r386355888", "createdAt": "2020-03-02T12:09:05Z", "author": {"login": "vekterli"}, "path": "staging_vespalib/src/vespa/vespalib/util/singleexecutor.cpp", "diffHunk": "@@ -0,0 +1,131 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"singleexecutor.h\"\n+#include <vespa/vespalib/util/time.h>\n+\n+namespace vespalib {\n+\n+SingleExecutor::SingleExecutor(uint32_t taskLimit)\n+    : _taskLimit(vespalib::roundUp2inN(taskLimit)),\n+      _wantedTaskLimit(_taskLimit.load()),\n+      _rp(0),\n+      _tasks(std::make_unique<Task::UP[]>(_taskLimit)),\n+      _consumerMonitor(),\n+      _producerMonitor(),\n+      _thread(*this),\n+      _lastAccepted(0),\n+      _maxPending(0),\n+      _wakeupConsumerAt(0),\n+      _producerNeedWakeup(false),\n+      _wp(0)\n+{\n+    _thread.start();\n+}\n+SingleExecutor::~SingleExecutor() {\n+    sync();\n+    _thread.stop().join();\n+}\n+\n+size_t\n+SingleExecutor::getNumThreads() const {\n+    return 1;\n+}\n+\n+uint64_t\n+SingleExecutor::addTask(Task::UP task) {\n+    MonitorGuard guard(_producerMonitor);\n+    wait_for_room(guard);\n+    uint64_t wp = _wp.load(std::memory_order_relaxed);\n+    _tasks[index(wp)] = std::move(task);\n+    _wp.store(wp + 1, std::memory_order_release);\n+    return wp;\n+}\n+\n+Executor::Task::UP\n+SingleExecutor::execute(Task::UP task) {\n+    uint64_t wp = addTask(std::move(task));\n+    if (wp == _wakeupConsumerAt.load(std::memory_order_relaxed)) {\n+        MonitorGuard guard(_consumerMonitor);\n+        guard.signal();\n+    }\n+    return task;\n+}\n+\n+void\n+SingleExecutor::setTaskLimit(uint32_t taskLimit) {\n+    _wantedTaskLimit = vespalib::roundUp2inN(taskLimit);\n+}\n+\n+SingleExecutor &\n+SingleExecutor::sync() {\n+    uint64_t wp = _wp.load(std::memory_order_relaxed);\n+    while (wp > _rp.load(std::memory_order_relaxed)) {\n+        std::this_thread::sleep_for(1ms);\n+    }\n+    return *this;\n+}\n+\n+void\n+SingleExecutor::run() {\n+    while (!_thread.stopped()) {\n+        drain_tasks();\n+        _wakeupConsumerAt.store(_wp.load(std::memory_order_relaxed) + (_taskLimit.load(std::memory_order_relaxed) >> 2), std::memory_order_relaxed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6449cf3d52ae44a54de59e478f8c0915671e23bb"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2381, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}