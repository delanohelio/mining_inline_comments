{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NDEwMDc4", "number": 11958, "title": "add various validation of endpoint certificates", "bodyText": "WIP", "createdAt": "2020-01-27T10:17:44Z", "url": "https://github.com/vespa-engine/vespa/pull/11958", "merged": true, "mergeCommit": {"oid": "8f340c58e8f7236a911818850d01b99d6cd74e6e"}, "closed": true, "closedAt": "2020-01-27T14:22:28Z", "author": {"login": "andreer"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-Z6sPAH2gAyMzY3NDEwMDc4OjI5MTE5NjJjZWYxMWFmZmFjYmEzYTM1NWFjZTkxY2IyZmY0NjEyN2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-demLAFqTM0ODY5NDM5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2911962cef11affacba3a355ace91cb2ff46127b", "author": {"user": {"login": "andreer", "name": "Andreas Eriksen"}}, "url": "https://github.com/vespa-engine/vespa/commit/2911962cef11affacba3a355ace91cb2ff46127b", "committedDate": "2020-01-27T10:09:58Z", "message": "add various validation of endpoint certificates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42d9ece77530bd4a803677f62380e41462d37b50", "author": {"user": {"login": "andreer", "name": "Andreas Eriksen"}}, "url": "https://github.com/vespa-engine/vespa/commit/42d9ece77530bd4a803677f62380e41462d37b50", "committedDate": "2020-01-27T11:50:47Z", "message": "move endpoint certificate handling out of applicationcontroller"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e4b9422124073188f9aab1c0498f9fd04f6c8c1", "author": {"user": {"login": "andreer", "name": "Andreas Eriksen"}}, "url": "https://github.com/vespa-engine/vespa/commit/9e4b9422124073188f9aab1c0498f9fd04f6c8c1", "committedDate": "2020-01-27T13:45:44Z", "message": "set up mocked unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Njc4MzYw", "url": "https://github.com/vespa-engine/vespa/pull/11958#pullrequestreview-348678360", "createdAt": "2020-01-27T13:56:41Z", "commit": {"oid": "9e4b9422124073188f9aab1c0498f9fd04f6c8c1"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1Njo0MVrOFiDdGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1Nzo0MFrOFiDfCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MjUwNg==", "bodyText": "log?", "url": "https://github.com/vespa-engine/vespa/pull/11958#discussion_r371252506", "createdAt": "2020-01-27T13:56:41Z", "author": {"login": "tokle"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.yahoo.vespa.hosted.controller.endpointcertificates;\n+\n+import com.yahoo.config.provision.ApplicationId;\n+import com.yahoo.config.provision.ClusterSpec;\n+import com.yahoo.config.provision.zone.ZoneApi;\n+import com.yahoo.config.provision.zone.ZoneId;\n+import com.yahoo.container.jdisc.secretstore.SecretStore;\n+import com.yahoo.log.LogLevel;\n+import com.yahoo.security.SubjectAlternativeName;\n+import com.yahoo.security.X509CertificateUtils;\n+import com.yahoo.vespa.hosted.controller.Instance;\n+import com.yahoo.vespa.hosted.controller.api.integration.certificates.ApplicationCertificate;\n+import com.yahoo.vespa.hosted.controller.api.integration.certificates.ApplicationCertificateProvider;\n+import com.yahoo.vespa.hosted.controller.api.integration.certificates.EndpointCertificateMetadata;\n+import com.yahoo.vespa.hosted.controller.api.integration.zone.ZoneRegistry;\n+import com.yahoo.vespa.hosted.controller.application.Endpoint;\n+import com.yahoo.vespa.hosted.controller.application.EndpointId;\n+import com.yahoo.vespa.hosted.controller.persistence.CuratorDb;\n+import com.yahoo.vespa.hosted.controller.persistence.EndpointCertificateMetadataSerializer;\n+\n+import java.security.cert.X509Certificate;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class EndpointCertificateManager {\n+\n+    private static final Logger log = Logger.getLogger(EndpointCertificateManager.class.getName());\n+\n+    private final ZoneRegistry zoneRegistry;\n+    private final CuratorDb curator;\n+    private final SecretStore secretStore;\n+    private final ApplicationCertificateProvider applicationCertificateProvider;\n+    private final Clock clock;\n+\n+    public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n+                                      CuratorDb curator,\n+                                      SecretStore secretStore,\n+                                      ApplicationCertificateProvider applicationCertificateProvider,\n+                                      Clock clock) {\n+        this.zoneRegistry = zoneRegistry;\n+        this.curator = curator;\n+        this.secretStore = secretStore;\n+        this.applicationCertificateProvider = applicationCertificateProvider;\n+        this.clock = clock;\n+    }\n+\n+    public Optional<EndpointCertificateMetadata> getEndpointCertificateMetadata(Instance instance, ZoneId zone) {\n+\n+        if (!zoneRegistry.zones().directlyRouted().ids().contains(zone)) return Optional.empty();\n+\n+        // Re-use certificate if already provisioned\n+        Optional<EndpointCertificateMetadata> endpointCertificateMetadata =\n+                curator.readEndpointCertificateMetadata(instance.id())\n+                        .or(() -> Optional.of(provisionEndpointCertificate(instance)));\n+\n+        // Only logs warnings for now\n+        endpointCertificateMetadata.ifPresent(certificateMetadata -> verifyEndpointCertificate(certificateMetadata, instance, zone));\n+\n+        return endpointCertificateMetadata;\n+    }\n+\n+    private EndpointCertificateMetadata provisionEndpointCertificate(Instance instance) {\n+        List<ZoneId> directlyRoutedZones = zoneRegistry.zones().directlyRouted().zones().stream().map(ZoneApi::getId).collect(Collectors.toUnmodifiableList());\n+        ApplicationCertificate newCertificate = applicationCertificateProvider\n+                .requestCaSignedCertificate(instance.id(), dnsNamesOf(instance.id(), directlyRoutedZones));\n+        EndpointCertificateMetadata provisionedCertificateMetadata = EndpointCertificateMetadataSerializer.fromTlsSecretsKeysString(newCertificate.secretsKeyNamePrefix());\n+        curator.writeEndpointCertificateMetadata(instance.id(), provisionedCertificateMetadata);\n+        return provisionedCertificateMetadata;\n+    }\n+\n+    private boolean verifyEndpointCertificate(EndpointCertificateMetadata endpointCertificateMetadata, Instance instance, ZoneId zone) {\n+        try {\n+            var pemEncodedEndpointCertificate = secretStore.getSecret(endpointCertificateMetadata.certName(), endpointCertificateMetadata.version());\n+\n+            if (pemEncodedEndpointCertificate == null) return logWarning(\"Certificate not found in secret store\");\n+\n+            List<X509Certificate> x509CertificateList = X509CertificateUtils.certificateListFromPem(pemEncodedEndpointCertificate);\n+\n+            if (x509CertificateList.isEmpty()) return logWarning(\"Empty certificate list\");\n+            if (x509CertificateList.size() < 2)\n+                return logWarning(\"Only a single certificate found in chain - intermediate certificates likely missing\");\n+\n+            Instant now = clock.instant();\n+            Instant firstExpiry = Instant.MAX;\n+            for (X509Certificate x509Certificate : x509CertificateList) {\n+                Instant notBefore = x509Certificate.getNotBefore().toInstant();\n+                Instant notAfter = x509Certificate.getNotAfter().toInstant();\n+                if (now.isBefore(notBefore)) return logWarning(\"Certificate is not yet valid\");\n+                if (now.isAfter(notAfter)) return logWarning(\"Certificate has expired\");\n+                if (notAfter.isBefore(firstExpiry)) firstExpiry = notAfter;\n+            }\n+\n+            X509Certificate endEntityCertificate = x509CertificateList.get(0);\n+            List<String> subjectAlternativeNames = X509CertificateUtils.getSubjectAlternativeNames(endEntityCertificate).stream()\n+                    .filter(san -> san.getType().equals(SubjectAlternativeName.Type.DNS_NAME))\n+                    .map(SubjectAlternativeName::getValue).collect(Collectors.toList());\n+\n+            System.out.println(subjectAlternativeNames);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4b9422124073188f9aab1c0498f9fd04f6c8c1"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MzAwMQ==", "bodyText": "Perhaps also check that the certificate does not contain any additional  SAN DNS values?", "url": "https://github.com/vespa-engine/vespa/pull/11958#discussion_r371253001", "createdAt": "2020-01-27T13:57:40Z", "author": {"login": "tokle"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/endpointcertificates/EndpointCertificateManager.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.yahoo.vespa.hosted.controller.endpointcertificates;\n+\n+import com.yahoo.config.provision.ApplicationId;\n+import com.yahoo.config.provision.ClusterSpec;\n+import com.yahoo.config.provision.zone.ZoneApi;\n+import com.yahoo.config.provision.zone.ZoneId;\n+import com.yahoo.container.jdisc.secretstore.SecretStore;\n+import com.yahoo.log.LogLevel;\n+import com.yahoo.security.SubjectAlternativeName;\n+import com.yahoo.security.X509CertificateUtils;\n+import com.yahoo.vespa.hosted.controller.Instance;\n+import com.yahoo.vespa.hosted.controller.api.integration.certificates.ApplicationCertificate;\n+import com.yahoo.vespa.hosted.controller.api.integration.certificates.ApplicationCertificateProvider;\n+import com.yahoo.vespa.hosted.controller.api.integration.certificates.EndpointCertificateMetadata;\n+import com.yahoo.vespa.hosted.controller.api.integration.zone.ZoneRegistry;\n+import com.yahoo.vespa.hosted.controller.application.Endpoint;\n+import com.yahoo.vespa.hosted.controller.application.EndpointId;\n+import com.yahoo.vespa.hosted.controller.persistence.CuratorDb;\n+import com.yahoo.vespa.hosted.controller.persistence.EndpointCertificateMetadataSerializer;\n+\n+import java.security.cert.X509Certificate;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class EndpointCertificateManager {\n+\n+    private static final Logger log = Logger.getLogger(EndpointCertificateManager.class.getName());\n+\n+    private final ZoneRegistry zoneRegistry;\n+    private final CuratorDb curator;\n+    private final SecretStore secretStore;\n+    private final ApplicationCertificateProvider applicationCertificateProvider;\n+    private final Clock clock;\n+\n+    public EndpointCertificateManager(ZoneRegistry zoneRegistry,\n+                                      CuratorDb curator,\n+                                      SecretStore secretStore,\n+                                      ApplicationCertificateProvider applicationCertificateProvider,\n+                                      Clock clock) {\n+        this.zoneRegistry = zoneRegistry;\n+        this.curator = curator;\n+        this.secretStore = secretStore;\n+        this.applicationCertificateProvider = applicationCertificateProvider;\n+        this.clock = clock;\n+    }\n+\n+    public Optional<EndpointCertificateMetadata> getEndpointCertificateMetadata(Instance instance, ZoneId zone) {\n+\n+        if (!zoneRegistry.zones().directlyRouted().ids().contains(zone)) return Optional.empty();\n+\n+        // Re-use certificate if already provisioned\n+        Optional<EndpointCertificateMetadata> endpointCertificateMetadata =\n+                curator.readEndpointCertificateMetadata(instance.id())\n+                        .or(() -> Optional.of(provisionEndpointCertificate(instance)));\n+\n+        // Only logs warnings for now\n+        endpointCertificateMetadata.ifPresent(certificateMetadata -> verifyEndpointCertificate(certificateMetadata, instance, zone));\n+\n+        return endpointCertificateMetadata;\n+    }\n+\n+    private EndpointCertificateMetadata provisionEndpointCertificate(Instance instance) {\n+        List<ZoneId> directlyRoutedZones = zoneRegistry.zones().directlyRouted().zones().stream().map(ZoneApi::getId).collect(Collectors.toUnmodifiableList());\n+        ApplicationCertificate newCertificate = applicationCertificateProvider\n+                .requestCaSignedCertificate(instance.id(), dnsNamesOf(instance.id(), directlyRoutedZones));\n+        EndpointCertificateMetadata provisionedCertificateMetadata = EndpointCertificateMetadataSerializer.fromTlsSecretsKeysString(newCertificate.secretsKeyNamePrefix());\n+        curator.writeEndpointCertificateMetadata(instance.id(), provisionedCertificateMetadata);\n+        return provisionedCertificateMetadata;\n+    }\n+\n+    private boolean verifyEndpointCertificate(EndpointCertificateMetadata endpointCertificateMetadata, Instance instance, ZoneId zone) {\n+        try {\n+            var pemEncodedEndpointCertificate = secretStore.getSecret(endpointCertificateMetadata.certName(), endpointCertificateMetadata.version());\n+\n+            if (pemEncodedEndpointCertificate == null) return logWarning(\"Certificate not found in secret store\");\n+\n+            List<X509Certificate> x509CertificateList = X509CertificateUtils.certificateListFromPem(pemEncodedEndpointCertificate);\n+\n+            if (x509CertificateList.isEmpty()) return logWarning(\"Empty certificate list\");\n+            if (x509CertificateList.size() < 2)\n+                return logWarning(\"Only a single certificate found in chain - intermediate certificates likely missing\");\n+\n+            Instant now = clock.instant();\n+            Instant firstExpiry = Instant.MAX;\n+            for (X509Certificate x509Certificate : x509CertificateList) {\n+                Instant notBefore = x509Certificate.getNotBefore().toInstant();\n+                Instant notAfter = x509Certificate.getNotAfter().toInstant();\n+                if (now.isBefore(notBefore)) return logWarning(\"Certificate is not yet valid\");\n+                if (now.isAfter(notAfter)) return logWarning(\"Certificate has expired\");\n+                if (notAfter.isBefore(firstExpiry)) firstExpiry = notAfter;\n+            }\n+\n+            X509Certificate endEntityCertificate = x509CertificateList.get(0);\n+            List<String> subjectAlternativeNames = X509CertificateUtils.getSubjectAlternativeNames(endEntityCertificate).stream()\n+                    .filter(san -> san.getType().equals(SubjectAlternativeName.Type.DNS_NAME))\n+                    .map(SubjectAlternativeName::getValue).collect(Collectors.toList());\n+\n+            System.out.println(subjectAlternativeNames);\n+\n+            if (!subjectAlternativeNames.containsAll(dnsNamesOf(instance.id(), List.of(zone))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e4b9422124073188f9aab1c0498f9fd04f6c8c1"}, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6769f64b639152760d84ed4e6f3300f1f83d90b", "author": {"user": {"login": "andreer", "name": "Andreas Eriksen"}}, "url": "https://github.com/vespa-engine/vespa/commit/a6769f64b639152760d84ed4e6f3300f1f83d90b", "committedDate": "2020-01-27T14:17:15Z", "message": "stricter SAN verification"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a8a46202e974a853dd6690c9359a3d26450dd89", "author": {"user": {"login": "andreer", "name": "Andreas Eriksen"}}, "url": "https://github.com/vespa-engine/vespa/commit/0a8a46202e974a853dd6690c9359a3d26450dd89", "committedDate": "2020-01-27T14:18:17Z", "message": "stricter SAN verification 2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Njk0Mzky", "url": "https://github.com/vespa-engine/vespa/pull/11958#pullrequestreview-348694392", "createdAt": "2020-01-27T14:18:54Z", "commit": {"oid": "a6769f64b639152760d84ed4e6f3300f1f83d90b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3884, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}