{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyMjY0NzA3", "number": 12390, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwOToyMjoyM1rODkMXoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwOToyMjoyM1rODkMXoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Mjc3OTg1OnYy", "diffSide": "RIGHT", "path": "orchestrator/src/main/java/com/yahoo/vespa/orchestrator/status/HostInfosServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwOToyMjoyM1rOFwYW_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwOToyMjoyM1rOFwYW_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI3NTA2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static String hostsPath(ApplicationId applicationInstanceReference) {\n          \n          \n            \n                    return applicationPath(applicationInstanceReference) + \"/hosts\";\n          \n          \n            \n                private static String hostsPath(ApplicationId application) {\n          \n          \n            \n                    return applicationPath(application) + \"/hosts\";", "url": "https://github.com/vespa-engine/vespa/pull/12390#discussion_r386275068", "createdAt": "2020-03-02T09:22:23Z", "author": {"login": "freva"}, "path": "orchestrator/src/main/java/com/yahoo/vespa/orchestrator/status/HostInfosServiceImpl.java", "diffHunk": "@@ -0,0 +1,128 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+package com.yahoo.vespa.orchestrator.status;\n+\n+import com.yahoo.config.provision.ApplicationId;\n+import com.yahoo.jdisc.Timer;\n+import com.yahoo.log.LogLevel;\n+import com.yahoo.vespa.applicationmodel.ApplicationInstanceReference;\n+import com.yahoo.vespa.applicationmodel.HostName;\n+import com.yahoo.vespa.curator.Curator;\n+import com.yahoo.vespa.orchestrator.OrchestratorUtil;\n+import com.yahoo.vespa.orchestrator.status.json.WireHostInfo;\n+import org.apache.zookeeper.KeeperException.NoNodeException;\n+\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Handles all ZooKeeper data structures related to each active application, including HostInfo.\n+ * Cache (if any) is above and not visible here.\n+ *\n+ * @author hakonhall\n+ */\n+public class HostInfosServiceImpl implements HostInfosService {\n+    private static final Logger log = Logger.getLogger(HostInfosServiceImpl.class.getName());\n+\n+    private final Curator curator;\n+    private final Timer timer;\n+\n+    HostInfosServiceImpl(Curator curator, Timer timer) {\n+        this.curator = curator;\n+        this.timer = timer;\n+    }\n+\n+    @Override\n+    public HostInfos getHostInfos(ApplicationInstanceReference reference) {\n+        ApplicationId application = OrchestratorUtil.toApplicationId(reference);\n+        String hostsRootPath = hostsPath(application);\n+        if (uncheck(() -> curator.framework().checkExists().forPath(hostsRootPath)) == null) {\n+            return new HostInfos();\n+        } else {\n+            List<String> hostnames = uncheck(() -> curator.framework().getChildren().forPath(hostsRootPath));\n+            Map<HostName, HostInfo> hostInfos = hostnames.stream().collect(Collectors.toMap(\n+                    hostname -> new HostName(hostname),\n+                    hostname -> {\n+                        byte[] bytes = uncheck(() -> curator.framework().getData().forPath(hostsRootPath + \"/\" + hostname));\n+                        return WireHostInfo.deserialize(bytes);\n+                    }));\n+            return new HostInfos(hostInfos);\n+        }\n+    }\n+\n+    @Override\n+    public boolean setHostStatus(ApplicationInstanceReference reference, HostName hostname, HostStatus status) {\n+        ApplicationId application = OrchestratorUtil.toApplicationId(reference);\n+        String path = hostPath(application, hostname);\n+\n+        if (status == HostStatus.NO_REMARKS) {\n+            return deleteNode_ignoreNoNodeException(path, \"Host already has state NO_REMARKS, path = \" + path);\n+        }\n+\n+        Optional<HostInfo> currentHostInfo = uncheck(() -> readBytesFromZk(path)).map(WireHostInfo::deserialize);\n+        if (currentHostInfo.isEmpty()) {\n+            Instant suspendedSince = timer.currentTime();\n+            HostInfo hostInfo = HostInfo.createSuspended(status, suspendedSince);\n+            byte[] hostInfoBytes = WireHostInfo.serialize(hostInfo);\n+            uncheck(() -> curator.framework().create().creatingParentsIfNeeded().forPath(path, hostInfoBytes));\n+        } else if (currentHostInfo.get().status() == status) {\n+            return false;\n+        } else {\n+            Instant suspendedSince = currentHostInfo.get().suspendedSince().orElseGet(timer::currentTime);\n+            HostInfo hostInfo = HostInfo.createSuspended(status, suspendedSince);\n+            byte[] hostInfoBytes = WireHostInfo.serialize(hostInfo);\n+            uncheck(() -> curator.framework().setData().forPath(path, hostInfoBytes));\n+        }\n+\n+        return true;\n+    }\n+\n+    private Optional<byte[]> readBytesFromZk(String path) throws Exception {\n+        try {\n+            return Optional.of(curator.framework().getData().forPath(path));\n+        } catch (NoNodeException e) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private boolean deleteNode_ignoreNoNodeException(String path, String debugLogMessageIfNotExists) {\n+        try {\n+            curator.framework().delete().forPath(path);\n+            return true;\n+        } catch (NoNodeException e) {\n+            log.log(LogLevel.DEBUG, debugLogMessageIfNotExists, e);\n+            return false;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static String applicationPath(ApplicationId application) {\n+        return \"/vespa/host-status/\" + application.serializedForm();\n+    }\n+\n+    private static String hostsPath(ApplicationId applicationInstanceReference) {\n+        return applicationPath(applicationInstanceReference) + \"/hosts\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74087e3787828c32d849c54af5ea3d336262cb62"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2390, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}