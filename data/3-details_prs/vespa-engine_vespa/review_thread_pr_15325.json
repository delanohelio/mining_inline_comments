{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwMDA2MTU5", "number": 15325, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNzowNTo1MVrOE4QmDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTozNzoxM1rOE4l-SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDI3NTk4OnYy", "diffSide": "RIGHT", "path": "vespalib/src/tests/spin_lock/spin_lock_test.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNzowNTo1MVrOHyEucg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOToyODowM1rOHym64Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2ODI3NA==", "bodyText": "SpinLock -> std::mutex", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522268274", "createdAt": "2020-11-12T17:05:51Z", "author": {"login": "arnej27959"}, "path": "vespalib/src/tests/spin_lock/spin_lock_test.cpp", "diffHunk": "@@ -0,0 +1,174 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/util/spin_lock.h>\n+#include <vespa/vespalib/util/benchmark_timer.h>\n+#include <vespa/vespalib/util/time.h>\n+#include <vespa/vespalib/testkit/test_kit.h>\n+\n+using namespace vespalib;\n+\n+bool verbose = false;\n+double budget = 0.25;\n+size_t thread_safety_work = 1000000;\n+\n+struct DummyLock {\n+    void lock() {}\n+    void unlock() {}\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+struct MyState {\n+    static constexpr size_t SZ = 5;\n+    std::array<size_t,SZ> state = {0,0,0,0,0};\n+    void update() {\n+        std::array<size_t,SZ> tmp;\n+        for (size_t i = 0; i < SZ; ++i) {\n+            tmp[i] = state[i];\n+        }\n+        for (size_t i = 0; i < SZ; ++i) {\n+            state[i] = tmp[i] + 1;\n+        }\n+    }\n+    bool check(size_t expect) const {\n+        for (size_t value: state) {\n+            if (value != expect) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    void report(size_t expect, const char *name) const {\n+        if (check(expect)) {\n+            fprintf(stderr, \"%s is thread safe\\n\", name);\n+        } else {\n+            fprintf(stderr, \"%s is not thread safe\\n\", name);\n+            fprintf(stderr, \"    expected %zu, got [%zu,%zu,%zu,%zu,%zu]\\n\",\n+                    expect, state[0], state[1], state[2], state[3], state[4]);\n+        }\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> void  basic_usage() {\n+    T lock;\n+    {\n+        std::lock_guard guard(lock);\n+    }\n+    {\n+        std::unique_lock guard(lock);\n+    }\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> size_t thread_safety_loop(T &lock, MyState &state, size_t thread_id, size_t thread_limit) {\n+    size_t loop_cnt = (thread_safety_work / thread_limit);\n+    TEST_BARRIER();\n+    auto t0 = steady_clock::now();\n+    TEST_BARRIER();\n+    if (thread_id < thread_limit) {\n+        for (size_t i = 0; i < loop_cnt; ++i) {\n+            std::lock_guard guard(lock);\n+            state.update();\n+        }\n+    }\n+    auto t1 = steady_clock::now();\n+    TEST_BARRIER();\n+    if (thread_id == 0) {\n+        auto t2 = steady_clock::now();\n+        size_t total_ms = count_ms(t2 - t0);\n+        fprintf(stderr, \"---> thread_safety_loop with %zu threads used %zu ms\\n\", thread_limit, total_ms);\n+    }\n+    TEST_BARRIER();\n+    if (verbose && (thread_id < thread_limit)) {\n+        size_t local_ms = count_ms(t1 - t0);\n+        fprintf(stderr, \"    -- thread %zu used %zu ms\\n\", thread_id, local_ms);\n+    }\n+    TEST_BARRIER();\n+    return (loop_cnt * thread_limit);\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> void estimate_cost(const char *name) __attribute__((noinline));\n+template <typename T> void estimate_cost(const char *name) {\n+    T lock;\n+    auto lock_loop = [&]()\n+                     {\n+                         // 250 * 4 = 1000 times lock/unlock\n+                         for (size_t i = 0; i < 250; ++i) {\n+                             // 4 times lock/unlock\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                         }\n+                     };\n+    BenchmarkTimer timer(budget);\n+    while (timer.has_budget()) {\n+        timer.before();\n+        lock_loop();\n+        timer.after();\n+    }\n+    auto cost_ns = timer.min_time() * 1000.0 * 1000.0;\n+    fprintf(stderr, \"%s: estimated lock/unlock time: %g ns\\n\", name, cost_ns);\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+TEST(\"require that locks can be used with lock_guard and unique_lock\") {\n+    TEST_DO(basic_usage<DummyLock>());\n+    TEST_DO(basic_usage<SpinLock>());\n+}\n+\n+TEST_MT_FF(\"report whether DummyLock is thread safe\", 24, DummyLock(), MyState()) {\n+    size_t expect = thread_safety_loop(f1, f2, thread_id, 24);\n+    if (thread_id == 0) {\n+        f2.report(expect, \"DummyLock\");\n+    }\n+}\n+\n+TEST_MT_FF(\"require that SpinLock is thread safe\", 24, SpinLock(), MyState()) {\n+    size_t expect = thread_safety_loop(f1, f2, thread_id, 24);\n+    expect += thread_safety_loop(f1, f2, thread_id, 12);\n+    expect += thread_safety_loop(f1, f2, thread_id, 6);\n+    expect += thread_safety_loop(f1, f2, thread_id, 3);\n+    if (thread_id == 0) {\n+        f2.report(expect, \"SpinLock\");\n+        EXPECT_TRUE(f2.check(expect));\n+    }\n+}\n+\n+TEST_MT_FF(\"require that SpinLock is thread safe\", 24, std::mutex(), MyState()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6268ea791bc989679227facbf528cc98f096ff4"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyODUxMw==", "bodyText": "fixed", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522828513", "createdAt": "2020-11-13T09:28:03Z", "author": {"login": "havardpe"}, "path": "vespalib/src/tests/spin_lock/spin_lock_test.cpp", "diffHunk": "@@ -0,0 +1,174 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/vespalib/util/spin_lock.h>\n+#include <vespa/vespalib/util/benchmark_timer.h>\n+#include <vespa/vespalib/util/time.h>\n+#include <vespa/vespalib/testkit/test_kit.h>\n+\n+using namespace vespalib;\n+\n+bool verbose = false;\n+double budget = 0.25;\n+size_t thread_safety_work = 1000000;\n+\n+struct DummyLock {\n+    void lock() {}\n+    void unlock() {}\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+struct MyState {\n+    static constexpr size_t SZ = 5;\n+    std::array<size_t,SZ> state = {0,0,0,0,0};\n+    void update() {\n+        std::array<size_t,SZ> tmp;\n+        for (size_t i = 0; i < SZ; ++i) {\n+            tmp[i] = state[i];\n+        }\n+        for (size_t i = 0; i < SZ; ++i) {\n+            state[i] = tmp[i] + 1;\n+        }\n+    }\n+    bool check(size_t expect) const {\n+        for (size_t value: state) {\n+            if (value != expect) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    void report(size_t expect, const char *name) const {\n+        if (check(expect)) {\n+            fprintf(stderr, \"%s is thread safe\\n\", name);\n+        } else {\n+            fprintf(stderr, \"%s is not thread safe\\n\", name);\n+            fprintf(stderr, \"    expected %zu, got [%zu,%zu,%zu,%zu,%zu]\\n\",\n+                    expect, state[0], state[1], state[2], state[3], state[4]);\n+        }\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> void  basic_usage() {\n+    T lock;\n+    {\n+        std::lock_guard guard(lock);\n+    }\n+    {\n+        std::unique_lock guard(lock);\n+    }\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> size_t thread_safety_loop(T &lock, MyState &state, size_t thread_id, size_t thread_limit) {\n+    size_t loop_cnt = (thread_safety_work / thread_limit);\n+    TEST_BARRIER();\n+    auto t0 = steady_clock::now();\n+    TEST_BARRIER();\n+    if (thread_id < thread_limit) {\n+        for (size_t i = 0; i < loop_cnt; ++i) {\n+            std::lock_guard guard(lock);\n+            state.update();\n+        }\n+    }\n+    auto t1 = steady_clock::now();\n+    TEST_BARRIER();\n+    if (thread_id == 0) {\n+        auto t2 = steady_clock::now();\n+        size_t total_ms = count_ms(t2 - t0);\n+        fprintf(stderr, \"---> thread_safety_loop with %zu threads used %zu ms\\n\", thread_limit, total_ms);\n+    }\n+    TEST_BARRIER();\n+    if (verbose && (thread_id < thread_limit)) {\n+        size_t local_ms = count_ms(t1 - t0);\n+        fprintf(stderr, \"    -- thread %zu used %zu ms\\n\", thread_id, local_ms);\n+    }\n+    TEST_BARRIER();\n+    return (loop_cnt * thread_limit);\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename T> void estimate_cost(const char *name) __attribute__((noinline));\n+template <typename T> void estimate_cost(const char *name) {\n+    T lock;\n+    auto lock_loop = [&]()\n+                     {\n+                         // 250 * 4 = 1000 times lock/unlock\n+                         for (size_t i = 0; i < 250; ++i) {\n+                             // 4 times lock/unlock\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                             lock.lock();\n+                             lock.unlock();\n+                         }\n+                     };\n+    BenchmarkTimer timer(budget);\n+    while (timer.has_budget()) {\n+        timer.before();\n+        lock_loop();\n+        timer.after();\n+    }\n+    auto cost_ns = timer.min_time() * 1000.0 * 1000.0;\n+    fprintf(stderr, \"%s: estimated lock/unlock time: %g ns\\n\", name, cost_ns);\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+TEST(\"require that locks can be used with lock_guard and unique_lock\") {\n+    TEST_DO(basic_usage<DummyLock>());\n+    TEST_DO(basic_usage<SpinLock>());\n+}\n+\n+TEST_MT_FF(\"report whether DummyLock is thread safe\", 24, DummyLock(), MyState()) {\n+    size_t expect = thread_safety_loop(f1, f2, thread_id, 24);\n+    if (thread_id == 0) {\n+        f2.report(expect, \"DummyLock\");\n+    }\n+}\n+\n+TEST_MT_FF(\"require that SpinLock is thread safe\", 24, SpinLock(), MyState()) {\n+    size_t expect = thread_safety_loop(f1, f2, thread_id, 24);\n+    expect += thread_safety_loop(f1, f2, thread_id, 12);\n+    expect += thread_safety_loop(f1, f2, thread_id, 6);\n+    expect += thread_safety_loop(f1, f2, thread_id, 3);\n+    if (thread_id == 0) {\n+        f2.report(expect, \"SpinLock\");\n+        EXPECT_TRUE(f2.check(expect));\n+    }\n+}\n+\n+TEST_MT_FF(\"require that SpinLock is thread safe\", 24, std::mutex(), MyState()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI2ODI3NA=="}, "originalCommit": {"oid": "b6268ea791bc989679227facbf528cc98f096ff4"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzY1OTM0OnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTowMjo1NFrOHymFhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOToyNzo1NVrOHym6jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgxNDg1Mg==", "bodyText": "Note that the spin lock does not provide priority inheritance, a low priority thread preempted while holding the spin lock can cause excessive spinning in a high priority thread if the system has few (e.g. a single) cpu cores.", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522814852", "createdAt": "2020-11-13T09:02:54Z", "author": {"login": "toregge"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6268ea791bc989679227facbf528cc98f096ff4"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyODQzMQ==", "bodyText": "added more warnings to the comment", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522828431", "createdAt": "2020-11-13T09:27:55Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgxNDg1Mg=="}, "originalCommit": {"oid": "b6268ea791bc989679227facbf528cc98f096ff4"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzcwMjA3OnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOToxNToyM1rOHymfgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTo0MzoyN1rOHynbcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMTUwNw==", "bodyText": "Could consider using std::atomic_flag here. It has a simpler interface than std::atomic but is the only atomic type guaranteed to be lock free (that means the static_assert below could be removed). The inner relaxed load loop seems to require a C++20 addition for it, so hopefully we have it..!", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522821507", "createdAt": "2020-11-13T09:15:23Z", "author": {"login": "vekterli"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzNDEyNw==", "bodyText": "I switched from atomic_flag to atomic_bool because I want to be able to read the variable without writing it to avoid totally messing up the cache. I do not think gcc is C++20 ready just yet, at least I do not think we have enabled it. It is highly unlikely that we want to run Vespa on a system that does not support atomic bool anyway.", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522834127", "createdAt": "2020-11-13T09:38:29Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMTUwNw=="}, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzNjg0OQ==", "bodyText": "Yeah, strangely being able to do test(std::memory_order_relaxed) is very recent. Reading variables is cutting edge technology", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522836849", "createdAt": "2020-11-13T09:43:27Z", "author": {"login": "vekterli"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMTUwNw=="}, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzcxNDgxOnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOToxOToxNlrOHymnbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTo0NToxM1rOHynfjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMzUzNA==", "bodyText": "_mm_pause may be more portable, but I believe it requires xmmintrin.h so if used maybe it should be wrapped away in its own translation unit to avoid header pollution.", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522823534", "createdAt": "2020-11-13T09:19:16Z", "author": {"login": "vekterli"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {\n+            while (_lock.load(std::memory_order_relaxed)) {\n+                __builtin_ia32_pause();                ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzNzkwMw==", "bodyText": "I could not figure out the subtle differences between _mm_pause and __builtin_ia32_pause across compilers, but concluded that if __builtin_ia32_pause is supported, it generates the appropriate code. I will let @toregge sink into this when he tries to compile Vespa on other platforms.", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522837903", "createdAt": "2020-11-13T09:45:13Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {\n+            while (_lock.load(std::memory_order_relaxed)) {\n+                __builtin_ia32_pause();                ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMzUzNA=="}, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NzcyMDg5OnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOToyMDo1MVrOHymrAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDoxMDoyOFrOHyoW3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyNDQ0OQ==", "bodyText": "Are we on a new and cool\u2122 enough version of GCC to be able to use the C++20 [[likely]] attribute?", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522824449", "createdAt": "2020-11-13T09:20:51Z", "author": {"login": "vekterli"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzODc0MA==", "bodyText": "I am not sure, I thought C++20 was off the table for now, but I might be wrong... @baldersheim ?", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522838740", "createdAt": "2020-11-13T09:46:45Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyNDQ0OQ=="}, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0Mjg1OQ==", "bodyText": "We are on 9 still, but could try to enable c++20 if it has support for it.", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522842859", "createdAt": "2020-11-13T09:53:55Z", "author": {"login": "baldersheim"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyNDQ0OQ=="}, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MjA2Mw==", "bodyText": "I could not find it on the list: (maybe it has some cool name)\nhttps://gcc.gnu.org/projects/cxx-status.html\nBut it does seem some C++20 features are available in gcc 9 (although experimental). We might want to wait until it is called 20 and not 2a...", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522852063", "createdAt": "2020-11-13T10:10:28Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyNDQ0OQ=="}, "originalCommit": {"oid": "5cbb0f6ff268ac75d2d3924e5f29ad8825018a2d"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3Nzc3ODY0OnYy", "diffSide": "RIGHT", "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTozNzoxM1rOHynOMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwOTo1MjowMVrOHynurg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzMzQ1OQ==", "bodyText": "Have you compared this to using yield ?", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522833459", "createdAt": "2020-11-13T09:37:13Z", "author": {"login": "baldersheim"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,42 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * Note that multiple threads trying to obtain the lock at the same\n+ * time will reduce performance due to atomic writes against the same\n+ * cache line.\n+ *\n+ * Note that being preempted while holding the lock will reduce\n+ * performance, even more if the thread holding the lock is lower\n+ * priority than the threads trying to obtain the lock. With a\n+ * deterministic scheduler this could even lead to deadlock.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {\n+            while (_lock.load(std::memory_order_relaxed)) {\n+                __builtin_ia32_pause();                ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0MTc3NA==", "bodyText": "turns out yield is much better than pause in all tested cases, I will switch. This also fixes portability; double win", "url": "https://github.com/vespa-engine/vespa/pull/15325#discussion_r522841774", "createdAt": "2020-11-13T09:52:01Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/util/spin_lock.h", "diffHunk": "@@ -0,0 +1,42 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <atomic>\n+\n+namespace vespalib {\n+\n+/**\n+ * A spin-lock implementation that favors uncontended performance.\n+ * Some measures are taken to reduce the impact of threads waiting to\n+ * get the lock since this will not affect the fast-path of obtaining\n+ * the lock immediately.\n+ *\n+ * Note that multiple threads trying to obtain the lock at the same\n+ * time will reduce performance due to atomic writes against the same\n+ * cache line.\n+ *\n+ * Note that being preempted while holding the lock will reduce\n+ * performance, even more if the thread holding the lock is lower\n+ * priority than the threads trying to obtain the lock. With a\n+ * deterministic scheduler this could even lead to deadlock.\n+ *\n+ * This implementation satisfies the BasicLockable requirements,\n+ * making it work with things like std::lock_guard.\n+ **/\n+class SpinLock {\n+private:\n+    std::atomic<bool> _lock;\n+public:\n+    SpinLock() noexcept : _lock(false) {\n+        static_assert(std::atomic<bool>::is_always_lock_free);\n+    }\n+    void lock() noexcept {\n+        while (__builtin_expect(_lock.exchange(true, std::memory_order_acquire), false)) {\n+            while (_lock.load(std::memory_order_relaxed)) {\n+                __builtin_ia32_pause();                ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzMzQ1OQ=="}, "originalCommit": {"oid": "7201a4f8b2e54686f6898998fc5b9c9962f3f20e"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 852, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}