{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTI2MDY4", "number": 13490, "title": "When we pull in a cacheline, we should use it too.", "bodyText": "There is possibly wasting 7/8 of it and very likely suffer a cache miss.\n@havardpe PR", "createdAt": "2020-06-04T22:38:25Z", "url": "https://github.com/vespa-engine/vespa/pull/13490", "merged": true, "mergeCommit": {"oid": "bda9b2e28e416daaefffa181d4dc8fe8566e8ca0"}, "closed": true, "closedAt": "2020-06-07T21:30:15Z", "author": {"login": "baldersheim"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoF456AH2gAyNDI4MTI2MDY4OjhlZjA4ZjBjODBhNDA5ZWNmZWJkMTc5ZDJhNzEzODJlZTliOWQ4MTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpCkuXAH2gAyNDI4MTI2MDY4OjhiODViNjIyMjQ4MDBlZjc0MGVhODBjMjIzZTVlN2MyYmFhZGFkYWU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8ef08f0c80a409ecfebd179d2a71382ee9b9d814", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/8ef08f0c80a409ecfebd179d2a71382ee9b9d814", "committedDate": "2020-06-04T22:34:44Z", "message": "When we pull in a cacheline, we should use it too.\nThere is possibly wasting 7/8 of it and very likely suffer a cache miss."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/3fded8534edd1ad2a9ae3e5e6575eabf209c76e6", "committedDate": "2020-06-05T08:21:49Z", "message": "Use c++11 for loop."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTc1MjU0", "url": "https://github.com/vespa-engine/vespa/pull/13490#pullrequestreview-425175254", "createdAt": "2020-06-05T10:17:38Z", "commit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoxNzozOFrOGfo1wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDo1MzowNFrOGfp1JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODE2Mg==", "bodyText": "should also test with inverted vectors", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828162", "createdAt": "2020-06-05T10:17:38Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODIzNA==", "bodyText": "should also test with inverted vectors", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828234", "createdAt": "2020-06-05T10:17:47Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");\n+                LOG_ABORT(\"should not be reached\");\n+            }\n+        }\n+    }\n+}\n+\n+void\n+verifyAnd64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleAndWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQyOA==", "bodyText": "misleading error message", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828428", "createdAt": "2020-06-05T10:18:09Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");\n+                LOG_ABORT(\"should not be reached\");\n+            }\n+        }\n+    }\n+}\n+\n+void\n+verifyAnd64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleAndWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.and64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQ3Mw==", "bodyText": "even more misleading error message", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435828473", "createdAt": "2020-06-05T10:18:15Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.cpp", "diffHunk": "@@ -101,6 +104,82 @@ void verifyPopulationCount(const IAccelrated & accel)\n     }\n }\n \n+void\n+fill(std::vector<uint64_t> & v, size_t n) {\n+    v.reserve(n);\n+    for (size_t i(0); i < n; i++) {\n+        v.emplace_back(random());\n+    }\n+}\n+\n+void\n+simpleAndWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] &= src[i];\n+    }\n+}\n+\n+void\n+simpleOrWith(std::vector<uint64_t> & dest, const std::vector<uint64_t> & src) {\n+    for (size_t i(0); i < dest.size(); i++) {\n+        dest[i] |= src[i];\n+    }\n+}\n+\n+void\n+verifyOr64(const IAccelrated & accel) {\n+    std::vector<uint64_t> vectors[3] ;\n+    for (auto & v : vectors) {\n+        fill(v, 16);\n+    }\n+    for (size_t offset = 0; offset < 8; offset++) {\n+        for (size_t i = 1; i < VESPA_NELEMS(vectors); i++) {\n+            std::vector<uint64_t> expected = vectors[0];\n+            for (size_t j = 1; j < i; j++) {\n+                simpleOrWith(expected, vectors[j]);\n+            }\n+            std::vector<std::pair<const uint64_t *, bool>> vRefs;\n+            for (size_t j(0); j < i; j++) {\n+                vRefs.emplace_back(&vectors[j][0], false);\n+            }\n+            uint64_t dest[8] __attribute((aligned(64)));\n+            accel.or64(offset, vRefs, dest);\n+            int diff = memcmp(&expected[offset], dest, sizeof(dest));\n+            if (diff != 0) {\n+                fprintf(stderr, \"Accelrator is not failing and64\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MDI0Mw==", "bodyText": "should add a static assert somewhere that this value is 64 bytes", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435840243", "createdAt": "2020-06-05T10:43:19Z", "author": {"login": "havardpe"}, "path": "searchlib/src/vespa/searchlib/queryeval/multibitvectoriterator.cpp", "diffHunk": "@@ -1,61 +1,90 @@\n // Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n \n-#include <vespa/searchlib/queryeval/multibitvectoriterator.h>\n-#include <vespa/searchlib/queryeval/andsearch.h>\n-#include <vespa/searchlib/queryeval/andnotsearch.h>\n-#include <vespa/searchlib/queryeval/sourceblendersearch.h>\n-#include <vespa/searchlib/queryeval/orsearch.h>\n+#include \"multibitvectoriterator.h\"\n+#include \"andsearch.h\"\n+#include \"andnotsearch.h\"\n+#include \"sourceblendersearch.h\"\n #include <vespa/searchlib/common/bitvectoriterator.h>\n-#include <vespa/searchlib/attribute/attributeiterators.h>\n #include <vespa/searchlib/fef/termfieldmatchdata.h>\n #include <vespa/searchlib/fef/termfieldmatchdataarray.h>\n #include <vespa/vespalib/util/optimized.h>\n+#include <vespa/vespalib/hwaccelrated/iaccelrated.h>\n \n namespace search::queryeval {\n \n using vespalib::Trinary;\n+using vespalib::hwaccelrated::IAccelrated;\n \n namespace {\n \n template<typename Update>\n class MultiBitVectorIterator : public MultiBitVectorIteratorBase\n {\n public:\n-    MultiBitVectorIterator(const Children & children) : MultiBitVectorIteratorBase(children) { }\n+    explicit MultiBitVectorIterator(const Children & children)\n+        : MultiBitVectorIteratorBase(children),\n+          _update(),\n+          _lastWords(),\n+          _accel(IAccelrated::getAccelrator())\n+    {\n+        memset(&_lastWords, 0, sizeof(_lastWords));\n+    }\n protected:\n     void updateLastValue(uint32_t docId);\n     void strictSeek(uint32_t docId);\n private:\n     void doSeek(uint32_t docId) override;\n     Trinary is_strict() const override { return Trinary::False; }\n     bool acceptExtraFilter() const override { return Update::isAnd(); }\n-    Update                  _update;\n+    Update              _update;\n+    Word                _lastWords[8] __attribute__((aligned(32)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NDM4OA==", "bodyText": "these functions are a bit confusing. The length of the operation is specified in bytes while the offset is specified in multiples of uint64_t. It also binds the Word abstraction to be uint64_t, making that abstraction less useful. Also; at glace, the 64 in the function name seems to reflect the fact that we are using 64-bit values, leaving the size of the operation a mystery...\nconsider using byte offset and passing the memory as void*", "url": "https://github.com/vespa-engine/vespa/pull/13490#discussion_r435844388", "createdAt": "2020-06-05T10:53:04Z", "author": {"login": "havardpe"}, "path": "vespalib/src/vespa/vespalib/hwaccelrated/iaccelrated.h", "diffHunk": "@@ -29,6 +30,9 @@ class IAccelrated\n     virtual size_t populationCount(const uint64_t *a, size_t sz) const = 0;\n     virtual double squaredEuclideanDistance(const float * a, const float * b, size_t sz) const = 0;\n     virtual double squaredEuclideanDistance(const double * a, const double * b, size_t sz) const = 0;\n+    // And 64 bytes from multiple sources\n+    virtual void and64(size_t offset, const std::vector<std::pair<const uint64_t *, bool>> &src, uint64_t *dest) const = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fded8534edd1ad2a9ae3e5e6575eabf209c76e6"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c2c60de38041e579cfaae4a8987248fbfc3d16c", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/8c2c60de38041e579cfaae4a8987248fbfc3d16c", "committedDate": "2020-06-07T13:19:18Z", "message": "- Test both normal and inverted bit vectors.\n- Use 64 byte alignment of buffer.\n- Improve error messages."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "633d97a8c892bbff4cb1c8bb58c5797435dd2ee0", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/633d97a8c892bbff4cb1c8bb58c5797435dd2ee0", "committedDate": "2020-06-07T13:50:17Z", "message": "- Stick to void * and byte offsets.\n- Correct spelling error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b85b62224800ef740ea80c223e5e7c2baadadae", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/8b85b62224800ef740ea80c223e5e7c2baadadae", "committedDate": "2020-06-07T21:16:54Z", "message": "Merge branch 'master' into balder/fetch-and-merge-a-cacheline"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3690, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}