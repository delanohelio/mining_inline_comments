{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNzQ4NjMy", "number": 15047, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMzozNjoxOVrOEyWuVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwOTowMDo0M1rOEyth4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjM2NTY3OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/instruction/generic_create/generic_create_test.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMzozNjoxOVrOHo8hAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNToxMjo1OFrOHpBfPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5NjU3Nw==", "bodyText": "consider testing with float mixed tensor as well", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512696577", "createdAt": "2020-10-27T13:36:19Z", "author": {"login": "havardpe"}, "path": "eval/src/tests/instruction/generic_create/generic_create_test.cpp", "diffHunk": "@@ -0,0 +1,97 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/fast_value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/instruction/generic_create.h>\n+#include <vespa/eval/eval/interpreted_function.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <stdlib.h>\n+#include <algorithm>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::instruction;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> create_layouts = {\n+    {x(3)},\n+    {x(3),y(2)},\n+    float_cells({x(3)}),\n+    {x({\"a\",\"b\",\"c\"})},\n+    {x({\"a\",\"b\",\"c\"}),y({\"foo\",\"bar\"})},\n+    float_cells({x({\"a\",\"b\",\"c\"})}),\n+    {x(3),y({\"foo\", \"bar\"})}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc42f4b6b5fcc331e077c921c639643d3fbaa07"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3ODA0NQ==", "bodyText": "fixes", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512778045", "createdAt": "2020-10-27T15:12:58Z", "author": {"login": "arnej27959"}, "path": "eval/src/tests/instruction/generic_create/generic_create_test.cpp", "diffHunk": "@@ -0,0 +1,97 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/fast_value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/instruction/generic_create.h>\n+#include <vespa/eval/eval/interpreted_function.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <stdlib.h>\n+#include <algorithm>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::instruction;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> create_layouts = {\n+    {x(3)},\n+    {x(3),y(2)},\n+    float_cells({x(3)}),\n+    {x({\"a\",\"b\",\"c\"})},\n+    {x({\"a\",\"b\",\"c\"}),y({\"foo\",\"bar\"})},\n+    float_cells({x({\"a\",\"b\",\"c\"})}),\n+    {x(3),y({\"foo\", \"bar\"})}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY5NjU3Nw=="}, "originalCommit": {"oid": "edc42f4b6b5fcc331e077c921c639643d3fbaa07"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjQwMjk2OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMzo0NDowM1rOHo84sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNToxMzowN1rOHpBfuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcwMjY0MA==", "bodyText": "consider having result type as first parameter", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512702640", "createdAt": "2020-10-27T13:44:03Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"generic_create.h\"\n+#include <vespa/eval/eval/wrap_param.h>\n+#include <vespa/vespalib/util/stash.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <cassert>\n+\n+using namespace vespalib::eval::tensor_function;\n+\n+namespace vespalib::eval::instruction {\n+\n+using State = InterpretedFunction::State;\n+using Instruction = InterpretedFunction::Instruction;\n+\n+namespace {\n+\n+struct CreateParam {\n+    using Key = std::vector<vespalib::string>;\n+    using Indexes = std::vector<size_t>;\n+\n+    const ValueType res_type;\n+    size_t num_mapped_dims;\n+    size_t dense_subspace_size;\n+    size_t num_children;\n+    std::map<Key,Indexes> my_spec;\n+    const ValueBuilderFactory &factory;\n+\n+    static constexpr size_t npos = -1;\n+\n+    Indexes &indexes(Key key) {\n+        auto iter = my_spec.find(key);\n+        if (iter == my_spec.end()) {\n+            Indexes empty(dense_subspace_size, npos);\n+            iter = my_spec.emplace(key, empty).first;\n+        }\n+        return iter->second;\n+    }\n+\n+    CreateParam(const GenericCreate::SpecMap &spec_in,\n+                const ValueType &res_type_in,\n+                const ValueBuilderFactory &factory_in)\n+        : res_type(res_type_in),\n+          num_mapped_dims(res_type.count_mapped_dimensions()),\n+          dense_subspace_size(res_type.dense_subspace_size()),\n+          num_children(spec_in.size()),\n+          my_spec(),\n+          factory(factory_in)\n+    {\n+        size_t last_child = num_children - 1;\n+        for (const auto & kv : spec_in) {\n+            Key sparse_addr;\n+            size_t dense_idx = 0;\n+            for (const auto &dim : res_type.dimensions()) {\n+                auto iter = kv.first.find(dim.name);\n+                if (dim.is_mapped()) {\n+                    sparse_addr.push_back(iter->second.name);\n+                } else {\n+                    assert(dim.is_indexed());\n+                    dense_idx *= dim.size;\n+                    dense_idx += iter->second.index;\n+                }\n+            }\n+            // note: reverse order of children on stack\n+            size_t stack_idx = last_child - kv.second;\n+            indexes(sparse_addr)[dense_idx] = stack_idx;\n+        }\n+    }\n+};\n+\n+template <typename T>\n+void my_generic_create_op(State &state, uint64_t param_in) {\n+    const auto &param = unwrap_param<CreateParam>(param_in);\n+    auto builder = param.factory.create_value_builder<T>(param.res_type,\n+                                                           param.num_mapped_dims,\n+                                                           param.dense_subspace_size,\n+                                                           param.my_spec.size());\n+    std::vector<vespalib::stringref> sparse_addr;\n+    for (const auto & kv : param.my_spec) {\n+        sparse_addr.clear();\n+        for (const auto & label : kv.first) {\n+            sparse_addr.emplace_back(label);\n+        }\n+        T *dst = builder->add_subspace(sparse_addr).begin();\n+        for (size_t stack_idx : kv.second) {\n+            if (stack_idx == CreateParam::npos) {\n+                *dst++ = T{};\n+            } else {\n+                const Value &child = state.peek(stack_idx);\n+                *dst++ = child.as_double();\n+            }\n+        }\n+    }        \n+    const Value &result = *state.stash.create<Value::UP>(builder->build(std::move(builder)));\n+    state.pop_n_push(param.num_children, result);\n+};\n+\n+struct SelectGenericCreateOp {\n+    template <typename T> static auto invoke() {\n+        return my_generic_create_op<T>;\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+} // namespace <unnamed>\n+\n+Instruction\n+GenericCreate::make_instruction(const SpecMap &spec,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc42f4b6b5fcc331e077c921c639643d3fbaa07"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3ODE2OA==", "bodyText": "fixed", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512778168", "createdAt": "2020-10-27T15:13:07Z", "author": {"login": "arnej27959"}, "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"generic_create.h\"\n+#include <vespa/eval/eval/wrap_param.h>\n+#include <vespa/vespalib/util/stash.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <cassert>\n+\n+using namespace vespalib::eval::tensor_function;\n+\n+namespace vespalib::eval::instruction {\n+\n+using State = InterpretedFunction::State;\n+using Instruction = InterpretedFunction::Instruction;\n+\n+namespace {\n+\n+struct CreateParam {\n+    using Key = std::vector<vespalib::string>;\n+    using Indexes = std::vector<size_t>;\n+\n+    const ValueType res_type;\n+    size_t num_mapped_dims;\n+    size_t dense_subspace_size;\n+    size_t num_children;\n+    std::map<Key,Indexes> my_spec;\n+    const ValueBuilderFactory &factory;\n+\n+    static constexpr size_t npos = -1;\n+\n+    Indexes &indexes(Key key) {\n+        auto iter = my_spec.find(key);\n+        if (iter == my_spec.end()) {\n+            Indexes empty(dense_subspace_size, npos);\n+            iter = my_spec.emplace(key, empty).first;\n+        }\n+        return iter->second;\n+    }\n+\n+    CreateParam(const GenericCreate::SpecMap &spec_in,\n+                const ValueType &res_type_in,\n+                const ValueBuilderFactory &factory_in)\n+        : res_type(res_type_in),\n+          num_mapped_dims(res_type.count_mapped_dimensions()),\n+          dense_subspace_size(res_type.dense_subspace_size()),\n+          num_children(spec_in.size()),\n+          my_spec(),\n+          factory(factory_in)\n+    {\n+        size_t last_child = num_children - 1;\n+        for (const auto & kv : spec_in) {\n+            Key sparse_addr;\n+            size_t dense_idx = 0;\n+            for (const auto &dim : res_type.dimensions()) {\n+                auto iter = kv.first.find(dim.name);\n+                if (dim.is_mapped()) {\n+                    sparse_addr.push_back(iter->second.name);\n+                } else {\n+                    assert(dim.is_indexed());\n+                    dense_idx *= dim.size;\n+                    dense_idx += iter->second.index;\n+                }\n+            }\n+            // note: reverse order of children on stack\n+            size_t stack_idx = last_child - kv.second;\n+            indexes(sparse_addr)[dense_idx] = stack_idx;\n+        }\n+    }\n+};\n+\n+template <typename T>\n+void my_generic_create_op(State &state, uint64_t param_in) {\n+    const auto &param = unwrap_param<CreateParam>(param_in);\n+    auto builder = param.factory.create_value_builder<T>(param.res_type,\n+                                                           param.num_mapped_dims,\n+                                                           param.dense_subspace_size,\n+                                                           param.my_spec.size());\n+    std::vector<vespalib::stringref> sparse_addr;\n+    for (const auto & kv : param.my_spec) {\n+        sparse_addr.clear();\n+        for (const auto & label : kv.first) {\n+            sparse_addr.emplace_back(label);\n+        }\n+        T *dst = builder->add_subspace(sparse_addr).begin();\n+        for (size_t stack_idx : kv.second) {\n+            if (stack_idx == CreateParam::npos) {\n+                *dst++ = T{};\n+            } else {\n+                const Value &child = state.peek(stack_idx);\n+                *dst++ = child.as_double();\n+            }\n+        }\n+    }        \n+    const Value &result = *state.stash.create<Value::UP>(builder->build(std::move(builder)));\n+    state.pop_n_push(param.num_children, result);\n+};\n+\n+struct SelectGenericCreateOp {\n+    template <typename T> static auto invoke() {\n+        return my_generic_create_op<T>;\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+} // namespace <unnamed>\n+\n+Instruction\n+GenericCreate::make_instruction(const SpecMap &spec,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcwMjY0MA=="}, "originalCommit": {"oid": "edc42f4b6b5fcc331e077c921c639643d3fbaa07"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjQzMDIwOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMzo0OToyNlrOHo9JjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNToxMzoxNVrOHpBgLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcwNjk1Ng==", "bodyText": "consider using array_array_map", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512706956", "createdAt": "2020-10-27T13:49:26Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"generic_create.h\"\n+#include <vespa/eval/eval/wrap_param.h>\n+#include <vespa/vespalib/util/stash.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <cassert>\n+\n+using namespace vespalib::eval::tensor_function;\n+\n+namespace vespalib::eval::instruction {\n+\n+using State = InterpretedFunction::State;\n+using Instruction = InterpretedFunction::Instruction;\n+\n+namespace {\n+\n+struct CreateParam {\n+    using Key = std::vector<vespalib::string>;\n+    using Indexes = std::vector<size_t>;\n+\n+    const ValueType res_type;\n+    size_t num_mapped_dims;\n+    size_t dense_subspace_size;\n+    size_t num_children;\n+    std::map<Key,Indexes> my_spec;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc42f4b6b5fcc331e077c921c639643d3fbaa07"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3ODI4NA==", "bodyText": "done", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512778284", "createdAt": "2020-10-27T15:13:15Z", "author": {"login": "arnej27959"}, "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"generic_create.h\"\n+#include <vespa/eval/eval/wrap_param.h>\n+#include <vespa/vespalib/util/stash.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <cassert>\n+\n+using namespace vespalib::eval::tensor_function;\n+\n+namespace vespalib::eval::instruction {\n+\n+using State = InterpretedFunction::State;\n+using Instruction = InterpretedFunction::Instruction;\n+\n+namespace {\n+\n+struct CreateParam {\n+    using Key = std::vector<vespalib::string>;\n+    using Indexes = std::vector<size_t>;\n+\n+    const ValueType res_type;\n+    size_t num_mapped_dims;\n+    size_t dense_subspace_size;\n+    size_t num_children;\n+    std::map<Key,Indexes> my_spec;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcwNjk1Ng=="}, "originalCommit": {"oid": "edc42f4b6b5fcc331e077c921c639643d3fbaa07"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMjY1MDQ2OnYy", "diffSide": "RIGHT", "path": "eval/src/tests/instruction/generic_create/generic_create_test.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNDozMTowMVrOHo_TQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxNToxMzoyNFrOHpBgwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0MjIxMA==", "bodyText": "consider using simple value to fill (since this is the 'reference')", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512742210", "createdAt": "2020-10-27T14:31:01Z", "author": {"login": "havardpe"}, "path": "eval/src/tests/instruction/generic_create/generic_create_test.cpp", "diffHunk": "@@ -0,0 +1,97 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/fast_value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/instruction/generic_create.h>\n+#include <vespa/eval/eval/interpreted_function.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <stdlib.h>\n+#include <algorithm>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::instruction;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> create_layouts = {\n+    {x(3)},\n+    {x(3),y(2)},\n+    float_cells({x(3)}),\n+    {x({\"a\",\"b\",\"c\"})},\n+    {x({\"a\",\"b\",\"c\"}),y({\"foo\",\"bar\"})},\n+    float_cells({x({\"a\",\"b\",\"c\"})}),\n+    {x(3),y({\"foo\", \"bar\"})}\n+};\n+\n+TensorSpec remove_each(const TensorSpec &a, size_t n) {\n+    TensorSpec b(a.type());\n+    for (const auto & kv : a.cells()) {\n+        size_t v = kv.second;\n+        if ((v % n) != 0) {\n+            b.add(kv.first, kv.second);\n+        }\n+    }\n+    return b;\n+}\n+\n+struct NumberedCellSpec {\n+    long int num;\n+    TensorSpec::Address addr;\n+    double value;\n+};\n+\n+bool operator< (const NumberedCellSpec &a, const NumberedCellSpec &b) {\n+    return a.num < b.num;\n+}\n+\n+TensorSpec perform_generic_create(const TensorSpec &a, const ValueBuilderFactory &factory)\n+{\n+    ValueType res_type = ValueType::from_spec(a.type());\n+    EXPECT_FALSE(res_type.is_error());\n+    Stash stash;\n+    std::vector<NumberedCellSpec> scramble;\n+    for (const auto & kv : a.cells()) {\n+        NumberedCellSpec cell{random(), kv.first, kv.second};\n+        scramble.push_back(cell);\n+    }\n+    std::sort(scramble.begin(), scramble.end());\n+    std::vector<Value::CREF> my_stack;\n+    std::map<TensorSpec::Address,size_t> create_spec;\n+    for (size_t child_idx = 0; child_idx < scramble.size(); ++child_idx) {\n+        auto cell = scramble[child_idx];\n+        create_spec.emplace(cell.addr, child_idx);\n+        my_stack.push_back(stash.create<DoubleValue>(cell.value));\n+    }\n+    auto my_op = GenericCreate::make_instruction(create_spec, res_type, factory, stash);\n+    InterpretedFunction::EvalSingle single(factory, my_op);\n+    return spec_from_value(single.eval(my_stack));\n+}\n+\n+void test_generic_create_with(const ValueBuilderFactory &factory) {\n+    for (const auto & layout : create_layouts) {\n+        TensorSpec full = spec(layout, N());\n+        auto actual = perform_generic_create(full, factory);\n+        EXPECT_EQ(actual, full);\n+        for (size_t n : {2, 3, 4, 5}) {\n+            TensorSpec partial = remove_each(full, n);\n+            actual = perform_generic_create(partial, factory);\n+            auto filled = spec_from_value(*value_from_spec(partial, factory));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edc42f4b6b5fcc331e077c921c639643d3fbaa07"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3ODQzMw==", "bodyText": "fixed", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r512778433", "createdAt": "2020-10-27T15:13:24Z", "author": {"login": "arnej27959"}, "path": "eval/src/tests/instruction/generic_create/generic_create_test.cpp", "diffHunk": "@@ -0,0 +1,97 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/fast_value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/instruction/generic_create.h>\n+#include <vespa/eval/eval/interpreted_function.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <stdlib.h>\n+#include <algorithm>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::instruction;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> create_layouts = {\n+    {x(3)},\n+    {x(3),y(2)},\n+    float_cells({x(3)}),\n+    {x({\"a\",\"b\",\"c\"})},\n+    {x({\"a\",\"b\",\"c\"}),y({\"foo\",\"bar\"})},\n+    float_cells({x({\"a\",\"b\",\"c\"})}),\n+    {x(3),y({\"foo\", \"bar\"})}\n+};\n+\n+TensorSpec remove_each(const TensorSpec &a, size_t n) {\n+    TensorSpec b(a.type());\n+    for (const auto & kv : a.cells()) {\n+        size_t v = kv.second;\n+        if ((v % n) != 0) {\n+            b.add(kv.first, kv.second);\n+        }\n+    }\n+    return b;\n+}\n+\n+struct NumberedCellSpec {\n+    long int num;\n+    TensorSpec::Address addr;\n+    double value;\n+};\n+\n+bool operator< (const NumberedCellSpec &a, const NumberedCellSpec &b) {\n+    return a.num < b.num;\n+}\n+\n+TensorSpec perform_generic_create(const TensorSpec &a, const ValueBuilderFactory &factory)\n+{\n+    ValueType res_type = ValueType::from_spec(a.type());\n+    EXPECT_FALSE(res_type.is_error());\n+    Stash stash;\n+    std::vector<NumberedCellSpec> scramble;\n+    for (const auto & kv : a.cells()) {\n+        NumberedCellSpec cell{random(), kv.first, kv.second};\n+        scramble.push_back(cell);\n+    }\n+    std::sort(scramble.begin(), scramble.end());\n+    std::vector<Value::CREF> my_stack;\n+    std::map<TensorSpec::Address,size_t> create_spec;\n+    for (size_t child_idx = 0; child_idx < scramble.size(); ++child_idx) {\n+        auto cell = scramble[child_idx];\n+        create_spec.emplace(cell.addr, child_idx);\n+        my_stack.push_back(stash.create<DoubleValue>(cell.value));\n+    }\n+    auto my_op = GenericCreate::make_instruction(create_spec, res_type, factory, stash);\n+    InterpretedFunction::EvalSingle single(factory, my_op);\n+    return spec_from_value(single.eval(my_stack));\n+}\n+\n+void test_generic_create_with(const ValueBuilderFactory &factory) {\n+    for (const auto & layout : create_layouts) {\n+        TensorSpec full = spec(layout, N());\n+        auto actual = perform_generic_create(full, factory);\n+        EXPECT_EQ(actual, full);\n+        for (size_t n : {2, 3, 4, 5}) {\n+            TensorSpec partial = remove_each(full, n);\n+            actual = perform_generic_create(partial, factory);\n+            auto filled = spec_from_value(*value_from_spec(partial, factory));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0MjIxMA=="}, "originalCommit": {"oid": "edc42f4b6b5fcc331e077c921c639643d3fbaa07"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjEwMjExOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwOTowMDo0M1rOHpf9kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwOTowMDo0M1rOHpf9kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3NzMyOA==", "bodyText": "I think this was problematic with some compilers since we need to use the implicit cast from string to stringref (there is no stringref constructor taking a string).\nprefer push_back here.", "url": "https://github.com/vespa-engine/vespa/pull/15047#discussion_r513277328", "createdAt": "2020-10-28T09:00:43Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/instruction/generic_create.cpp", "diffHunk": "@@ -81,21 +81,22 @@ void my_generic_create_op(State &state, uint64_t param_in) {\n                                                          param.dense_subspace_size,\n                                                          param.my_spec.size());\n     std::vector<vespalib::stringref> sparse_addr;\n-    for (const auto & kv : param.my_spec) {\n-        sparse_addr.clear();\n-        for (const auto & label : kv.first) {\n-            sparse_addr.emplace_back(label);\n-        }\n-        T *dst = builder->add_subspace(sparse_addr).begin();\n-        for (size_t stack_idx : kv.second) {\n-            if (stack_idx == CreateParam::npos) {\n-                *dst++ = T{};\n-            } else {\n-                const Value &child = state.peek(stack_idx);\n-                *dst++ = child.as_double();\n+    param.my_spec.each_entry([&](const auto &key, const auto &values)\n+        {\n+            sparse_addr.clear();\n+            for (const auto & label : key) {\n+                sparse_addr.emplace_back(label);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbd8cc9c5d336c42ac8a1443880d536f4b97a604"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1022, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}