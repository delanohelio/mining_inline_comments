{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNjg1MTkw", "number": 11817, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwODoyNzoxNVrODYvprQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwODozOTo1NlrODYv0dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjczMTMzOnYy", "diffSide": "RIGHT", "path": "eval/src/tests/ann/xp-hnswlike-nns.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwODoyNzoxNVrOFexwEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwODoyNzoxNVrOFexwEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgxNjcyMw==", "bodyText": "Please update copyright to current year.", "url": "https://github.com/vespa-engine/vespa/pull/11817#discussion_r367816723", "createdAt": "2020-01-17T08:27:15Z", "author": {"login": "geirst"}, "path": "eval/src/tests/ann/xp-hnswlike-nns.cpp", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ad26b78130087c78651977e593583807a0a582b"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3Mjc1ODkyOnYy", "diffSide": "RIGHT", "path": "eval/src/tests/ann/xp-hnswlike-nns.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwODozOTo1NlrOFeyBQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwODozOTo1NlrOFeyBQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgyMTEyMA==", "bodyText": "Perhaps this could be a constructor parameter?", "url": "https://github.com/vespa-engine/vespa/pull/11817#discussion_r367821120", "createdAt": "2020-01-17T08:39:56Z", "author": {"login": "geirst"}, "path": "eval/src/tests/ann/xp-hnswlike-nns.cpp", "diffHunk": "@@ -0,0 +1,394 @@\n+// Copyright 2019 Oath Inc. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <algorithm>\n+#include <assert.h>\n+#include <queue>\n+#include <random>\n+#include \"nns.h\"\n+\n+using LinkList = std::vector<uint32_t>;\n+\n+struct Node {\n+    std::vector<LinkList> _links;\n+    Node(uint32_t , uint32_t numLevels, uint32_t M)\n+        : _links(numLevels)\n+    {\n+        for (uint32_t i = 0; i < _links.size(); ++i) {\n+            _links[i].reserve((i == 0) ? (2 * M + 1) : (M+1));\n+        }\n+    }\n+};\n+\n+struct VisitedSet\n+{\n+    using Mark = unsigned short;\n+    Mark *ptr;\n+    Mark curval;\n+    size_t sz;\n+    VisitedSet(const VisitedSet &) = delete;\n+    VisitedSet& operator=(const VisitedSet &) = delete;\n+    explicit VisitedSet(size_t size) {\n+        ptr = (Mark *)malloc(size * sizeof(Mark));\n+        curval = -1;\n+        sz = size;\n+    }\n+    void clear() {\n+        ++curval;\n+        if (curval == 0) {\n+            memset(ptr, 0, sz * sizeof(Mark));\n+            ++curval;\n+        }\n+    }\n+    ~VisitedSet() { free(ptr); }\n+    void mark(size_t id) { ptr[id] = curval; }\n+    bool isMarked(size_t id) const { return ptr[id] == curval; }\n+};\n+\n+struct VisitedSetPool\n+{\n+    std::unique_ptr<VisitedSet> lastUsed;\n+    VisitedSetPool() {\n+        lastUsed = std::make_unique<VisitedSet>(250);\n+    }\n+    ~VisitedSetPool() {}\n+    VisitedSet &get(size_t size) {\n+        if (size > lastUsed->sz) {\n+            lastUsed = std::make_unique<VisitedSet>(size*2);\n+        }\n+        lastUsed->clear();\n+        return *lastUsed;\n+    }\n+};\n+\n+struct HnswHit {\n+    float dist;\n+    uint32_t docid;\n+    HnswHit(uint32_t di, SqDist sq) : dist(sq.distance), docid(di) {}\n+};\n+\n+\n+using QueueEntry = HnswHit;\n+struct GreaterDist {\n+    bool operator() (const QueueEntry &lhs, const QueueEntry& rhs) const {\n+        return (rhs.dist < lhs.dist);\n+    }\n+};\n+struct LesserDist {\n+    bool operator() (const QueueEntry &lhs, const QueueEntry& rhs) const {\n+        return (lhs.dist < rhs.dist);\n+    }\n+};\n+\n+using NearestList = std::vector<QueueEntry>;\n+\n+struct NearestPriQ : std::priority_queue<QueueEntry, NearestList, GreaterDist>\n+{\n+};\n+\n+struct FurthestPriQ : std::priority_queue<QueueEntry, NearestList, LesserDist>\n+{\n+   NearestList steal() {\n+       NearestList result;\n+       c.swap(result);\n+       return result;\n+   }\n+   const NearestList& peek() const { return c; }\n+};\n+\n+class HnswLikeNns : public NNS<float>\n+{\n+private:\n+    std::vector<Node> _nodes;\n+    uint32_t _entryId;\n+    int _entryLevel;\n+    uint32_t _M;\n+    uint32_t _efConstruction;\n+    double _levelMultiplier;\n+    std::default_random_engine _rndGen;\n+    VisitedSetPool _visitedSetPool;\n+\n+    double distance(Vector v, uint32_t id) const;\n+\n+    double distance(uint32_t a, uint32_t b) const {\n+        Vector v = _dva.get(a);\n+        return distance(v, b);\n+    }\n+\n+    int randomLevel() {\n+        std::uniform_real_distribution<double> distribution(0.0, 1.0);\n+        double r = -log(distribution(_rndGen)) * _levelMultiplier;\n+        return (int) r;\n+    }\n+\n+public:\n+    HnswLikeNns(uint32_t numDims, const DocVectorAccess<float> &dva)\n+        : NNS(numDims, dva),\n+          _nodes(),\n+          _entryId(0),\n+          _entryLevel(-1),\n+          _M(16),\n+          _efConstruction(150),\n+          _levelMultiplier(1.0 / log(1.0 * _M))\n+    {\n+        _nodes.reserve(1234567);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ad26b78130087c78651977e593583807a0a582b"}, "originalPosition": 133}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2664, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}