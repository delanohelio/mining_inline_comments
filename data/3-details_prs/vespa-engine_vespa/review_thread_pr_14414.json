{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3MjQwMTQx", "number": 14414, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMzowMDo1OFrOEjlLAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMzowMjozM1rOEjlN4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NzQ0NjQzOnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/simple_value.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMzowMDo1OFrOHSApRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMzowMDo1OFrOHSApRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY0Njk4Mg==", "bodyText": "Consider rename _num_mapped -> _num_mapped_dims to be more explicit on what it represents. This also applies for same variable name used in ValueBuilderFactory.", "url": "https://github.com/vespa-engine/vespa/pull/14414#discussion_r488646982", "createdAt": "2020-09-15T13:00:58Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/eval/simple_value.h", "diffHunk": "@@ -0,0 +1,215 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"value.h\"\n+#include \"value_type.h\"\n+#include <vespa/eval/tensor/dense/typed_cells.h>\n+#include <vespa/vespalib/stllike/string.h>\n+#include <vector>\n+#include <map>\n+\n+namespace vespalib { class Stash; }\n+\n+namespace vespalib::eval {\n+\n+class TensorSpec;\n+\n+using TypedCells = ::vespalib::tensor::TypedCells;\n+\n+/**\n+ * Experimental interface layer that will be moved into Value when all\n+ * existing implementations are able to implement it. This interface\n+ * will try to unify scalars, dense tensors, sparse tensors and mixed\n+ * tensors while also enabling operations to be implemented\n+ * efficiently using this interface without having knowledge about the\n+ * actual implementation. Baseline operations will treat all values as\n+ * mixed tensors. Simplified and optimized variants may replace them\n+ * as done today based on type knowledge.\n+ *\n+ * All values are expected to be separated into a continuous area\n+ * storing cells as concatenated dense subspaces, and an index\n+ * structure used to look up label combinations; mapping them into a\n+ * set of dense subspaces.\n+ **/\n+struct NewValue : Value {\n+\n+    // Root lookup structure for mapping labels to dense subspace indexes\n+    struct Index {\n+\n+        // A view able to look up dense subspace indexes from labels\n+        // specifying a partial address for the dimensions given to\n+        // create_view. A view is re-usable. Lookups are performed by\n+        // calling the lookup function and lookup results are\n+        // extracted using the next_result function.\n+        struct View {\n+\n+            // look up dense subspace indexes from labels specifying a\n+            // partial address for the dimensions given to\n+            // create_view. Results from the lookup is extracted using\n+            // the next_result function.\n+            virtual void lookup(const std::vector<const vespalib::stringref*> &addr) = 0;\n+\n+            // Extract the next result (if any) from the previous\n+            // lookup into the given partial address and index. Only\n+            // the labels for the dimensions NOT specified in\n+            // create_view will be extracted here.\n+            virtual bool next_result(const std::vector<vespalib::stringref*> &addr_out, size_t &idx_out) = 0;\n+\n+            virtual ~View() {}\n+        };\n+\n+        // total number of mappings (equal to the number of dense subspaces)\n+        virtual size_t size() const = 0;\n+\n+        // create a view able to look up dense subspaces based on\n+        // labels from a subset of the mapped dimensions.\n+        virtual std::unique_ptr<View> create_view(const std::vector<size_t> &dims) const = 0;\n+\n+        virtual ~Index() {}\n+    };\n+    virtual TypedCells cells() const = 0;\n+    virtual const Index &index() const = 0;\n+    virtual ~NewValue() {}\n+};\n+\n+/**\n+ * Tagging interface used as return type from factories before\n+ * downcasting to actual builder with specialized cell type.\n+ **/\n+struct ValueBuilderBase {\n+    virtual ~ValueBuilderBase() {}\n+};\n+\n+/**\n+ * Interface used to build a value one dense subspace at a\n+ * time. Enables decoupling of what the value should contain from how\n+ * to store the value.\n+ **/\n+template <typename T>\n+struct ValueBuilder : ValueBuilderBase {\n+    // add a dense subspace for the given address (label for all\n+    // mapped dimensions in canonical order). Note that previously\n+    // returned subspaces will be invalidated when new subspaces are\n+    // added. Also note that adding the same subspace multiple times\n+    // is not allowed.\n+    virtual ArrayRef<T> add_subspace(const std::vector<vespalib::stringref> &addr) = 0;\n+\n+    // Given the ownership of the builder itself, produce the newly\n+    // created value. This means that builders can only be used once,\n+    // it also means values can build themselves.\n+    virtual std::unique_ptr<NewValue> build(std::unique_ptr<ValueBuilder> self) = 0;\n+};\n+\n+/**\n+ * Factory able to create appropriate value builders. We do not really\n+ * care about the full mathematical type here, but it needs to be\n+ * passed since it is exposed in the value api. The expected number of\n+ * subspaces is also passed since it enables the builder to pre-size\n+ * internal structures appropriately. Note that since we are not able\n+ * to have virtual templated functions we need to cast the created\n+ * builder. With interoperability between all values.\n+ **/\n+struct ValueBuilderFactory {\n+    template <typename T>\n+    std::unique_ptr<ValueBuilder<T>> create_value_builder(const ValueType &type,\n+            size_t num_mapped_in, size_t subspace_size_in, size_t expect_subspaces) const\n+    {\n+        assert(check_cell_type<T>(type.cell_type()));\n+        auto base = create_value_builder_base(type, num_mapped_in, subspace_size_in, expect_subspaces);\n+        ValueBuilder<T> *builder = dynamic_cast<ValueBuilder<T>*>(base.get());\n+        assert(builder);\n+        base.release();\n+        return std::unique_ptr<ValueBuilder<T>>(builder);\n+    }\n+    template <typename T>\n+    std::unique_ptr<ValueBuilder<T>> create_value_builder(const ValueType &type) const\n+    {\n+        return create_value_builder<T>(type, type.count_mapped_dimensions(), type.dense_subspace_size(), 1);\n+    }\n+    virtual ~ValueBuilderFactory() {}\n+protected:\n+    virtual std::unique_ptr<ValueBuilderBase> create_value_builder_base(const ValueType &type,\n+            size_t num_mapped_in, size_t subspace_size_in, size_t expect_subspaces) const = 0;\n+};\n+\n+/**\n+ * A simple implementation of a generic value that can also be used to\n+ * build new values. This class focuses on simplicity over speed and\n+ * is intended as a reference implementation that can also be used to\n+ * test the correctness of tensor operations as they are moved away\n+ * from the implementation of individual tensor classes.\n+ **/\n+class SimpleValue : public NewValue, public NewValue::Index\n+{\n+private:\n+    using Addr = std::vector<vespalib::string>;\n+    ValueType _type;\n+    size_t _num_mapped;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5e7fb555fc75678ba9a802f01549635895630a4"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NzQ1Mzc3OnYy", "diffSide": "RIGHT", "path": "eval/src/vespa/eval/eval/simple_value.h", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMzowMjozM1rOHSAtuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMzowMjozM1rOHSAtuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY0ODEyMA==", "bodyText": "Consider rename expect_subspaces -> expected_subspaces, as the current name sounds like it should be a bool.", "url": "https://github.com/vespa-engine/vespa/pull/14414#discussion_r488648120", "createdAt": "2020-09-15T13:02:33Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/eval/simple_value.h", "diffHunk": "@@ -0,0 +1,215 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"value.h\"\n+#include \"value_type.h\"\n+#include <vespa/eval/tensor/dense/typed_cells.h>\n+#include <vespa/vespalib/stllike/string.h>\n+#include <vector>\n+#include <map>\n+\n+namespace vespalib { class Stash; }\n+\n+namespace vespalib::eval {\n+\n+class TensorSpec;\n+\n+using TypedCells = ::vespalib::tensor::TypedCells;\n+\n+/**\n+ * Experimental interface layer that will be moved into Value when all\n+ * existing implementations are able to implement it. This interface\n+ * will try to unify scalars, dense tensors, sparse tensors and mixed\n+ * tensors while also enabling operations to be implemented\n+ * efficiently using this interface without having knowledge about the\n+ * actual implementation. Baseline operations will treat all values as\n+ * mixed tensors. Simplified and optimized variants may replace them\n+ * as done today based on type knowledge.\n+ *\n+ * All values are expected to be separated into a continuous area\n+ * storing cells as concatenated dense subspaces, and an index\n+ * structure used to look up label combinations; mapping them into a\n+ * set of dense subspaces.\n+ **/\n+struct NewValue : Value {\n+\n+    // Root lookup structure for mapping labels to dense subspace indexes\n+    struct Index {\n+\n+        // A view able to look up dense subspace indexes from labels\n+        // specifying a partial address for the dimensions given to\n+        // create_view. A view is re-usable. Lookups are performed by\n+        // calling the lookup function and lookup results are\n+        // extracted using the next_result function.\n+        struct View {\n+\n+            // look up dense subspace indexes from labels specifying a\n+            // partial address for the dimensions given to\n+            // create_view. Results from the lookup is extracted using\n+            // the next_result function.\n+            virtual void lookup(const std::vector<const vespalib::stringref*> &addr) = 0;\n+\n+            // Extract the next result (if any) from the previous\n+            // lookup into the given partial address and index. Only\n+            // the labels for the dimensions NOT specified in\n+            // create_view will be extracted here.\n+            virtual bool next_result(const std::vector<vespalib::stringref*> &addr_out, size_t &idx_out) = 0;\n+\n+            virtual ~View() {}\n+        };\n+\n+        // total number of mappings (equal to the number of dense subspaces)\n+        virtual size_t size() const = 0;\n+\n+        // create a view able to look up dense subspaces based on\n+        // labels from a subset of the mapped dimensions.\n+        virtual std::unique_ptr<View> create_view(const std::vector<size_t> &dims) const = 0;\n+\n+        virtual ~Index() {}\n+    };\n+    virtual TypedCells cells() const = 0;\n+    virtual const Index &index() const = 0;\n+    virtual ~NewValue() {}\n+};\n+\n+/**\n+ * Tagging interface used as return type from factories before\n+ * downcasting to actual builder with specialized cell type.\n+ **/\n+struct ValueBuilderBase {\n+    virtual ~ValueBuilderBase() {}\n+};\n+\n+/**\n+ * Interface used to build a value one dense subspace at a\n+ * time. Enables decoupling of what the value should contain from how\n+ * to store the value.\n+ **/\n+template <typename T>\n+struct ValueBuilder : ValueBuilderBase {\n+    // add a dense subspace for the given address (label for all\n+    // mapped dimensions in canonical order). Note that previously\n+    // returned subspaces will be invalidated when new subspaces are\n+    // added. Also note that adding the same subspace multiple times\n+    // is not allowed.\n+    virtual ArrayRef<T> add_subspace(const std::vector<vespalib::stringref> &addr) = 0;\n+\n+    // Given the ownership of the builder itself, produce the newly\n+    // created value. This means that builders can only be used once,\n+    // it also means values can build themselves.\n+    virtual std::unique_ptr<NewValue> build(std::unique_ptr<ValueBuilder> self) = 0;\n+};\n+\n+/**\n+ * Factory able to create appropriate value builders. We do not really\n+ * care about the full mathematical type here, but it needs to be\n+ * passed since it is exposed in the value api. The expected number of\n+ * subspaces is also passed since it enables the builder to pre-size\n+ * internal structures appropriately. Note that since we are not able\n+ * to have virtual templated functions we need to cast the created\n+ * builder. With interoperability between all values.\n+ **/\n+struct ValueBuilderFactory {\n+    template <typename T>\n+    std::unique_ptr<ValueBuilder<T>> create_value_builder(const ValueType &type,\n+            size_t num_mapped_in, size_t subspace_size_in, size_t expect_subspaces) const", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5e7fb555fc75678ba9a802f01549635895630a4"}, "originalPosition": 116}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1346, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}