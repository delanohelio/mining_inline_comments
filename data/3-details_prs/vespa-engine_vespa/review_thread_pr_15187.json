{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1OTk3Njkw", "number": 15187, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDowNjoyNVrOE2BdlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMDowNjoyMFrOE2sMfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDgyNTE3OnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDowNjoyNVrOHunv2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDowNjoyNVrOHunv2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0Nzc2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n          \n          \n            \n             * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518647768", "createdAt": "2020-11-06T10:06:25Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad9ce9460a3d8a3743234960164a14dfa952151"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDgyODEyOnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDowNzoxNlrOHunxoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDowNzoxNlrOHunxoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0ODIyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.ready = new TreeMap<>(ready);\n          \n          \n            \n                    this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518648224", "createdAt": "2020-11-06T10:07:16Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad9ce9460a3d8a3743234960164a14dfa952151"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDgzNzc5OnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxMDoxMlrOHun3zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxMDoxMlrOHun3zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0OTgwNQ==", "bodyText": "This will intentionally happen for all the things the first time this all rolls out to existing deployments, so no reprocessing will start immediately.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518649805", "createdAt": "2020-11-06T10:10:12Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad9ce9460a3d8a3743234960164a14dfa952151"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDg0OTEzOnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxMzoyOFrOHun-pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxMzoyOFrOHun-pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MTU1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        case SUCCESSFUL: // Intentional fallthrough \u2014 both are done states.\n          \n          \n            \n                        case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518651558", "createdAt": "2020-11-06T10:13:28Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 both are done states.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad9ce9460a3d8a3743234960164a14dfa952151"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDg1OTI4OnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxNjoxOVrOHuoElg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxNjoxOVrOHuoElg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MzA3OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            log.log(FINE, () -> \"Aborting reindexing of \" + type + \" due to shutdown \u2014\u00a0will continue later\");\n          \n          \n            \n                            log.log(FINE, () -> \"Halting reindexing of \" + type + \" due to shutdown \u2014\u00a0will continue later\");", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518653078", "createdAt": "2020-11-06T10:16:19Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 both are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+            case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n+        }\n+\n+        // Visit buckets until they're all done, or until we are interrupted.\n+        status = status.running();\n+        VisitorControlHandler control = new VisitorControlHandler();\n+        visit(type, status.progress().orElse(null), control);\n+\n+        // Progress is null if no buckets were successfully visited due to interrupt.\n+        if (control.getProgress() != null)\n+            status = status.progressed(control.getProgress());\n+\n+        // If we were interrupted, the result may not yet be set in the control handler.\n+        CompletionCode code = control.getResult() != null ? control.getResult().getCode() : ABORTED;\n+        switch (code) {\n+            default:\n+                log.log(WARNING, \"Unexpected visitor result '\" + control.getResult().getCode() + \"'\");\n+            case FAILURE: // Intentional fallthrough \u2014\u00a0this is an error.\n+                log.log(WARNING, \"Visiting failed: \" + control.getResult().getMessage());\n+                return status.failed(clock.instant(), control.getResult().getMessage());\n+            case ABORTED:\n+                log.log(FINE, () -> \"Aborting reindexing of \" + type + \" due to shutdown \u2014\u00a0will continue later\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad9ce9460a3d8a3743234960164a14dfa952151"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MDg2ODE4OnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxOToxMVrOHuoKfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxOToxMVrOHuoKfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1NDU4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n          \n          \n            \n                        case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n          \n          \n            \n                        log.log(FINE, () -> \"Running reindexing of \" + type + \", which started at \" + status.startedAt());", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518654588", "createdAt": "2020-11-06T10:19:11Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until unterrupted, or util no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready);\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 both are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+            case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad9ce9460a3d8a3743234960164a14dfa952151"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTAxNTIwOnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDo1OTo1MlrOHupjzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMTowNDowM1rOHupuYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY3NzQ1NQ==", "bodyText": "I'd prefer if this were called bucketSpaceOf, as \"bucket space\" to \"bucket\" is a bit like \"table\" is to \"tablet\" in e.g. BigTable, i.e. on different levels of abstraction. Consider also renaming other variables to match.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518677455", "createdAt": "2020-11-06T10:59:52Z", "author": {"login": "vekterli"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+            case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n+            log.log(FINE, () -> \"Running reindexing of \" + type + \", which started at \" + status.startedAt());\n+        }\n+\n+        // Visit buckets until they're all done, or until we are interrupted.\n+        status = status.running();\n+        VisitorControlHandler control = new VisitorControlHandler();\n+        visit(type, status.progress().orElse(null), control);\n+\n+        // Progress is null if no buckets were successfully visited due to interrupt.\n+        if (control.getProgress() != null)\n+            status = status.progressed(control.getProgress());\n+\n+        // If we were interrupted, the result may not yet be set in the control handler.\n+        CompletionCode code = control.getResult() != null ? control.getResult().getCode() : ABORTED;\n+        switch (code) {\n+            default:\n+                log.log(WARNING, \"Unexpected visitor result '\" + control.getResult().getCode() + \"'\");\n+            case FAILURE: // Intentional fallthrough \u2014\u00a0this is an error.\n+                log.log(WARNING, \"Visiting failed: \" + control.getResult().getMessage());\n+                return status.failed(clock.instant(), control.getResult().getMessage());\n+            case ABORTED:\n+                log.log(FINE, () -> \"Halting reindexing of \" + type + \" due to shutdown \u2014\u00a0will continue later\");\n+                return status.halted();\n+            case SUCCESS:\n+                log.log(INFO, \"Completed reindexing of \" + type + \" after \" + Duration.between(status.startedAt(), clock.instant()));\n+                return status.successful(clock.instant());\n+        }\n+    }\n+\n+    private void visit(DocumentType type, ProgressToken progress, VisitorControlHandler control) {\n+        VisitorParameters parameters = createParameters(type, progress);\n+        parameters.setControlHandler(control);\n+        VisitorSession session;\n+        try {\n+            session = access.createVisitorSession(parameters);\n+        }\n+        catch (ParseException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // Wait until done, or interrupted, in which case we abort the visit but don't wait for it to complete.\n+        try {\n+            control.waitUntilDone();\n+        }\n+        catch (InterruptedException e) {\n+            control.abort();\n+            Thread.currentThread().interrupt();\n+        }\n+        session.destroy(); // If thread is interrupted, this will not wait, but will retain the interrupted flag.\n+    }\n+\n+    VisitorParameters createParameters(DocumentType type, ProgressToken progress) {\n+        VisitorParameters parameters = new VisitorParameters(type.getName());\n+        parameters.setRemoteDataHandler(cluster.name());\n+        parameters.setResumeToken(progress);\n+        parameters.setFieldSet(type.getName() + \":[document]\");\n+        parameters.setPriority(DocumentProtocol.Priority.LOW_1);\n+        parameters.setRoute(cluster.route());\n+        parameters.setBucketSpace(cluster.bucketOf(type));\n+        // parameters.setVisitorLibrary(\"ReindexVisitor\");\n+        return parameters;\n+    }\n+\n+\n+    static class Cluster {\n+\n+        private final String name;\n+        private final String configId;\n+        private final Map<DocumentType, String> documentBuckets;\n+\n+        Cluster(String name, String configId, Map<DocumentType, String> documentBuckets) {\n+            this.name = requireNonNull(name);\n+            this.configId = requireNonNull(configId);\n+            this.documentBuckets = Map.copyOf(documentBuckets);\n+        }\n+\n+        String name() {\n+            return name;\n+        }\n+\n+        String route() {\n+            return \"[Storage:cluster=\" + name + \";clusterconfigid=\" + configId + \"]\";\n+        }\n+\n+        String bucketOf(DocumentType documentType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY4MDE2Mw==", "bodyText": "Yes yes yes. Obviously ;)", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518680163", "createdAt": "2020-11-06T11:04:03Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+            case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n+            log.log(FINE, () -> \"Running reindexing of \" + type + \", which started at \" + status.startedAt());\n+        }\n+\n+        // Visit buckets until they're all done, or until we are interrupted.\n+        status = status.running();\n+        VisitorControlHandler control = new VisitorControlHandler();\n+        visit(type, status.progress().orElse(null), control);\n+\n+        // Progress is null if no buckets were successfully visited due to interrupt.\n+        if (control.getProgress() != null)\n+            status = status.progressed(control.getProgress());\n+\n+        // If we were interrupted, the result may not yet be set in the control handler.\n+        CompletionCode code = control.getResult() != null ? control.getResult().getCode() : ABORTED;\n+        switch (code) {\n+            default:\n+                log.log(WARNING, \"Unexpected visitor result '\" + control.getResult().getCode() + \"'\");\n+            case FAILURE: // Intentional fallthrough \u2014\u00a0this is an error.\n+                log.log(WARNING, \"Visiting failed: \" + control.getResult().getMessage());\n+                return status.failed(clock.instant(), control.getResult().getMessage());\n+            case ABORTED:\n+                log.log(FINE, () -> \"Halting reindexing of \" + type + \" due to shutdown \u2014\u00a0will continue later\");\n+                return status.halted();\n+            case SUCCESS:\n+                log.log(INFO, \"Completed reindexing of \" + type + \" after \" + Duration.between(status.startedAt(), clock.instant()));\n+                return status.successful(clock.instant());\n+        }\n+    }\n+\n+    private void visit(DocumentType type, ProgressToken progress, VisitorControlHandler control) {\n+        VisitorParameters parameters = createParameters(type, progress);\n+        parameters.setControlHandler(control);\n+        VisitorSession session;\n+        try {\n+            session = access.createVisitorSession(parameters);\n+        }\n+        catch (ParseException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // Wait until done, or interrupted, in which case we abort the visit but don't wait for it to complete.\n+        try {\n+            control.waitUntilDone();\n+        }\n+        catch (InterruptedException e) {\n+            control.abort();\n+            Thread.currentThread().interrupt();\n+        }\n+        session.destroy(); // If thread is interrupted, this will not wait, but will retain the interrupted flag.\n+    }\n+\n+    VisitorParameters createParameters(DocumentType type, ProgressToken progress) {\n+        VisitorParameters parameters = new VisitorParameters(type.getName());\n+        parameters.setRemoteDataHandler(cluster.name());\n+        parameters.setResumeToken(progress);\n+        parameters.setFieldSet(type.getName() + \":[document]\");\n+        parameters.setPriority(DocumentProtocol.Priority.LOW_1);\n+        parameters.setRoute(cluster.route());\n+        parameters.setBucketSpace(cluster.bucketOf(type));\n+        // parameters.setVisitorLibrary(\"ReindexVisitor\");\n+        return parameters;\n+    }\n+\n+\n+    static class Cluster {\n+\n+        private final String name;\n+        private final String configId;\n+        private final Map<DocumentType, String> documentBuckets;\n+\n+        Cluster(String name, String configId, Map<DocumentType, String> documentBuckets) {\n+            this.name = requireNonNull(name);\n+            this.configId = requireNonNull(configId);\n+            this.documentBuckets = Map.copyOf(documentBuckets);\n+        }\n+\n+        String name() {\n+            return name;\n+        }\n+\n+        String route() {\n+            return \"[Storage:cluster=\" + name + \";clusterconfigid=\" + configId + \"]\";\n+        }\n+\n+        String bucketOf(DocumentType documentType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY3NzQ1NQ=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTIyNDA4OnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjowNjowMlrOHuriVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo0Mzo1MlrOHu1dGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcwOTg0Ng==", "bodyText": "This should not be logged as warning", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518709846", "createdAt": "2020-11-06T12:06:02Z", "author": {"login": "bjorncs"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg0MzY2NQ==", "bodyText": "I don't know ... ti shouldn't happen. We only send out config for \"now\", and those \"now\"s should be a little in the past.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518843665", "createdAt": "2020-11-06T15:57:01Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcwOTg0Ng=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MjM0Nw==", "bodyText": "Can go with INFO.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518872347", "createdAt": "2020-11-06T16:43:52Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcwOTg0Ng=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTI3MjQyOnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjoyMjowNlrOHur_qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo0Mzo0NVrOHu1c4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcxNzM1Mw==", "bodyText": "Spelling", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518717353", "createdAt": "2020-11-06T12:22:06Z", "author": {"login": "bjorncs"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MjI5MQ==", "bodyText": "Thanks.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518872291", "createdAt": "2020-11-06T16:43:45Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n+            case FAILED:\n+                log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n+            case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.\n+                return status;\n+            case RUNNING:\n+                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcxNzM1Mw=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTI3NDgyOnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjoyMjo1NFrOHusBLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo0Mjo0M1rOHu1aUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcxNzc0MA==", "bodyText": "Consider throwing an exception (assuming this is an unexpected behaviour).", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518717740", "createdAt": "2020-11-06T12:22:54Z", "author": {"login": "bjorncs"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MTYzMw==", "bodyText": "It's unexpected, but would like to continue with other document types anyway. Any types before this one would also be processed.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518871633", "createdAt": "2020-11-06T16:42:43Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorControlHandler.CompletionCode;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static com.yahoo.documentapi.VisitorControlHandler.CompletionCode.ABORTED;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until interrupted, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n+    public void reindex() throws ReindexingLockException {\n+        try (Lock lock = database.lockReindexing()) {\n+            Reindexing reindexing = database.readReindexing();\n+            for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n+                if (ready.get(type).isAfter(clock.instant())) {\n+                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                }\n+                else {\n+                    // If this is a new document type (or a new cluster), no reindexing is required.\n+                    Status status = reindexing.status().getOrDefault(type,\n+                                                                     Status.ready(clock.instant())\n+                                                                           .running()\n+                                                                           .successful(clock.instant()));\n+                    reindexing = reindexing.with(type, progress(type, status));\n+                }\n+                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                    break;\n+            }\n+            database.writeReindexing(reindexing);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n+    private Status progress(DocumentType type, Status status) {\n+        if (ready.get(type).isAfter(status.startedAt()))\n+            status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n+\n+        switch (status.state()) {\n+            default:\n+                log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcxNzc0MA=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTI5MzI3OnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingCurator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjoyODo0MVrOHusMBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo0MTowN1rOHu1Waw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMDUxOA==", "bodyText": "Are we leaking Guava types from our curator framework? \ud83e\udd26", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518720518", "createdAt": "2020-11-06T12:28:41Z", "author": {"login": "bjorncs"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingCurator.java", "diffHunk": "@@ -2,6 +2,7 @@\n package ai.vespa.reindexing;\n \n import ai.vespa.reindexing.Reindexing.Status;\n+import com.google.common.util.concurrent.UncheckedTimeoutException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNzE5OA==", "bodyText": "Catching these might not even work if bundles disagree on the class instance", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518737198", "createdAt": "2020-11-06T13:03:09Z", "author": {"login": "bjorncs"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingCurator.java", "diffHunk": "@@ -2,6 +2,7 @@\n package ai.vespa.reindexing;\n \n import ai.vespa.reindexing.Reindexing.Status;\n+import com.google.common.util.concurrent.UncheckedTimeoutException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMDUxOA=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDYzNQ==", "bodyText": "How nice. Will make a note to fix it.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518870635", "createdAt": "2020-11-06T16:41:07Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingCurator.java", "diffHunk": "@@ -2,6 +2,7 @@\n package ai.vespa.reindexing;\n \n import ai.vespa.reindexing.Reindexing.Status;\n+import com.google.common.util.concurrent.UncheckedTimeoutException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMDUxOA=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTMwMTQ3OnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingMaintainer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjozMToyMFrOHusQ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo0MDozM1rOHu1VNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMTc2Mw==", "bodyText": "s/reindexngg/reindexing", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518721763", "createdAt": "2020-11-06T12:31:20Z", "author": {"login": "bjorncs"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingMaintainer.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexer.Cluster;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.google.inject.Inject;\n+import com.yahoo.cloud.config.ClusterListConfig;\n+import com.yahoo.cloud.config.ZookeepersConfig;\n+import com.yahoo.component.AbstractComponent;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.DocumentTypeManager;\n+import com.yahoo.document.config.DocumentmanagerConfig;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.net.HostName;\n+import com.yahoo.vespa.config.content.AllClustersBucketSpacesConfig;\n+import com.yahoo.vespa.config.content.reindexing.ReindexingConfig;\n+import com.yahoo.vespa.curator.Curator;\n+import com.yahoo.vespa.zookeeper.VespaZooKeeperServer;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+\n+/**\n+ * Runs in all cluster controller containers, and progresses reindexngg efforts.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDMyNQ==", "bodyText": "Thanks", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518870325", "createdAt": "2020-11-06T16:40:33Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingMaintainer.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexer.Cluster;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.google.inject.Inject;\n+import com.yahoo.cloud.config.ClusterListConfig;\n+import com.yahoo.cloud.config.ZookeepersConfig;\n+import com.yahoo.component.AbstractComponent;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.DocumentTypeManager;\n+import com.yahoo.document.config.DocumentmanagerConfig;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.net.HostName;\n+import com.yahoo.vespa.config.content.AllClustersBucketSpacesConfig;\n+import com.yahoo.vespa.config.content.reindexing.ReindexingConfig;\n+import com.yahoo.vespa.curator.Curator;\n+import com.yahoo.vespa.zookeeper.VespaZooKeeperServer;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+\n+/**\n+ * Runs in all cluster controller containers, and progresses reindexngg efforts.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMTc2Mw=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTMwNjIxOnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingMaintainer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMjozMzowM1rOHusT3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjo0MDoxNFrOHu1Ukg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMjUyNQ==", "bodyText": "Consider adding debug-logging when this happens", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518722525", "createdAt": "2020-11-06T12:33:03Z", "author": {"login": "bjorncs"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingMaintainer.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexer.Cluster;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.google.inject.Inject;\n+import com.yahoo.cloud.config.ClusterListConfig;\n+import com.yahoo.cloud.config.ZookeepersConfig;\n+import com.yahoo.component.AbstractComponent;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.DocumentTypeManager;\n+import com.yahoo.document.config.DocumentmanagerConfig;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.net.HostName;\n+import com.yahoo.vespa.config.content.AllClustersBucketSpacesConfig;\n+import com.yahoo.vespa.config.content.reindexing.ReindexingConfig;\n+import com.yahoo.vespa.curator.Curator;\n+import com.yahoo.vespa.zookeeper.VespaZooKeeperServer;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+\n+/**\n+ * Runs in all cluster controller containers, and progresses reindexngg efforts.\n+ * Work is only done by one container at a time, by requiring a shared ZooKeeper lock to be held while visiting.\n+ * Whichever maintainer gets the lock holds it until all reindexing is done, or until shutdown.\n+ *\n+ * @author jonmv\n+ */\n+public class ReindexingMaintainer extends AbstractComponent {\n+\n+    private static final Logger log = Logger.getLogger(Reindexing.class.getName());\n+\n+    private final Reindexer reindexer;\n+    private final ScheduledExecutorService executor;\n+\n+    // VespaZooKeeperServer dependency to ensure the ZK cluster is running.\n+    @Inject\n+    public ReindexingMaintainer(VespaZooKeeperServer zooKeeperServer, DocumentAccess access, ZookeepersConfig zookeepersConfig,\n+                                ClusterListConfig clusterListConfig, AllClustersBucketSpacesConfig allClustersBucketSpacesConfig,\n+                                ReindexingConfig reindexingConfig, DocumentmanagerConfig documentmanagerConfig) {\n+        this(Clock.systemUTC(), access, zookeepersConfig, clusterListConfig, allClustersBucketSpacesConfig, reindexingConfig, documentmanagerConfig);\n+    }\n+\n+    ReindexingMaintainer(Clock clock, DocumentAccess access, ZookeepersConfig zookeepersConfig,\n+                         ClusterListConfig clusterListConfig, AllClustersBucketSpacesConfig allClustersBucketSpacesConfig,\n+                         ReindexingConfig reindexingConfig, DocumentmanagerConfig documentmanagerConfig) {\n+        DocumentTypeManager manager = new DocumentTypeManager(documentmanagerConfig);\n+        this.reindexer = new Reindexer(parseCluster(reindexingConfig.clusterName(), clusterListConfig, allClustersBucketSpacesConfig, manager),\n+                                       parseReady(reindexingConfig, manager),\n+                                       new ReindexingCurator(Curator.create(zookeepersConfig.zookeeperserverlist()), manager),\n+                                       access,\n+                                       clock);\n+        this.executor = new ScheduledThreadPoolExecutor(1, new DaemonThreadFactory(\"reindexer-\"));\n+        if (reindexingConfig.enabled())\n+            scheduleStaggered((delayMillis, intervalMillis) -> executor.scheduleAtFixedRate(this::maintain, delayMillis, intervalMillis, TimeUnit.MILLISECONDS),\n+                              Duration.ofMinutes(1), clock.instant(), HostName.getLocalhost(), zookeepersConfig.zookeeperserverlist());\n+    }\n+\n+    private void maintain() {\n+        try {\n+            reindexer.reindex();\n+        }\n+        catch (ReindexingLockException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3MDE2Mg==", "bodyText": "Yeah, done.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518870162", "createdAt": "2020-11-06T16:40:14Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingMaintainer.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexer.Cluster;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.google.inject.Inject;\n+import com.yahoo.cloud.config.ClusterListConfig;\n+import com.yahoo.cloud.config.ZookeepersConfig;\n+import com.yahoo.component.AbstractComponent;\n+import com.yahoo.concurrent.DaemonThreadFactory;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.DocumentTypeManager;\n+import com.yahoo.document.config.DocumentmanagerConfig;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.net.HostName;\n+import com.yahoo.vespa.config.content.AllClustersBucketSpacesConfig;\n+import com.yahoo.vespa.config.content.reindexing.ReindexingConfig;\n+import com.yahoo.vespa.curator.Curator;\n+import com.yahoo.vespa.zookeeper.VespaZooKeeperServer;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiConsumer;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+\n+/**\n+ * Runs in all cluster controller containers, and progresses reindexngg efforts.\n+ * Work is only done by one container at a time, by requiring a shared ZooKeeper lock to be held while visiting.\n+ * Whichever maintainer gets the lock holds it until all reindexing is done, or until shutdown.\n+ *\n+ * @author jonmv\n+ */\n+public class ReindexingMaintainer extends AbstractComponent {\n+\n+    private static final Logger log = Logger.getLogger(Reindexing.class.getName());\n+\n+    private final Reindexer reindexer;\n+    private final ScheduledExecutorService executor;\n+\n+    // VespaZooKeeperServer dependency to ensure the ZK cluster is running.\n+    @Inject\n+    public ReindexingMaintainer(VespaZooKeeperServer zooKeeperServer, DocumentAccess access, ZookeepersConfig zookeepersConfig,\n+                                ClusterListConfig clusterListConfig, AllClustersBucketSpacesConfig allClustersBucketSpacesConfig,\n+                                ReindexingConfig reindexingConfig, DocumentmanagerConfig documentmanagerConfig) {\n+        this(Clock.systemUTC(), access, zookeepersConfig, clusterListConfig, allClustersBucketSpacesConfig, reindexingConfig, documentmanagerConfig);\n+    }\n+\n+    ReindexingMaintainer(Clock clock, DocumentAccess access, ZookeepersConfig zookeepersConfig,\n+                         ClusterListConfig clusterListConfig, AllClustersBucketSpacesConfig allClustersBucketSpacesConfig,\n+                         ReindexingConfig reindexingConfig, DocumentmanagerConfig documentmanagerConfig) {\n+        DocumentTypeManager manager = new DocumentTypeManager(documentmanagerConfig);\n+        this.reindexer = new Reindexer(parseCluster(reindexingConfig.clusterName(), clusterListConfig, allClustersBucketSpacesConfig, manager),\n+                                       parseReady(reindexingConfig, manager),\n+                                       new ReindexingCurator(Curator.create(zookeepersConfig.zookeeperserverlist()), manager),\n+                                       access,\n+                                       clock);\n+        this.executor = new ScheduledThreadPoolExecutor(1, new DaemonThreadFactory(\"reindexer-\"));\n+        if (reindexingConfig.enabled())\n+            scheduleStaggered((delayMillis, intervalMillis) -> executor.scheduleAtFixedRate(this::maintain, delayMillis, intervalMillis, TimeUnit.MILLISECONDS),\n+                              Duration.ofMinutes(1), clock.instant(), HostName.getLocalhost(), zookeepersConfig.zookeeperserverlist());\n+    }\n+\n+    private void maintain() {\n+        try {\n+            reindexer.reindex();\n+        }\n+        catch (ReindexingLockException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMjUyNQ=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTgxMTE3OnYy", "diffSide": "RIGHT", "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNDo1Mjo0OFrOHuxH4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNjozOToyMlrOHu1Slw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwMTM3OQ==", "bodyText": "s/destinatino/destination", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518801379", "createdAt": "2020-11-06T14:52:48Z", "author": {"login": "bjorncs"}, "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -28,7 +28,7 @@\n \n /**\n  * Local visitor session that copies and iterates through all items in the local document access.\n- * Each document must be ack'ed for the session to be done visiting.\n+ * Each document must be ack'ed for the session to be done visiting, unless the destinatino is remote.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg2OTY1NQ==", "bodyText": "Thanks", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r518869655", "createdAt": "2020-11-06T16:39:22Z", "author": {"login": "jonmv"}, "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -28,7 +28,7 @@\n \n /**\n  * Local visitor session that copies and iterates through all items in the local document access.\n- * Each document must be ack'ed for the session to be done visiting.\n+ * Each document must be ack'ed for the session to be done visiting, unless the destinatino is remote.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwMTM3OQ=="}, "originalCommit": {"oid": "cab5c5ae03d0b6bb76f0fbda57e99f6302349bab"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzYzMDQyOnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOToyMDowMVrOHvlcdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMDo0MToyMFrOHvopog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1ODYxNA==", "bodyText": "I presume this is a synchronous write to ZooKeeper? If it's observed to be a performance issue, it could be useful to consider making progress updates async since this is called in the context of a visitor client worker thread callback.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519658614", "createdAt": "2020-11-09T09:20:01Z", "author": {"login": "vekterli"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -60,72 +63,94 @@ public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCu\n         this.clock = clock;\n     }\n \n+    /** Tells this to stop reindexing at its leisure. */\n+    public void shutdown() {\n+        phaser.forceTermination();\n+    }\n+\n     /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n     public void reindex() throws ReindexingLockException {\n+        if (phaser.isTerminated())\n+            throw new IllegalStateException(\"Already shut down\");\n+\n         try (Lock lock = database.lockReindexing()) {\n-            Reindexing reindexing = database.readReindexing();\n             for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n-                if (ready.get(type).isAfter(clock.instant())) {\n-                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n-                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n-                }\n-                else {\n-                    // If this is a new document type (or a new cluster), no reindexing is required.\n-                    Status status = reindexing.status().getOrDefault(type,\n-                                                                     Status.ready(clock.instant())\n-                                                                           .running()\n-                                                                           .successful(clock.instant()));\n-                    reindexing = reindexing.with(type, progress(type, status));\n-                }\n-                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                if (ready.get(type).isAfter(clock.instant()))\n+                    log.log(INFO, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                  \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                else\n+                    progress(type);\n+\n+                if (phaser.isTerminated())\n                     break;\n             }\n-            database.writeReindexing(reindexing);\n         }\n     }\n \n     @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n-    private Status progress(DocumentType type, Status status) {\n+    private void progress(DocumentType type) {\n+        // If this is a new document type (or a new cluster), no reindexing is required.\n+        reindexing = database.readReindexing();\n+        status = reindexing.status().getOrDefault(type,\n+                                                  Status.ready(clock.instant())\n+                                                        .running()\n+                                                        .successful(clock.instant()));\n         if (ready.get(type).isAfter(status.startedAt()))\n             status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n \n+        database.writeReindexing(reindexing = reindexing.with(type, status));\n+\n         switch (status.state()) {\n             default:\n                 log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n             case FAILED:\n                 log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n             case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.\n-                return status;\n+                return;\n             case RUNNING:\n-                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+                log.log(WARNING, \"Unexpected state 'RUNNING' of reindexing of \" + type);\n             case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n-            log.log(FINE, () -> \"Running reindexing of \" + type + \", which started at \" + status.startedAt());\n+            log.log(FINE, () -> \"Running reindexing of \" + type);\n         }\n \n         // Visit buckets until they're all done, or until we are interrupted.\n         status = status.running();\n-        VisitorControlHandler control = new VisitorControlHandler();\n+        AtomicReference<Instant> progressLastStored = new AtomicReference<>(clock.instant());\n+        VisitorControlHandler control = new VisitorControlHandler() {\n+            @Override\n+            public void onProgress(ProgressToken token) {\n+                super.onProgress(token);\n+                status = status.progressed(token);\n+                if (progressLastStored.get().isBefore(clock.instant().minusSeconds(10))) {\n+                    progressLastStored.set(clock.instant());\n+                    database.writeReindexing(reindexing = reindexing.with(type, status));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f35d882805926489f59c0ce3402fbd57b0ea11"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcxMTEzOA==", "bodyText": "Noted.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519711138", "createdAt": "2020-11-09T10:41:20Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -60,72 +63,94 @@ public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCu\n         this.clock = clock;\n     }\n \n+    /** Tells this to stop reindexing at its leisure. */\n+    public void shutdown() {\n+        phaser.forceTermination();\n+    }\n+\n     /** Starts and tracks reprocessing of ready document types until done, or interrupted. */\n     public void reindex() throws ReindexingLockException {\n+        if (phaser.isTerminated())\n+            throw new IllegalStateException(\"Already shut down\");\n+\n         try (Lock lock = database.lockReindexing()) {\n-            Reindexing reindexing = database.readReindexing();\n             for (DocumentType type : ready.keySet()) { // We consider only document types for which we have config.\n-                if (ready.get(type).isAfter(clock.instant())) {\n-                    log.log(WARNING, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n-                                     \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n-                }\n-                else {\n-                    // If this is a new document type (or a new cluster), no reindexing is required.\n-                    Status status = reindexing.status().getOrDefault(type,\n-                                                                     Status.ready(clock.instant())\n-                                                                           .running()\n-                                                                           .successful(clock.instant()));\n-                    reindexing = reindexing.with(type, progress(type, status));\n-                }\n-                if (Thread.interrupted()) // Clear interruption status so blocking calls function normally again.\n+                if (ready.get(type).isAfter(clock.instant()))\n+                    log.log(INFO, \"Received config for reindexing which is ready in the future \u2014 will process later \" +\n+                                  \"(\" + ready.get(type) + \" is after \" + clock.instant() + \")\");\n+                else\n+                    progress(type);\n+\n+                if (phaser.isTerminated())\n                     break;\n             }\n-            database.writeReindexing(reindexing);\n         }\n     }\n \n     @SuppressWarnings(\"fallthrough\") // (\u30ce\u0ca0 \u2229\u0ca0)\u30ce\u5f61( \\o\u00b0o)\\\n-    private Status progress(DocumentType type, Status status) {\n+    private void progress(DocumentType type) {\n+        // If this is a new document type (or a new cluster), no reindexing is required.\n+        reindexing = database.readReindexing();\n+        status = reindexing.status().getOrDefault(type,\n+                                                  Status.ready(clock.instant())\n+                                                        .running()\n+                                                        .successful(clock.instant()));\n         if (ready.get(type).isAfter(status.startedAt()))\n             status = Status.ready(clock.instant()); // Need to restart, as a newer reindexing is required.\n \n+        database.writeReindexing(reindexing = reindexing.with(type, status));\n+\n         switch (status.state()) {\n             default:\n                 log.log(WARNING, \"Unknown reindexing state '\" + status.state() + \"'\");\n             case FAILED:\n                 log.log(FINE, () -> \"Not continuing reindexing of \" + type + \" due to previous failure\");\n             case SUCCESSFUL: // Intentional fallthrough \u2014 all three are done states.\n-                return status;\n+                return;\n             case RUNNING:\n-                log.log(WARNING, \"Unepxected state 'RUNNING' of reindexing of \" + type);\n+                log.log(WARNING, \"Unexpected state 'RUNNING' of reindexing of \" + type);\n             case READY: // Intentional fallthrough \u2014\u00a0must just assume we failed updating state when exiting previously.\n-            log.log(FINE, () -> \"Running reindexing of \" + type + \", which started at \" + status.startedAt());\n+            log.log(FINE, () -> \"Running reindexing of \" + type);\n         }\n \n         // Visit buckets until they're all done, or until we are interrupted.\n         status = status.running();\n-        VisitorControlHandler control = new VisitorControlHandler();\n+        AtomicReference<Instant> progressLastStored = new AtomicReference<>(clock.instant());\n+        VisitorControlHandler control = new VisitorControlHandler() {\n+            @Override\n+            public void onProgress(ProgressToken token) {\n+                super.onProgress(token);\n+                status = status.progressed(token);\n+                if (progressLastStored.get().isBefore(clock.instant().minusSeconds(10))) {\n+                    progressLastStored.set(clock.instant());\n+                    database.writeReindexing(reindexing = reindexing.with(type, status));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1ODYxNA=="}, "originalCommit": {"oid": "61f35d882805926489f59c0ce3402fbd57b0ea11"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzcyOTE0OnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingCurator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwOTo0MzozM1rOHvmYBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMDo0MjowOFrOHvoroQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3Mzg2Mg==", "bodyText": "Could we ever get a case where multiple (disparate) reindexing controller clusters run against the same ZooKeeper cluster? I don't really see this happening with our current setup, mind you. We could probably use some ZK chroot-style magic if we need to support it.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519673862", "createdAt": "2020-11-09T09:43:33Z", "author": {"login": "vekterli"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingCurator.java", "diffHunk": "@@ -33,14 +37,22 @@\n     private static final String STATE = \"state\";\n     private static final String MESSAGE = \"message\";\n \n-    private static final Path statusPath = Path.fromString(\"/reindexing/v1/status\");\n+    private static final Path rootPath = Path.fromString(\"/reindexing/v1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f35d882805926489f59c0ce3402fbd57b0ea11"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcxMTY0OQ==", "bodyText": "Can add cluster name as part of the root.", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519711649", "createdAt": "2020-11-09T10:42:08Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/ReindexingCurator.java", "diffHunk": "@@ -33,14 +37,22 @@\n     private static final String STATE = \"state\";\n     private static final String MESSAGE = \"message\";\n \n-    private static final Path statusPath = Path.fromString(\"/reindexing/v1/status\");\n+    private static final Path rootPath = Path.fromString(\"/reindexing/v1\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3Mzg2Mg=="}, "originalCommit": {"oid": "61f35d882805926489f59c0ce3402fbd57b0ea11"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NzgyNjUzOnYy", "diffSide": "RIGHT", "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMDowNjoyMFrOHvnTSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMDo0MjozM1rOHvosmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4OTAzNQ==", "bodyText": "For those of us not too familiar with these newfangled and fancy Phaser doohickies, a comment on how this ends up transitively aborting the active visitor session would be nice \ud83e\udd96", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519689035", "createdAt": "2020-11-09T10:06:20Z", "author": {"login": "vekterli"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,235 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until shutdown is called, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+    private final Phaser phaser = new Phaser(2); // Reindexer and visitor.\n+\n+    private Reindexing reindexing;\n+    private Status status;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketSpaceOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Tells this to stop reindexing at its leisure. */\n+    public void shutdown() {\n+        phaser.forceTermination();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61f35d882805926489f59c0ce3402fbd57b0ea11"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcxMTg5OQ==", "bodyText": "Of course!", "url": "https://github.com/vespa-engine/vespa/pull/15187#discussion_r519711899", "createdAt": "2020-11-09T10:42:33Z", "author": {"login": "jonmv"}, "path": "clustercontroller-reindexer/src/main/java/ai/vespa/reindexing/Reindexer.java", "diffHunk": "@@ -0,0 +1,235 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package ai.vespa.reindexing;\n+\n+import ai.vespa.reindexing.Reindexing.Status;\n+import ai.vespa.reindexing.ReindexingCurator.ReindexingLockException;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.DocumentProtocol;\n+import com.yahoo.vespa.curator.Lock;\n+\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.logging.Level.FINE;\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.joining;\n+\n+/**\n+ * Progresses reindexing efforts by creating visitor sessions against its own content cluster,\n+ * which send documents straight to storage \u2014\u00a0via indexing if the documenet type has \"index\" mode.\n+ * The {@link #reindex} method blocks until shutdown is called, or until no more reindexing is left to do.\n+ *\n+ * @author jonmv\n+ */\n+public class Reindexer {\n+\n+    private static final Logger log = Logger.getLogger(Reindexer.class.getName());\n+\n+    private final Cluster cluster;\n+    private final Map<DocumentType, Instant> ready;\n+    private final ReindexingCurator database;\n+    private final DocumentAccess access;\n+    private final Clock clock;\n+    private final Phaser phaser = new Phaser(2); // Reindexer and visitor.\n+\n+    private Reindexing reindexing;\n+    private Status status;\n+\n+    public Reindexer(Cluster cluster, Map<DocumentType, Instant> ready, ReindexingCurator database,\n+                     DocumentAccess access, Clock clock) {\n+        for (DocumentType type : ready.keySet())\n+            cluster.bucketSpaceOf(type); // Verifies this is known.\n+\n+        this.cluster = cluster;\n+        this.ready = new TreeMap<>(ready); // Iterate through document types in consistent order.\n+        this.database = database;\n+        this.access = access;\n+        this.clock = clock;\n+    }\n+\n+    /** Tells this to stop reindexing at its leisure. */\n+    public void shutdown() {\n+        phaser.forceTermination();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4OTAzNQ=="}, "originalCommit": {"oid": "61f35d882805926489f59c0ce3402fbd57b0ea11"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 992, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}