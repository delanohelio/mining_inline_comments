{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczODMzOTk2", "number": 14165, "title": "Deploy to Vespa Cloud from python, talk to endpoints with mTLS", "bodyText": "@thigm85", "createdAt": "2020-08-26T11:14:34Z", "url": "https://github.com/vespa-engine/vespa/pull/14165", "merged": true, "mergeCommit": {"oid": "3b8f7fdff4872bd010286753f6072ec492f14a48"}, "closed": true, "closedAt": "2020-09-01T12:37:09Z", "author": {"login": "jonmv"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdC7YwBgBqjM2OTgxNjk3NjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdElAj9AFqTQ3OTYxNjk0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fd6618c0413c42f8cd179d2e37aacf9a467b720", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/2fd6618c0413c42f8cd179d2e37aacf9a467b720", "committedDate": "2020-08-26T11:14:20Z", "message": "Stash-commit -- will overwrite later"}, "afterCommit": {"oid": "446fb49b86cba755eb072546d477cdf5d26a6746", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/446fb49b86cba755eb072546d477cdf5d26a6746", "committedDate": "2020-08-27T07:36:17Z", "message": "Stash-commit -- will overwrite later"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdec75f5e841b06015ebb1801b7f73ee87caa934", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/fdec75f5e841b06015ebb1801b7f73ee87caa934", "committedDate": "2020-08-27T11:36:40Z", "message": "Set certificate/key parameter for HTTP requests in class Vespa"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/657ccdfad595192340758093a1eef0aab4c12310", "committedDate": "2020-08-27T12:05:06Z", "message": "Talk to Vespa Cloud with API key, deploy package with mTLS, etc."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "446fb49b86cba755eb072546d477cdf5d26a6746", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/446fb49b86cba755eb072546d477cdf5d26a6746", "committedDate": "2020-08-27T07:36:17Z", "message": "Stash-commit -- will overwrite later"}, "afterCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/657ccdfad595192340758093a1eef0aab4c12310", "committedDate": "2020-08-27T12:05:06Z", "message": "Talk to Vespa Cloud with API key, deploy package with mTLS, etc."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NjU0ODg3", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-476654887", "createdAt": "2020-08-27T12:09:24Z", "commit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowOToyNFrOHINUxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowOToyNFrOHINUxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2ODk2Nw==", "bodyText": "Not sure if this works against the local docker instance.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478368967", "createdAt": "2020-08-27T12:09:24Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -87,7 +90,7 @@ def query(\n         if debug_request:\n             return VespaResult(vespa_result={}, request_body=body)\n         else:\n-            r = post(self.search_end_point, json=body)\n+            r = post(self.search_end_point, json=body, cert=self.cert)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NjU0OTUw", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-476654950", "createdAt": "2020-08-27T12:09:29Z", "commit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowOToyOVrOHINU7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjowOToyOVrOHINU7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM2OTAwNQ==", "bodyText": "Same here.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478369005", "createdAt": "2020-08-27T12:09:29Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -103,7 +106,7 @@ def feed_data_point(self, schema: str, data_id: str, fields: Dict) -> Response:\n             self.end_point, schema, schema, str(data_id)\n         )\n         vespa_format = {\"fields\": fields}\n-        response = post(end_point, json=vespa_format)\n+        response = post(end_point, json=vespa_format, cert=self.cert)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NjU2MzEz", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-476656313", "createdAt": "2020-08-27T12:11:23Z", "commit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMToyM1rOHINZUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMToyM1rOHINZUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ==", "bodyText": "This file can only be read by the user writing it, and is deleted immediately when closed. The VespaCloud closes this file on its close, and is meant to be used like\nwith VespaCloud('tenant', 'application', '/path/to/api_key') as cloud:\n    ...", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478370131", "createdAt": "2020-08-27T12:11:23Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NjU3MTAx", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-476657101", "createdAt": "2020-08-27T12:12:27Z", "commit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMjoyOFrOHINb8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxMjoyOFrOHINb8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDgwMA==", "bodyText": "Hard-coded container name here. Remember this is the container name changes (in services.xml).", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478370800", "createdAt": "2020-08-27T12:12:28Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')\n+        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP521R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n+        certificate = x509.CertificateBuilder() \\\n+            .subject_name(name) \\\n+            .issuer_name(name) \\\n+            .serial_number(x509.random_serial_number()) \\\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n+            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n+            .public_key(key.public_key()) \\\n+            .sign(key, hashes.SHA256(), default_backend())\n+        return (key, certificate)\n+\n+    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n+        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n+        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n+        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n+\n+    def get_endpoint(self, instance: str, region: str) -> str:\n+        endpoints = self.request('GET',\n+                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n+                                 .format(self.tenant, self.application, instance, region))['endpoints']\n+        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NjU5NTI2", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-476659526", "createdAt": "2020-08-27T12:15:08Z", "commit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxNTowOFrOHINjEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMjoxNTowOFrOHINjEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjYyNw==", "bodyText": "This deletes the data key/cert forever. Consider allowing the user to specify the certificate file, for persistent storage, if it's meaningful to allow the user to keep talking to its endpoint outside of the python code, or if the VespaCloud variable can't be kept in scope.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478372627", "createdAt": "2020-08-27T12:15:08Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')\n+        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP521R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n+        certificate = x509.CertificateBuilder() \\\n+            .subject_name(name) \\\n+            .issuer_name(name) \\\n+            .serial_number(x509.random_serial_number()) \\\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n+            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n+            .public_key(key.public_key()) \\\n+            .sign(key, hashes.SHA256(), default_backend())\n+        return (key, certificate)\n+\n+    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n+        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n+        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n+        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n+\n+    def get_endpoint(self, instance: str, region: str) -> str:\n+        endpoints = self.request('GET',\n+                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n+                                 .format(self.tenant, self.application, instance, region))['endpoints']\n+        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n+        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n+            .format(self.tenant, self.application, instance, job)\n+        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n+        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n+        print(response['message'])\n+        return response['run']\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request('GET',\n+                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n+                                  .format(self.tenant, self.application, instance, job, run, last))\n+\n+            for step, entries in update['log'].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get('lastId', last)\n+\n+            if update['active']:\n+                sleep(1)\n+            else:\n+                status = update['status']\n+                if   status == 'success':                    return\n+                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n+                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n+                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n+                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n+                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n+                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime('%H:%M:%S', gmtime(entry['at'] / 1e3))\n+        message = entry['message'].replace('\\n', '\\n' + ' '*23)\n+        if step != 'copyVespaLogs' or entry['type'] == 'error':\n+            print('{:<7} [{}]  {}'.format(entry['type'].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+\n+        region = self.get_dev_region()\n+        job = 'dev-' + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(instance, region)\n+        return Vespa(url = endpoint_url, cert = self.data_cert_file.name)\n+\n+    def close(self):\n+        self.connection.close()\n+        self.data_cert_file.close()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 198}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4615ca63b9b5bb08e11b50cb07d57b5610e9aaf9", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/4615ca63b9b5bb08e11b50cb07d57b5610e9aaf9", "committedDate": "2020-08-27T12:19:39Z", "message": "Add method to delete a deployment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/325ecffb37c24ca9538d105b830aaf1e5991c716", "committedDate": "2020-08-27T15:31:41Z", "message": "Use a cheaper elliptic curve"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MzI0OTE2", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-477324916", "createdAt": "2020-08-28T07:02:22Z", "commit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzowMjoyMlrOHIr79w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwNzoxNDozMlrOHIsRHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3MDUxOQ==", "bodyText": "Please indicate the type of the string. Is it a filename, two PEM encoded objects, etc.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478870519", "createdAt": "2020-08-28T07:02:22Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -15,13 +15,15 @@ def __init__(\n         url: str,\n         port: Optional[int] = None,\n         deployment_message: Optional[List[str]] = None,\n+        cert: Optional[str] = None,\n     ) -> None:\n         \"\"\"\n         Establish a connection with a Vespa application.\n \n         :param url: URL\n         :param port: Port\n         :param deployment_message: Message returned by Vespa engine after deployment.\n+        :param cert: Certificate and key pair used for mTLS.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3NTY1Ng==", "bodyText": "Is there a way to use an in-memory file object instead of a temporary on-disk file?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478875656", "createdAt": "2020-08-28T07:13:54Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,160 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n+        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, 'rb') as key_data:\n+            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile('wt')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MDEzMQ=="}, "originalCommit": {"oid": "657ccdfad595192340758093a1eef0aab4c12310"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3NTkzNA==", "bodyText": "This should indicate the type in the cert. Is it a file name or the object itself?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r478875934", "createdAt": "2020-08-28T07:14:32Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/application.py", "diffHunk": "@@ -15,13 +15,15 @@ def __init__(\n         url: str,\n         port: Optional[int] = None,\n         deployment_message: Optional[List[str]] = None,\n+        cert: Optional[str] = None,\n     ) -> None:\n         \"\"\"\n         Establish a connection with a Vespa application.\n \n         :param url: URL\n         :param port: Port\n         :param deployment_message: Message returned by Vespa engine after deployment.\n+        :param cert: Certificate and key pair used for mTLS.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "325ecffb37c24ca9538d105b830aaf1e5991c716"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5404109687aaf9f4b2374a61c44a6a53cd3b965e", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/5404109687aaf9f4b2374a61c44a6a53cd3b965e", "committedDate": "2020-08-28T07:32:40Z", "message": "Fix doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b552acd4e5e99a5d57aabc821dd3c77e9e5a389", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/3b552acd4e5e99a5d57aabc821dd3c77e9e5a389", "committedDate": "2020-08-28T08:29:36Z", "message": "Merge branch 'master' into jonmv/deploy-from-python"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fe56225c30428ba4756116e2b1934ec99b0132a", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/8fe56225c30428ba4756116e2b1934ec99b0132a", "committedDate": "2020-08-28T12:04:15Z", "message": "include the cryptography library as a depedency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/8ea44156c1b3468ef175a094c8d81478f7c0009b", "committedDate": "2020-08-28T12:05:00Z", "message": "remove hard-coded cluster name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3Njc3MTg2", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-477677186", "createdAt": "2020-08-28T12:13:19Z", "commit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoxMzoxOVrOHJA57A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoxMzoxOVrOHJA57A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNDA2MA==", "bodyText": "Hehe, this is why I hate autoformatters :)", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479214060", "createdAt": "2020-08-28T12:13:19Z", "author": {"login": "jonmv"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -504,122 +513,208 @@ def __init__(self, tenant: str, application: str, key_location: str) -> None:\n         self.tenant = tenant\n         self.application = application\n         self.api_key = self.read_private_key(key_location)\n-        self.api_public_key_bytes = standard_b64encode(self.api_key.public_key().public_bytes(serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo))\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n         self.data_key, self.data_certificate = self.create_certificate_pair()\n-        self.data_cert_file = self.write_private_key_and_cert(self.data_key, self.data_certificate)\n-        self.connection = http.client.HTTPSConnection('api.vespa-external.aws.oath.cloud', 4443)\n+        self.data_cert_file = self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate\n+        )\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n \n     @staticmethod\n     def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n-        with open(key_location, 'rb') as key_data:\n-            key = serialization.load_pem_private_key(key_data.read(), None, default_backend())\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n             if not isinstance(key, ec.EllipticCurvePrivateKey):\n-                raise TypeError(\"Key at \" + key_location + \" must be an elliptic curve private key\")\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n             return key\n \n     @staticmethod\n-    def write_private_key_and_cert(key: ec.EllipticCurvePrivateKey, cert: x509.Certificate) -> (str, str):\n-        cert_file = tempfile.NamedTemporaryFile('wt')\n-        cert_file.write(key.private_bytes(serialization.Encoding.PEM, serialization.PrivateFormat.TraditionalOpenSSL, serialization.NoEncryption()).decode('UTF-8'))\n-        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode('UTF-8'))\n+    def write_private_key_and_cert(\n+        key: ec.EllipticCurvePrivateKey, cert: x509.Certificate\n+    ) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile(\"wt\")\n+        cert_file.write(\n+            key.private_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PrivateFormat.TraditionalOpenSSL,\n+                serialization.NoEncryption(),\n+            ).decode(\"UTF-8\")\n+        )\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n         cert_file.flush()\n         return cert_file\n \n     @staticmethod\n     def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n         key = ec.generate_private_key(ec.SECP384R1, default_backend())\n-        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u'localhost')])\n-        certificate = x509.CertificateBuilder() \\\n-            .subject_name(name) \\\n-            .issuer_name(name) \\\n-            .serial_number(x509.random_serial_number()) \\\n-            .not_valid_before(datetime.utcnow() - timedelta(minutes = 1)) \\\n-            .not_valid_after(datetime.utcnow() + timedelta(days = 7)) \\\n-            .public_key(key.public_key()) \\\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n             .sign(key, hashes.SHA256(), default_backend())\n+        )\n         return (key, certificate)\n \n-    def request(self, method: str, path: str, body: BytesIO = BytesIO(), headers = {}) -> dict:\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n         digest = hashes.Hash(hashes.SHA256(), default_backend())\n         body.seek(0)\n         digest.update(body.read())\n-        content_hash = standard_b64encode(digest.finalize()).decode('UTF-8')\n-        timestamp = datetime.utcnow().isoformat() + 'Z' # Java's Instant.parse requires the neutral time zone appended\n-        url = 'https://' + self.connection.host + \":\" + str(self.connection.port) + path\n-\n-        canonical_message = method + '\\n' + url + '\\n' + timestamp + '\\n' + content_hash\n-        signature = self.api_key.sign(canonical_message.encode('UTF-8'), ec.ECDSA(hashes.SHA256()))\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n \n         headers = {\n             \"X-Timestamp\": timestamp,\n             \"X-Content-Hash\": content_hash,\n-            \"X-Key-Id\": self.tenant + ':' + self.application + ':' + \"default\",\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n             \"X-Key\": self.api_public_key_bytes,\n             \"X-Authorization\": standard_b64encode(signature),\n-            **headers\n+            **headers,\n         }\n \n         body.seek(0)\n         self.connection.request(method, path, body, headers)\n         with self.connection.getresponse() as response:\n             parsed = json.load(response)\n             if response.status != 200:\n-                raise RuntimeError(\"Status code \" + str(response.status) + \" doing \" + method + \" at \" + url + \":\\n\" + parsed['message'])\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n             return parsed\n \n     def get_dev_region(self) -> str:\n-        return self.request('GET', '/zone/v1/environment/dev/default')['name']\n-\n-    def get_endpoint(self, instance: str, region: str) -> str:\n-        endpoints = self.request('GET',\n-                                 '/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}' \\\n-                                 .format(self.tenant, self.application, instance, region))['endpoints']\n-        container_url = [endpoint['url'] for endpoint in endpoints if endpoint['cluster'] == 'test_app_container']\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n         if not container_url:\n             raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n         return container_url[0]\n \n-    def start_deployment(self, instance: str, job: str, application_package: ApplicationPackage) -> int:\n-        deploy_path = '/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}' \\\n-            .format(self.tenant, self.application, instance, job)\n-        application_zip_bytes = application_package.to_application_zip({ 'application/security/clients.pem': self.data_certificate.public_bytes(serialization.Encoding.PEM) })\n-        response = self.request('POST', deploy_path, application_zip_bytes, { 'Content-Type': 'application/zip' })\n-        print(response['message'])\n-        return response['run']\n+    def start_deployment(\n+        self, instance: str, job: str, application_package: ApplicationPackage\n+    ) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+        application_zip_bytes = application_package.to_application_zip(\n+            {\n+                \"application/security/clients.pem\": self.data_certificate.public_bytes(\n+                    serialization.Encoding.PEM\n+                )\n+            }\n+        )\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n \n     def follow_deployment(self, instance: str, job: str, run: int):\n         last = -1\n         while True:\n-            update = self.request('GET',\n-                                  '/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}' \\\n-                                  .format(self.tenant, self.application, instance, job, run, last))\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n \n-            for step, entries in update['log'].items():\n+            for step, entries in update[\"log\"].items():\n                 for entry in entries:\n                     self.print_log_entry(step, entry)\n-            last = update.get('lastId', last)\n+            last = update.get(\"lastId\", last)\n \n-            if update['active']:\n+            if update[\"active\"]:\n                 sleep(1)\n             else:\n-                status = update['status']\n-                if   status == 'success':                    return\n-                elif status == 'error':                      raise RuntimeError(\"Unexpected error during deployment; see log for details\")\n-                elif status == 'aborted':                    raise RuntimeError(\"Deployment was aborted, probably by a newer deployment\")\n-                elif status == 'outOfCapacity':              raise RuntimeError(\"No capacity left in zone; please contact the Vespa team\")\n-                elif status == 'deploymentFailed':           raise RuntimeError(\"Deployment failed; see log for details\")\n-                elif status == 'installationFailed':         raise RuntimeError(\"Installation failed; see Vespa log for details\")\n-                elif status == 'running':                    raise RuntimeError(\"Deployment not completed\")\n-                elif status == 'endpointCertificateTimeout': raise RuntimeError(\"Endpoint certificate not ready in time; please contact Vespa team\")\n-                elif status == 'testFailure':                raise RuntimeError(\"Unexpected status; tests are not run for manual deployments\")\n-                else:                                        raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "originalPosition": 319}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3Njc3MzMy", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-477677332", "createdAt": "2020-08-28T12:13:34Z", "commit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoxMzozNFrOHJA7CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoxMzozNFrOHJA7CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIxNDM0NA==", "bodyText": "@jonmv It would be nice to include the deployment_message argument when creating the Vespa instance. What would best represent the deployment message in the Vespa Cloud case?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r479214344", "createdAt": "2020-08-28T12:13:34Z", "author": {"login": "thigm85"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +499,264 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(self, tenant: str, application: str, key_location: str) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.data_cert_file = self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate\n+        )\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    @staticmethod\n+    def write_private_key_and_cert(\n+        key: ec.EllipticCurvePrivateKey, cert: x509.Certificate\n+    ) -> (str, str):\n+        cert_file = tempfile.NamedTemporaryFile(\"wt\")\n+        cert_file.write(\n+            key.private_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PrivateFormat.TraditionalOpenSSL,\n+                serialization.NoEncryption(),\n+            ).decode(\"UTF-8\")\n+        )\n+        cert_file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+        cert_file.flush()\n+        return cert_file\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def start_deployment(\n+        self, instance: str, job: str, application_package: ApplicationPackage\n+    ) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+        application_zip_bytes = application_package.to_application_zip(\n+            {\n+                \"application/security/clients.pem\": self.data_certificate.public_bytes(\n+                    serialization.Encoding.PEM\n+                )\n+            }\n+        )\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n+\n+            for step, entries in update[\"log\"].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get(\"lastId\", last)\n+\n+            if update[\"active\"]:\n+                sleep(1)\n+            else:\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")\n+\n+    @staticmethod\n+    def print_log_entry(step: str, entry: dict):\n+        timestamp = strftime(\"%H:%M:%S\", gmtime(entry[\"at\"] / 1e3))\n+        message = entry[\"message\"].replace(\"\\n\", \"\\n\" + \" \" * 23)\n+        if step != \"copyVespaLogs\" or entry[\"type\"] == \"error\":\n+            print(\"{:<7} [{}]  {}\".format(entry[\"type\"].upper(), timestamp, message))\n+\n+    def deploy(self, instance: str, application_package: ApplicationPackage) -> Vespa:\n+        \"\"\"\n+        Deploy the given application package as the given instance in the Vespa Cloud dev environment.\n+\n+        :param instance: Name of this instance of the application, in the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+\n+        :return: a Vespa connection instance.\n+        \"\"\"\n+        region = self.get_dev_region()\n+        job = \"dev-\" + region\n+        run = self.start_deployment(instance, job, application_package)\n+        self.follow_deployment(instance, job, run)\n+        endpoint_url = self.get_endpoint(\n+            instance=instance,\n+            region=region,\n+            application_package_name=application_package.name,\n+        )\n+        return Vespa(url=endpoint_url, cert=self.data_cert_file.name)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ea44156c1b3468ef175a094c8d81478f7c0009b"}, "originalPosition": 327}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a5bde7032c6641426725b65b934e99fb2410e68", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/6a5bde7032c6641426725b65b934e99fb2410e68", "committedDate": "2020-08-31T08:30:02Z", "message": "refactor VespaCloud code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/b95ad7d58de6aa1149fb921cc6464d8309420828", "committedDate": "2020-08-31T19:53:14Z", "message": "Merge pull request #14205 from vespa-engine/tgm/reestructure-python-deploy\n\nrefactor VespaCloud code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4OTE0MDQ3", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-478914047", "createdAt": "2020-08-31T20:01:58Z", "commit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NDQyMDEx", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-479442011", "createdAt": "2020-09-01T06:43:53Z", "commit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNjo0Mzo1NFrOHKmwsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNjo1Mjo1NlrOHKnMgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4Mjg2NQ==", "bodyText": "What is the difference between application_package_name and self.application?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480882865", "createdAt": "2020-09-01T06:43:54Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDE3Nw==", "bodyText": "Debug print() leftover?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480884177", "createdAt": "2020-09-01T06:45:35Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NDkzOQ==", "bodyText": "Why write the zip file to disk when you just send the memory backed buffer to self.request()?", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480884939", "createdAt": "2020-09-01T06:46:35Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4NzExMQ==", "bodyText": "I would consider splitting this into two methods. One that does a single poll and status report, and one that blocks and continually polls until deployment is done.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480887111", "createdAt": "2020-09-01T06:49:13Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg4OTk4NA==", "bodyText": "Consider moving status code -> message into a separate map to make this if-elif-else block shorter.", "url": "https://github.com/vespa-engine/vespa/pull/14165#discussion_r480889984", "createdAt": "2020-09-01T06:52:56Z", "author": {"login": "oyving"}, "path": "python/vespa/vespa/package.py", "diffHunk": "@@ -468,3 +490,289 @@ def deploy(self, disk_folder: str, container_memory: str = \"4G\"):\n             port=self.local_port,\n             deployment_message=deployment_message,\n         )\n+\n+\n+class VespaCloud(object):\n+    def __init__(\n+        self,\n+        tenant: str,\n+        application: str,\n+        key_location: str,\n+        application_package: ApplicationPackage,\n+    ) -> None:\n+        \"\"\"\n+        Deploy application to the Vespa Cloud (cloud.vespa.ai)\n+\n+        :param tenant: Tenant name registered in the Vespa Cloud.\n+        :param application: Application name registered in the Vespa Cloud.\n+        :param key_location: Location of the private key used for signing HTTP requests to the Vespa Cloud.\n+        :param application_package: ApplicationPackage to be deployed.\n+        \"\"\"\n+        self.tenant = tenant\n+        self.application = application\n+        self.application_package = application_package\n+        self.api_key = self.read_private_key(key_location)\n+        self.api_public_key_bytes = standard_b64encode(\n+            self.api_key.public_key().public_bytes(\n+                serialization.Encoding.PEM,\n+                serialization.PublicFormat.SubjectPublicKeyInfo,\n+            )\n+        )\n+        self.data_key, self.data_certificate = self.create_certificate_pair()\n+        self.private_cert_file_name = \"private_cert.txt\"\n+        self.connection = http.client.HTTPSConnection(\n+            \"api.vespa-external.aws.oath.cloud\", 4443\n+        )\n+\n+    @staticmethod\n+    def read_private_key(key_location: str) -> ec.EllipticCurvePrivateKey:\n+        with open(key_location, \"rb\") as key_data:\n+            key = serialization.load_pem_private_key(\n+                key_data.read(), None, default_backend()\n+            )\n+            if not isinstance(key, ec.EllipticCurvePrivateKey):\n+                raise TypeError(\n+                    \"Key at \" + key_location + \" must be an elliptic curve private key\"\n+                )\n+            return key\n+\n+    def write_private_key_and_cert(\n+        self, key: ec.EllipticCurvePrivateKey, cert: x509.Certificate, disk_folder: str\n+    ) -> None:\n+        cert_file = os.path.join(disk_folder, self.private_cert_file_name)\n+        with open(cert_file, \"w+\") as file:\n+            file.write(\n+                key.private_bytes(\n+                    serialization.Encoding.PEM,\n+                    serialization.PrivateFormat.TraditionalOpenSSL,\n+                    serialization.NoEncryption(),\n+                ).decode(\"UTF-8\")\n+            )\n+            file.write(cert.public_bytes(serialization.Encoding.PEM).decode(\"UTF-8\"))\n+\n+    @staticmethod\n+    def create_certificate_pair() -> (ec.EllipticCurvePrivateKey, x509.Certificate):\n+        key = ec.generate_private_key(ec.SECP384R1, default_backend())\n+        name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, u\"localhost\")])\n+        certificate = (\n+            x509.CertificateBuilder()\n+            .subject_name(name)\n+            .issuer_name(name)\n+            .serial_number(x509.random_serial_number())\n+            .not_valid_before(datetime.utcnow() - timedelta(minutes=1))\n+            .not_valid_after(datetime.utcnow() + timedelta(days=7))\n+            .public_key(key.public_key())\n+            .sign(key, hashes.SHA256(), default_backend())\n+        )\n+        return (key, certificate)\n+\n+    def request(\n+        self, method: str, path: str, body: BytesIO = BytesIO(), headers={}\n+    ) -> dict:\n+        digest = hashes.Hash(hashes.SHA256(), default_backend())\n+        body.seek(0)\n+        digest.update(body.read())\n+        content_hash = standard_b64encode(digest.finalize()).decode(\"UTF-8\")\n+        timestamp = (\n+            datetime.utcnow().isoformat() + \"Z\"\n+        )  # Java's Instant.parse requires the neutral time zone appended\n+        url = \"https://\" + self.connection.host + \":\" + str(self.connection.port) + path\n+\n+        canonical_message = method + \"\\n\" + url + \"\\n\" + timestamp + \"\\n\" + content_hash\n+        signature = self.api_key.sign(\n+            canonical_message.encode(\"UTF-8\"), ec.ECDSA(hashes.SHA256())\n+        )\n+\n+        headers = {\n+            \"X-Timestamp\": timestamp,\n+            \"X-Content-Hash\": content_hash,\n+            \"X-Key-Id\": self.tenant + \":\" + self.application + \":\" + \"default\",\n+            \"X-Key\": self.api_public_key_bytes,\n+            \"X-Authorization\": standard_b64encode(signature),\n+            **headers,\n+        }\n+\n+        body.seek(0)\n+        self.connection.request(method, path, body, headers)\n+        with self.connection.getresponse() as response:\n+            parsed = json.load(response)\n+            if response.status != 200:\n+                raise RuntimeError(\n+                    \"Status code \"\n+                    + str(response.status)\n+                    + \" doing \"\n+                    + method\n+                    + \" at \"\n+                    + url\n+                    + \":\\n\"\n+                    + parsed[\"message\"]\n+                )\n+            return parsed\n+\n+    def get_dev_region(self) -> str:\n+        return self.request(\"GET\", \"/zone/v1/environment/dev/default\")[\"name\"]\n+\n+    def get_endpoint(\n+        self, instance: str, region: str, application_package_name: str\n+    ) -> str:\n+        endpoints = self.request(\n+            \"GET\",\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/environment/dev/region/{}\".format(\n+                self.tenant, self.application, instance, region\n+            ),\n+        )[\"endpoints\"]\n+        container_url = [\n+            endpoint[\"url\"]\n+            for endpoint in endpoints\n+            if endpoint[\"cluster\"] == \"{}_container\".format(application_package_name)\n+        ]\n+        if not container_url:\n+            raise RuntimeError(\"No endpoints found for container 'test_app_container'\")\n+        return container_url[0]\n+\n+    def to_application_zip(self) -> BytesIO:\n+        buffer = BytesIO()\n+        with zipfile.ZipFile(buffer, \"a\") as zip_archive:\n+            zip_archive.writestr(\n+                \"application/schemas/{}.sd\".format(\n+                    self.application_package.schema.name\n+                ),\n+                self.application_package.schema_to_text,\n+            )\n+            zip_archive.writestr(\n+                \"application/services.xml\", self.application_package.services_to_text\n+            )\n+            zip_archive.writestr(\n+                \"application/security/clients.pem\",\n+                self.data_certificate.public_bytes(serialization.Encoding.PEM),\n+            )\n+\n+        return buffer\n+\n+    def start_deployment(self, instance: str, job: str, disk_folder: str) -> int:\n+        deploy_path = (\n+            \"/application/v4/tenant/{}/application/{}/instance/{}/deploy/{}\".format(\n+                self.tenant, self.application, instance, job\n+            )\n+        )\n+\n+        application_zip_bytes = self.to_application_zip()\n+\n+        self.write_private_key_and_cert(\n+            self.data_key, self.data_certificate, disk_folder\n+        )\n+        with open(os.path.join(disk_folder, \"application.zip\"), \"wb\") as zipfile:\n+            zipfile.write(application_zip_bytes.getvalue())\n+\n+        response = self.request(\n+            \"POST\",\n+            deploy_path,\n+            application_zip_bytes,\n+            {\"Content-Type\": \"application/zip\"},\n+        )\n+        print(response[\"message\"])\n+        return response[\"run\"]\n+\n+    def follow_deployment(self, instance: str, job: str, run: int):\n+        last = -1\n+        while True:\n+            update = self.request(\n+                \"GET\",\n+                \"/application/v4/tenant/{}/application/{}/instance/{}/job/{}/run/{}?after={}\".format(\n+                    self.tenant, self.application, instance, job, run, last\n+                ),\n+            )\n+\n+            for step, entries in update[\"log\"].items():\n+                for entry in entries:\n+                    self.print_log_entry(step, entry)\n+            last = update.get(\"lastId\", last)\n+\n+            if update[\"active\"]:\n+                sleep(1)\n+            else:\n+                status = update[\"status\"]\n+                if status == \"success\":\n+                    return\n+                elif status == \"error\":\n+                    raise RuntimeError(\n+                        \"Unexpected error during deployment; see log for details\"\n+                    )\n+                elif status == \"aborted\":\n+                    raise RuntimeError(\n+                        \"Deployment was aborted, probably by a newer deployment\"\n+                    )\n+                elif status == \"outOfCapacity\":\n+                    raise RuntimeError(\n+                        \"No capacity left in zone; please contact the Vespa team\"\n+                    )\n+                elif status == \"deploymentFailed\":\n+                    raise RuntimeError(\"Deployment failed; see log for details\")\n+                elif status == \"installationFailed\":\n+                    raise RuntimeError(\"Installation failed; see Vespa log for details\")\n+                elif status == \"running\":\n+                    raise RuntimeError(\"Deployment not completed\")\n+                elif status == \"endpointCertificateTimeout\":\n+                    raise RuntimeError(\n+                        \"Endpoint certificate not ready in time; please contact Vespa team\"\n+                    )\n+                elif status == \"testFailure\":\n+                    raise RuntimeError(\n+                        \"Unexpected status; tests are not run for manual deployments\"\n+                    )\n+                else:\n+                    raise RuntimeError(\"Unexpected status '\" + status + \"'\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b95ad7d58de6aa1149fb921cc6464d8309420828"}, "originalPosition": 357}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4caa167c822fadc35533c0328f4615e4e83d1a9", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/b4caa167c822fadc35533c0328f4615e4e83d1a9", "committedDate": "2020-09-01T08:12:00Z", "message": "remove unnecessary application_package_name argument"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2c3dbfb0afbab0d29dd0404bbfb97ea0c83e97c", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/e2c3dbfb0afbab0d29dd0404bbfb97ea0c83e97c", "committedDate": "2020-09-01T08:28:19Z", "message": "remove unnecessary library"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53276570bec1d4380756ec60f30dd51b3626c83f", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/53276570bec1d4380756ec60f30dd51b3626c83f", "committedDate": "2020-09-01T08:37:46Z", "message": "add underscore for private methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76f9207ca0595a29e60b5e2ae7eaac571d8d9319", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/76f9207ca0595a29e60b5e2ae7eaac571d8d9319", "committedDate": "2020-09-01T08:57:58Z", "message": "split _follow_deployment into two methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9891a14ba87f40e2593a619468a372727f9f9e4a", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/9891a14ba87f40e2593a619468a372727f9f9e4a", "committedDate": "2020-09-01T09:06:54Z", "message": "simplify if block with status_message dict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e57fb7f186a4f82faa50d36c1e68a783d684410", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/3e57fb7f186a4f82faa50d36c1e68a783d684410", "committedDate": "2020-09-01T10:27:31Z", "message": "print now write to self.output"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d33cf55e6c8914c066052b45a2e082725723e47c", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/d33cf55e6c8914c066052b45a2e082725723e47c", "committedDate": "2020-09-01T10:30:20Z", "message": "do not write zip file to disk"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aff555c1504adc2becf3a384ea1baac9804019ef", "author": {"user": {"login": "thigm85", "name": "Thiago G. Martins"}}, "url": "https://github.com/vespa-engine/vespa/commit/aff555c1504adc2becf3a384ea1baac9804019ef", "committedDate": "2020-09-01T10:37:59Z", "message": "create outfile_file argument with sys.output as default."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NjE2OTQx", "url": "https://github.com/vespa-engine/vespa/pull/14165#pullrequestreview-479616941", "createdAt": "2020-09-01T10:40:02Z", "commit": {"oid": "aff555c1504adc2becf3a384ea1baac9804019ef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4460, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}