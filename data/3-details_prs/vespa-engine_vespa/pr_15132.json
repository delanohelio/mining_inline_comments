{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzODkxNjM5", "number": 15132, "title": "Arnej/add generic peek instruction", "bodyText": "I confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.\n@havardpe please review", "createdAt": "2020-11-02T08:31:49Z", "url": "https://github.com/vespa-engine/vespa/pull/15132", "merged": true, "mergeCommit": {"oid": "0b902f8a83015de3f37c8adb449f360add305780"}, "closed": true, "closedAt": "2020-11-03T12:26:08Z", "author": {"login": "arnej27959"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdYgUzRAH2gAyNTEzODkxNjM5Ojc0ZjA3MDMxZTgwZmFjODM5MWY3MGJkOTQ2MTFmZGZlMzM0Nzk3NDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdY3VC5gFqTUyMjM5OTM0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "74f07031e80fac8391f70bd94611fdfe33479741", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/74f07031e80fac8391f70bd94611fdfe33479741", "committedDate": "2020-11-02T08:31:06Z", "message": "add GenericPeek instruction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2df87df2442f55bd5b11e4b05d50495c33e175ef", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/2df87df2442f55bd5b11e4b05d50495c33e175ef", "committedDate": "2020-11-02T08:31:06Z", "message": "also verify peek wiring in TensorFunction"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNDcyMzQ0", "url": "https://github.com/vespa-engine/vespa/pull/15132#pullrequestreview-521472344", "createdAt": "2020-11-02T09:46:29Z", "commit": {"oid": "2df87df2442f55bd5b11e4b05d50495c33e175ef"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTo0NjozMFrOHr9BLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwOTo0NjozMFrOHr9BLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1MDU0MQ==", "bodyText": "you can pass dense_output + input_offset to the plan so you do not have to add it for each cell in the inner loop.", "url": "https://github.com/vespa-engine/vespa/pull/15132#discussion_r515850541", "createdAt": "2020-11-02T09:46:30Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/instruction/generic_peek.cpp", "diffHunk": "@@ -0,0 +1,364 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"generic_peek.h\"\n+#include <vespa/eval/eval/nested_loop.h>\n+#include <vespa/eval/eval/wrap_param.h>\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/stash.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+\n+using namespace vespalib::eval::tensor_function;\n+\n+namespace vespalib::eval::instruction {\n+\n+using State = InterpretedFunction::State;\n+using Instruction = InterpretedFunction::Instruction;\n+\n+namespace {\n+\n+static constexpr size_t npos = -1;\n+\n+enum class Source { FROM_CHILD, VERBATIM };\n+\n+using Spec = GenericPeek::SpecMap;\n+\n+size_t count_children(const Spec &spec)\n+{\n+    size_t num_children = 0;\n+    for (const auto & [dim_name, child_or_label] : spec) {\n+        if (std::holds_alternative<size_t>(child_or_label)) {\n+            ++num_children;\n+        }\n+    }\n+    return num_children;\n+}\n+\n+struct ExtractedSpecs {\n+    using Dimension = ValueType::Dimension;\n+    struct MyComp {\n+        bool operator() (const Dimension &a, const Spec::value_type &b) { return a.name < b.first; }\n+        bool operator() (const Spec::value_type &a, const Dimension &b) { return a.first < b.name; }\n+    };\n+    struct DimSpec {\n+        Source source;\n+        vespalib::stringref name;\n+        GenericPeek::MyLabel child_or_label;\n+        size_t get_child_idx() const {\n+            return std::get<size_t>(child_or_label);\n+        }\n+        TensorSpec::Label get_label() const {\n+            return std::get<TensorSpec::Label>(child_or_label);\n+        }\n+    };\n+    std::vector<Dimension> dimensions;\n+    std::vector<DimSpec> specs;\n+\n+    ExtractedSpecs(bool indexed,\n+                   const std::vector<Dimension> &input_dims,\n+                   const Spec &spec)\n+    {\n+        auto visitor = overload\n+        {\n+            [&](visit_ranges_first, const auto &a) {\n+                if (a.is_indexed() == indexed) dimensions.push_back(a);\n+            },\n+            [&](visit_ranges_second, const auto &) {\n+                // spec has unknown dimension\n+                abort();\n+            },\n+            [&](visit_ranges_both, const auto &a, const auto &b) {\n+                if (a.is_indexed() == indexed) {\n+                    dimensions.push_back(a);\n+                    const auto & [spec_dim_name, child_or_label] = b;\n+                    assert(a.name == spec_dim_name);\n+                    if (std::holds_alternative<size_t>(child_or_label)) {\n+                        specs.emplace_back(DimSpec{Source::FROM_CHILD, a.name, child_or_label});\n+                    } else {\n+                        specs.emplace_back(DimSpec{Source::VERBATIM, a.name, child_or_label});\n+                    }\n+                }\n+            }\n+        };\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     spec.begin(), spec.end(), MyComp());\n+    }\n+    ~ExtractedSpecs();\n+};\n+ExtractedSpecs::~ExtractedSpecs() = default;\n+\n+struct DenseSizes {\n+    std::vector<size_t> size;\n+    std::vector<size_t> stride;\n+    size_t cur_size;\n+\n+    DenseSizes(const std::vector<ValueType::Dimension> &dims)\n+        : size(), stride(), cur_size(1)\n+    {\n+        for (const auto &dim : dims) {\n+            assert(dim.is_indexed());\n+            size.push_back(dim.size);\n+        }\n+        stride.resize(size.size());\n+        for (size_t i = size.size(); i-- > 0; ) {\n+            stride[i] = cur_size;\n+            cur_size *= size[i];\n+        }\n+    }\n+};\n+\n+/** Compute input offsets for all output cells */\n+struct DensePlan {\n+    size_t in_dense_size;\n+    size_t out_dense_size;\n+    std::vector<size_t> loop_cnt;\n+    std::vector<size_t> in_stride;\n+    size_t verbatim_offset = 0;\n+    std::vector<size_t> children;\n+    std::vector<size_t> child_stride;\n+    std::vector<size_t> child_limit;\n+\n+    DensePlan(const ValueType &input_type, const Spec &spec)\n+    {\n+        const ExtractedSpecs mine(true, input_type.dimensions(), spec);\n+        DenseSizes sizes(mine.dimensions);\n+        in_dense_size = sizes.cur_size;\n+        out_dense_size = 1;\n+        auto pos = mine.specs.begin();\n+        for (size_t i = 0; i < mine.dimensions.size(); ++i) {\n+            const auto &dim = mine.dimensions[i];\n+            if ((pos == mine.specs.end()) || (dim.name < pos->name)) {\n+                loop_cnt.push_back(sizes.size[i]);\n+                in_stride.push_back(sizes.stride[i]);\n+                out_dense_size *= sizes.size[i];\n+            } else {\n+                assert(dim.name == pos->name);\n+                switch(pos->source) {\n+                case Source::FROM_CHILD:\n+                    child_stride.push_back(sizes.stride[i]);\n+                    children.push_back(pos->get_child_idx());\n+                    child_limit.push_back(sizes.size[i]);\n+                    break;\n+                case Source::VERBATIM:\n+                    const auto &label = pos->get_label();\n+                    assert(label.is_indexed());\n+                    assert(label.index < sizes.size[i]);\n+                    verbatim_offset += label.index * sizes.stride[i];\n+                    break;\n+                }\n+                ++pos;\n+            }\n+        }\n+        assert(pos == mine.specs.end());\n+    }\n+\n+    /** Get initial offset (from verbatim labels and child values) */\n+    template <typename Getter>\n+    size_t get_offset(const Getter &get_child_value) const {\n+        size_t offset = verbatim_offset;\n+        for (size_t i = 0; i < children.size(); ++i) {\n+            size_t from_child = get_child_value(children[i]);\n+            if (from_child < child_limit[i]) {\n+                offset += from_child * child_stride[i];\n+            } else {\n+                return npos;\n+            }\n+        }\n+        return offset;\n+    }\n+\n+    template<typename F> void execute(size_t offset, const F &f) const {\n+        run_nested_loop<F>(offset, loop_cnt, in_stride, f);\n+    }\n+};\n+\n+struct SparseState {\n+    std::vector<vespalib::string> view_addr;\n+    std::vector<vespalib::stringref> view_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<vespalib::stringref> output_addr;\n+    std::vector<vespalib::stringref *> fetch_addr;\n+\n+    SparseState(std::vector<vespalib::string> view_addr_in, size_t out_dims)\n+        : view_addr(std::move(view_addr_in)),\n+          view_refs(view_addr.size()),\n+          lookup_refs(view_addr.size()),\n+          output_addr(out_dims),\n+          fetch_addr(out_dims)\n+    {\n+        for (size_t i = 0; i < view_addr.size(); ++i) {\n+            view_refs[i] = view_addr[i];\n+            lookup_refs[i] = &view_refs[i];\n+        }\n+        for (size_t i = 0; i < out_dims; ++i) {\n+            fetch_addr[i] = &output_addr[i];\n+        }\n+    }\n+    ~SparseState();\n+};\n+SparseState::~SparseState() = default;\n+\n+struct SparsePlan {\n+    size_t out_mapped_dims;\n+    std::vector<Source> sources;\n+    std::vector<vespalib::string> verbatim;\n+    std::vector<size_t> view_dims;\n+    std::vector<size_t> children;\n+\n+    SparsePlan(const ValueType &input_type,\n+               const GenericPeek::SpecMap &spec)\n+        : out_mapped_dims(0), sources(), verbatim(), view_dims(), children()\n+    {\n+        const ExtractedSpecs mine(false, input_type.dimensions(), spec);\n+        auto pos = mine.specs.begin();\n+        for (size_t dim_idx = 0; dim_idx < mine.dimensions.size(); ++dim_idx) {\n+            const auto & dim = mine.dimensions[dim_idx];\n+            if ((pos == mine.specs.end()) || (dim.name < pos->name)) {\n+                ++out_mapped_dims;\n+            } else {\n+                assert(dim.name == pos->name);\n+                view_dims.push_back(dim_idx);\n+                sources.push_back(pos->source);\n+                switch (pos->source) {\n+                case Source::FROM_CHILD:\n+                    children.push_back(pos->get_child_idx());\n+                    break;\n+                case Source::VERBATIM:\n+                    const auto &label = pos->get_label();\n+                    assert(label.is_mapped());\n+                    verbatim.push_back(label.name);\n+                    break;\n+                }\n+                ++pos;\n+            }\n+        }\n+        assert(pos == mine.specs.end());\n+    }\n+\n+    ~SparsePlan();\n+\n+    template <typename Getter>\n+    SparseState make_state(const Getter &get_child_value) const {\n+        std::vector<vespalib::string> view_addr;\n+        auto vpos = verbatim.begin();\n+        auto cpos = children.begin();\n+        for (auto source : sources) {\n+            switch (source) {\n+            case Source::VERBATIM:\n+                view_addr.push_back(*vpos++);\n+                break;\n+            case Source::FROM_CHILD:\n+                view_addr.push_back(vespalib::make_string(\"%\" PRId64, get_child_value(*cpos++)));\n+                break;\n+            }\n+        }\n+        assert(vpos == verbatim.end());\n+        assert(cpos == children.end());\n+        assert(view_addr.size() == view_dims.size());\n+        return SparseState(std::move(view_addr), out_mapped_dims);\n+    }\n+};\n+SparsePlan::~SparsePlan() = default;\n+\n+struct PeekParam {\n+    const ValueType res_type;\n+    DensePlan dense_plan;\n+    SparsePlan sparse_plan;\n+    size_t num_children;\n+    const ValueBuilderFactory &factory;\n+\n+    PeekParam(const ValueType &input_type,\n+              const ValueType &res_type_in,\n+              const GenericPeek::SpecMap &spec_in,\n+              const ValueBuilderFactory &factory_in)\n+        : res_type(res_type_in),\n+          dense_plan(input_type, spec_in),\n+          sparse_plan(input_type, spec_in),\n+          num_children(count_children(spec_in)),\n+          factory(factory_in)\n+    {\n+        assert(dense_plan.in_dense_size == input_type.dense_subspace_size());\n+        assert(dense_plan.out_dense_size == res_type.dense_subspace_size());\n+    }\n+};\n+\n+template <typename ICT, typename OCT, typename Getter>\n+Value::UP\n+generic_mixed_peek(const ValueType &res_type,\n+                   const Value &input_value,\n+                   const SparsePlan &sparse_plan,\n+                   const DensePlan &dense_plan,\n+                   const ValueBuilderFactory &factory,\n+                   const Getter &get_child_value)\n+{\n+    auto input_cells = input_value.cells().typify<ICT>();\n+    size_t bad_guess = 1;\n+    auto builder = factory.create_value_builder<OCT>(res_type,\n+                                                     sparse_plan.out_mapped_dims,\n+                                                     dense_plan.out_dense_size,\n+                                                     bad_guess);\n+    size_t filled_subspaces = 0;\n+    size_t dense_offset = dense_plan.get_offset(get_child_value);\n+    if (dense_offset != npos) {\n+        SparseState state = sparse_plan.make_state(get_child_value);\n+        auto view = input_value.index().create_view(sparse_plan.view_dims);\n+        view->lookup(state.lookup_refs);\n+        size_t input_subspace;\n+        while (view->next_result(state.fetch_addr, input_subspace)) {\n+            auto dst = builder->add_subspace(state.output_addr).begin();\n+            auto input_offset = input_subspace * dense_plan.in_dense_size;\n+            dense_plan.execute(dense_offset,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2df87df2442f55bd5b11e4b05d50495c33e175ef"}, "originalPosition": 312}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ab640d4c04d417cca5573541fdf17db0e400978", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/1ab640d4c04d417cca5573541fdf17db0e400978", "committedDate": "2020-11-02T09:55:37Z", "message": "move add of input_offset to execute startup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17a344730bca802521110c56c37f47ed16965a03", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/17a344730bca802521110c56c37f47ed16965a03", "committedDate": "2020-11-03T10:43:10Z", "message": "refactor, simplify, and cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMzk5MzQ5", "url": "https://github.com/vespa-engine/vespa/pull/15132#pullrequestreview-522399349", "createdAt": "2020-11-03T11:19:11Z", "commit": {"oid": "17a344730bca802521110c56c37f47ed16965a03"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2084, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}