{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMjQxNzQx", "number": 14848, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMTozNjozNFrOEtcOKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMTozNjozNFrOEtcOKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2MDgzNzUzOnYy", "diffSide": "RIGHT", "path": "storage/src/vespa/storage/visiting/visitormanager.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMTozNjozNFrOHhOuQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMjowOTowOFrOHhPzcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYwNjI3Mg==", "bodyText": "I'm a bit puzzled by the original code here. Since the queued timestamp and currentTime are both in microseconds, dividing by 1,000,000 implies that timediff is in discrete seconds and not in milliseconds. Expected wait period will therefore be off by a few orders of magnitude... I don't think this has mattered in practice, since it just means we'll wake up the thread more frequently than strictly required.", "url": "https://github.com/vespa-engine/vespa/pull/14848#discussion_r504606272", "createdAt": "2020-10-14T11:36:34Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/visiting/visitormanager.cpp", "diffHunk": "@@ -208,39 +202,33 @@ VisitorManager::run(framework::ThreadHandle& thread)\n     while (true) {\n         thread.registerTick(framework::PROCESS_CYCLE);\n         {\n-            vespalib::LockGuard waiter(_visitorLock);\n+            std::lock_guard waiter(_visitorLock);\n             if (thread.interrupted()) {\n                 break;\n             }\n             timedOut = _visitorQueue.releaseTimedOut();\n         }\n-        framework::MicroSecTime currentTime(\n-                _component.getClock().getTimeInMicros());\n+        framework::MicroSecTime currentTime(_component.getClock().getTimeInMicros());\n         for (std::list<CQ::CommandEntry>::iterator it = timedOut.begin();\n              it != timedOut.end(); ++it)\n         {\n-            _metrics->queueTimeoutWaitTime.addValue(\n-                    currentTime.getTime() - it->_time);\n-            std::shared_ptr<api::StorageReply> reply(\n-                    it->_command->makeReply().release());\n-            reply->setResult(api::ReturnCode(api::ReturnCode::BUSY,\n-                                        \"Visitor timed out in visitor queue\"));\n+            _metrics->queueTimeoutWaitTime.addValue(currentTime.getTime() - it->_time);\n+            std::shared_ptr<api::StorageReply> reply(it->_command->makeReply());\n+            reply->setResult(api::ReturnCode(api::ReturnCode::BUSY,\"Visitor timed out in visitor queue\"));\n             sendUp(reply);\n         }\n         {\n-            vespalib::MonitorGuard waiter(_visitorLock);\n+            std::unique_lock waiter(_visitorLock);\n             if (thread.interrupted()) {\n                 break;\n             } else if (_visitorQueue.empty()) {\n-                waiter.wait(1000);\n+                _visitorCond.wait_for(waiter, 1000ms);\n                 thread.registerTick(framework::WAIT_CYCLE);\n             } else {\n-                uint64_t timediff = (_visitorQueue.tbegin()->_time\n-                                     - currentTime.getTime())\n-                                            / 1000000;\n+                uint64_t timediff = (_visitorQueue.tbegin()->_time- currentTime.getTime()) / 1000000;\n                 timediff = std::min(timediff, uint64_t(1000));\n                 if (timediff > 0) {\n-                    waiter.wait(timediff);\n+                    _visitorCond.wait_for(waiter, std::chrono::milliseconds(timediff));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6184c299103e4967c4413939b2d50249a3c09258"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYyMzk4NA==", "bodyText": "Then we are 2. I think it is overdue to replace replace the framework times with vespalib::duration. I think that was one of things we postponed last time we tried to unify time.", "url": "https://github.com/vespa-engine/vespa/pull/14848#discussion_r504623984", "createdAt": "2020-10-14T12:09:08Z", "author": {"login": "baldersheim"}, "path": "storage/src/vespa/storage/visiting/visitormanager.cpp", "diffHunk": "@@ -208,39 +202,33 @@ VisitorManager::run(framework::ThreadHandle& thread)\n     while (true) {\n         thread.registerTick(framework::PROCESS_CYCLE);\n         {\n-            vespalib::LockGuard waiter(_visitorLock);\n+            std::lock_guard waiter(_visitorLock);\n             if (thread.interrupted()) {\n                 break;\n             }\n             timedOut = _visitorQueue.releaseTimedOut();\n         }\n-        framework::MicroSecTime currentTime(\n-                _component.getClock().getTimeInMicros());\n+        framework::MicroSecTime currentTime(_component.getClock().getTimeInMicros());\n         for (std::list<CQ::CommandEntry>::iterator it = timedOut.begin();\n              it != timedOut.end(); ++it)\n         {\n-            _metrics->queueTimeoutWaitTime.addValue(\n-                    currentTime.getTime() - it->_time);\n-            std::shared_ptr<api::StorageReply> reply(\n-                    it->_command->makeReply().release());\n-            reply->setResult(api::ReturnCode(api::ReturnCode::BUSY,\n-                                        \"Visitor timed out in visitor queue\"));\n+            _metrics->queueTimeoutWaitTime.addValue(currentTime.getTime() - it->_time);\n+            std::shared_ptr<api::StorageReply> reply(it->_command->makeReply());\n+            reply->setResult(api::ReturnCode(api::ReturnCode::BUSY,\"Visitor timed out in visitor queue\"));\n             sendUp(reply);\n         }\n         {\n-            vespalib::MonitorGuard waiter(_visitorLock);\n+            std::unique_lock waiter(_visitorLock);\n             if (thread.interrupted()) {\n                 break;\n             } else if (_visitorQueue.empty()) {\n-                waiter.wait(1000);\n+                _visitorCond.wait_for(waiter, 1000ms);\n                 thread.registerTick(framework::WAIT_CYCLE);\n             } else {\n-                uint64_t timediff = (_visitorQueue.tbegin()->_time\n-                                     - currentTime.getTime())\n-                                            / 1000000;\n+                uint64_t timediff = (_visitorQueue.tbegin()->_time- currentTime.getTime()) / 1000000;\n                 timediff = std::min(timediff, uint64_t(1000));\n                 if (timediff > 0) {\n-                    waiter.wait(timediff);\n+                    _visitorCond.wait_for(waiter, std::chrono::milliseconds(timediff));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYwNjI3Mg=="}, "originalCommit": {"oid": "6184c299103e4967c4413939b2d50249a3c09258"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1154, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}