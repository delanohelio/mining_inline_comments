{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNTA5MzQx", "number": 13788, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzoyMzowOVrOEK5Qrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzoyMzowOVrOEK5Qrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODU5Mzc0OnYy", "diffSide": "RIGHT", "path": "vespa-osgi-testrunner/src/main/java/com/yahoo/vespa/testrunner/TestRunnerHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzoyMzowOVrOGsMq7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzoyMzowOVrOGsMq7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5ODEyNA==", "bodyText": "Consider replacing these classes with equivalents from container-core.", "url": "https://github.com/vespa-engine/vespa/pull/13788#discussion_r448998124", "createdAt": "2020-07-02T13:23:09Z", "author": {"login": "bjorncs"}, "path": "vespa-osgi-testrunner/src/main/java/com/yahoo/vespa/testrunner/TestRunnerHandler.java", "diffHunk": "@@ -0,0 +1,177 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.vespa.testrunner;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.google.inject.Inject;\n+import com.yahoo.container.jdisc.HttpRequest;\n+import com.yahoo.container.jdisc.HttpResponse;\n+import com.yahoo.container.jdisc.LoggingRequestHandler;\n+import com.yahoo.container.logging.AccessLog;\n+import com.yahoo.slime.Cursor;\n+import com.yahoo.slime.JsonFormat;\n+import com.yahoo.slime.Slime;\n+import com.yahoo.vespa.testrunner.legacy.LegacyTestRunner;\n+import com.yahoo.vespa.testrunner.legacy.TestProfile;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.util.Collection;\n+import java.util.concurrent.Executor;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+\n+import static com.yahoo.jdisc.Response.Status;\n+\n+/**\n+ * @author valerijf\n+ * @author jvenstad\n+ * @author mortent\n+ */\n+public class TestRunnerHandler extends LoggingRequestHandler {\n+\n+    private static final String CONTENT_TYPE_APPLICATION_JSON = \"application/json\";\n+\n+    private final JunitRunner junitRunner;\n+    private final LegacyTestRunner testRunner;\n+    private final boolean useOsgiMode;\n+\n+    @Inject\n+    public TestRunnerHandler(Executor executor, AccessLog accessLog, JunitRunner junitRunner, LegacyTestRunner testRunner) {\n+        super(executor, accessLog);\n+        this.junitRunner = junitRunner;\n+        this.testRunner = testRunner;\n+        this.useOsgiMode = junitRunner.isSupported();\n+    }\n+\n+    @Override\n+    public HttpResponse handle(HttpRequest request) {\n+        try {\n+            switch (request.getMethod()) {\n+                case GET: return handleGET(request);\n+                case POST: return handlePOST(request);\n+\n+                default: return new Response(Status.METHOD_NOT_ALLOWED, \"Method '\" + request.getMethod() + \"' is not supported\");\n+            }\n+        } catch (IllegalArgumentException e) {\n+            return new Response(Status.BAD_REQUEST, Exceptions.toMessageString(e));\n+        } catch (Exception e) {\n+            log.log(Level.WARNING, \"Unexpected error handling '\" + request.getUri() + \"'\", e);\n+            return new Response(Status.INTERNAL_SERVER_ERROR, Exceptions.toMessageString(e));\n+        }\n+    }\n+\n+    private HttpResponse handleGET(HttpRequest request) {\n+        String path = request.getUri().getPath();\n+        if (path.equals(\"/tester/v1/log\")) {\n+            return new SlimeJsonResponse(logToSlime(testRunner.getLog(request.hasProperty(\"after\")\n+                                                                               ? Long.parseLong(request.getProperty(\"after\"))\n+                                                                               : -1)));\n+        } else if (path.equals(\"/tester/v1/status\")) {\n+            log.info(\"Responding with status \" + testRunner.getStatus());\n+            return new Response(testRunner.getStatus().name());\n+        }\n+        return new Response(Status.NOT_FOUND, \"Not found: \" + request.getUri().getPath());\n+    }\n+\n+    private HttpResponse handlePOST(HttpRequest request) throws IOException {\n+        final String path = request.getUri().getPath();\n+        if (path.startsWith(\"/tester/v1/run/\")) {\n+            String type = lastElement(path);\n+            TestProfile testProfile = TestProfile.valueOf(type.toUpperCase() + \"_TEST\");\n+            byte[] config = request.getData().readAllBytes();\n+            testRunner.test(testProfile, config);\n+            log.info(\"Started tests of type \" + type + \" and status is \" + testRunner.getStatus());\n+            return new Response(\"Successfully started \" + type + \" tests\");\n+        }\n+        return new Response(Status.NOT_FOUND, \"Not found: \" + request.getUri().getPath());\n+    }\n+\n+    private static String lastElement(String path) {\n+        if (path.endsWith(\"/\"))\n+            path = path.substring(0, path.length() - 1);\n+        int lastSlash = path.lastIndexOf(\"/\");\n+        if (lastSlash < 0) return path;\n+        return path.substring(lastSlash + 1);\n+    }\n+\n+    static Slime logToSlime(Collection<LogRecord> log) {\n+        Slime slime = new Slime();\n+        Cursor root = slime.setObject();\n+        Cursor recordArray = root.setArray(\"logRecords\");\n+        logArrayToSlime(recordArray, log);\n+        return slime;\n+    }\n+\n+    static void logArrayToSlime(Cursor recordArray, Collection<LogRecord> log) {\n+        log.forEach(record -> {\n+            Cursor recordObject = recordArray.addObject();\n+            recordObject.setLong(\"id\", record.getSequenceNumber());\n+            recordObject.setLong(\"at\", record.getMillis());\n+            recordObject.setString(\"type\", typeOf(record.getLevel()));\n+            String message = record.getMessage();\n+            if (record.getThrown() != null) {\n+                ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+                record.getThrown().printStackTrace(new PrintStream(buffer));\n+                message += \"\\n\" + buffer;\n+            }\n+            recordObject.setString(\"message\", message);\n+        });\n+    }\n+\n+    public static String typeOf(Level level) {\n+        return    level.getName().equals(\"html\") ? \"html\"\n+                : level.intValue() < Level.INFO.intValue() ? \"debug\"\n+                : level.intValue() < Level.WARNING.intValue() ? \"info\"\n+                : level.intValue() < Level.SEVERE.intValue() ? \"warning\"\n+                : \"error\";\n+    }\n+\n+    private static class SlimeJsonResponse extends HttpResponse {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac07745df504a8642ee3b9edd9f8bad78544181"}, "originalPosition": 133}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1837, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}