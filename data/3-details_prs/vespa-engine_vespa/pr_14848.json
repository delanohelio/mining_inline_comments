{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzMjQxNzQx", "number": 14848, "title": "Use std::mutex/std::condition instead of vespalib::Monitor.", "bodyText": "@vekterli PR", "createdAt": "2020-10-14T09:35:10Z", "url": "https://github.com/vespa-engine/vespa/pull/14848", "merged": true, "mergeCommit": {"oid": "a772b100924a2faf79577931cc9ecbbe9f1c9d95"}, "closed": true, "closedAt": "2020-10-14T12:09:18Z", "author": {"login": "baldersheim"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSZx9WAH2gAyNTAzMjQxNzQxOjYxODRjMjk5MTAzZTQ5NjdjNDQxMzkzOWIyZDUwMjQ5YTNjMDkyNTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSbs6fAFqTUwODI1NDIyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6184c299103e4967c4413939b2d50249a3c09258", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/6184c299103e4967c4413939b2d50249a3c09258", "committedDate": "2020-10-14T09:30:04Z", "message": "Use std::mutex/std::condition instead of vespalib::Monitor."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4MjU0MjIy", "url": "https://github.com/vespa-engine/vespa/pull/14848#pullrequestreview-508254222", "createdAt": "2020-10-14T11:36:34Z", "commit": {"oid": "6184c299103e4967c4413939b2d50249a3c09258"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMTozNjozNFrOHhOuQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxMTozNjozNFrOHhOuQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDYwNjI3Mg==", "bodyText": "I'm a bit puzzled by the original code here. Since the queued timestamp and currentTime are both in microseconds, dividing by 1,000,000 implies that timediff is in discrete seconds and not in milliseconds. Expected wait period will therefore be off by a few orders of magnitude... I don't think this has mattered in practice, since it just means we'll wake up the thread more frequently than strictly required.", "url": "https://github.com/vespa-engine/vespa/pull/14848#discussion_r504606272", "createdAt": "2020-10-14T11:36:34Z", "author": {"login": "vekterli"}, "path": "storage/src/vespa/storage/visiting/visitormanager.cpp", "diffHunk": "@@ -208,39 +202,33 @@ VisitorManager::run(framework::ThreadHandle& thread)\n     while (true) {\n         thread.registerTick(framework::PROCESS_CYCLE);\n         {\n-            vespalib::LockGuard waiter(_visitorLock);\n+            std::lock_guard waiter(_visitorLock);\n             if (thread.interrupted()) {\n                 break;\n             }\n             timedOut = _visitorQueue.releaseTimedOut();\n         }\n-        framework::MicroSecTime currentTime(\n-                _component.getClock().getTimeInMicros());\n+        framework::MicroSecTime currentTime(_component.getClock().getTimeInMicros());\n         for (std::list<CQ::CommandEntry>::iterator it = timedOut.begin();\n              it != timedOut.end(); ++it)\n         {\n-            _metrics->queueTimeoutWaitTime.addValue(\n-                    currentTime.getTime() - it->_time);\n-            std::shared_ptr<api::StorageReply> reply(\n-                    it->_command->makeReply().release());\n-            reply->setResult(api::ReturnCode(api::ReturnCode::BUSY,\n-                                        \"Visitor timed out in visitor queue\"));\n+            _metrics->queueTimeoutWaitTime.addValue(currentTime.getTime() - it->_time);\n+            std::shared_ptr<api::StorageReply> reply(it->_command->makeReply());\n+            reply->setResult(api::ReturnCode(api::ReturnCode::BUSY,\"Visitor timed out in visitor queue\"));\n             sendUp(reply);\n         }\n         {\n-            vespalib::MonitorGuard waiter(_visitorLock);\n+            std::unique_lock waiter(_visitorLock);\n             if (thread.interrupted()) {\n                 break;\n             } else if (_visitorQueue.empty()) {\n-                waiter.wait(1000);\n+                _visitorCond.wait_for(waiter, 1000ms);\n                 thread.registerTick(framework::WAIT_CYCLE);\n             } else {\n-                uint64_t timediff = (_visitorQueue.tbegin()->_time\n-                                     - currentTime.getTime())\n-                                            / 1000000;\n+                uint64_t timediff = (_visitorQueue.tbegin()->_time- currentTime.getTime()) / 1000000;\n                 timediff = std::min(timediff, uint64_t(1000));\n                 if (timediff > 0) {\n-                    waiter.wait(timediff);\n+                    _visitorCond.wait_for(waiter, std::chrono::milliseconds(timediff));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6184c299103e4967c4413939b2d50249a3c09258"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2372, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}