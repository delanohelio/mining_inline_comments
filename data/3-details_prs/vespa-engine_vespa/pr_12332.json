{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NTQzOTE3", "number": 12332, "title": "Adding more threads does not work when the Q is unbound. Use a Synchr\u2026", "bodyText": "\u2026onousQ instead.\n@havardpe PR", "createdAt": "2020-02-25T12:10:30Z", "url": "https://github.com/vespa-engine/vespa/pull/12332", "merged": true, "mergeCommit": {"oid": "c5fe9ef400333b1e2958b442cc0a6379cc4efaaf"}, "closed": true, "closedAt": "2020-02-25T15:21:09Z", "author": {"login": "baldersheim"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHw-5rAH2gAyMzc5NTQzOTE3OmYxNzY5MGQ5NTMzZWVmMGYyNDcxNTc3MTg0MzY5NTQ4YjBmM2IzODA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHztckgH2gAyMzc5NTQzOTE3OjYyZWEwOTJkOWZiYTgzNjcwYTZiOTkyM2VjNzc2ZDkxMGMzMzFkMzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f17690d9533eef0f2471577184369548b0f3b380", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/f17690d9533eef0f2471577184369548b0f3b380", "committedDate": "2020-02-25T12:07:42Z", "message": "Adding more threads does not work when the Q is unbound. Use a SynchronousQ instead."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/d7d87a8e45e0dace606493dfed2f903a614b76f7", "committedDate": "2020-02-25T14:23:58Z", "message": "Use a global bounded cached tread pool as primary, and a single threaded one for fallback."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MjA0NzA0", "url": "https://github.com/vespa-engine/vespa/pull/12332#pullrequestreview-364204704", "createdAt": "2020-02-25T14:55:43Z", "commit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NTo0M1rOFuJNgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1OTo0OFrOFuJY6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTczMQ==", "bodyText": "I suggest having a method to wait for an executor completion and calling it for each executor", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383929731", "createdAt": "2020-02-25T14:55:43Z", "author": {"login": "havardpe"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(), ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.primary\"));\n+                globalFallbackExecutor = Executors.newSingleThreadExecutor(ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.fallback\"));\n+            }\n+            usages ++;\n+            return new ExecutorWithFallback(globalPrimaryExecutor, globalFallbackExecutor);\n         }\n     }\n \n-    public Connector shutdown() {\n-        executor.shutdown();\n-        return this;\n+    private static void release(ExecutorWithFallback executor) {\n+        synchronized (globalLock) {\n+            if (executor.primary != globalPrimaryExecutor) {\n+                throw new IllegalStateException(\"primary executor \" + executor.primary + \" != \" + globalPrimaryExecutor);\n+            }\n+            if (executor.secondary != globalFallbackExecutor) {\n+                throw new IllegalStateException(\"secondary executor \" + executor.secondary + \" != \" + globalFallbackExecutor);\n+            }\n+            usages--;\n+            if (usages == 0) {\n+                globalPrimaryExecutor.shutdown();\n+                globalFallbackExecutor.shutdown();\n+                while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMDAzMg==", "bodyText": "extra space", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383930032", "createdAt": "2020-02-25T14:56:09Z", "author": {"login": "havardpe"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(), ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.primary\"));\n+                globalFallbackExecutor = Executors.newSingleThreadExecutor(ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.fallback\"));\n+            }\n+            usages ++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjAwOQ==", "bodyText": "consider checking usages and secondary pointer for consistency", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383932009", "createdAt": "2020-02-25T14:58:53Z", "author": {"login": "havardpe"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjY1MA==", "bodyText": "in the future, this could be moved to vespajlib since it is a general utility not directly tied to rpc", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383932650", "createdAt": "2020-02-25T14:59:48Z", "author": {"login": "havardpe"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62ea092d9fba83670a6b9923ec776d910c331d37", "author": {"user": {"login": "baldersheim", "name": "Henning Baldersheim"}}, "url": "https://github.com/vespa-engine/vespa/commit/62ea092d9fba83670a6b9923ec776d910c331d37", "committedDate": "2020-02-25T15:18:21Z", "message": "Add sanity checks and avoid codeduplicationi after codereview."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2810, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}