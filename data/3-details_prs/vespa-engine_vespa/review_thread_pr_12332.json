{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NTQzOTE3", "number": 12332, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NTo0M1rODiu63A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1OTo0OFrODivB_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzQ2OTA4OnYy", "diffSide": "RIGHT", "path": "jrt/src/com/yahoo/jrt/Connector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NTo0M1rOFuJNgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNToxODo1OFrOFuKJ8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTczMQ==", "bodyText": "I suggest having a method to wait for an executor completion and calling it for each executor", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383929731", "createdAt": "2020-02-25T14:55:43Z", "author": {"login": "havardpe"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(), ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.primary\"));\n+                globalFallbackExecutor = Executors.newSingleThreadExecutor(ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.fallback\"));\n+            }\n+            usages ++;\n+            return new ExecutorWithFallback(globalPrimaryExecutor, globalFallbackExecutor);\n         }\n     }\n \n-    public Connector shutdown() {\n-        executor.shutdown();\n-        return this;\n+    private static void release(ExecutorWithFallback executor) {\n+        synchronized (globalLock) {\n+            if (executor.primary != globalPrimaryExecutor) {\n+                throw new IllegalStateException(\"primary executor \" + executor.primary + \" != \" + globalPrimaryExecutor);\n+            }\n+            if (executor.secondary != globalFallbackExecutor) {\n+                throw new IllegalStateException(\"secondary executor \" + executor.secondary + \" != \" + globalFallbackExecutor);\n+            }\n+            usages--;\n+            if (usages == 0) {\n+                globalPrimaryExecutor.shutdown();\n+                globalFallbackExecutor.shutdown();\n+                while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NTIwMA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383945200", "createdAt": "2020-02-25T15:18:58Z", "author": {"login": "baldersheim"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(), ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.primary\"));\n+                globalFallbackExecutor = Executors.newSingleThreadExecutor(ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.fallback\"));\n+            }\n+            usages ++;\n+            return new ExecutorWithFallback(globalPrimaryExecutor, globalFallbackExecutor);\n         }\n     }\n \n-    public Connector shutdown() {\n-        executor.shutdown();\n-        return this;\n+    private static void release(ExecutorWithFallback executor) {\n+        synchronized (globalLock) {\n+            if (executor.primary != globalPrimaryExecutor) {\n+                throw new IllegalStateException(\"primary executor \" + executor.primary + \" != \" + globalPrimaryExecutor);\n+            }\n+            if (executor.secondary != globalFallbackExecutor) {\n+                throw new IllegalStateException(\"secondary executor \" + executor.secondary + \" != \" + globalFallbackExecutor);\n+            }\n+            usages--;\n+            if (usages == 0) {\n+                globalPrimaryExecutor.shutdown();\n+                globalFallbackExecutor.shutdown();\n+                while (true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTczMQ=="}, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzQ3MDkxOnYy", "diffSide": "RIGHT", "path": "jrt/src/com/yahoo/jrt/Connector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1NjowOVrOFuJOsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNToxODo0NFrOFuKJVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMDAzMg==", "bodyText": "extra space", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383930032", "createdAt": "2020-02-25T14:56:09Z", "author": {"login": "havardpe"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(), ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.primary\"));\n+                globalFallbackExecutor = Executors.newSingleThreadExecutor(ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.fallback\"));\n+            }\n+            usages ++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NTA0Nw==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383945047", "createdAt": "2020-02-25T15:18:44Z", "author": {"login": "baldersheim"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n+                        new SynchronousQueue<>(), ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.primary\"));\n+                globalFallbackExecutor = Executors.newSingleThreadExecutor(ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector.fallback\"));\n+            }\n+            usages ++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMDAzMg=="}, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzQ4MzQyOnYy", "diffSide": "RIGHT", "path": "jrt/src/com/yahoo/jrt/Connector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1ODo1M1rOFuJWaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNToxOToxNVrOFuKKsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjAwOQ==", "bodyText": "consider checking usages and secondary pointer for consistency", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383932009", "createdAt": "2020-02-25T14:58:53Z", "author": {"login": "havardpe"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NTM5NQ==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383945395", "createdAt": "2020-02-25T15:19:15Z", "author": {"login": "baldersheim"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {\n+        private final Executor primary;\n+        private final Executor secondary;\n+        ExecutorWithFallback(Executor primary, Executor secondary) {\n+            this.primary = primary;\n+            this.secondary = secondary;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            try {\n+                primary.execute(command);\n+            } catch (RejectedExecutionException e1) {\n+                secondary.execute(() -> retryForEver(command));\n+            }\n+        }\n+        private void retryForEver(Runnable command) {\n+            while (true) {\n+                try {\n+                    primary.execute(command);\n+                    return;\n+                } catch (RejectedExecutionException rejected) {\n+                    try {\n+                        Thread.sleep(1);\n+                    } catch (InterruptedException silenced) { }\n+                }\n+            }\n+        }\n     }\n \n-    public void connectLater(Connection conn) {\n-        try {\n-            executor.execute(() -> connect(conn));\n-        } catch (RejectedExecutionException e) {\n-            conn.transportThread().addConnection(conn);\n+    private static ExecutorWithFallback acquire() {\n+        synchronized (globalLock) {\n+            if (globalPrimaryExecutor == null) {\n+                globalPrimaryExecutor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjAwOQ=="}, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzQ4NzMzOnYy", "diffSide": "RIGHT", "path": "jrt/src/com/yahoo/jrt/Connector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDo1OTo0OFrOFuJY6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNToxOTozMVrOFuKLWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjY1MA==", "bodyText": "in the future, this could be moved to vespajlib since it is a general utility not directly tied to rpc", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383932650", "createdAt": "2020-02-25T14:59:48Z", "author": {"login": "havardpe"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NTU2Mg==", "bodyText": "Added TODO", "url": "https://github.com/vespa-engine/vespa/pull/12332#discussion_r383945562", "createdAt": "2020-02-25T15:19:31Z", "author": {"login": "baldersheim"}, "path": "jrt/src/com/yahoo/jrt/Connector.java", "diffHunk": "@@ -3,42 +3,119 @@\n \n import com.yahoo.concurrent.ThreadFactoryFactory;\n \n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.SynchronousQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n \n-class Connector {\n+class Connector implements AutoCloseable {\n \n-    private final ExecutorService executor = new ThreadPoolExecutor(1, 64, 1L, TimeUnit.SECONDS,\n-                                                                    new LinkedBlockingQueue<>(),\n-                                                                    ThreadFactoryFactory.getDaemonThreadFactory(\"jrt.connector\"));\n+    private static final Object globalLock = new Object();\n+    private static ExecutorService globalPrimaryExecutor = null;\n+    private static ExecutorService globalFallbackExecutor = null;\n+    private static long usages = 0;\n \n-    private void connect(Connection conn) {\n-        conn.transportThread().addConnection(conn.connect());\n+    private static class ExecutorWithFallback implements Executor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjY1MA=="}, "originalCommit": {"oid": "d7d87a8e45e0dace606493dfed2f903a614b76f7"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2353, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}