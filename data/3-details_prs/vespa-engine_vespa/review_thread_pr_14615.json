{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0NzExMjQ3", "number": 14615, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjoxODozOFrOEohXuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjoxODozOFrOEohXuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTI1MjQzOnYy", "diffSide": "RIGHT", "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/GroupPreparer.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjoxODozOFrOHZqTAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxMjoyMTo1MlrOHZqaZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTQ0MA==", "bodyText": "Why are nodes removed from surplusActiveNodes - I don't see any nodes are removed in the current/previous code?", "url": "https://github.com/vespa-engine/vespa/pull/14615#discussion_r496669440", "createdAt": "2020-09-29T12:18:38Z", "author": {"login": "hakonhall"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/GroupPreparer.java", "diffHunk": "@@ -59,28 +61,26 @@ public GroupPreparer(NodeRepository nodeRepository,\n                               List<Node> surplusActiveNodes, MutableInteger highestIndex, int wantedGroups) {\n         boolean dynamicProvisioningEnabled = nodeRepository.canProvisionHosts() && nodeRepository.zone().getCloud().dynamicProvisioning();\n         boolean allocateFully = dynamicProvisioningEnabled && preprovisionCapacityFlag.value().isEmpty();\n-        try (Mutex lock = nodeRepository.lock(application)) {\n \n-            // Lock ready pool to ensure that the same nodes are not simultaneously allocated by others\n-            try (Mutex allocationLock = nodeRepository.lockUnallocated()) {\n+        // Try preparing in memory without lock. Most of the time there should be no changes and we can return nodes\n+        // previously allocated.\n+        {\n+            MutableInteger probePrepareHighestIndex = new MutableInteger(highestIndex.get());\n+            NodeAllocation probeAllocation = prepareAllocation(application, cluster, requestedNodes, surplusActiveNodes,\n+                    probePrepareHighestIndex, wantedGroups, allocateFully, PROBE_LOCK);\n+            if (probeAllocation.fulfilledAndNoChanges()) {\n+                List<Node> acceptedNodes = probeAllocation.finalNodes();\n+                surplusActiveNodes.removeAll(acceptedNodes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90c8b5c969f16ba7ca0bc64f718a3ad8bdf527ff"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3MTAxMQ==", "bodyText": "The same thing is done in the existing code, at the end of the method.", "url": "https://github.com/vespa-engine/vespa/pull/14615#discussion_r496671011", "createdAt": "2020-09-29T12:21:15Z", "author": {"login": "mpolden"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/GroupPreparer.java", "diffHunk": "@@ -59,28 +61,26 @@ public GroupPreparer(NodeRepository nodeRepository,\n                               List<Node> surplusActiveNodes, MutableInteger highestIndex, int wantedGroups) {\n         boolean dynamicProvisioningEnabled = nodeRepository.canProvisionHosts() && nodeRepository.zone().getCloud().dynamicProvisioning();\n         boolean allocateFully = dynamicProvisioningEnabled && preprovisionCapacityFlag.value().isEmpty();\n-        try (Mutex lock = nodeRepository.lock(application)) {\n \n-            // Lock ready pool to ensure that the same nodes are not simultaneously allocated by others\n-            try (Mutex allocationLock = nodeRepository.lockUnallocated()) {\n+        // Try preparing in memory without lock. Most of the time there should be no changes and we can return nodes\n+        // previously allocated.\n+        {\n+            MutableInteger probePrepareHighestIndex = new MutableInteger(highestIndex.get());\n+            NodeAllocation probeAllocation = prepareAllocation(application, cluster, requestedNodes, surplusActiveNodes,\n+                    probePrepareHighestIndex, wantedGroups, allocateFully, PROBE_LOCK);\n+            if (probeAllocation.fulfilledAndNoChanges()) {\n+                List<Node> acceptedNodes = probeAllocation.finalNodes();\n+                surplusActiveNodes.removeAll(acceptedNodes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTQ0MA=="}, "originalCommit": {"oid": "90c8b5c969f16ba7ca0bc64f718a3ad8bdf527ff"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3MTI5Mg==", "bodyText": "Now I see it - never mind", "url": "https://github.com/vespa-engine/vespa/pull/14615#discussion_r496671292", "createdAt": "2020-09-29T12:21:47Z", "author": {"login": "hakonhall"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/GroupPreparer.java", "diffHunk": "@@ -59,28 +61,26 @@ public GroupPreparer(NodeRepository nodeRepository,\n                               List<Node> surplusActiveNodes, MutableInteger highestIndex, int wantedGroups) {\n         boolean dynamicProvisioningEnabled = nodeRepository.canProvisionHosts() && nodeRepository.zone().getCloud().dynamicProvisioning();\n         boolean allocateFully = dynamicProvisioningEnabled && preprovisionCapacityFlag.value().isEmpty();\n-        try (Mutex lock = nodeRepository.lock(application)) {\n \n-            // Lock ready pool to ensure that the same nodes are not simultaneously allocated by others\n-            try (Mutex allocationLock = nodeRepository.lockUnallocated()) {\n+        // Try preparing in memory without lock. Most of the time there should be no changes and we can return nodes\n+        // previously allocated.\n+        {\n+            MutableInteger probePrepareHighestIndex = new MutableInteger(highestIndex.get());\n+            NodeAllocation probeAllocation = prepareAllocation(application, cluster, requestedNodes, surplusActiveNodes,\n+                    probePrepareHighestIndex, wantedGroups, allocateFully, PROBE_LOCK);\n+            if (probeAllocation.fulfilledAndNoChanges()) {\n+                List<Node> acceptedNodes = probeAllocation.finalNodes();\n+                surplusActiveNodes.removeAll(acceptedNodes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTQ0MA=="}, "originalCommit": {"oid": "90c8b5c969f16ba7ca0bc64f718a3ad8bdf527ff"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY3MTMzMg==", "bodyText": "Removed here:\n\n  \n    \n      vespa/node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/GroupPreparer.java\n    \n    \n         Line 119\n      in\n      90c8b5c\n    \n    \n    \n    \n\n        \n          \n           surplusActiveNodes.removeAll(acceptedNodes);", "url": "https://github.com/vespa-engine/vespa/pull/14615#discussion_r496671332", "createdAt": "2020-09-29T12:21:52Z", "author": {"login": "freva"}, "path": "node-repository/src/main/java/com/yahoo/vespa/hosted/provision/provisioning/GroupPreparer.java", "diffHunk": "@@ -59,28 +61,26 @@ public GroupPreparer(NodeRepository nodeRepository,\n                               List<Node> surplusActiveNodes, MutableInteger highestIndex, int wantedGroups) {\n         boolean dynamicProvisioningEnabled = nodeRepository.canProvisionHosts() && nodeRepository.zone().getCloud().dynamicProvisioning();\n         boolean allocateFully = dynamicProvisioningEnabled && preprovisionCapacityFlag.value().isEmpty();\n-        try (Mutex lock = nodeRepository.lock(application)) {\n \n-            // Lock ready pool to ensure that the same nodes are not simultaneously allocated by others\n-            try (Mutex allocationLock = nodeRepository.lockUnallocated()) {\n+        // Try preparing in memory without lock. Most of the time there should be no changes and we can return nodes\n+        // previously allocated.\n+        {\n+            MutableInteger probePrepareHighestIndex = new MutableInteger(highestIndex.get());\n+            NodeAllocation probeAllocation = prepareAllocation(application, cluster, requestedNodes, surplusActiveNodes,\n+                    probePrepareHighestIndex, wantedGroups, allocateFully, PROBE_LOCK);\n+            if (probeAllocation.fulfilledAndNoChanges()) {\n+                List<Node> acceptedNodes = probeAllocation.finalNodes();\n+                surplusActiveNodes.removeAll(acceptedNodes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2OTQ0MA=="}, "originalCommit": {"oid": "90c8b5c969f16ba7ca0bc64f718a3ad8bdf527ff"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1253, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}