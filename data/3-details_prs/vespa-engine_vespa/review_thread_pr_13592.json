{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0NTEyMjM5", "number": 13592, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzoxMTo0NlrOEFh5qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzoxMTo0NlrOEFh5qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MjMzNzY4OnYy", "diffSide": "RIGHT", "path": "searchcore/src/vespa/searchcore/proton/attribute/attribute_writer.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzoxMTo0NlrOGjxggg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzozMjo1N1rOGjyU7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NDQ4Mg==", "bodyText": "This will hang if promise is never set, e.g. when PreparePutTask::run() doesn't set promise due to field value not being set.", "url": "https://github.com/vespa-engine/vespa/pull/13592#discussion_r440164482", "createdAt": "2020-06-15T13:11:46Z", "author": {"login": "toregge"}, "path": "searchcore/src/vespa/searchcore/proton/attribute/attribute_writer.cpp", "diffHunk": "@@ -303,6 +351,101 @@ PutTask::run()\n     }\n }\n \n+\n+class PreparePutTask : public vespalib::Executor::Task {\n+private:\n+    const SerialNum _serial_num;\n+    const uint32_t _docid;\n+    AttributeVector& _attr;\n+    FieldValue::SP _field_value;\n+    std::promise<std::unique_ptr<PrepareResult>> _result_promise;\n+\n+public:\n+    PreparePutTask(SerialNum serial_num_in,\n+                   uint32_t docid_in,\n+                   const AttributeWriter::WriteField& field,\n+                   std::shared_ptr<DocumentFieldExtractor> field_extractor);\n+    ~PreparePutTask() override;\n+    void run() override;\n+    SerialNum serial_num() const { return _serial_num; }\n+    uint32_t docid() const { return _docid; }\n+    AttributeVector& attr() { return _attr; }\n+    FieldValue::SP field_value() { return _field_value; }\n+    std::future<std::unique_ptr<PrepareResult>> result_future() {\n+        return _result_promise.get_future();\n+    }\n+};\n+\n+PreparePutTask::PreparePutTask(SerialNum serial_num_in,\n+                               uint32_t docid_in,\n+                               const AttributeWriter::WriteField& field,\n+                               std::shared_ptr<DocumentFieldExtractor> field_extractor)\n+    : _serial_num(serial_num_in),\n+      _docid(docid_in),\n+      _attr(field.getAttribute()),\n+      _field_value(),\n+      _result_promise()\n+{\n+    // Note: No need to store the field extractor as we are not extracting struct fields.\n+    auto value = field_extractor->getFieldValue(field.getFieldPath());\n+    _field_value.reset(value.release());\n+}\n+\n+PreparePutTask::~PreparePutTask() = default;\n+\n+void\n+PreparePutTask::run()\n+{\n+    if (_attr.getStatus().getLastSyncToken() < _serial_num) {\n+        if (_field_value.get()) {\n+            _result_promise.set_value(AttributeUpdater::prepare_set_value(_attr, _docid, *_field_value));\n+        }\n+    }\n+}\n+\n+class CompletePutTask : public vespalib::Executor::Task {\n+private:\n+    const SerialNum _serial_num;\n+    const uint32_t _docid;\n+    AttributeVector& _attr;\n+    FieldValue::SP _field_value;\n+    std::future<std::unique_ptr<PrepareResult>> _result_future;\n+    const bool _immediate_commit;\n+    std::remove_reference_t<AttributeWriter::OnWriteDoneType> _on_write_done;\n+\n+public:\n+    CompletePutTask(PreparePutTask& prepare_task,\n+                    bool immediate_commit,\n+                    AttributeWriter::OnWriteDoneType on_write_done);\n+    ~CompletePutTask() override;\n+    void run() override;\n+};\n+\n+CompletePutTask::CompletePutTask(PreparePutTask& prepare_task,\n+                                 bool immediate_commit,\n+                                 AttributeWriter::OnWriteDoneType on_write_done)\n+    : _serial_num(prepare_task.serial_num()),\n+      _docid(prepare_task.docid()),\n+      _attr(prepare_task.attr()),\n+      _field_value(prepare_task.field_value()),\n+      _result_future(prepare_task.result_future()),\n+      _immediate_commit(immediate_commit),\n+      _on_write_done(on_write_done)\n+{\n+}\n+\n+CompletePutTask::~CompletePutTask() = default;\n+\n+void\n+CompletePutTask::run()\n+{\n+    if (_attr.getStatus().getLastSyncToken() < _serial_num) {\n+        auto result = _result_future.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b17ee23a6fd3c81ffc5ca8505b74ac922a6f6165"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NzkwMA==", "bodyText": "Fixed", "url": "https://github.com/vespa-engine/vespa/pull/13592#discussion_r440177900", "createdAt": "2020-06-15T13:32:57Z", "author": {"login": "geirst"}, "path": "searchcore/src/vespa/searchcore/proton/attribute/attribute_writer.cpp", "diffHunk": "@@ -303,6 +351,101 @@ PutTask::run()\n     }\n }\n \n+\n+class PreparePutTask : public vespalib::Executor::Task {\n+private:\n+    const SerialNum _serial_num;\n+    const uint32_t _docid;\n+    AttributeVector& _attr;\n+    FieldValue::SP _field_value;\n+    std::promise<std::unique_ptr<PrepareResult>> _result_promise;\n+\n+public:\n+    PreparePutTask(SerialNum serial_num_in,\n+                   uint32_t docid_in,\n+                   const AttributeWriter::WriteField& field,\n+                   std::shared_ptr<DocumentFieldExtractor> field_extractor);\n+    ~PreparePutTask() override;\n+    void run() override;\n+    SerialNum serial_num() const { return _serial_num; }\n+    uint32_t docid() const { return _docid; }\n+    AttributeVector& attr() { return _attr; }\n+    FieldValue::SP field_value() { return _field_value; }\n+    std::future<std::unique_ptr<PrepareResult>> result_future() {\n+        return _result_promise.get_future();\n+    }\n+};\n+\n+PreparePutTask::PreparePutTask(SerialNum serial_num_in,\n+                               uint32_t docid_in,\n+                               const AttributeWriter::WriteField& field,\n+                               std::shared_ptr<DocumentFieldExtractor> field_extractor)\n+    : _serial_num(serial_num_in),\n+      _docid(docid_in),\n+      _attr(field.getAttribute()),\n+      _field_value(),\n+      _result_promise()\n+{\n+    // Note: No need to store the field extractor as we are not extracting struct fields.\n+    auto value = field_extractor->getFieldValue(field.getFieldPath());\n+    _field_value.reset(value.release());\n+}\n+\n+PreparePutTask::~PreparePutTask() = default;\n+\n+void\n+PreparePutTask::run()\n+{\n+    if (_attr.getStatus().getLastSyncToken() < _serial_num) {\n+        if (_field_value.get()) {\n+            _result_promise.set_value(AttributeUpdater::prepare_set_value(_attr, _docid, *_field_value));\n+        }\n+    }\n+}\n+\n+class CompletePutTask : public vespalib::Executor::Task {\n+private:\n+    const SerialNum _serial_num;\n+    const uint32_t _docid;\n+    AttributeVector& _attr;\n+    FieldValue::SP _field_value;\n+    std::future<std::unique_ptr<PrepareResult>> _result_future;\n+    const bool _immediate_commit;\n+    std::remove_reference_t<AttributeWriter::OnWriteDoneType> _on_write_done;\n+\n+public:\n+    CompletePutTask(PreparePutTask& prepare_task,\n+                    bool immediate_commit,\n+                    AttributeWriter::OnWriteDoneType on_write_done);\n+    ~CompletePutTask() override;\n+    void run() override;\n+};\n+\n+CompletePutTask::CompletePutTask(PreparePutTask& prepare_task,\n+                                 bool immediate_commit,\n+                                 AttributeWriter::OnWriteDoneType on_write_done)\n+    : _serial_num(prepare_task.serial_num()),\n+      _docid(prepare_task.docid()),\n+      _attr(prepare_task.attr()),\n+      _field_value(prepare_task.field_value()),\n+      _result_future(prepare_task.result_future()),\n+      _immediate_commit(immediate_commit),\n+      _on_write_done(on_write_done)\n+{\n+}\n+\n+CompletePutTask::~CompletePutTask() = default;\n+\n+void\n+CompletePutTask::run()\n+{\n+    if (_attr.getStatus().getLastSyncToken() < _serial_num) {\n+        auto result = _result_future.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NDQ4Mg=="}, "originalCommit": {"oid": "b17ee23a6fd3c81ffc5ca8505b74ac922a6f6165"}, "originalPosition": 248}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1946, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}