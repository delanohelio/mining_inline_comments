{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTIzOTQ4", "number": 15472, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo0Mzo1MVrOE9SS9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo0Mzo1MVrOE9SS9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjk4MzU5OnYy", "diffSide": "RIGHT", "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/ConfigConvergenceChecker.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTo0Mzo1MVrOH55P-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMTowNjo1N1rOH72Mhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA==", "bodyText": "Level.FINE", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r530468858", "createdAt": "2020-11-25T15:43:51Z", "author": {"login": "jonmv"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/ConfigConvergenceChecker.java", "diffHunk": "@@ -108,46 +117,67 @@ public JSONResponse getServiceConfigGenerationResponse(Application application,\n \n     @Override\n     public void deconstruct() {\n-        clientBuilderFactory.close();\n-    }\n-\n-    @Path(statePath)\n-    public interface StateApi {\n-        @Path(configSubPath)\n-        @GET\n-        JsonNode config();\n-    }\n-\n-    public interface StateApiFactory {\n-        StateApi createStateApi(Client client, URI serviceUri);\n+        try {\n+            client.close();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n     }\n \n     /** Gets service generation for a list of services (in parallel). */\n     private Map<ServiceInfo, Long> getServiceGenerations(List<ServiceInfo> services, Duration timeout) {\n-        return services.parallelStream()\n-                       .collect(Collectors.toMap(service -> service,\n-                                                 service -> {\n-                                                     try {\n-                                                         return getServiceGeneration(URI.create(\"http://\" + service.getHostName()\n-                                                                                                + \":\" + getStatePort(service).get()), timeout);\n-                                                     }\n-                                                     catch (ProcessingException e) { // Cannot connect to service to determine service generation\n-                                                         return -1L;\n-                                                     }\n-                                                 },\n-                                                 (v1, v2) -> { throw new IllegalStateException(\"Duplicate keys for values '\" + v1 + \"' and '\" + v2 + \"'.\"); },\n-                                                 LinkedHashMap::new\n-                                                ));\n+        List<CompletableFuture<Void>> inprogressRequests = new ArrayList<>();\n+        ConcurrentMap<ServiceInfo, Long> temporaryResult = new ConcurrentHashMap<>();\n+        for (ServiceInfo service : services) {\n+            int statePort = getStatePort(service).orElse(0);\n+            if (statePort <= 0) continue;\n+\n+            URI uri = URI.create(\"http://\" + service.getHostName() + \":\" + statePort);\n+            CompletableFuture<Void> inprogressRequest = getServiceGeneration(uri, timeout)\n+                    .handle((result, error) -> {\n+                        if (result != null) {\n+                            temporaryResult.put(service, result);\n+                        } else {\n+                            log.log(\n+                                    LogLevel.DEBUG,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93e887cb2d7ae0177eb70450b50007b1bff66985"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3MDI1Mw==", "bodyText": "I think they are equivalent (LogLevel being the Vespa wrapper for Level). Any benefits using Level instead?", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r530470253", "createdAt": "2020-11-25T15:45:45Z", "author": {"login": "bjorncs"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/ConfigConvergenceChecker.java", "diffHunk": "@@ -108,46 +117,67 @@ public JSONResponse getServiceConfigGenerationResponse(Application application,\n \n     @Override\n     public void deconstruct() {\n-        clientBuilderFactory.close();\n-    }\n-\n-    @Path(statePath)\n-    public interface StateApi {\n-        @Path(configSubPath)\n-        @GET\n-        JsonNode config();\n-    }\n-\n-    public interface StateApiFactory {\n-        StateApi createStateApi(Client client, URI serviceUri);\n+        try {\n+            client.close();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n     }\n \n     /** Gets service generation for a list of services (in parallel). */\n     private Map<ServiceInfo, Long> getServiceGenerations(List<ServiceInfo> services, Duration timeout) {\n-        return services.parallelStream()\n-                       .collect(Collectors.toMap(service -> service,\n-                                                 service -> {\n-                                                     try {\n-                                                         return getServiceGeneration(URI.create(\"http://\" + service.getHostName()\n-                                                                                                + \":\" + getStatePort(service).get()), timeout);\n-                                                     }\n-                                                     catch (ProcessingException e) { // Cannot connect to service to determine service generation\n-                                                         return -1L;\n-                                                     }\n-                                                 },\n-                                                 (v1, v2) -> { throw new IllegalStateException(\"Duplicate keys for values '\" + v1 + \"' and '\" + v2 + \"'.\"); },\n-                                                 LinkedHashMap::new\n-                                                ));\n+        List<CompletableFuture<Void>> inprogressRequests = new ArrayList<>();\n+        ConcurrentMap<ServiceInfo, Long> temporaryResult = new ConcurrentHashMap<>();\n+        for (ServiceInfo service : services) {\n+            int statePort = getStatePort(service).orElse(0);\n+            if (statePort <= 0) continue;\n+\n+            URI uri = URI.create(\"http://\" + service.getHostName() + \":\" + statePort);\n+            CompletableFuture<Void> inprogressRequest = getServiceGeneration(uri, timeout)\n+                    .handle((result, error) -> {\n+                        if (result != null) {\n+                            temporaryResult.put(service, result);\n+                        } else {\n+                            log.log(\n+                                    LogLevel.DEBUG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA=="}, "originalCommit": {"oid": "93e887cb2d7ae0177eb70450b50007b1bff66985"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDc4NQ==", "bodyText": "I know @gjoranv went to great lengths to replace with Level values some time ago. I don't know why, though.", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r530474785", "createdAt": "2020-11-25T15:51:46Z", "author": {"login": "jonmv"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/ConfigConvergenceChecker.java", "diffHunk": "@@ -108,46 +117,67 @@ public JSONResponse getServiceConfigGenerationResponse(Application application,\n \n     @Override\n     public void deconstruct() {\n-        clientBuilderFactory.close();\n-    }\n-\n-    @Path(statePath)\n-    public interface StateApi {\n-        @Path(configSubPath)\n-        @GET\n-        JsonNode config();\n-    }\n-\n-    public interface StateApiFactory {\n-        StateApi createStateApi(Client client, URI serviceUri);\n+        try {\n+            client.close();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n     }\n \n     /** Gets service generation for a list of services (in parallel). */\n     private Map<ServiceInfo, Long> getServiceGenerations(List<ServiceInfo> services, Duration timeout) {\n-        return services.parallelStream()\n-                       .collect(Collectors.toMap(service -> service,\n-                                                 service -> {\n-                                                     try {\n-                                                         return getServiceGeneration(URI.create(\"http://\" + service.getHostName()\n-                                                                                                + \":\" + getStatePort(service).get()), timeout);\n-                                                     }\n-                                                     catch (ProcessingException e) { // Cannot connect to service to determine service generation\n-                                                         return -1L;\n-                                                     }\n-                                                 },\n-                                                 (v1, v2) -> { throw new IllegalStateException(\"Duplicate keys for values '\" + v1 + \"' and '\" + v2 + \"'.\"); },\n-                                                 LinkedHashMap::new\n-                                                ));\n+        List<CompletableFuture<Void>> inprogressRequests = new ArrayList<>();\n+        ConcurrentMap<ServiceInfo, Long> temporaryResult = new ConcurrentHashMap<>();\n+        for (ServiceInfo service : services) {\n+            int statePort = getStatePort(service).orElse(0);\n+            if (statePort <= 0) continue;\n+\n+            URI uri = URI.create(\"http://\" + service.getHostName() + \":\" + statePort);\n+            CompletableFuture<Void> inprogressRequest = getServiceGeneration(uri, timeout)\n+                    .handle((result, error) -> {\n+                        if (result != null) {\n+                            temporaryResult.put(service, result);\n+                        } else {\n+                            log.log(\n+                                    LogLevel.DEBUG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA=="}, "originalCommit": {"oid": "93e887cb2d7ae0177eb70450b50007b1bff66985"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUwMzIxNw==", "bodyText": "Ok, I removed use of LogLevel in new PR.", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r530503217", "createdAt": "2020-11-25T16:32:00Z", "author": {"login": "bjorncs"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/ConfigConvergenceChecker.java", "diffHunk": "@@ -108,46 +117,67 @@ public JSONResponse getServiceConfigGenerationResponse(Application application,\n \n     @Override\n     public void deconstruct() {\n-        clientBuilderFactory.close();\n-    }\n-\n-    @Path(statePath)\n-    public interface StateApi {\n-        @Path(configSubPath)\n-        @GET\n-        JsonNode config();\n-    }\n-\n-    public interface StateApiFactory {\n-        StateApi createStateApi(Client client, URI serviceUri);\n+        try {\n+            client.close();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n     }\n \n     /** Gets service generation for a list of services (in parallel). */\n     private Map<ServiceInfo, Long> getServiceGenerations(List<ServiceInfo> services, Duration timeout) {\n-        return services.parallelStream()\n-                       .collect(Collectors.toMap(service -> service,\n-                                                 service -> {\n-                                                     try {\n-                                                         return getServiceGeneration(URI.create(\"http://\" + service.getHostName()\n-                                                                                                + \":\" + getStatePort(service).get()), timeout);\n-                                                     }\n-                                                     catch (ProcessingException e) { // Cannot connect to service to determine service generation\n-                                                         return -1L;\n-                                                     }\n-                                                 },\n-                                                 (v1, v2) -> { throw new IllegalStateException(\"Duplicate keys for values '\" + v1 + \"' and '\" + v2 + \"'.\"); },\n-                                                 LinkedHashMap::new\n-                                                ));\n+        List<CompletableFuture<Void>> inprogressRequests = new ArrayList<>();\n+        ConcurrentMap<ServiceInfo, Long> temporaryResult = new ConcurrentHashMap<>();\n+        for (ServiceInfo service : services) {\n+            int statePort = getStatePort(service).orElse(0);\n+            if (statePort <= 0) continue;\n+\n+            URI uri = URI.create(\"http://\" + service.getHostName() + \":\" + statePort);\n+            CompletableFuture<Void> inprogressRequest = getServiceGeneration(uri, timeout)\n+                    .handle((result, error) -> {\n+                        if (result != null) {\n+                            temporaryResult.put(service, result);\n+                        } else {\n+                            log.log(\n+                                    LogLevel.DEBUG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA=="}, "originalCommit": {"oid": "93e887cb2d7ae0177eb70450b50007b1bff66985"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUxNTk3NQ==", "bodyText": "I had to remove LogLevel from config in order to use config inside vespalog, and then it was proposed to remove LogLevel usage from all modules. I think the motivation was that custom log levels are unnecessary and a bit odd.", "url": "https://github.com/vespa-engine/vespa/pull/15472#discussion_r532515975", "createdAt": "2020-11-30T11:06:57Z", "author": {"login": "gjoranv"}, "path": "configserver/src/main/java/com/yahoo/vespa/config/server/application/ConfigConvergenceChecker.java", "diffHunk": "@@ -108,46 +117,67 @@ public JSONResponse getServiceConfigGenerationResponse(Application application,\n \n     @Override\n     public void deconstruct() {\n-        clientBuilderFactory.close();\n-    }\n-\n-    @Path(statePath)\n-    public interface StateApi {\n-        @Path(configSubPath)\n-        @GET\n-        JsonNode config();\n-    }\n-\n-    public interface StateApiFactory {\n-        StateApi createStateApi(Client client, URI serviceUri);\n+        try {\n+            client.close();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n     }\n \n     /** Gets service generation for a list of services (in parallel). */\n     private Map<ServiceInfo, Long> getServiceGenerations(List<ServiceInfo> services, Duration timeout) {\n-        return services.parallelStream()\n-                       .collect(Collectors.toMap(service -> service,\n-                                                 service -> {\n-                                                     try {\n-                                                         return getServiceGeneration(URI.create(\"http://\" + service.getHostName()\n-                                                                                                + \":\" + getStatePort(service).get()), timeout);\n-                                                     }\n-                                                     catch (ProcessingException e) { // Cannot connect to service to determine service generation\n-                                                         return -1L;\n-                                                     }\n-                                                 },\n-                                                 (v1, v2) -> { throw new IllegalStateException(\"Duplicate keys for values '\" + v1 + \"' and '\" + v2 + \"'.\"); },\n-                                                 LinkedHashMap::new\n-                                                ));\n+        List<CompletableFuture<Void>> inprogressRequests = new ArrayList<>();\n+        ConcurrentMap<ServiceInfo, Long> temporaryResult = new ConcurrentHashMap<>();\n+        for (ServiceInfo service : services) {\n+            int statePort = getStatePort(service).orElse(0);\n+            if (statePort <= 0) continue;\n+\n+            URI uri = URI.create(\"http://\" + service.getHostName() + \":\" + statePort);\n+            CompletableFuture<Void> inprogressRequest = getServiceGeneration(uri, timeout)\n+                    .handle((result, error) -> {\n+                        if (result != null) {\n+                            temporaryResult.put(service, result);\n+                        } else {\n+                            log.log(\n+                                    LogLevel.DEBUG,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2ODg1OA=="}, "originalCommit": {"oid": "93e887cb2d7ae0177eb70450b50007b1bff66985"}, "originalPosition": 165}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 811, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}