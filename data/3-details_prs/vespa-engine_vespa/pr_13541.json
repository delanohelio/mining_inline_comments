{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNDkxNTEz", "number": 13541, "title": "Add draft LocalVisitorSession", "bodyText": "@vekterli please review for discussion only. Will add tests and wire into the LocalDocumentAccess if it looks OK.", "createdAt": "2020-06-10T14:22:38Z", "url": "https://github.com/vespa-engine/vespa/pull/13541", "merged": true, "mergeCommit": {"oid": "790abf9aee5de1e6b2cd16a711ead1d9f4f755dc"}, "closed": true, "closedAt": "2020-06-11T12:12:25Z", "author": {"login": "jonmv"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcp6y0rgFqTQyODEzMjAyMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqNIZFABqjM0MzM4NTQyNjc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MTMyMDIy", "url": "https://github.com/vespa-engine/vespa/pull/13541#pullrequestreview-428132022", "createdAt": "2020-06-10T14:46:58Z", "commit": {"oid": "0bb39325a2257d71a8619a19dd19e6aa004d72ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNDo0Njo1OFrOGh4eHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNDo0Njo1OFrOGh4eHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE4MTQwNQ==", "bodyText": "Very unclear what this is used for.", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438181405", "createdAt": "2020-06-10T14:46:58Z", "author": {"login": "jonmv"}, "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    data.onMessage(new PutDocumentMessage(new DocumentPut(document)),\n+                                                               new AckToken(id));\n+                });\n+                // Transition to a terminal state when done\n+                state.updateAndGet(current -> {\n+                    switch (current) {\n+                        case RUNNING:\n+                            control.onDone(VisitorControlHandler.CompletionCode.SUCCESS, \"Success\");\n+                            return State.SUCCESS;\n+                        case ABORTED:\n+                            control.onDone(VisitorControlHandler.CompletionCode.ABORTED, \"Aborted by user\");\n+                            return State.ABORTED;\n+                        default:\n+                            control.onDone(VisitorControlHandler.CompletionCode.FAILURE, \"Unexpected state '\" + current + \"'\");;\n+                            return State.FAILURE;\n+                    }\n+                });\n+            }\n+            // Transition to failure terminal state on error\n+            catch (Exception e) {\n+                state.set(State.FAILURE);\n+                outstanding.clear();\n+                control.onDone(VisitorControlHandler.CompletionCode.FAILURE, Exceptions.toMessageString(e));\n+            }\n+            finally {\n+                data.onDone();\n+            }\n+        }).start();\n+    }\n+\n+    @Override\n+    public boolean isDone() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb39325a2257d71a8619a19dd19e6aa004d72ac"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MTMyODQx", "url": "https://github.com/vespa-engine/vespa/pull/13541#pullrequestreview-428132841", "createdAt": "2020-06-10T14:47:46Z", "commit": {"oid": "0bb39325a2257d71a8619a19dd19e6aa004d72ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNDo0Nzo0NlrOGh4gaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNDo0Nzo0NlrOGh4gaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE4MTk5NQ==", "bodyText": "This could be called unconditionally now.", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438181995", "createdAt": "2020-06-10T14:47:46Z", "author": {"login": "jonmv"}, "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    data.onMessage(new PutDocumentMessage(new DocumentPut(document)),\n+                                                               new AckToken(id));\n+                });\n+                // Transition to a terminal state when done\n+                state.updateAndGet(current -> {\n+                    switch (current) {\n+                        case RUNNING:\n+                            control.onDone(VisitorControlHandler.CompletionCode.SUCCESS, \"Success\");\n+                            return State.SUCCESS;\n+                        case ABORTED:\n+                            control.onDone(VisitorControlHandler.CompletionCode.ABORTED, \"Aborted by user\");\n+                            return State.ABORTED;\n+                        default:\n+                            control.onDone(VisitorControlHandler.CompletionCode.FAILURE, \"Unexpected state '\" + current + \"'\");;\n+                            return State.FAILURE;\n+                    }\n+                });\n+            }\n+            // Transition to failure terminal state on error\n+            catch (Exception e) {\n+                state.set(State.FAILURE);\n+                outstanding.clear();\n+                control.onDone(VisitorControlHandler.CompletionCode.FAILURE, Exceptions.toMessageString(e));\n+            }\n+            finally {\n+                data.onDone();\n+            }\n+        }).start();\n+    }\n+\n+    @Override\n+    public boolean isDone() {\n+        return outstanding.isEmpty();\n+    }\n+\n+    @Override\n+    public ProgressToken getProgress() {\n+        throw new UnsupportedOperationException(\"Progress tokens are not supported\");\n+    }\n+\n+    @Override\n+    public Trace getTrace() {\n+        throw new UnsupportedOperationException(\"Traces are not supported\");\n+    }\n+\n+    @Override\n+    public boolean waitUntilDone(long timeoutMs) throws InterruptedException {\n+        return control.waitUntilDone(timeoutMs);\n+    }\n+\n+    @Override\n+    public void ack(AckToken token) {\n+        outstanding.remove((DocumentId) token.ackObject);\n+    }\n+\n+    @Override\n+    public void abort() {\n+        state.updateAndGet(current -> current == State.RUNNING ? State.ABORTED : current);\n+        outstanding.clear();\n+    }\n+\n+    @Override\n+    public VisitorResponse getNext() {\n+        return data.getNext();\n+    }\n+\n+    @Override\n+    public VisitorResponse getNext(int timeoutMilliseconds) throws InterruptedException {\n+        return data.getNext(timeoutMilliseconds);\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        if ( ! isDone())\n+            abort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb39325a2257d71a8619a19dd19e6aa004d72ac"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MTM0MjA2", "url": "https://github.com/vespa-engine/vespa/pull/13541#pullrequestreview-428134206", "createdAt": "2020-06-10T14:49:06Z", "commit": {"oid": "0bb39325a2257d71a8619a19dd19e6aa004d72ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNDo0OTowNlrOGh4kjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNDo0OTowNlrOGh4kjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE4MzA1NQ==", "bodyText": "Urgh indentation.", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438183055", "createdAt": "2020-06-10T14:49:06Z", "author": {"login": "jonmv"}, "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    data.onMessage(new PutDocumentMessage(new DocumentPut(document)),\n+                                                               new AckToken(id));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bb39325a2257d71a8619a19dd19e6aa004d72ac"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NzIxMDAw", "url": "https://github.com/vespa-engine/vespa/pull/13541#pullrequestreview-428721000", "createdAt": "2020-06-11T08:57:33Z", "commit": {"oid": "0f103200c3cd366a4343428bd39bbf4d2ac78442"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMDo0NjowM1rOGiYC1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTozNDozNVrOGiZXkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY5ODcxMA==", "bodyText": "Shall it be guaranteed that onDocument is always called from a single thread in the local implementation? If not, consider adding synchronization in the data handlers here.", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438698710", "createdAt": "2020-06-11T10:46:03Z", "author": {"login": "vekterli"}, "path": "documentapi/src/test/java/com/yahoo/documentapi/local/LocalDocumentApiTestCase.java", "diffHunk": "@@ -0,0 +1,241 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.document.DocumentRemove;\n+import com.yahoo.document.DocumentType;\n+import com.yahoo.document.DocumentUpdate;\n+import com.yahoo.document.datatypes.StringFieldValue;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.document.update.FieldUpdate;\n+import com.yahoo.documentapi.AsyncParameters;\n+import com.yahoo.documentapi.AsyncSession;\n+import com.yahoo.documentapi.DocumentAccess;\n+import com.yahoo.documentapi.DocumentAccessParams;\n+import com.yahoo.documentapi.DocumentResponse;\n+import com.yahoo.documentapi.DumpVisitorDataHandler;\n+import com.yahoo.documentapi.Response;\n+import com.yahoo.documentapi.Result;\n+import com.yahoo.documentapi.SyncParameters;\n+import com.yahoo.documentapi.SyncSession;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.test.AbstractDocumentApiTestCase;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Runs the superclass tests on this implementation\n+ *\n+ * @author bratseth\n+ */\n+public class LocalDocumentApiTestCase extends AbstractDocumentApiTestCase {\n+\n+    protected LocalDocumentAccess access;\n+\n+    @Override\n+    protected DocumentAccess access() {\n+        return access;\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        DocumentAccessParams params = new DocumentAccessParams();\n+        params.setDocumentManagerConfigId(\"file:src/test/cfg/documentmanager.cfg\");\n+        access = new LocalDocumentAccess(params);\n+    }\n+\n+    @After\n+    public void shutdownAccess() {\n+        access.shutdown();\n+    }\n+\n+    @Test\n+    public void testNoExceptionFromAsync() {\n+        AsyncSession session = access.createAsyncSession(new AsyncParameters());\n+\n+        DocumentType type = access.getDocumentTypeManager().getDocumentType(\"music\");\n+        DocumentUpdate docUp = new DocumentUpdate(type, new DocumentId(\"id:ns:music::2\"));\n+\n+        Result result = session.update(docUp);\n+        assertTrue(result.isSuccess());\n+        Response response = session.getNext();\n+        assertEquals(result.getRequestId(), response.getRequestId());\n+        assertFalse(response.isSuccess());\n+        session.destroy();\n+    }\n+\n+    @Test\n+    public void testAsyncFetch() {\n+        AsyncSession session = access.createAsyncSession(new AsyncParameters());\n+        List<DocumentId> ids = new ArrayList<>();\n+        ids.add(new DocumentId(\"id:music:music::1\"));\n+        ids.add(new DocumentId(\"id:music:music::2\"));\n+        ids.add(new DocumentId(\"id:music:music::3\"));\n+        for (DocumentId id : ids)\n+            session.put(new Document(access.getDocumentTypeManager().getDocumentType(\"music\"), id));\n+        int timeout = 100;\n+\n+        long startTime = System.currentTimeMillis();\n+        Set<Long> outstandingRequests = new HashSet<>();\n+        for (DocumentId id : ids) {\n+            Result result = session.get(id);\n+            if ( ! result.isSuccess())\n+                throw new IllegalStateException(\"Failed requesting document \" + id, result.getError().getCause());\n+            outstandingRequests.add(result.getRequestId());\n+        }\n+\n+        List<Document> documents = new ArrayList<>();\n+        try {\n+            while ( ! outstandingRequests.isEmpty()) {\n+                int timeSinceStart = (int)(System.currentTimeMillis() - startTime);\n+                Response response = session.getNext(timeout - timeSinceStart);\n+                if (response == null)\n+                    throw new RuntimeException(\"Timed out waiting for documents\"); // or return what you have\n+                if ( ! outstandingRequests.contains(response.getRequestId())) continue; // Stale: Ignore\n+\n+                if (response.isSuccess())\n+                    documents.add(((DocumentResponse)response).getDocument());\n+                outstandingRequests.remove(response.getRequestId());\n+            }\n+        }\n+        catch (InterruptedException e) {\n+            throw new RuntimeException(\"Interrupted while waiting for documents\", e);\n+        }\n+\n+        assertEquals(3, documents.size());\n+        for (Document document : documents)\n+            assertNotNull(document);\n+    }\n+\n+    @Test\n+    public void testFeedingAndVisiting() throws InterruptedException, ParseException {\n+        DocumentType musicType = access().getDocumentTypeManager().getDocumentType(\"music\");\n+        Document doc1 = new Document(musicType, \"id:ns:music::1\"); doc1.setFieldValue(\"artist\", \"one\");\n+        Document doc2 = new Document(musicType, \"id:ns:music::2\"); doc2.setFieldValue(\"artist\", \"two\");\n+        Document doc3 = new Document(musicType, \"id:ns:music::3\");\n+\n+        // Select all music documents where the \"artist\" field is set\n+        VisitorParameters parameters = new VisitorParameters(\"music.artist\");\n+        parameters.setFieldSet(\"music:artist\");\n+        VisitorControlHandler control = new VisitorControlHandler();\n+        parameters.setControlHandler(control);\n+        List<Document> received = new ArrayList<>();\n+        parameters.setLocalDataHandler(new DumpVisitorDataHandler() {\n+            @Override public void onDocument(Document doc, long timeStamp) {\n+                received.add(doc);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801998b41aa21cd2998c93fcb48a6a380e875697"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwNjY5NQ==", "bodyText": "Since outstanding is a ConcurrentSkipListMap I'm presuming it operates on a logical snapshot of the set of initial document IDs where concurrent removes can't mess anything up? It's been a while since I've looked into its semantics \ud83d\ude42", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438706695", "createdAt": "2020-06-11T11:03:12Z", "author": {"login": "vekterli"}, "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentGet;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.fieldset.FieldCollection;\n+import com.yahoo.document.fieldset.FieldSet;\n+import com.yahoo.document.fieldset.FieldSetRepo;\n+import com.yahoo.document.select.DocumentSelector;\n+import com.yahoo.document.select.Result;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final DocumentSelector selector;\n+    private final FieldSet fieldSet;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) throws ParseException {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.selector = new DocumentSelector(parameters.getDocumentSelection());\n+        this.fieldSet = new FieldSetRepo().parse(access.getDocumentTypeManager(), parameters.fieldSet());\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(Comparator.comparing(DocumentId::toString));\n+        this.outstanding.putAll(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    if (selector.accepts(new DocumentPut(document)) != Result.TRUE)\n+                        return;\n+\n+                    Document copy = new Document(document.getDataType(), document.getId());\n+                    for (Field field : document.getDataType().getFields())\n+                        if (fieldSet.contains(field))\n+                            copy.setFieldValue(field, document.getFieldValue(field));\n+\n+                    data.onMessage(new PutDocumentMessage(new DocumentPut(copy)),\n+                                   new AckToken(id));\n+                });\n+                // Transition to a terminal state when done\n+                state.updateAndGet(current -> {\n+                    switch (current) {\n+                        case RUNNING:\n+                            control.onDone(VisitorControlHandler.CompletionCode.SUCCESS, \"Success\");\n+                            return State.SUCCESS;\n+                        case ABORTED:\n+                            control.onDone(VisitorControlHandler.CompletionCode.ABORTED, \"Aborted by user\");\n+                            return State.ABORTED;\n+                        default:\n+                            control.onDone(VisitorControlHandler.CompletionCode.FAILURE, \"Unexpected state '\" + current + \"'\");;\n+                            return State.FAILURE;\n+                    }\n+                });\n+            }\n+            // Transition to failure terminal state on error\n+            catch (Exception e) {\n+                state.set(State.FAILURE);\n+                outstanding.clear();\n+                control.onDone(VisitorControlHandler.CompletionCode.FAILURE, Exceptions.toMessageString(e));\n+            }\n+            finally {\n+                data.onDone();\n+            }\n+        }).start();\n+    }\n+\n+    @Override\n+    public boolean isDone() {\n+        return    outstanding.isEmpty() // All documents ack'ed\n+               && control.isDone();     // Control handler has been notified\n+    }\n+\n+    @Override\n+    public ProgressToken getProgress() {\n+        throw new UnsupportedOperationException(\"Progress tokens are not supported\");\n+    }\n+\n+    @Override\n+    public Trace getTrace() {\n+        throw new UnsupportedOperationException(\"Traces are not supported\");\n+    }\n+\n+    @Override\n+    public boolean waitUntilDone(long timeoutMs) throws InterruptedException {\n+        return control.waitUntilDone(timeoutMs);\n+    }\n+\n+    @Override\n+    public void ack(AckToken token) {\n+        outstanding.remove((DocumentId) token.ackObject);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801998b41aa21cd2998c93fcb48a6a380e875697"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxMDYxNw==", "bodyText": "I'm one of those filthy {} lovers, so consider adding braces around at least the outer for-loop since it's easy to accidentally put things in the wrong scope when using multiple nested control flow statements", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438710617", "createdAt": "2020-06-11T11:12:18Z", "author": {"login": "vekterli"}, "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentGet;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.fieldset.FieldCollection;\n+import com.yahoo.document.fieldset.FieldSet;\n+import com.yahoo.document.fieldset.FieldSetRepo;\n+import com.yahoo.document.select.DocumentSelector;\n+import com.yahoo.document.select.Result;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final DocumentSelector selector;\n+    private final FieldSet fieldSet;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) throws ParseException {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.selector = new DocumentSelector(parameters.getDocumentSelection());\n+        this.fieldSet = new FieldSetRepo().parse(access.getDocumentTypeManager(), parameters.fieldSet());\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(Comparator.comparing(DocumentId::toString));\n+        this.outstanding.putAll(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    if (selector.accepts(new DocumentPut(document)) != Result.TRUE)\n+                        return;\n+\n+                    Document copy = new Document(document.getDataType(), document.getId());\n+                    for (Field field : document.getDataType().getFields())\n+                        if (fieldSet.contains(field))\n+                            copy.setFieldValue(field, document.getFieldValue(field));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801998b41aa21cd2998c93fcb48a6a380e875697"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyMDQwMg==", "bodyText": "Alternatively, I see that this functionality is already provided in FieldSetRepo.copyFields", "url": "https://github.com/vespa-engine/vespa/pull/13541#discussion_r438720402", "createdAt": "2020-06-11T11:34:35Z", "author": {"login": "vekterli"}, "path": "documentapi/src/main/java/com/yahoo/documentapi/local/LocalVisitorSession.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package com.yahoo.documentapi.local;\n+\n+import com.yahoo.document.Document;\n+import com.yahoo.document.DocumentGet;\n+import com.yahoo.document.DocumentId;\n+import com.yahoo.document.DocumentPut;\n+import com.yahoo.document.Field;\n+import com.yahoo.document.fieldset.FieldCollection;\n+import com.yahoo.document.fieldset.FieldSet;\n+import com.yahoo.document.fieldset.FieldSetRepo;\n+import com.yahoo.document.select.DocumentSelector;\n+import com.yahoo.document.select.Result;\n+import com.yahoo.document.select.parser.ParseException;\n+import com.yahoo.documentapi.AckToken;\n+import com.yahoo.documentapi.ProgressToken;\n+import com.yahoo.documentapi.VisitorControlHandler;\n+import com.yahoo.documentapi.VisitorDataHandler;\n+import com.yahoo.documentapi.VisitorDataQueue;\n+import com.yahoo.documentapi.VisitorParameters;\n+import com.yahoo.documentapi.VisitorResponse;\n+import com.yahoo.documentapi.VisitorSession;\n+import com.yahoo.documentapi.messagebus.protocol.PutDocumentMessage;\n+import com.yahoo.messagebus.Trace;\n+import com.yahoo.yolean.Exceptions;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Local visitor session that copies and iterates through all items in the local document access.\n+ * Each document must be ack'ed for the session to be done visiting.\n+ * Only document puts are sent by this session, and this is done from a separate thread.\n+ *\n+ * @author jonmv\n+ */\n+public class LocalVisitorSession implements VisitorSession {\n+\n+    private enum State { RUNNING, FAILURE, ABORTED, SUCCESS }\n+\n+    private final VisitorDataHandler data;\n+    private final VisitorControlHandler control;\n+    private final Map<DocumentId, Document> outstanding;\n+    private final DocumentSelector selector;\n+    private final FieldSet fieldSet;\n+    private final AtomicReference<State> state;\n+\n+    public LocalVisitorSession(LocalDocumentAccess access, VisitorParameters parameters) throws ParseException {\n+        if (parameters.getResumeToken() != null)\n+            throw new UnsupportedOperationException(\"Continuation via progress tokens is not supported\");\n+\n+        if (parameters.getRemoteDataHandler() != null)\n+            throw new UnsupportedOperationException(\"Remote data handlers are not supported\");\n+\n+        this.selector = new DocumentSelector(parameters.getDocumentSelection());\n+        this.fieldSet = new FieldSetRepo().parse(access.getDocumentTypeManager(), parameters.fieldSet());\n+\n+        this.data = parameters.getLocalDataHandler() == null ? new VisitorDataQueue() : parameters.getLocalDataHandler();\n+        this.data.reset();\n+        this.data.setSession(this);\n+\n+        this.control = parameters.getControlHandler() == null ? new VisitorControlHandler() : parameters.getControlHandler();\n+        this.control.reset();\n+        this.control.setSession(this);\n+\n+        this.outstanding = new ConcurrentSkipListMap<>(Comparator.comparing(DocumentId::toString));\n+        this.outstanding.putAll(access.documents);\n+        this.state = new AtomicReference<>(State.RUNNING);\n+\n+        start();\n+    }\n+\n+    void start() {\n+        new Thread(() -> {\n+            try {\n+                // Iterate through all documents and pass on to data handler\n+                outstanding.forEach((id, document) -> {\n+                    if (selector.accepts(new DocumentPut(document)) != Result.TRUE)\n+                        return;\n+\n+                    Document copy = new Document(document.getDataType(), document.getId());\n+                    for (Field field : document.getDataType().getFields())\n+                        if (fieldSet.contains(field))\n+                            copy.setFieldValue(field, document.getFieldValue(field));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxMDYxNw=="}, "originalCommit": {"oid": "801998b41aa21cd2998c93fcb48a6a380e875697"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4911919473cf6511fbd193c95cf0db81e5ebae07", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/4911919473cf6511fbd193c95cf0db81e5ebae07", "committedDate": "2020-06-11T11:45:11Z", "message": "Add draft LocalVisitorSession"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16ddfeb30367b2ee20ceaa7d89594585b5365e77", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/16ddfeb30367b2ee20ceaa7d89594585b5365e77", "committedDate": "2020-06-11T11:45:11Z", "message": "Minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04612f061138bda3e5bff58313a2323dc4005b87", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/04612f061138bda3e5bff58313a2323dc4005b87", "committedDate": "2020-06-11T11:45:11Z", "message": "Update abi spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42852ad470315f3bd3e8da2701f3a2de91d14b95", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/42852ad470315f3bd3e8da2701f3a2de91d14b95", "committedDate": "2020-06-11T11:45:11Z", "message": "Respect selection and field set parameters, and unit test LocalVisitorSession"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fbc3d229163ab22c80988bf80c7919e5c1a4497", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/3fbc3d229163ab22c80988bf80c7919e5c1a4497", "committedDate": "2020-06-11T12:08:43Z", "message": "Use library to copy fields, and make more robust wrt. future concurrency changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "801998b41aa21cd2998c93fcb48a6a380e875697", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/801998b41aa21cd2998c93fcb48a6a380e875697", "committedDate": "2020-06-11T09:30:36Z", "message": "Respect selection and field set parameters, and unit test LocalVisitorSession"}, "afterCommit": {"oid": "3fbc3d229163ab22c80988bf80c7919e5c1a4497", "author": {"user": {"login": "jonmv", "name": "Jon Marius Venstad"}}, "url": "https://github.com/vespa-engine/vespa/commit/3fbc3d229163ab22c80988bf80c7919e5c1a4497", "committedDate": "2020-06-11T12:08:43Z", "message": "Use library to copy fields, and make more robust wrt. future concurrency changes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3739, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}