{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MDgxOTkx", "number": 15484, "title": "Arnej/add serialized fast value attribute", "bodyText": "I confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.\n@geirst please review", "createdAt": "2020-11-26T13:36:22Z", "url": "https://github.com/vespa-engine/vespa/pull/15484", "merged": true, "mergeCommit": {"oid": "8d9680d2101c76229190598547362ab2760d3d2f"}, "closed": true, "closedAt": "2020-12-01T14:02:52Z", "author": {"login": "arnej27959"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgTDxuAH2gAyNTI4MDgxOTkxOjAxZmJjMjliNjEzMjhmZGFkNmM4NjA3YjUwOTlmZmQzYjVjZjQ1YTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdhiP9-gFqTU0MDc0NjY3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "01fbc29b61328fdad6c8607b5099ffd3b5cf45a1", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/01fbc29b61328fdad6c8607b5099ffd3b5cf45a1", "committedDate": "2020-11-26T13:35:08Z", "message": "more explicit name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1644ca6e82ca22275e8d350724d995682ed87b1f", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/1644ca6e82ca22275e8d350724d995682ed87b1f", "committedDate": "2020-11-26T13:35:08Z", "message": "add SerializedFastValueAttribute"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d68669ae2a1e35b88db93308f6c4922f698c4ab2", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/d68669ae2a1e35b88db93308f6c4922f698c4ab2", "committedDate": "2020-11-26T13:35:08Z", "message": "use SerializedFastValueAttribute if possible"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5c16579174f3e20b4cc67886476aa9e05408102", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/d5c16579174f3e20b4cc67886476aa9e05408102", "committedDate": "2020-11-26T13:35:08Z", "message": "more consistent version checking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/600249318782e85982cce4b1e1f8bcf9a1c7a000", "committedDate": "2020-11-27T12:48:28Z", "message": "test SerializedFastValueAttribute instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c", "committedDate": "2020-11-27T13:47:43Z", "message": "Merge branch 'master' into arnej/add-serialized_fast_value_attribute\n\nfix trivial conflict.\n\nConflicts:\n\tsearchlib/src/tests/features/tensor/tensor_test.cpp"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5OTcyOTgw", "url": "https://github.com/vespa-engine/vespa/pull/15484#pullrequestreview-539972980", "createdAt": "2020-11-27T13:17:29Z", "commit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzoxNzoyOVrOH6-FBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzozMjowM1rOH6-iTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5NjU0OQ==", "bodyText": "Please add copyright.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531596549", "createdAt": "2020-11-27T13:17:29Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.h", "diffHunk": "@@ -0,0 +1,26 @@\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5NjY0MA==", "bodyText": "Please add copyright.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531596640", "createdAt": "2020-11-27T13:17:42Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.cpp", "diffHunk": "@@ -0,0 +1,207 @@\n+#include \"serialized_fast_value_attribute.h\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU5Njk5Ng==", "bodyText": "Please add copyright.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531596996", "createdAt": "2020-11-27T13:18:29Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwMTczMw==", "bodyText": "Please rename to a more descriptive name.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531601733", "createdAt": "2020-11-27T13:27:36Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+\n+#include \"streamed_value_store.h\"\n+#include \"tensor_deserialize.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/streamed/streamed_value_builder_factory.h>\n+#include <vespa/eval/streamed/streamed_value_view.h>\n+#include <vespa/vespalib/datastore/datastore.hpp>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_store\");\n+\n+using vespalib::datastore::Handle;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+constexpr size_t MIN_BUFFER_ARRAYS = 1024;\n+\n+struct CellsMemBlock {\n+    uint32_t num;\n+    uint32_t total_sz;\n+    const char *ptr;\n+    CellsMemBlock(TypedCells cells)\n+      : num(cells.size),\n+        total_sz(CellTypeUtils::mem_size(cells.type, num)),\n+        ptr((const char *)cells.data)\n+    {}\n+};\n+\n+template<typename T>\n+T *fix_alignment(T *ptr, size_t align)\n+{\n+    static_assert(sizeof(T) == 1);\n+    assert((align & (align-1)) == 0); // must be 2^N\n+    size_t ptr_val = (size_t)ptr;\n+    size_t unalign = ptr_val & (align - 1);\n+    if (unalign == 0) {\n+        return ptr;\n+    } else {\n+        return ptr + (align - unalign);\n+    }\n+}\n+\n+} // namespace <unnamed>\n+\n+StreamedValueStore::StreamedValueStore(const ValueType &tensor_type)\n+  : TensorStore(_concreteStore),\n+    _concreteStore(),\n+    _bufferType(RefType::align(1),\n+                MIN_BUFFER_ARRAYS,\n+                RefType::offsetSize() / RefType::align(1)),\n+    _tensor_type(tensor_type),\n+    _data_from_type(_tensor_type)\n+{\n+    _store.addType(&_bufferType);\n+    _store.initActiveBuffers();\n+}\n+\n+StreamedValueStore::~StreamedValueStore()\n+{\n+    _store.dropBuffers();\n+}\n+\n+std::pair<const char *, uint32_t>\n+StreamedValueStore::getRawBuffer(RefType ref) const\n+{\n+    if (!ref.valid()) {\n+        return std::make_pair(nullptr, 0u);\n+    }\n+    const char *buf = _store.getEntry<char>(ref);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    return std::make_pair(buf + sizeof(uint32_t), len);\n+}\n+\n+Handle<char>\n+StreamedValueStore::allocRawBuffer(uint32_t size)\n+{\n+    if (size == 0) {\n+        return Handle<char>();\n+    }\n+    size_t extSize = size + sizeof(uint32_t);\n+    size_t bufSize = RefType::align(extSize);\n+    auto result = _concreteStore.rawAllocator<char>(_typeId).alloc(bufSize);\n+    *reinterpret_cast<uint32_t *>(result.data) = size;\n+    char *padWritePtr = result.data + extSize;\n+    for (size_t i = extSize; i < bufSize; ++i) {\n+        *padWritePtr++ = 0;\n+    }\n+    // Hide length of buffer (first 4 bytes) from users of the buffer.\n+    return Handle<char>(result.ref, result.data + sizeof(uint32_t));\n+}\n+\n+void\n+StreamedValueStore::holdTensor(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return;\n+    }\n+    RefType iRef(ref);\n+    const char *buf = _store.getEntry<char>(iRef);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    _concreteStore.holdElem(ref, len + sizeof(uint32_t));\n+}\n+\n+TensorStore::EntryRef\n+StreamedValueStore::move(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return RefType();\n+    }\n+    auto oldraw = getRawBuffer(ref);\n+    auto newraw = allocRawBuffer(oldraw.second);\n+    memcpy(newraw.data, oldraw.first, oldraw.second);\n+    _concreteStore.holdElem(ref, oldraw.second + sizeof(uint32_t));\n+    return newraw.ref;\n+}\n+\n+StreamedValueStore::StreamedValueData\n+StreamedValueStore::get_tensor_data(EntryRef ref) const\n+{\n+    StreamedValueData retval;\n+    retval.valid = false;\n+    auto raw = getRawBuffer(ref);\n+    if (raw.second == 0u) {\n+        return retval;\n+    }\n+    vespalib::nbostream_longlivedbuf source(raw.first, raw.second);\n+    uint32_t num_cells = source.readValue<uint32_t>();\n+    {\n+        uint32_t alignment = CellTypeUtils::alignment(_data_from_type.cell_type);\n+        const char *aligned_ptr = fix_alignment(source.peek(), alignment);\n+        size_t adjustment = aligned_ptr - source.peek();\n+        source.adjustReadPos(adjustment);\n+    }\n+    retval.cells_ref = TypedCells(source.peek(), _data_from_type.cell_type, num_cells);\n+    source.adjustReadPos(CellTypeUtils::mem_size(_data_from_type.cell_type, num_cells));\n+    retval.num_subspaces = source.readValue<uint32_t>();\n+    retval.labels_buffer = vespalib::ConstArrayRef<char>(source.peek(), source.size());\n+ \n+    if (retval.num_subspaces * _data_from_type.dense_subspace_size == num_cells) {\n+        retval.valid = true;\n+        return retval;\n+    }\n+    LOG(warning, \"inconsistent stored tensor data: \"\n+        \"num_subspaces[%zu] * dense_subspace_size[%u] = %zu != num_cells[%u]\",\n+        retval.num_subspaces, _data_from_type.dense_subspace_size,\n+        retval.num_subspaces * _data_from_type.dense_subspace_size,\n+        num_cells);\n+    return retval;\n+}\n+\n+bool\n+StreamedValueStore::encode_tensor(EntryRef ref, vespalib::nbostream &target) const\n+{\n+    if (auto data = get_tensor_data(ref)) {\n+        StreamedValueView value(\n+            _tensor_type, _data_from_type.num_mapped_dimensions,\n+            data.cells_ref, data.num_subspaces, data.labels_buffer);\n+        vespalib::eval::encode_value(value, target);\n+        return true;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+void\n+StreamedValueStore::my_encode(const Value::Index &index,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwMzYwNA==", "bodyText": "Please update copyright.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531603604", "createdAt": "2020-11-27T13:31:10Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.h", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNDA0NQ==", "bodyText": "Please update description to reflect implementation. Would also be nice with a short description of the serialisation format used.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531604045", "createdAt": "2020-11-27T13:32:03Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.h", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright 2017 Yahoo Holdings. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include \"tensor_store.h\"\n+#include <vespa/eval/eval/value_type.h>\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/typify.h>\n+\n+namespace search::tensor {\n+\n+/**\n+ * Class for storing serialized tensors in memory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "600249318782e85982cce4b1e1f8bcf9a1c7a000"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMDA5NjM4", "url": "https://github.com/vespa-engine/vespa/pull/15484#pullrequestreview-540009638", "createdAt": "2020-11-27T14:14:34Z", "commit": {"oid": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxNDozNVrOH6_2UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxNjoxNlrOH6_56Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNTU1Mw==", "bodyText": "Consider adding labels to error message.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531625553", "createdAt": "2020-11-27T14:14:35Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/serialized_fast_value_attribute.cpp", "diffHunk": "@@ -0,0 +1,207 @@\n+#include \"serialized_fast_value_attribute.h\"\n+#include \"streamed_value_saver.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/fast_value.hpp>\n+#include <vespa/eval/streamed/streamed_value_utils.h>\n+#include <vespa/fastlib/io/bufferedfile.h>\n+#include <vespa/searchlib/attribute/readerbase.h>\n+#include <vespa/searchlib/util/fileutil.h>\n+#include <vespa/vespalib/util/rcuvector.hpp>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.serialized_fast_value_attribute\");\n+\n+#include \"blob_sequence_reader.h\"\n+#include \"tensor_attribute.hpp\"\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+struct ValueBlock : LabelBlock {\n+    TypedCells cells;\n+};\n+\n+class ValueBlockStream {\n+private:\n+    const StreamedValueStore::DataFromType &_from_type;\n+    LabelBlockStream _label_block_stream;\n+    const char *_cells_ptr;\n+\n+    size_t dsss() const { return _from_type.dense_subspace_size; }\n+    auto cell_type() const { return _from_type.cell_type; }\n+public:\n+    ValueBlock next_block() {\n+        auto labels = _label_block_stream.next_block();\n+        if (labels) {\n+            TypedCells subspace_cells(_cells_ptr, cell_type(), dsss());\n+            _cells_ptr += CellTypeUtils::mem_size(cell_type(), dsss());\n+            return ValueBlock{labels, subspace_cells};\n+        } else {\n+            TypedCells none(nullptr, cell_type(), 0);\n+            return ValueBlock{labels, none};\n+        }\n+    }\n+    \n+    ValueBlockStream(const StreamedValueStore::DataFromType &from_type,\n+                     const StreamedValueStore::StreamedValueData &from_store)\n+      : _from_type(from_type),\n+        _label_block_stream(from_store.num_subspaces,\n+                            from_store.labels_buffer,\n+                            from_type.num_mapped_dimensions),\n+        _cells_ptr((const char *)from_store.cells_ref.data)\n+    {\n+        _label_block_stream.reset();\n+    }\n+    \n+    ~ValueBlockStream();\n+};\n+\n+ValueBlockStream::~ValueBlockStream() = default;\n+\n+class OnlyFastValueIndex : public Value {\n+private:\n+    const ValueType &_type;\n+    TypedCells _cells;\n+    FastValueIndex my_index;\n+public:\n+    OnlyFastValueIndex(const ValueType &type,\n+                       const StreamedValueStore::DataFromType &from_type,\n+                       const StreamedValueStore::StreamedValueData &from_store)\n+      : _type(type),\n+        _cells(from_store.cells_ref),\n+        my_index(from_type.num_mapped_dimensions,\n+                 from_store.num_subspaces)\n+    {\n+        assert(_type.cell_type() == _cells.type);\n+        std::vector<vespalib::stringref> address(from_type.num_mapped_dimensions);\n+        auto block_stream = ValueBlockStream(from_type, from_store);\n+        size_t ss = 0;\n+        while (auto block = block_stream.next_block()) {\n+            size_t idx = my_index.map.add_mapping(block.address);\n+            if (idx != ss) {\n+                LOG(error, \"add_mapping returned idx=%zu for subspace %zu\", idx, ss);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNjAzOQ==", "bodyText": "Change to an assert.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531626039", "createdAt": "2020-11-27T14:15:28Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+\n+#include \"streamed_value_store.h\"\n+#include \"tensor_deserialize.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/streamed/streamed_value_builder_factory.h>\n+#include <vespa/eval/streamed/streamed_value_view.h>\n+#include <vespa/vespalib/datastore/datastore.hpp>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_store\");\n+\n+using vespalib::datastore::Handle;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+constexpr size_t MIN_BUFFER_ARRAYS = 1024;\n+\n+struct CellsMemBlock {\n+    uint32_t num;\n+    uint32_t total_sz;\n+    const char *ptr;\n+    CellsMemBlock(TypedCells cells)\n+      : num(cells.size),\n+        total_sz(CellTypeUtils::mem_size(cells.type, num)),\n+        ptr((const char *)cells.data)\n+    {}\n+};\n+\n+template<typename T>\n+T *fix_alignment(T *ptr, size_t align)\n+{\n+    static_assert(sizeof(T) == 1);\n+    assert((align & (align-1)) == 0); // must be 2^N\n+    size_t ptr_val = (size_t)ptr;\n+    size_t unalign = ptr_val & (align - 1);\n+    if (unalign == 0) {\n+        return ptr;\n+    } else {\n+        return ptr + (align - unalign);\n+    }\n+}\n+\n+} // namespace <unnamed>\n+\n+StreamedValueStore::StreamedValueStore(const ValueType &tensor_type)\n+  : TensorStore(_concreteStore),\n+    _concreteStore(),\n+    _bufferType(RefType::align(1),\n+                MIN_BUFFER_ARRAYS,\n+                RefType::offsetSize() / RefType::align(1)),\n+    _tensor_type(tensor_type),\n+    _data_from_type(_tensor_type)\n+{\n+    _store.addType(&_bufferType);\n+    _store.initActiveBuffers();\n+}\n+\n+StreamedValueStore::~StreamedValueStore()\n+{\n+    _store.dropBuffers();\n+}\n+\n+std::pair<const char *, uint32_t>\n+StreamedValueStore::getRawBuffer(RefType ref) const\n+{\n+    if (!ref.valid()) {\n+        return std::make_pair(nullptr, 0u);\n+    }\n+    const char *buf = _store.getEntry<char>(ref);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    return std::make_pair(buf + sizeof(uint32_t), len);\n+}\n+\n+Handle<char>\n+StreamedValueStore::allocRawBuffer(uint32_t size)\n+{\n+    if (size == 0) {\n+        return Handle<char>();\n+    }\n+    size_t extSize = size + sizeof(uint32_t);\n+    size_t bufSize = RefType::align(extSize);\n+    auto result = _concreteStore.rawAllocator<char>(_typeId).alloc(bufSize);\n+    *reinterpret_cast<uint32_t *>(result.data) = size;\n+    char *padWritePtr = result.data + extSize;\n+    for (size_t i = extSize; i < bufSize; ++i) {\n+        *padWritePtr++ = 0;\n+    }\n+    // Hide length of buffer (first 4 bytes) from users of the buffer.\n+    return Handle<char>(result.ref, result.data + sizeof(uint32_t));\n+}\n+\n+void\n+StreamedValueStore::holdTensor(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return;\n+    }\n+    RefType iRef(ref);\n+    const char *buf = _store.getEntry<char>(iRef);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    _concreteStore.holdElem(ref, len + sizeof(uint32_t));\n+}\n+\n+TensorStore::EntryRef\n+StreamedValueStore::move(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return RefType();\n+    }\n+    auto oldraw = getRawBuffer(ref);\n+    auto newraw = allocRawBuffer(oldraw.second);\n+    memcpy(newraw.data, oldraw.first, oldraw.second);\n+    _concreteStore.holdElem(ref, oldraw.second + sizeof(uint32_t));\n+    return newraw.ref;\n+}\n+\n+StreamedValueStore::StreamedValueData\n+StreamedValueStore::get_tensor_data(EntryRef ref) const\n+{\n+    StreamedValueData retval;\n+    retval.valid = false;\n+    auto raw = getRawBuffer(ref);\n+    if (raw.second == 0u) {\n+        return retval;\n+    }\n+    vespalib::nbostream_longlivedbuf source(raw.first, raw.second);\n+    uint32_t num_cells = source.readValue<uint32_t>();\n+    {\n+        uint32_t alignment = CellTypeUtils::alignment(_data_from_type.cell_type);\n+        const char *aligned_ptr = fix_alignment(source.peek(), alignment);\n+        size_t adjustment = aligned_ptr - source.peek();\n+        source.adjustReadPos(adjustment);\n+    }\n+    retval.cells_ref = TypedCells(source.peek(), _data_from_type.cell_type, num_cells);\n+    source.adjustReadPos(CellTypeUtils::mem_size(_data_from_type.cell_type, num_cells));\n+    retval.num_subspaces = source.readValue<uint32_t>();\n+    retval.labels_buffer = vespalib::ConstArrayRef<char>(source.peek(), source.size());\n+ \n+    if (retval.num_subspaces * _data_from_type.dense_subspace_size == num_cells) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNjQ3Mw==", "bodyText": "We can remove the log message with the assert above.", "url": "https://github.com/vespa-engine/vespa/pull/15484#discussion_r531626473", "createdAt": "2020-11-27T14:16:16Z", "author": {"login": "geirst"}, "path": "searchlib/src/vespa/searchlib/tensor/streamed_value_store.cpp", "diffHunk": "@@ -0,0 +1,241 @@\n+\n+#include \"streamed_value_store.h\"\n+#include \"tensor_deserialize.h\"\n+#include <vespa/eval/eval/value.h>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/streamed/streamed_value_builder_factory.h>\n+#include <vespa/eval/streamed/streamed_value_view.h>\n+#include <vespa/vespalib/datastore/datastore.hpp>\n+#include <vespa/vespalib/objects/nbostream.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/log/log.h>\n+\n+LOG_SETUP(\".searchlib.tensor.streamed_value_store\");\n+\n+using vespalib::datastore::Handle;\n+using namespace vespalib::eval;\n+\n+namespace search::tensor {\n+\n+namespace {\n+\n+constexpr size_t MIN_BUFFER_ARRAYS = 1024;\n+\n+struct CellsMemBlock {\n+    uint32_t num;\n+    uint32_t total_sz;\n+    const char *ptr;\n+    CellsMemBlock(TypedCells cells)\n+      : num(cells.size),\n+        total_sz(CellTypeUtils::mem_size(cells.type, num)),\n+        ptr((const char *)cells.data)\n+    {}\n+};\n+\n+template<typename T>\n+T *fix_alignment(T *ptr, size_t align)\n+{\n+    static_assert(sizeof(T) == 1);\n+    assert((align & (align-1)) == 0); // must be 2^N\n+    size_t ptr_val = (size_t)ptr;\n+    size_t unalign = ptr_val & (align - 1);\n+    if (unalign == 0) {\n+        return ptr;\n+    } else {\n+        return ptr + (align - unalign);\n+    }\n+}\n+\n+} // namespace <unnamed>\n+\n+StreamedValueStore::StreamedValueStore(const ValueType &tensor_type)\n+  : TensorStore(_concreteStore),\n+    _concreteStore(),\n+    _bufferType(RefType::align(1),\n+                MIN_BUFFER_ARRAYS,\n+                RefType::offsetSize() / RefType::align(1)),\n+    _tensor_type(tensor_type),\n+    _data_from_type(_tensor_type)\n+{\n+    _store.addType(&_bufferType);\n+    _store.initActiveBuffers();\n+}\n+\n+StreamedValueStore::~StreamedValueStore()\n+{\n+    _store.dropBuffers();\n+}\n+\n+std::pair<const char *, uint32_t>\n+StreamedValueStore::getRawBuffer(RefType ref) const\n+{\n+    if (!ref.valid()) {\n+        return std::make_pair(nullptr, 0u);\n+    }\n+    const char *buf = _store.getEntry<char>(ref);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    return std::make_pair(buf + sizeof(uint32_t), len);\n+}\n+\n+Handle<char>\n+StreamedValueStore::allocRawBuffer(uint32_t size)\n+{\n+    if (size == 0) {\n+        return Handle<char>();\n+    }\n+    size_t extSize = size + sizeof(uint32_t);\n+    size_t bufSize = RefType::align(extSize);\n+    auto result = _concreteStore.rawAllocator<char>(_typeId).alloc(bufSize);\n+    *reinterpret_cast<uint32_t *>(result.data) = size;\n+    char *padWritePtr = result.data + extSize;\n+    for (size_t i = extSize; i < bufSize; ++i) {\n+        *padWritePtr++ = 0;\n+    }\n+    // Hide length of buffer (first 4 bytes) from users of the buffer.\n+    return Handle<char>(result.ref, result.data + sizeof(uint32_t));\n+}\n+\n+void\n+StreamedValueStore::holdTensor(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return;\n+    }\n+    RefType iRef(ref);\n+    const char *buf = _store.getEntry<char>(iRef);\n+    uint32_t len = *reinterpret_cast<const uint32_t *>(buf);\n+    _concreteStore.holdElem(ref, len + sizeof(uint32_t));\n+}\n+\n+TensorStore::EntryRef\n+StreamedValueStore::move(EntryRef ref)\n+{\n+    if (!ref.valid()) {\n+        return RefType();\n+    }\n+    auto oldraw = getRawBuffer(ref);\n+    auto newraw = allocRawBuffer(oldraw.second);\n+    memcpy(newraw.data, oldraw.first, oldraw.second);\n+    _concreteStore.holdElem(ref, oldraw.second + sizeof(uint32_t));\n+    return newraw.ref;\n+}\n+\n+StreamedValueStore::StreamedValueData\n+StreamedValueStore::get_tensor_data(EntryRef ref) const\n+{\n+    StreamedValueData retval;\n+    retval.valid = false;\n+    auto raw = getRawBuffer(ref);\n+    if (raw.second == 0u) {\n+        return retval;\n+    }\n+    vespalib::nbostream_longlivedbuf source(raw.first, raw.second);\n+    uint32_t num_cells = source.readValue<uint32_t>();\n+    {\n+        uint32_t alignment = CellTypeUtils::alignment(_data_from_type.cell_type);\n+        const char *aligned_ptr = fix_alignment(source.peek(), alignment);\n+        size_t adjustment = aligned_ptr - source.peek();\n+        source.adjustReadPos(adjustment);\n+    }\n+    retval.cells_ref = TypedCells(source.peek(), _data_from_type.cell_type, num_cells);\n+    source.adjustReadPos(CellTypeUtils::mem_size(_data_from_type.cell_type, num_cells));\n+    retval.num_subspaces = source.readValue<uint32_t>();\n+    retval.labels_buffer = vespalib::ConstArrayRef<char>(source.peek(), source.size());\n+ \n+    if (retval.num_subspaces * _data_from_type.dense_subspace_size == num_cells) {\n+        retval.valid = true;\n+        return retval;\n+    }\n+    LOG(warning, \"inconsistent stored tensor data: \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42785e0da5ca8ba8f8d6535ee5b192a7b52cef5c"}, "originalPosition": 149}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da1bc43297be17d4f7ea18026c9984f07098af73", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/da1bc43297be17d4f7ea18026c9984f07098af73", "committedDate": "2020-11-27T15:39:02Z", "message": "review follow-up fixes\n\n* add documentation comment for OnlyFastValueIndex\n* flesh out documentation comment for StreamedValueStore\n* no need for nbostream_longlivedbuf here\n* rename my_encode -> serialize_labels\n* less random logging of problems\n* report labels for addresses causing subspace collision"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ac10dad24980734a161533c36b232cfc5d3a2f9", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/4ac10dad24980734a161533c36b232cfc5d3a2f9", "committedDate": "2020-11-27T15:52:51Z", "message": "check tensor type in attribute, just assert in store"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNzQ2Njcy", "url": "https://github.com/vespa-engine/vespa/pull/15484#pullrequestreview-540746672", "createdAt": "2020-11-30T09:50:57Z", "commit": {"oid": "4ac10dad24980734a161533c36b232cfc5d3a2f9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1896, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}