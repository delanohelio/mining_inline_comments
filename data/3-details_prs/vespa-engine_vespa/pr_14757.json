{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5MjE0ODYx", "number": 14757, "title": "Add tensor partial update 2", "bodyText": "I confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.\n@havardpe please review", "createdAt": "2020-10-07T12:31:28Z", "url": "https://github.com/vespa-engine/vespa/pull/14757", "merged": true, "mergeCommit": {"oid": "a09b5e3ecf05ea03c43dc16f42e0ab9956e5c837"}, "closed": true, "closedAt": "2020-10-09T12:17:13Z", "author": {"login": "arnej27959"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQLwDcAH2gAyNDk5MjE0ODYxOjNmNzU0NjBkNjU3ZWRlYjZlZTZiNjYwMzViNTdiNDE4NTY5YTM0YzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQ3Yw1gFqTUwNTc0Nzc2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3f75460d657edeb6ee6b66035b57b418569a34c3", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/3f75460d657edeb6ee6b66035b57b418569a34c3", "committedDate": "2020-10-07T12:01:28Z", "message": "simplify TensorSpec::add()\n\n* the old multiple-add semantics weren't used for anything,\n  so make it more predictable and constrained."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d8516aecc9caf10435cd63cd59973d29e5c07cc", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/7d8516aecc9caf10435cd63cd59973d29e5c07cc", "committedDate": "2020-10-07T12:02:01Z", "message": "add TensorPartialUpdate with add/modify/remove"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd344fae9aaad5b78ab0cf6c9e122d258e544338", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/bd344fae9aaad5b78ab0cf6c9e122d258e544338", "committedDate": "2020-10-07T12:28:43Z", "message": "add PartialModify unit test for bad input"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf22d0d633e3c10c3983082f77a0ce94886cd142", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/bf22d0d633e3c10c3983082f77a0ce94886cd142", "committedDate": "2020-10-07T12:29:08Z", "message": "add PartialAdd unit test for bad input"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/04f832a3306c838b3febe21f85d7364e14306695", "committedDate": "2020-10-07T12:29:18Z", "message": "add PartialRemove unit test for bad input"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92ba58419a060ca954159b09b1a1c8914db673db", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/92ba58419a060ca954159b09b1a1c8914db673db", "committedDate": "2020-10-08T10:00:22Z", "message": "update comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29671a8e2d4f4f626625ce8a4e9683cd7227f091", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/29671a8e2d4f4f626625ce8a4e9683cd7227f091", "committedDate": "2020-10-08T10:01:17Z", "message": "only keep DimCase enums that are possible (within current constraints)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6861f023c18e5af08510b9f0b349c480788b5d7d", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/6861f023c18e5af08510b9f0b349c480788b5d7d", "committedDate": "2020-10-08T10:05:13Z", "message": "remove leftovers from logging warnings when addresses did not convert successfully"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38aeb55dce31ae16a0f45b250e87d233eab21842", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/38aeb55dce31ae16a0f45b250e87d233eab21842", "committedDate": "2020-10-08T10:09:07Z", "message": "do the TensorPartialUpdate operations directly in invoke()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d492833e53c7f732d6fc4f70f57a708b42e1cf97", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/d492833e53c7f732d6fc4f70f57a708b42e1cf97", "committedDate": "2020-10-08T10:30:54Z", "message": "test larger mixed, cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9526256266deeca7075f329a15ef3c062e3d835", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/b9526256266deeca7075f329a15ef3c062e3d835", "committedDate": "2020-10-08T10:34:20Z", "message": "move common code to copy_tensor_with_filter()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0571536c35ea992d47f3407f59de7f794530e0a", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/b0571536c35ea992d47f3407f59de7f794530e0a", "committedDate": "2020-10-08T11:26:15Z", "message": "simplify validation\n\n* and rename Addresses -> SparseCoords"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NTk1OTcy", "url": "https://github.com/vespa-engine/vespa/pull/14757#pullrequestreview-504595972", "createdAt": "2020-10-08T09:30:16Z", "commit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwOTozMDoxNlrOHeV5lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMTo0NDowN1rOHealZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3ODEzNQ==", "bodyText": "I suggest just dropping concat, since others may also have use of this.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501578135", "createdAt": "2020-10-08T09:30:16Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/eval/tensor_spec.cpp", "diffHunk": "@@ -46,9 +46,14 @@ TensorSpec & TensorSpec::operator = (const TensorSpec &) = default;\n TensorSpec::~TensorSpec() { }\n \n TensorSpec &\n-TensorSpec::set(Address address, double value) {\n-    auto res = _cells.emplace(std::move(address), value);\n-    if (!res.second) { assert(res.first->second.value == value); }\n+TensorSpec::add(Address address, double value) {\n+    auto [iter, inserted] = _cells.emplace(std::move(address), value);\n+    if (! inserted) {\n+        // to simplify reference concat implementation, allow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU3OTcyMw==", "bodyText": "vespalib::eval::operation::op2_t is the canonical type for this kind of function", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501579723", "createdAt": "2020-10-08T09:32:43Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.h", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::tensor {\n+\n+struct TensorPartialUpdate {\n+    using join_fun_t = double (*)(double, double);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4MTEzOA==", "bodyText": "dimensions", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501581138", "createdAt": "2020-10-08T09:34:59Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.h", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::tensor {\n+\n+struct TensorPartialUpdate {\n+    using join_fun_t = double (*)(double, double);\n+    using Value = vespalib::eval::Value;\n+    using ValueBuilderFactory = vespalib::eval::ValueBuilderFactory;\n+\n+    // make a copy of the input, but apply function(oldvalue, modifier.cellvalue)\n+    // to cells which also exist in the \"modifier\".\n+    // modifier.type() must be sparse with exactly the same dimension names\n+    // as the input type.\n+    // returns null pointer if this constraint is violated.\n+    static Value::UP modify(const Value &input, join_fun_t function,\n+                            const Value &modifier, const ValueBuilderFactory &factory);\n+\n+    // make a copy of the input, but add or overwrite cells from add_cells.\n+    // requires same type for input and add_cells.\n+    // returns null pointer if this constraint is violated.\n+    static Value::UP add(const Value &input, const Value &add_cells, const ValueBuilderFactory &factory);\n+\n+    // make a copy of the input, but remove cells present in remove_spec.\n+    // cell values in remove_spec are ignored.\n+    // requires same set of mapped imensions input and remove_spec.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4NDAyMg==", "bodyText": "is this too complicated?", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501584022", "createdAt": "2020-10-08T09:39:29Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU4OTYyMQ==", "bodyText": "const char * seems a bit low level", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501589621", "createdAt": "2020-10-08T09:48:20Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5MTUzMA==", "bodyText": "no need for dimension name of you are not going to print stuff", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501591530", "createdAt": "2020-10-08T09:51:23Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU5MjUyNg==", "bodyText": "consider naming this something with Sparse; SparseAddresses, SparseCoords", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501592526", "createdAt": "2020-10-08T09:52:55Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY0MDA4Mw==", "bodyText": "consider checking number of dimensions together with modifier sparseness and only checking valid here.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501640083", "createdAt": "2020-10-08T11:15:55Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY0NTYxNw==", "bodyText": "consider doing simple encode/decode for value copy", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501645617", "createdAt": "2020-10-08T11:26:38Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||\n+            (input_dims.size() != modifier_dims.size()) ||\n+            (input_dims.size() != how.size()))\n+        {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.name.c_str(), dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, Addresses &helper, const ValueBuilderFactory &factory)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY1MzM1Ng==", "bodyText": "compare to modifier.dimensions() directly to ensure there are no dense ones as well.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501653356", "createdAt": "2020-10-08T11:41:09Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||\n+            (input_dims.size() != modifier_dims.size()) ||\n+            (input_dims.size() != how.size()))\n+        {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.name.c_str(), dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, Addresses &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto view = input.index().create_view({});\n+    view->lookup({});\n+    auto input_cells = input.cells().typify<CT>();\n+    size_t input_subspace;\n+    while (view->next_result(helper.next_result_refs, input_subspace)) {\n+        size_t input_offset = input_subspace * dsss;\n+        auto src = input_cells.begin() + input_offset;\n+        auto dst = builder->add_subspace(helper.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_modify_value(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_modify_value<ICT,MCT>(input, function, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_add_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> overwritten_subspaces;\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(addrs.next_result_refs, modifier_subspace_index)) {\n+        size_t modifier_offset = dsss * modifier_subspace_index;\n+        auto src = modifier_cells.begin() + modifier_offset;\n+        auto dst = builder->add_subspace(addrs.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+        lookup_view->lookup(addrs.lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten_subspaces.insert(input_subspace_index);\n+        }\n+    }\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (overwritten_subspaces.count(input_subspace_index) == 0) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder->add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_add_cells<ICT,MCT>(input, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename ICT>\n+Value::UP\n+my_remove_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.mapped_dimensions()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY1NDUxOQ==", "bodyText": "no need to precalculate this", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501654519", "createdAt": "2020-10-08T11:43:24Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||\n+            (input_dims.size() != modifier_dims.size()) ||\n+            (input_dims.size() != how.size()))\n+        {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.name.c_str(), dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, Addresses &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto view = input.index().create_view({});\n+    view->lookup({});\n+    auto input_cells = input.cells().typify<CT>();\n+    size_t input_subspace;\n+    while (view->next_result(helper.next_result_refs, input_subspace)) {\n+        size_t input_offset = input_subspace * dsss;\n+        auto src = input_cells.begin() + input_offset;\n+        auto dst = builder->add_subspace(helper.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_modify_value(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_modify_value<ICT,MCT>(input, function, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_add_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> overwritten_subspaces;\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(addrs.next_result_refs, modifier_subspace_index)) {\n+        size_t modifier_offset = dsss * modifier_subspace_index;\n+        auto src = modifier_cells.begin() + modifier_offset;\n+        auto dst = builder->add_subspace(addrs.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+        lookup_view->lookup(addrs.lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten_subspaces.insert(input_subspace_index);\n+        }\n+    }\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (overwritten_subspaces.count(input_subspace_index) == 0) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder->add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_add_cells<ICT,MCT>(input, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename ICT>\n+Value::UP\n+my_remove_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.mapped_dimensions()) {\n+        LOG(error, \"when removing cells from a tensor, mapped dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    if (input_type.mapped_dimensions().size() == 0) {\n+        LOG(error, \"cannot remove cells from a dense tensor\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> removed_subspaces;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY1NDg4Ng==", "bodyText": "just look up directly in the modify view to find out which ones not to include", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501654886", "createdAt": "2020-10-08T11:44:07Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    SKIP_MAPPED, SKIP_INDEXED,\n+    MISSING_MAPPED, MISSING_INDEXED,\n+    MAPPED_MATCH, INDEXED_MATCH,\n+    CONV_TO_INDEXED, CONV_TO_MAPPED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    std::vector<const char *> dim_names;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            // \"bad label{%s} in modifier tensor, was %zu, must be < %zu\", dim_names[dim], coord, cur\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                // \"bad label{%s} in modifier tensor, was '%s'\", dim_names[dim], label.data()\n+                offset = npos();\n+                ++dim;\n+                return;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(const char *name, size_t sz) {\n+        dim_sizes.push_back(sz);\n+        dim_names.push_back(name);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct Addresses {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    Addresses(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~Addresses();\n+};\n+Addresses::~Addresses() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    Addresses for_output;\n+    Addresses from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if ((! valid) ||\n+            (input_dims.size() != modifier_dims.size()) ||\n+            (input_dims.size() != how.size()))\n+        {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.name.c_str(), dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, Addresses &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto view = input.index().create_view({});\n+    view->lookup({});\n+    auto input_cells = input.cells().typify<CT>();\n+    size_t input_subspace;\n+    while (view->next_result(helper.next_result_refs, input_subspace)) {\n+        size_t input_offset = input_subspace * dsss;\n+        auto src = input_cells.begin() + input_offset;\n+        auto dst = builder->add_subspace(helper.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_modify_value(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_modify_value<ICT,MCT>(input, function, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+my_add_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> overwritten_subspaces;\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(addrs.next_result_refs, modifier_subspace_index)) {\n+        size_t modifier_offset = dsss * modifier_subspace_index;\n+        auto src = modifier_cells.begin() + modifier_offset;\n+        auto dst = builder->add_subspace(addrs.addr).begin();\n+        for (size_t i = 0; i < dsss; ++i) {\n+            dst[i] = src[i];\n+        }\n+        lookup_view->lookup(addrs.lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten_subspaces.insert(input_subspace_index);\n+        }\n+    }\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (overwritten_subspaces.count(input_subspace_index) == 0) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder->add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+    return builder->build(std::move(builder));\n+}\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory)\n+    {\n+        return my_add_cells<ICT,MCT>(input, modifier, factory);\n+    }\n+};\n+\n+//-----------------------------------------------------------------------------\n+\n+template <typename ICT>\n+Value::UP\n+my_remove_cells(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.mapped_dimensions()) {\n+        LOG(error, \"when removing cells from a tensor, mapped dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    if (input_type.mapped_dimensions().size() == 0) {\n+        LOG(error, \"cannot remove cells from a dense tensor\");\n+        return Value::UP();\n+    }\n+    const auto input_cells = input.cells().typify<ICT>();\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    Addresses addrs(num_mapped_in_input);\n+    std::set<size_t> removed_subspaces;\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(addrs.next_result_refs, modifier_subspace_index)) {\n+        lookup_view->lookup(addrs.lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            removed_subspaces.insert(input_subspace_index);\n+        }\n+    }\n+    const size_t expected_subspaces = input.index().size() - removed_subspaces.size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04f832a3306c838b3febe21f85d7364e14306695"}, "originalPosition": 336}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2daddf3d47872b10a22ed0a36935684c99a00421", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/2daddf3d47872b10a22ed0a36935684c99a00421", "committedDate": "2020-10-08T11:52:44Z", "message": "fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "872bf39ed7117dc095fde9bc5a50da1c24121010", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/872bf39ed7117dc095fde9bc5a50da1c24121010", "committedDate": "2020-10-08T12:01:16Z", "message": "require sparse remove_spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37017c1ebcf8903a23afe555bba867f0bed3d94c", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/37017c1ebcf8903a23afe555bba867f0bed3d94c", "committedDate": "2020-10-08T12:04:39Z", "message": "cosmetic fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NzQ2NzQx", "url": "https://github.com/vespa-engine/vespa/pull/14757#pullrequestreview-504746741", "createdAt": "2020-10-08T12:50:48Z", "commit": {"oid": "37017c1ebcf8903a23afe555bba867f0bed3d94c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6117eda9d534283dec4f565cd793ac037e18f00c", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/6117eda9d534283dec4f565cd793ac037e18f00c", "committedDate": "2020-10-08T13:22:29Z", "message": "reverse how the remove lookup is done"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2ca43e7a54f922079e4778214708f7594fdac4c", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/f2ca43e7a54f922079e4778214708f7594fdac4c", "committedDate": "2020-10-08T13:35:29Z", "message": "use copy_tensor_with_filter even more"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Nzk5ODU0", "url": "https://github.com/vespa-engine/vespa/pull/14757#pullrequestreview-504799854", "createdAt": "2020-10-08T13:46:28Z", "commit": {"oid": "f2ca43e7a54f922079e4778214708f7594fdac4c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzo0NjoyOFrOHefZXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzo0NjoyOFrOHefZXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTczMzcyNw==", "bodyText": "I suggest switching from skip to keep semantic on the predicate. Also, I strongly suggest passing both the address and the subspace to avoid depending too much on side-effect on objects passed into this function.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r501733727", "createdAt": "2020-10-08T13:46:28Z", "author": {"login": "havardpe"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,347 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    MAPPED_MATCH, CONV_TO_INDEXED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                offset = npos();\n+                break;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(size_t sz) {\n+        dim_sizes.push_back(sz);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct SparseCoords {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    SparseCoords(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~SparseCoords();\n+};\n+SparseCoords::~SparseCoords() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    SparseCoords for_output;\n+    SparseCoords from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                   const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if (! valid) {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            return;\n+        }\n+        assert(input_dims.size() == modifier_dims.size());\n+        assert(input_dims.size() == how.size());\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT, typename ICT = CT, typename SkipFun>\n+void copy_tensor_with_filter(const Value &input,\n+                             size_t dsss,\n+                             SparseCoords &addrs,\n+                             ValueBuilder<CT> &builder,\n+                             SkipFun && skip_subspaces)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2ca43e7a54f922079e4778214708f7594fdac4c"}, "originalPosition": 158}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98b5b5eb136cf7ee25fab7238573ab13482cebf3", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/98b5b5eb136cf7ee25fab7238573ab13482cebf3", "committedDate": "2020-10-08T13:53:00Z", "message": "reverse skip -> keep; pass lookup_refs also"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/d62fa408073fb5fcdbc657b73ad2e7e7a391d076", "committedDate": "2020-10-08T14:06:04Z", "message": "reverse params to filter predicate"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1NDM0MDYx", "url": "https://github.com/vespa-engine/vespa/pull/14757#pullrequestreview-505434061", "createdAt": "2020-10-09T07:43:45Z", "commit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwNzo0Mzo0NVrOHe-qpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwOTowMTowOFrOHfBUIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI0NjA1NQ==", "bodyText": "Consider using /** */ for function comments (as done elsewhere). Also consider upper case letter when starting a sentence.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502246055", "createdAt": "2020-10-09T07:43:45Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/tensor/partial_update.h", "diffHunk": "@@ -0,0 +1,36 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#pragma once\n+\n+#include <vespa/eval/eval/value.h>\n+\n+namespace vespalib::tensor {\n+\n+struct TensorPartialUpdate {\n+    using join_fun_t = double (*)(double, double);\n+    using Value = vespalib::eval::Value;\n+    using ValueBuilderFactory = vespalib::eval::ValueBuilderFactory;\n+\n+    // make a copy of the input, but apply function(oldvalue, modifier.cellvalue)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI0ODE2Ng==", "bodyText": "Consider printing tensor types in error message.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502248166", "createdAt": "2020-10-09T07:47:47Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,349 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    MAPPED_MATCH, CONV_TO_INDEXED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                offset = npos();\n+                break;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(size_t sz) {\n+        dim_sizes.push_back(sz);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct SparseCoords {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    SparseCoords(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~SparseCoords();\n+};\n+SparseCoords::~SparseCoords() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    SparseCoords for_output;\n+    SparseCoords from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                   const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if (! valid) {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            return;\n+        }\n+        assert(input_dims.size() == modifier_dims.size());\n+        assert(input_dims.size() == how.size());\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT, typename ICT = CT, typename KeepFun>\n+void copy_tensor_with_filter(const Value &input,\n+                             size_t dsss,\n+                             SparseCoords &addrs,\n+                             ValueBuilder<CT> &builder,\n+                             KeepFun && keep_subspace)\n+{\n+    const auto input_cells = input.cells().typify<ICT>();\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (keep_subspace(addrs.lookup_refs, input_subspace_index)) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder.add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+}\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, SparseCoords &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto no_filter = [] (const auto &, size_t) {\n+        return true;\n+    };\n+    copy_tensor_with_filter<CT>(input, dsss, helper, *builder, no_filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformModify::invoke(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformAdd::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3ODc3NA==", "bodyText": "Consider printing tensor types in error message.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502278774", "createdAt": "2020-10-09T08:43:02Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,349 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    MAPPED_MATCH, CONV_TO_INDEXED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                offset = npos();\n+                break;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(size_t sz) {\n+        dim_sizes.push_back(sz);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct SparseCoords {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    SparseCoords(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~SparseCoords();\n+};\n+SparseCoords::~SparseCoords() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    SparseCoords for_output;\n+    SparseCoords from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                   const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if (! valid) {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            return;\n+        }\n+        assert(input_dims.size() == modifier_dims.size());\n+        assert(input_dims.size() == how.size());\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT, typename ICT = CT, typename KeepFun>\n+void copy_tensor_with_filter(const Value &input,\n+                             size_t dsss,\n+                             SparseCoords &addrs,\n+                             ValueBuilder<CT> &builder,\n+                             KeepFun && keep_subspace)\n+{\n+    const auto input_cells = input.cells().typify<ICT>();\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (keep_subspace(addrs.lookup_refs, input_subspace_index)) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder.add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+}\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, SparseCoords &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto no_filter = [] (const auto &, size_t) {\n+        return true;\n+    };\n+    copy_tensor_with_filter<CT>(input, dsss, helper, *builder, no_filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformModify::invoke(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformAdd::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    SparseCoords addrs(num_mapped_in_input);\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    std::vector<bool> overwritten(input.index().size(), false);\n+    auto remember_subspaces = [&] (const auto & lookup_refs, size_t) {\n+        lookup_view->lookup(lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten[input_subspace_index] = true;\n+        }\n+        return true;\n+    };\n+    copy_tensor_with_filter<ICT, MCT>(modifier, dsss, addrs, *builder, remember_subspaces);\n+    auto filter = [&] (const auto &, size_t input_subspace) {\n+        return ! overwritten[input_subspace];\n+    };\n+    copy_tensor_with_filter<ICT>(input, dsss, addrs, *builder, filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformRemove {\n+    template<typename ICT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT>\n+Value::UP\n+PerformRemove::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when removing cells from a tensor, mapped dimensions must be equal\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI3ODk0Nw==", "bodyText": "Consider printing dense tensor type in error message.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502278947", "createdAt": "2020-10-09T08:43:20Z", "author": {"login": "geirst"}, "path": "eval/src/vespa/eval/tensor/partial_update.cpp", "diffHunk": "@@ -0,0 +1,349 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include \"partial_update.h\"\n+#include <vespa/vespalib/util/overload.h>\n+#include <vespa/vespalib/util/typify.h>\n+#include <vespa/vespalib/util/visit_ranges.h>\n+#include <cassert>\n+#include <set>\n+\n+#include <vespa/log/log.h>\n+LOG_SETUP(\".eval.tensor.partial_update\");\n+\n+using namespace vespalib::eval;\n+\n+namespace vespalib::tensor {\n+\n+namespace {\n+\n+using join_fun_t = double (*)(double, double);\n+\n+static constexpr size_t npos() { return -1; }\n+\n+enum class DimCase {\n+    MAPPED_MATCH, CONV_TO_INDEXED\n+};\n+\n+struct DenseCoords {\n+    std::vector<size_t> dim_sizes;\n+    size_t total_size = 1;\n+    size_t offset;\n+    size_t dim;\n+    void clear() { offset = 0; dim = 0; }\n+    void with(size_t coord) {\n+        size_t cur = dim_sizes[dim];\n+        if (coord < cur) {\n+            if (offset != npos()) {\n+                offset *= cur;\n+                offset += coord;\n+            }\n+        } else {\n+            offset = npos();\n+        }\n+        ++dim;\n+    }\n+    void with(vespalib::stringref label) {\n+        uint32_t result = 0;\n+        for (char c : label) {\n+            if (c < '0' || c > '9') { // bad char\n+                offset = npos();\n+                break;\n+            }\n+            result = result * 10 + (c - '0');\n+        }\n+        with(result);\n+    }\n+    void add_dim(size_t sz) {\n+        dim_sizes.push_back(sz);\n+        total_size *= sz;\n+    }\n+    size_t get() const {\n+        assert(dim == dim_sizes.size());\n+        return offset;\n+    }\n+    ~DenseCoords();\n+};\n+DenseCoords::~DenseCoords() = default;\n+\n+struct SparseCoords {\n+    std::vector<vespalib::stringref> addr;\n+    std::vector<vespalib::stringref *> next_result_refs;\n+    std::vector<const vespalib::stringref *> lookup_refs;\n+    std::vector<size_t> lookup_view_dims;\n+    SparseCoords(size_t sz)\n+        : addr(sz), next_result_refs(sz), lookup_refs(sz), lookup_view_dims(sz)\n+    {\n+        for (size_t i = 0; i < sz; ++i) {\n+            next_result_refs[i] = &addr[i];\n+            lookup_refs[i] = &addr[i];\n+            lookup_view_dims[i] = i;\n+        }\n+    }\n+    ~SparseCoords();\n+};\n+SparseCoords::~SparseCoords() = default;\n+\n+struct AddressHandler {\n+    std::vector<DimCase> how;\n+    DenseCoords target_coords;\n+    SparseCoords for_output;\n+    SparseCoords from_modifier;\n+    bool valid;\n+\n+    AddressHandler(const ValueType &input_type,\n+                   const ValueType &modifier_type)\n+        : how(), target_coords(),\n+          for_output(input_type.count_mapped_dimensions()),\n+          from_modifier(modifier_type.count_mapped_dimensions()),\n+          valid(true)\n+    {\n+        if (! modifier_type.is_sparse()) {\n+            LOG(error, \"Unexpected non-sparse modifier tensor, type is %s\",\n+                modifier_type.to_spec().c_str());\n+            valid = false;\n+            return;\n+        }\n+        // analyse dimensions\n+        auto visitor = overload {\n+            [&](visit_ranges_either, const auto &) { valid = false; },\n+            [&](visit_ranges_both, const auto &a, const auto &) {\n+                how.push_back(a.is_mapped() ? DimCase::MAPPED_MATCH : DimCase::CONV_TO_INDEXED);\n+            }\n+        };\n+        const auto & input_dims = input_type.dimensions();\n+        const auto & modifier_dims = modifier_type.dimensions();\n+        visit_ranges(visitor,\n+                     input_dims.begin(), input_dims.end(),\n+                     modifier_dims.begin(), modifier_dims.end(),\n+                     [](const auto &a, const auto &b){ return (a.name < b.name); });\n+        if (! valid) {\n+            LOG(error, \"Value type %s does not match modifier type %s (should have same dimensions)\",\n+                input_type.to_spec().c_str(),\n+                modifier_type.to_spec().c_str());\n+            return;\n+        }\n+        assert(input_dims.size() == modifier_dims.size());\n+        assert(input_dims.size() == how.size());\n+        for (const auto & dim : input_type.dimensions()) {\n+            if (dim.is_indexed()) {\n+                target_coords.add_dim(dim.size);\n+            }\n+        }\n+    }\n+\n+    void handle_address()\n+    {\n+        target_coords.clear();\n+        auto out = for_output.addr.begin();\n+        for (size_t i = 0; i < how.size(); ++i) {\n+            if (how[i] == DimCase::CONV_TO_INDEXED) {\n+                target_coords.with(from_modifier.addr[i]);\n+            } else {\n+                *out++ = from_modifier.addr[i];\n+            }\n+        }\n+        assert(out == for_output.addr.end());\n+        assert(target_coords.dim == target_coords.dim_sizes.size());\n+    }\n+\n+    ~AddressHandler();\n+};\n+AddressHandler::~AddressHandler() = default;\n+\n+template <typename CT, typename ICT = CT, typename KeepFun>\n+void copy_tensor_with_filter(const Value &input,\n+                             size_t dsss,\n+                             SparseCoords &addrs,\n+                             ValueBuilder<CT> &builder,\n+                             KeepFun && keep_subspace)\n+{\n+    const auto input_cells = input.cells().typify<ICT>();\n+    auto input_view = input.index().create_view({});\n+    input_view->lookup({});\n+    size_t input_subspace_index;\n+    while (input_view->next_result(addrs.next_result_refs, input_subspace_index)) {\n+        if (keep_subspace(addrs.lookup_refs, input_subspace_index)) {\n+            size_t input_offset = dsss * input_subspace_index;\n+            auto src = input_cells.begin() + input_offset;\n+            auto dst = builder.add_subspace(addrs.addr).begin();\n+            for (size_t i = 0; i < dsss; ++i) {\n+                dst[i] = src[i];\n+            }\n+        }\n+    }\n+}\n+\n+template <typename CT>\n+Value::UP\n+copy_tensor(const Value &input, const ValueType &input_type, SparseCoords &helper, const ValueBuilderFactory &factory)\n+{\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size();\n+    auto builder = factory.create_value_builder<CT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    auto no_filter = [] (const auto &, size_t) {\n+        return true;\n+    };\n+    copy_tensor_with_filter<CT>(input, dsss, helper, *builder, no_filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformModify {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            join_fun_t function,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformModify::invoke(const Value &input, join_fun_t function, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const ValueType &modifier_type = modifier.type();\n+    AddressHandler handler(input_type, modifier_type);\n+    if (! handler.valid) {\n+        return Value::UP();\n+    }\n+    // copy input to output\n+    auto out = copy_tensor<ICT>(input, input_type, handler.for_output, factory);\n+    // need to overwrite some cells\n+    auto output_cells = unconstify(out->cells().template typify<ICT>());\n+    const auto modifier_cells = modifier.cells().typify<MCT>();\n+    auto modifier_view = modifier.index().create_view({});\n+    auto lookup_view = out->index().create_view(handler.for_output.lookup_view_dims);\n+    modifier_view->lookup({});\n+    size_t modifier_subspace_index;\n+    while (modifier_view->next_result(handler.from_modifier.next_result_refs, modifier_subspace_index)) {\n+        handler.handle_address();\n+        size_t dense_idx = handler.target_coords.get();\n+        if (dense_idx == npos()) {\n+            continue;\n+        }\n+        lookup_view->lookup(handler.for_output.lookup_refs);\n+        size_t output_subspace_index;\n+        if (lookup_view->next_result({}, output_subspace_index)) {\n+            size_t subspace_offset = dsss * output_subspace_index;\n+            auto dst = output_cells.begin() + subspace_offset;\n+            ICT lhs = dst[dense_idx];\n+            MCT rhs = modifier_cells[modifier_subspace_index];\n+            dst[dense_idx] = function(lhs, rhs);\n+        }\n+    }\n+    return out;\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformAdd {\n+    template<typename ICT, typename MCT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT, typename MCT>\n+Value::UP\n+PerformAdd::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when adding cells to a tensor, dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    const size_t dsss = input_type.dense_subspace_size();\n+    const size_t expected_subspaces = input.index().size() + modifier.index().size();\n+    auto builder = factory.create_value_builder<ICT>(input_type, num_mapped_in_input, dsss, expected_subspaces);\n+    SparseCoords addrs(num_mapped_in_input);\n+    auto lookup_view = input.index().create_view(addrs.lookup_view_dims);\n+    std::vector<bool> overwritten(input.index().size(), false);\n+    auto remember_subspaces = [&] (const auto & lookup_refs, size_t) {\n+        lookup_view->lookup(lookup_refs);\n+        size_t input_subspace_index;\n+        if (lookup_view->next_result({}, input_subspace_index)) {\n+            overwritten[input_subspace_index] = true;\n+        }\n+        return true;\n+    };\n+    copy_tensor_with_filter<ICT, MCT>(modifier, dsss, addrs, *builder, remember_subspaces);\n+    auto filter = [&] (const auto &, size_t input_subspace) {\n+        return ! overwritten[input_subspace];\n+    };\n+    copy_tensor_with_filter<ICT>(input, dsss, addrs, *builder, filter);\n+    return builder->build(std::move(builder));\n+}\n+\n+//-----------------------------------------------------------------------------\n+\n+struct PerformRemove {\n+    template<typename ICT>\n+    static Value::UP invoke(const Value &input,\n+                            const Value &modifier,\n+                            const ValueBuilderFactory &factory);\n+};\n+\n+template <typename ICT>\n+Value::UP\n+PerformRemove::invoke(const Value &input, const Value &modifier, const ValueBuilderFactory &factory)\n+{\n+    const ValueType &input_type = input.type();\n+    const ValueType &modifier_type = modifier.type();\n+    if (input_type.mapped_dimensions() != modifier_type.dimensions()) {\n+        LOG(error, \"when removing cells from a tensor, mapped dimensions must be equal\");\n+        return Value::UP();\n+    }\n+    const size_t num_mapped_in_input = input_type.count_mapped_dimensions();\n+    if (num_mapped_in_input == 0) {\n+        LOG(error, \"cannot remove cells from a dense tensor\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI4NTMxMw==", "bodyText": "Should we remove EXPECT_TRUE(up) on line 55 or the else clause?", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502285313", "createdAt": "2020-10-09T08:54:15Z", "author": {"login": "geirst"}, "path": "eval/src/tests/tensor/partial_add/partial_add_test.cpp", "diffHunk": "@@ -0,0 +1,123 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/tensor/cell_values.h>\n+#include <vespa/eval/tensor/default_tensor_engine.h>\n+#include <vespa/eval/tensor/partial_update.h>\n+#include <vespa/eval/tensor/sparse/sparse_tensor.h>\n+#include <vespa/eval/tensor/tensor.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <optional>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> add_layouts = {\n+    {x({\"a\"})},                           {x({\"b\"})},\n+    {x({\"a\",\"b\"})},                       {x({\"a\",\"c\"})},\n+    float_cells({x({\"a\",\"b\"})}),          {x({\"a\",\"c\"})},\n+    {x({\"a\",\"b\"})},                       float_cells({x({\"a\",\"c\"})}),\n+    float_cells({x({\"a\",\"b\"})}),          float_cells({x({\"a\",\"c\"})}),\n+    {x({\"a\",\"b\",\"c\"}),y({\"d\",\"e\"})},      {x({\"b\",\"f\"}),y({\"d\",\"g\"})},             \n+    {x(3),y({\"a\",\"b\"})},                  {x(3),y({\"b\",\"c\"})}\n+};\n+\n+TensorSpec reference_add(const TensorSpec &a, const TensorSpec &b) {\n+    TensorSpec result(a.type());\n+    for (const auto &cell: b.cells()) {\n+        result.add(cell.first, cell.second);\n+    }\n+    auto end_iter = b.cells().end();\n+    for (const auto &cell: a.cells()) {\n+        auto iter = b.cells().find(cell.first);\n+        if (iter == end_iter) {\n+            result.add(cell.first, cell.second);\n+        }\n+    }\n+    return result;\n+}\n+\n+Value::UP try_partial_add(const TensorSpec &a, const TensorSpec &b) {\n+    const auto &factory = SimpleValueBuilderFactory::get();\n+    auto lhs = value_from_spec(a, factory);\n+    auto rhs = value_from_spec(b, factory);\n+    return tensor::TensorPartialUpdate::add(*lhs, *rhs, factory);\n+}\n+\n+TensorSpec perform_partial_add(const TensorSpec &a, const TensorSpec &b) {\n+    auto up = try_partial_add(a, b);\n+    EXPECT_TRUE(up);\n+    if (up) {\n+        return spec_from_value(*up);\n+    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI4OTQ0Mw==", "bodyText": "Consider removing remains of debug printing.", "url": "https://github.com/vespa-engine/vespa/pull/14757#discussion_r502289443", "createdAt": "2020-10-09T09:01:08Z", "author": {"login": "geirst"}, "path": "eval/src/tests/tensor/partial_remove/partial_remove_test.cpp", "diffHunk": "@@ -0,0 +1,131 @@\n+// Copyright Verizon Media. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.\n+\n+#include <vespa/eval/eval/simple_value.h>\n+#include <vespa/eval/eval/test/tensor_model.hpp>\n+#include <vespa/eval/eval/value_codec.h>\n+#include <vespa/eval/tensor/cell_values.h>\n+#include <vespa/eval/tensor/default_tensor_engine.h>\n+#include <vespa/eval/tensor/partial_update.h>\n+#include <vespa/eval/tensor/sparse/sparse_tensor.h>\n+#include <vespa/eval/tensor/tensor.h>\n+#include <vespa/vespalib/util/stringfmt.h>\n+#include <vespa/vespalib/gtest/gtest.h>\n+#include <optional>\n+\n+using namespace vespalib;\n+using namespace vespalib::eval;\n+using namespace vespalib::eval::test;\n+\n+using vespalib::make_string_short::fmt;\n+\n+std::vector<Layout> remove_layouts = {\n+    {x({\"a\"})},                           {x({\"b\"})},\n+    {x({\"a\",\"b\"})},                       {x({\"a\",\"c\"})},\n+    {x({\"a\",\"b\"})},                       {x({\"a\",\"b\"})},\n+    float_cells({x({\"a\",\"b\"})}),          {x({\"a\",\"c\"})},\n+    {x({\"a\",\"b\"})},                       float_cells({x({\"a\",\"c\"})}),\n+    float_cells({x({\"a\",\"b\"})}),          float_cells({x({\"a\",\"c\"})}),\n+    {x({\"a\",\"b\",\"c\"}),y({\"d\",\"e\"})},      {x({\"b\",\"f\"}),y({\"d\",\"g\"})},             \n+    {x(3),y({\"a\",\"b\"})},                  {y({\"b\",\"c\"})}\n+};\n+\n+TensorSpec::Address only_sparse(const TensorSpec::Address &input) {\n+    TensorSpec::Address output;\n+    for (const auto & kv : input) {\n+        if (kv.second.is_mapped()) {\n+            output.emplace(kv.first, kv.second);\n+        }\n+    }\n+    return output;\n+}\n+\n+TensorSpec reference_remove(const TensorSpec &a, const TensorSpec &b) {\n+    TensorSpec result(a.type());\n+    auto end_iter = b.cells().end();\n+    for (const auto &cell: a.cells()) {\n+        auto iter = b.cells().find(only_sparse(cell.first));\n+        if (iter == end_iter) {\n+            result.add(cell.first, cell.second);\n+        }\n+    }\n+    return result;\n+}\n+\n+Value::UP try_partial_remove(const TensorSpec &a, const TensorSpec &b) {\n+    const auto &factory = SimpleValueBuilderFactory::get();\n+    auto lhs = value_from_spec(a, factory);\n+    auto rhs = value_from_spec(b, factory);\n+    return tensor::TensorPartialUpdate::remove(*lhs, *rhs, factory);\n+}\n+\n+TensorSpec perform_partial_remove(const TensorSpec &a, const TensorSpec &b) {\n+    auto up = try_partial_remove(a, b);\n+    if (up) {\n+        return spec_from_value(*up);\n+    } else {\n+        return TensorSpec(a.type());\n+    }\n+}\n+\n+TensorSpec perform_old_remove(const TensorSpec &a, const TensorSpec &b) {\n+    const auto &engine = tensor::DefaultTensorEngine::ref();\n+    auto lhs = engine.from_spec(a);\n+    auto rhs = engine.from_spec(b);\n+    auto lhs_tensor = dynamic_cast<tensor::Tensor *>(lhs.get());\n+    EXPECT_TRUE(lhs_tensor);\n+    auto rhs_sparse = dynamic_cast<tensor::SparseTensor *>(rhs.get());\n+    EXPECT_TRUE(rhs_sparse);\n+    tensor::CellValues cell_values(*rhs_sparse);\n+    auto up = lhs_tensor->remove(cell_values);\n+    EXPECT_TRUE(up);\n+    return engine.to_spec(*up);\n+}\n+\n+\n+TEST(PartialAddTest, partial_remove_works_for_simple_values) {\n+    ASSERT_TRUE((remove_layouts.size() % 2) == 0);\n+    for (size_t i = 0; i < remove_layouts.size(); i += 2) {\n+        TensorSpec lhs = spec(remove_layouts[i], N());\n+        TensorSpec rhs = spec(remove_layouts[i + 1], Div16(N()));\n+        SCOPED_TRACE(fmt(\"\\n===\\nLHS: %s\\nRHS: %s\\n===\\n\", lhs.to_string().c_str(), rhs.to_string().c_str()));\n+        auto expect = reference_remove(lhs, rhs);\n+        auto actual = perform_partial_remove(lhs, rhs);\n+        EXPECT_EQ(actual, expect);\n+    }\n+}\n+\n+TEST(PartialAddTest, partial_remove_works_like_old_remove) {\n+    ASSERT_TRUE((remove_layouts.size() % 2) == 0);\n+    for (size_t i = 0; i < remove_layouts.size(); i += 2) {\n+        TensorSpec lhs = spec(remove_layouts[i], N());\n+        TensorSpec rhs = spec(remove_layouts[i + 1], Div16(N()));\n+        SCOPED_TRACE(fmt(\"\\n===\\nLHS: %s\\nRHS: %s\\n===\\n\", lhs.to_string().c_str(), rhs.to_string().c_str()));\n+        auto expect = perform_old_remove(lhs, rhs);\n+        auto actual = perform_partial_remove(lhs, rhs);\n+        EXPECT_EQ(actual, expect);\n+        // printf(\"%s remove %s -> %s\\n\", lhs.to_string().c_str(), rhs.to_string().c_str(), actual.to_string().c_str());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d62fa408073fb5fcdbc657b73ad2e7e7a391d076"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d182e182abe3c3eb380218c219b80fc0323bc7c", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/5d182e182abe3c3eb380218c219b80fc0323bc7c", "committedDate": "2020-10-09T11:58:54Z", "message": "fix formatting of comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe475aa4bf3c42d3e0a83caa35f8d6b370bc9eef", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/fe475aa4bf3c42d3e0a83caa35f8d6b370bc9eef", "committedDate": "2020-10-09T12:12:07Z", "message": "minor refactoring after review\n\n* collapse and rename with() methods of DenseCoords\n* rename some variables\n* add comment describing AddressHandler helper class\n* include tensor types in error logging messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b0d4076c774ae677fbe4a2e687dd0d011c0e370", "author": {"user": {"login": "arnej27959", "name": "Arne H Juul"}}, "url": "https://github.com/vespa-engine/vespa/commit/9b0d4076c774ae677fbe4a2e687dd0d011c0e370", "committedDate": "2020-10-09T12:14:02Z", "message": "cleanup unit tests after review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1NzQ3NzYw", "url": "https://github.com/vespa-engine/vespa/pull/14757#pullrequestreview-505747760", "createdAt": "2020-10-09T14:51:51Z", "commit": {"oid": "9b0d4076c774ae677fbe4a2e687dd0d011c0e370"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2464, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}