{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwODcyODc1", "number": 12366, "title": "Determine endpoints from routing policies for all routing methods", "bodyText": "Routing policies are now always fetched and stored on deploy. All zones\nalready provide useful data in /loadbalancers/v1/ independent of routing\nmethod used.\nAll consumers now retrieve endpoints through RoutingController.\nThere's a fallback that retrieves endpoints from RoutingGenerator which must\nexist until all applications have deployed at least once.\nTests no longer use RoutingGenerator (except in the test for the previous bullet point)\n\nFYI @tokle", "createdAt": "2020-02-27T14:10:20Z", "url": "https://github.com/vespa-engine/vespa/pull/12366", "merged": true, "mergeCommit": {"oid": "c192a5997f8e65c8a8d51e3e42442a39b5f5e187"}, "closed": true, "closedAt": "2020-02-28T09:18:55Z", "author": {"login": "mpolden"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIbwAegH2gAyMzgwODcyODc1OmMyNjM2NjBmNDFiMDEwNTgwNWJjMzk2MWJmNTJiYTM0ZThkODg3MTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIsNI3gH2gAyMzgwODcyODc1OjAzYWNkNjgxMjg3NTUxZjJjNjhlMjVjNjg4Yjg0YzMzYzlmOTcxM2I=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c263660f41b0105805bc3961bf52ba34e8d88715", "author": {"user": {"login": "mpolden", "name": "Martin Polden"}}, "url": "https://github.com/vespa-engine/vespa/commit/c263660f41b0105805bc3961bf52ba34e8d88715", "committedDate": "2020-02-27T13:57:21Z", "message": "Make AbstractFilteringList an Iterable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a96289fb65f540a473f5ad6baa838df191fab8cb", "author": {"user": {"login": "mpolden", "name": "Martin Polden"}}, "url": "https://github.com/vespa-engine/vespa/commit/a96289fb65f540a473f5ad6baa838df191fab8cb", "committedDate": "2020-02-27T13:57:21Z", "message": "Rename method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f68ea0c5bb592cf92d5a150934d39f30167d066", "author": {"user": {"login": "mpolden", "name": "Martin Polden"}}, "url": "https://github.com/vespa-engine/vespa/commit/0f68ea0c5bb592cf92d5a150934d39f30167d066", "committedDate": "2020-02-27T13:57:21Z", "message": "Determine endpoints from routing policies for all routing methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MjI1NDQ2", "url": "https://github.com/vespa-engine/vespa/pull/12366#pullrequestreview-366225446", "createdAt": "2020-02-28T08:24:48Z", "commit": {"oid": "0f68ea0c5bb592cf92d5a150934d39f30167d066"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODoyNDo0OFrOFvs3Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODoyNDo0OFrOFvs3Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU2MjM5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** Returns all non-global endpoints for given deployments, grouped by their cluster ID and zone */\n          \n          \n            \n                /** Returns all non-global endpoints and corresponding cluster IDs for given deployments, grouped by their zone */", "url": "https://github.com/vespa-engine/vespa/pull/12366#discussion_r385562399", "createdAt": "2020-02-28T08:24:48Z", "author": {"login": "jonmv"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/RoutingController.java", "diffHunk": "@@ -71,53 +68,57 @@ public RotationRepository rotations() {\n         return rotationRepository;\n     }\n \n-    /** Returns all legacy endpoint URLs for given deployment, including global, in the shared routing layer */\n-    public List<URI> legacyEndpointsOf(DeploymentId deployment) {\n-        return routingEndpointsOf(deployment).stream()\n-                                             .map(RoutingEndpoint::endpoint)\n-                                             .map(URI::create)\n-                                             .collect(Collectors.toUnmodifiableList());\n-    }\n-\n-    /** Returns legacy zone endpoints for given deployment, in the shared routing layer */\n-    public Map<ClusterSpec.Id, URI> legacyZoneEndpointsOf(DeploymentId deployment) {\n-        if (!supportsRoutingMethod(RoutingMethod.shared, deployment.zoneId())) {\n-            return Map.of();\n+    /** Returns zone-scoped endpoints for given deployment */\n+    public EndpointList endpointsOf(DeploymentId deployment) {\n+        var endpoints = new LinkedHashSet<Endpoint>();\n+        for (var policy : routingPolicies.get(deployment).values()) {\n+            if (!policy.status().isActive()) continue;\n+            for (var routingMethod :  controller.zoneRegistry().routingMethods(policy.id().zone())) {\n+                endpoints.add(policy.endpointIn(controller.system(), routingMethod));\n+            }\n         }\n-        try {\n-            return routingGenerator.clusterEndpoints(deployment);\n-        } catch (RuntimeException e) {\n-            log.log(Level.WARNING, \"Failed to get endpoint information for \" + deployment, e);\n-            return Map.of();\n+        if (endpoints.isEmpty()) { // TODO(mpolden): Remove this once all applications have deployed once\n+            controller.serviceRegistry().routingGenerator().clusterEndpoints(deployment)\n+                      .forEach((cluster, url) -> endpoints.add(Endpoint.of(deployment.applicationId())\n+                                                                       .target(cluster, deployment.zoneId())\n+                                                                       .routingMethod(RoutingMethod.shared)\n+                                                                       .on(Port.fromRoutingMethod(RoutingMethod.shared))\n+                                                                       .in(controller.system())));\n         }\n+        return EndpointList.copyOf(endpoints);\n     }\n \n-    /**\n-     * Returns all non-global endpoint URLs for given deployment, grouped by their cluster ID. If deployment supports\n-     * {@link RoutingMethod#exclusive} endpoints defined through routing polices are returned.\n-     */\n-    public Map<ClusterSpec.Id, URI> zoneEndpointsOf(DeploymentId deployment) {\n-        if ( ! controller.applications().getInstance(deployment.applicationId())\n-                .map(application -> application.deployments().containsKey(deployment.zoneId()))\n-                .orElse(deployment.applicationId().instance().isTester()))\n-            throw new NotExistsException(\"Deployment\", deployment.toString());\n-\n-        // In exclusively routed zones we create endpoint URLs from routing policies\n-        if (supportsRoutingMethod(RoutingMethod.exclusive, deployment.zoneId())) {\n-            return routingPolicies.get(deployment).values().stream()\n-                                  .filter(policy -> policy.endpointIn(controller.system()).scope() == Endpoint.Scope.zone)\n-                                  .collect(Collectors.toUnmodifiableMap(policy -> policy.id().cluster(),\n-                                                                        policy -> policy.endpointIn(controller.system())\n-                                                                                        .url()));\n+    /** Returns global-scoped endpoints for given instance */\n+    public EndpointList endpointsOf(ApplicationId instance) {\n+        var endpoints = new LinkedHashSet<Endpoint>();\n+        // Add global endpoints provided by rotations\n+        for (var rotation : controller.applications().requireInstance(instance).rotations()) {\n+            EndpointList.global(RoutingId.of(instance, rotation.endpointId()),\n+                                controller.system(), systemRoutingMethods())\n+                        .requiresRotation()\n+                        .primary()\n+                        .ifPresent(endpoints::add);\n+        }\n+        // Add global endpoints provided by routing policices\n+        for (var policy : routingPolicies.get(instance).values()) {\n+            if (!policy.status().isActive()) continue;\n+            for (var endpointId : policy.endpoints()) {\n+                EndpointList.global(RoutingId.of(instance, endpointId),\n+                                    controller.system(), systemRoutingMethods())\n+                            .not().requiresRotation()\n+                            .forEach(endpoints::add);\n+            }\n         }\n-        return legacyZoneEndpointsOf(deployment);\n+        return EndpointList.copyOf(endpoints);\n     }\n \n-    /** Returns all non-global endpoint URLs for given deployments, grouped by their cluster ID and zone */\n-    public Map<ZoneId, Map<ClusterSpec.Id, URI>> zoneEndpointsOf(Collection<DeploymentId> deployments) {\n-        var endpoints = new TreeMap<ZoneId, Map<ClusterSpec.Id, URI>>(Comparator.comparing(ZoneId::value));\n+    /** Returns all non-global endpoints for given deployments, grouped by their cluster ID and zone */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f68ea0c5bb592cf92d5a150934d39f30167d066"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f49ad07b9fd1ac272e28e384fadb246025aedfff", "author": {"user": {"login": "mpolden", "name": "Martin Polden"}}, "url": "https://github.com/vespa-engine/vespa/commit/f49ad07b9fd1ac272e28e384fadb246025aedfff", "committedDate": "2020-02-28T08:25:45Z", "message": "Leave all filtering up to callers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0efd91857e90409635a0600e542cfa8bdc5fdb7a", "author": {"user": {"login": "mpolden", "name": "Martin Polden"}}, "url": "https://github.com/vespa-engine/vespa/commit/0efd91857e90409635a0600e542cfa8bdc5fdb7a", "committedDate": "2020-02-28T08:28:14Z", "message": "Correct javadoc\n\nCo-Authored-By: Jon Marius Venstad <jonmv@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MjI2OTk5", "url": "https://github.com/vespa-engine/vespa/pull/12366#pullrequestreview-366226999", "createdAt": "2020-02-28T08:28:04Z", "commit": {"oid": "0f68ea0c5bb592cf92d5a150934d39f30167d066"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODoyODowNVrOFvs7og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODo1NjowOFrOFvtopQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU2MzU1NA==", "bodyText": "Thanks :)", "url": "https://github.com/vespa-engine/vespa/pull/12366#discussion_r385563554", "createdAt": "2020-02-28T08:28:05Z", "author": {"login": "jonmv"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/application/Endpoint.java", "diffHunk": "@@ -45,6 +51,17 @@ private Endpoint(String name, ApplicationId application, ZoneId zone, SystemName\n         this.wildcard = wildcard;\n     }\n \n+    /**\n+     * Returns the name of this endpoint (the first component of the DNS name). Depending on the endpoint type, this\n+     * can be one of the following:\n+     * - A wildcard (any scope)\n+     * - A cluster name (only zone scope)\n+     * - An endpoint ID (only global scope)\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f68ea0c5bb592cf92d5a150934d39f30167d066"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU2NDI3NA==", "bodyText": "Too late to forbid these?", "url": "https://github.com/vespa-engine/vespa/pull/12366#discussion_r385564274", "createdAt": "2020-02-28T08:29:58Z", "author": {"login": "jonmv"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/application/Endpoint.java", "diffHunk": "@@ -169,6 +198,30 @@ private static String dnsSuffix(SystemName system, boolean legacy) {\n         }\n     }\n \n+    private static String upstreamIdOf(String name, ApplicationId application, ZoneId zone) {\n+        return Stream.of(namePart(name, \"\"),\n+                         instancePart(application, \"\"),\n+                         application.tenant().value(),\n+                         application.application().value(),\n+                         zone.region().value(),\n+                         zone.environment().value())\n+                     .filter(Predicate.not(String::isEmpty))\n+                     .map(Endpoint::sanitizeUpstream)\n+                     .collect(Collectors.joining(\".\"));\n+    }\n+\n+    /** Remove any invalid characters from a upstream part */\n+    private static String sanitizeUpstream(String part) {\n+        return truncate(part.toLowerCase()\n+                            .replace('_', '-')\n+                            .replaceAll(\"[^a-z0-9-]*\", \"\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f68ea0c5bb592cf92d5a150934d39f30167d066"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU2NDg0Nw==", "bodyText": ":'(", "url": "https://github.com/vespa-engine/vespa/pull/12366#discussion_r385564847", "createdAt": "2020-02-28T08:31:23Z", "author": {"login": "jonmv"}, "path": "controller-server/src/main/java/com/yahoo/vespa/hosted/controller/application/EndpointList.java", "diffHunk": "@@ -34,37 +31,65 @@ private EndpointList(Collection<? extends Endpoint> endpoints) {\n         this(endpoints, false);\n     }\n \n-    /** Returns the main endpoint, if any */\n-    public Optional<Endpoint> main() {\n-        return asList().stream().filter(Predicate.not(Endpoint::legacy)).findFirst();\n+    /** Returns the primary (non-legacy) endpoint, if any */\n+    public Optional<Endpoint> primary() {\n+        return not().matching(Endpoint::legacy).asList().stream().findFirst();\n+    }\n+\n+    /** Returns the subset of endpoints named according to given ID */\n+    public EndpointList named(EndpointId id) {\n+        return matching(endpoint -> endpoint.name().equals(id.id()));\n     }\n \n     /** Returns the subset of endpoints are either legacy or not */\n     public EndpointList legacy(boolean legacy) {\n         return matching(endpoint -> endpoint.legacy() == legacy);\n     }\n \n+    /** Returns the subset of endpoints that require a rotation */\n+    public EndpointList requiresRotation() {\n+        return matching(Endpoint::requiresRotation);\n+    }\n+\n     /** Returns the subset of endpoints with given scope */\n     public EndpointList scope(Endpoint.Scope scope) {\n         return matching(endpoint -> endpoint.scope() == scope);\n     }\n \n-    public static EndpointList of(Stream<Endpoint> endpoints) {\n-        return new EndpointList(endpoints.collect(Collectors.toUnmodifiableList()));\n+    /** Returns all global endpoints for given routing ID and system provided by given routing methods */\n+    public static EndpointList global(RoutingId routingId, SystemName system, List<RoutingMethod> routingMethods) {\n+        var endpoints = new ArrayList<Endpoint>();\n+        for (var method : routingMethods) {\n+            endpoints.add(Endpoint.of(routingId.application())\n+                                  .named(routingId.endpointId())\n+                                  .on(Port.fromRoutingMethod(method))\n+                                  .routingMethod(method)\n+                                  .in(system));\n+            // TODO(mpolden): Remove this once all applications have migrated away from legacy endpoints\n+            if (method == RoutingMethod.shared) {\n+                endpoints.add(Endpoint.of(routingId.application())\n+                                      .named(routingId.endpointId())\n+                                      .on(Port.plain(4080))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f68ea0c5bb592cf92d5a150934d39f30167d066"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3Mzc1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** Add a routing policy for this in given zone, with status set to active */\n          \n          \n            \n                /** Add a routing policy for this in given zone, with status set to inactive */", "url": "https://github.com/vespa-engine/vespa/pull/12366#discussion_r385573752", "createdAt": "2020-02-28T08:53:01Z", "author": {"login": "jonmv"}, "path": "controller-server/src/test/java/com/yahoo/vespa/hosted/controller/deployment/DeploymentContext.java", "diffHunk": "@@ -230,24 +218,15 @@ public DeploymentContext flushDnsUpdates(int count) {\n     }\n \n     /** Add a routing policy for this in given zone, with status set to active */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f68ea0c5bb592cf92d5a150934d39f30167d066"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NTA3Nw==", "bodyText": "\u2b50\ufe0f", "url": "https://github.com/vespa-engine/vespa/pull/12366#discussion_r385575077", "createdAt": "2020-02-28T08:56:08Z", "author": {"login": "jonmv"}, "path": "controller-server/src/test/java/com/yahoo/vespa/hosted/controller/deployment/DeploymentContext.java", "diffHunk": "@@ -405,7 +381,6 @@ public DeploymentContext timeOutConvergence(JobType type) {\n         runner.advance(currentRun(job));\n         assertTrue(jobs.run(id).get().hasFailed());\n         assertTrue(jobs.run(id).get().hasEnded());\n-        doTeardown(job);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f68ea0c5bb592cf92d5a150934d39f30167d066"}, "originalPosition": 131}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03acd681287551f2c68e25c688b84c33c9f9713b", "author": {"user": {"login": "mpolden", "name": "Martin Polden"}}, "url": "https://github.com/vespa-engine/vespa/commit/03acd681287551f2c68e25c688b84c33c9f9713b", "committedDate": "2020-02-28T09:07:39Z", "message": "Correct javadoc\n\nCo-Authored-By: Jon Marius Venstad <jonmv@users.noreply.github.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2830, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}