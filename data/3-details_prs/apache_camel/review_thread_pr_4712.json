{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMTc2NjI1", "number": 4712, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODoyNzoyN1rOE_wL2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODoyNzoyN1rOE_wL2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1Mjg1MjEwOnYy", "diffSide": "RIGHT", "path": "components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob/integration/BlobConsumerITTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODoyNzoyN1rOH9oe-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDoyMTo1N1rOH9spaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4ODQ3Mw==", "bodyText": "I think that if 15 will be increased to 16 (or larger number) test will still pass.", "url": "https://github.com/apache/camel/pull/4712#discussion_r534388473", "createdAt": "2020-12-02T18:27:27Z", "author": {"login": "DenisIstomin"}, "path": "components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob/integration/BlobConsumerITTest.java", "diffHunk": "@@ -128,42 +132,35 @@ void testBatchFilePolling() throws InterruptedException, IOException {\n             exchange.getIn().setHeader(BlobConstants.BLOB_NAME, \"test_batch_blob_2\");\n         });\n \n-        // test output stream based\n-        final MockEndpoint mockEndpoint = getMockEndpoint(\"mock:resultBatch\");\n-        mockEndpoint.expectedMessageCount(2);\n-        mockEndpoint.assertIsSatisfied(100);\n+        MockEndpoint.assertIsSatisfied(context());\n \n         final BlobInputStream blobInputStream = mockEndpoint.getExchanges().get(0).getIn().getBody(BlobInputStream.class);\n         final BlobInputStream blobInputStream2 = mockEndpoint.getExchanges().get(1).getIn().getBody(BlobInputStream.class);\n \n         assertNotNull(blobInputStream, \"BlobInputStream must be set\");\n         assertNotNull(blobInputStream2, \"BlobInputStream must be set\");\n \n-        final String bufferedText = new BufferedReader(new InputStreamReader(blobInputStream)).readLine();\n-        final String bufferedText2 = new BufferedReader(new InputStreamReader(blobInputStream2)).readLine();\n+        final String bufferedText = context().getTypeConverter().convertTo(String.class, blobInputStream);\n+        final String bufferedText2 = context().getTypeConverter().convertTo(String.class, blobInputStream2);\n \n         assertEquals(\"Block Batch Blob 1\", bufferedText);\n         assertEquals(\"Block Batch Blob 2\", bufferedText2);\n \n-        // test file based\n-        final MockEndpoint mockEndpointFile = getMockEndpoint(\"mock:resultBatchFile\");\n-        mockEndpointFile.expectedMessageCount(2);\n-        mockEndpointFile.assertIsSatisfied(100);\n-\n         final File file = mockEndpointFile.getExchanges().get(0).getIn().getBody(File.class);\n         final File file2 = mockEndpointFile.getExchanges().get(1).getIn().getBody(File.class);\n \n         assertNotNull(file, \"File must be set\");\n         assertNotNull(file2, \"File must be set\");\n \n-        assertEquals(\"Block Batch Blob 1\", FileUtils.readFileToString(file, Charset.defaultCharset()));\n-        assertEquals(\"Block Batch Blob 2\", FileUtils.readFileToString(file2, Charset.defaultCharset()));\n+        assertEquals(\"Block Batch Blob 1\", context().getTypeConverter().convertTo(String.class, file));\n+        assertEquals(\"Block Batch Blob 2\", context().getTypeConverter().convertTo(String.class, file2));\n     }\n \n     @Test\n-    @Disabled(\"This test should be fixed to use mock:resultRegex endpoint instead of mock:resultBatch\")\n-    void testRegexPolling() throws InterruptedException {\n-        Pattern pattern = Pattern.compile(regex);\n+    void testRegexPolling() throws Exception {\n+        // test regex based\n+        final MockEndpoint mockEndpoint = getMockEndpoint(\"mock:resultRegex\");\n+        mockEndpoint.expectedMessageCount(15);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "146e4ad70212799bd1fe115e42ab4aa8522f12a9"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1NjY4MQ==", "bodyText": "Thanks for your feedback. It should be fixed now.", "url": "https://github.com/apache/camel/pull/4712#discussion_r534456681", "createdAt": "2020-12-02T20:21:57Z", "author": {"login": "bvahdat"}, "path": "components/camel-azure-storage-blob/src/test/java/org/apache/camel/component/azure/storage/blob/integration/BlobConsumerITTest.java", "diffHunk": "@@ -128,42 +132,35 @@ void testBatchFilePolling() throws InterruptedException, IOException {\n             exchange.getIn().setHeader(BlobConstants.BLOB_NAME, \"test_batch_blob_2\");\n         });\n \n-        // test output stream based\n-        final MockEndpoint mockEndpoint = getMockEndpoint(\"mock:resultBatch\");\n-        mockEndpoint.expectedMessageCount(2);\n-        mockEndpoint.assertIsSatisfied(100);\n+        MockEndpoint.assertIsSatisfied(context());\n \n         final BlobInputStream blobInputStream = mockEndpoint.getExchanges().get(0).getIn().getBody(BlobInputStream.class);\n         final BlobInputStream blobInputStream2 = mockEndpoint.getExchanges().get(1).getIn().getBody(BlobInputStream.class);\n \n         assertNotNull(blobInputStream, \"BlobInputStream must be set\");\n         assertNotNull(blobInputStream2, \"BlobInputStream must be set\");\n \n-        final String bufferedText = new BufferedReader(new InputStreamReader(blobInputStream)).readLine();\n-        final String bufferedText2 = new BufferedReader(new InputStreamReader(blobInputStream2)).readLine();\n+        final String bufferedText = context().getTypeConverter().convertTo(String.class, blobInputStream);\n+        final String bufferedText2 = context().getTypeConverter().convertTo(String.class, blobInputStream2);\n \n         assertEquals(\"Block Batch Blob 1\", bufferedText);\n         assertEquals(\"Block Batch Blob 2\", bufferedText2);\n \n-        // test file based\n-        final MockEndpoint mockEndpointFile = getMockEndpoint(\"mock:resultBatchFile\");\n-        mockEndpointFile.expectedMessageCount(2);\n-        mockEndpointFile.assertIsSatisfied(100);\n-\n         final File file = mockEndpointFile.getExchanges().get(0).getIn().getBody(File.class);\n         final File file2 = mockEndpointFile.getExchanges().get(1).getIn().getBody(File.class);\n \n         assertNotNull(file, \"File must be set\");\n         assertNotNull(file2, \"File must be set\");\n \n-        assertEquals(\"Block Batch Blob 1\", FileUtils.readFileToString(file, Charset.defaultCharset()));\n-        assertEquals(\"Block Batch Blob 2\", FileUtils.readFileToString(file2, Charset.defaultCharset()));\n+        assertEquals(\"Block Batch Blob 1\", context().getTypeConverter().convertTo(String.class, file));\n+        assertEquals(\"Block Batch Blob 2\", context().getTypeConverter().convertTo(String.class, file2));\n     }\n \n     @Test\n-    @Disabled(\"This test should be fixed to use mock:resultRegex endpoint instead of mock:resultBatch\")\n-    void testRegexPolling() throws InterruptedException {\n-        Pattern pattern = Pattern.compile(regex);\n+    void testRegexPolling() throws Exception {\n+        // test regex based\n+        final MockEndpoint mockEndpoint = getMockEndpoint(\"mock:resultRegex\");\n+        mockEndpoint.expectedMessageCount(15);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4ODQ3Mw=="}, "originalCommit": {"oid": "146e4ad70212799bd1fe115e42ab4aa8522f12a9"}, "originalPosition": 130}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4767, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}