{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1MTMwNzI5", "number": 929, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQyMDo1NTozN1rOFQlbEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxOTozMzo1MVrOFUN-dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyOTM0Njc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQyMDo1NTozN1rOIWhmiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNzoxOTozMFrOIXJN_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ5MDEyMQ==", "bodyText": "Just accept request class name?", "url": "https://github.com/opensearch-project/security/pull/929#discussion_r560490121", "createdAt": "2021-01-19T20:55:37Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "diffHunk": "@@ -158,106 +152,165 @@ private static final boolean isLocalAll(final String... requestedPatterns) {\n         return false;\n     }\n \n-    private Resolved resolveIndexPatterns(final IndicesOptions indicesOptions, final boolean enableCrossClusterResolution, final String... requestedPatterns0) {\n+    private class ResolvedIndicesProvider implements IndicesProvider {\n+        private final ImmutableSet.Builder<String> aliases;\n+        private final ImmutableSet.Builder<String> allIndices;\n+        private final ImmutableSet.Builder<String> originalRequested;\n+        private final ImmutableSet.Builder<String> remoteIndices;\n+        // set of previously resolved index requests to avoid resolving\n+        // the same index more than once while processing bulk requests\n+        private final Set<MultiKey> alreadyResolved;\n+        private final String name;\n \n-        if(log.isTraceEnabled()) {\n-            log.trace(\"resolve requestedPatterns: \"+ Arrays.toString(requestedPatterns0));\n+        ResolvedIndicesProvider(Object request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEzOTE5Ng==", "bodyText": "It is better to unify conversion from request object to name inside ResolvedIndicesProvider constructor.", "url": "https://github.com/opensearch-project/security/pull/929#discussion_r561139196", "createdAt": "2021-01-20T17:19:30Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "diffHunk": "@@ -158,106 +152,165 @@ private static final boolean isLocalAll(final String... requestedPatterns) {\n         return false;\n     }\n \n-    private Resolved resolveIndexPatterns(final IndicesOptions indicesOptions, final boolean enableCrossClusterResolution, final String... requestedPatterns0) {\n+    private class ResolvedIndicesProvider implements IndicesProvider {\n+        private final ImmutableSet.Builder<String> aliases;\n+        private final ImmutableSet.Builder<String> allIndices;\n+        private final ImmutableSet.Builder<String> originalRequested;\n+        private final ImmutableSet.Builder<String> remoteIndices;\n+        // set of previously resolved index requests to avoid resolving\n+        // the same index more than once while processing bulk requests\n+        private final Set<MultiKey> alreadyResolved;\n+        private final String name;\n \n-        if(log.isTraceEnabled()) {\n-            log.trace(\"resolve requestedPatterns: \"+ Arrays.toString(requestedPatterns0));\n+        ResolvedIndicesProvider(Object request) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ5MDEyMQ=="}, "originalCommit": null, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyOTM2OTQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQyMTowMjoxNFrOIWh0Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQwMDowMToyNlrOIXZVxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ5MzYwNg==", "bodyText": "Do keys have correctly overridden equals (original - Arrays.equals(original, that.original) was done in previous code) ? Is there a way to simply to avoid complex structures like MultiKey in Set ?", "url": "https://github.com/opensearch-project/security/pull/929#discussion_r560493606", "createdAt": "2021-01-19T21:02:14Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "diffHunk": "@@ -158,106 +152,165 @@ private static final boolean isLocalAll(final String... requestedPatterns) {\n         return false;\n     }\n \n-    private Resolved resolveIndexPatterns(final IndicesOptions indicesOptions, final boolean enableCrossClusterResolution, final String... requestedPatterns0) {\n+    private class ResolvedIndicesProvider implements IndicesProvider {\n+        private final ImmutableSet.Builder<String> aliases;\n+        private final ImmutableSet.Builder<String> allIndices;\n+        private final ImmutableSet.Builder<String> originalRequested;\n+        private final ImmutableSet.Builder<String> remoteIndices;\n+        // set of previously resolved index requests to avoid resolving\n+        // the same index more than once while processing bulk requests\n+        private final Set<MultiKey> alreadyResolved;\n+        private final String name;\n \n-        if(log.isTraceEnabled()) {\n-            log.trace(\"resolve requestedPatterns: \"+ Arrays.toString(requestedPatterns0));\n+        ResolvedIndicesProvider(Object request) {\n+            aliases = ImmutableSet.builder();\n+            allIndices = ImmutableSet.builder();\n+            originalRequested = ImmutableSet.builder();\n+            remoteIndices = ImmutableSet.builder();\n+            alreadyResolved = new HashSet<>();\n+            name = request.getClass().getSimpleName();\n         }\n \n-        if (isAllWithNoRemote(requestedPatterns0)) {\n-            if (log.isTraceEnabled()) {\n-                log.trace(Arrays.toString(requestedPatterns0) + \" is an ALL pattern without any remote indices\");\n+        private void resolveIndexPatterns(final String name, final IndicesOptions indicesOptions, final boolean enableCrossClusterResolution, final String[] original) {\n+\n+            if(log.isTraceEnabled()) {\n+                log.trace(\"resolve requestedPatterns: \"+ Arrays.toString(original));\n             }\n-            return Resolved._LOCAL_ALL;\n-        }\n \n-        Set<String> remoteIndices;\n-        final List<String> localRequestedPatterns = new ArrayList<>(Arrays.asList(requestedPatterns0));\n+            if (isAllWithNoRemote(original)) {\n+                if (log.isTraceEnabled()) {\n+                    log.trace(Arrays.toString(original) + \" is an ALL pattern without any remote indices\");\n+                }\n+                resolveToLocalAll();\n+                return;\n+            }\n+\n+            Set<String> remoteIndices;\n+            final List<String> localRequestedPatterns = new ArrayList<>(Arrays.asList(original));\n+\n+            final RemoteClusterService remoteClusterService = OpenDistroSecurityPlugin.GuiceHolder.getRemoteClusterService();\n \n-        final RemoteClusterService remoteClusterService = OpenDistroSecurityPlugin.GuiceHolder.getRemoteClusterService();\n+            if(remoteClusterService.isCrossClusterSearchEnabled() && enableCrossClusterResolution) {\n+                remoteIndices = new HashSet<>();\n+                final Map<String, OriginalIndices> remoteClusterIndices = OpenDistroSecurityPlugin.GuiceHolder.getRemoteClusterService()\n+                        .groupIndices(indicesOptions, original, idx -> resolver.hasIndexAbstraction(idx, clusterService.state()));\n+                final Set<String> remoteClusters = remoteClusterIndices.keySet().stream()\n+                        .filter(k->!RemoteClusterService.LOCAL_CLUSTER_GROUP_KEY.equals(k)).collect(Collectors.toSet());\n+                for(String remoteCluster : remoteClusters) {\n+                    for(String remoteIndex : remoteClusterIndices.get(remoteCluster).indices()) {\n+                        remoteIndices.add(RemoteClusterService.buildRemoteIndexName(remoteCluster, remoteIndex));\n+                    }\n+                }\n \n-        if(remoteClusterService.isCrossClusterSearchEnabled() && enableCrossClusterResolution) {\n-            remoteIndices = new HashSet<>();\n-            final Map<String, OriginalIndices> remoteClusterIndices = OpenDistroSecurityPlugin.GuiceHolder.getRemoteClusterService()\n-                    .groupIndices(indicesOptions, requestedPatterns0, idx -> resolver.hasIndexAbstraction(idx, clusterService.state()));\n-            final Set<String> remoteClusters = remoteClusterIndices.keySet().stream()\n-                    .filter(k->!RemoteClusterService.LOCAL_CLUSTER_GROUP_KEY.equals(k)).collect(Collectors.toSet());\n-            for(String remoteCluster : remoteClusters) {\n-                for(String remoteIndex : remoteClusterIndices.get(remoteCluster).indices()) {\n-                    remoteIndices.add(RemoteClusterService.buildRemoteIndexName(remoteCluster, remoteIndex));\n+                final Iterator<String> iterator = localRequestedPatterns.iterator();\n+                while (iterator.hasNext()) {\n+                    final String[] split = iterator.next().split(String.valueOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR), 2);\n+                    final WildcardMatcher matcher = WildcardMatcher.from(split[0]);\n+                    if (split.length > 1 && matcher.matchAny(remoteClusters)) {\n+                        iterator.remove();\n+                    }\n                 }\n-            }\n \n-            final Iterator<String> iterator = localRequestedPatterns.iterator();\n-            while (iterator.hasNext()) {\n-                final String[] split = iterator.next().split(String.valueOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR), 2);\n-                final WildcardMatcher matcher = WildcardMatcher.from(split[0]);\n-                if (split.length > 1 && matcher.matchAny(remoteClusters)) {\n-                    iterator.remove();\n+                if (log.isTraceEnabled()) {\n+                    log.trace(\"CCS is enabled, we found this local patterns \" + localRequestedPatterns + \" and this remote patterns: \" + remoteIndices);\n                 }\n-            }\n \n-            if (log.isTraceEnabled()) {\n-                log.trace(\"CCS is enabled, we found this local patterns \" + localRequestedPatterns + \" and this remote patterns: \" + remoteIndices);\n+            } else {\n+                remoteIndices = Collections.emptySet();\n             }\n \n-        } else {\n-            remoteIndices = Collections.emptySet();\n-        }\n+            final Collection<String> matchingAliases;\n+            Collection<String> matchingAllIndices;\n+\n+            if (isLocalAll(original)) {\n+                if (log.isTraceEnabled()) {\n+                    log.trace(Arrays.toString(original) + \" is an LOCAL ALL pattern\");\n+                }\n+                matchingAliases = Resolved.All_SET;\n+                matchingAllIndices = Resolved.All_SET;\n \n-        final Collection<String> matchingAliases;\n-        Collection<String> matchingAllIndices;\n+            } else if (!remoteIndices.isEmpty() && localRequestedPatterns.isEmpty()) {\n+                if (log.isTraceEnabled()) {\n+                    log.trace(Arrays.toString(original) + \" is an LOCAL EMPTY request\");\n+                }\n+                matchingAllIndices = Collections.emptySet();\n+                matchingAliases = Collections.emptySet();\n+            }\n+\n+            else {\n+                final ClusterState state = clusterService.state();\n+                final Set<String> dateResolvedLocalRequestedPatterns = localRequestedPatterns\n+                                .stream()\n+                                .map(resolver::resolveDateMathExpression)\n+                                .collect(Collectors.toSet());\n+                final WildcardMatcher dateResolvedMatcher = WildcardMatcher.from(dateResolvedLocalRequestedPatterns);\n+                //fill matchingAliases\n+                final Map<String, IndexAbstraction> lookup = state.metadata().getIndicesLookup();\n+                matchingAliases = lookup.entrySet()\n+                        .stream()\n+                        .filter(e -> e.getValue().getType() == ALIAS)\n+                        .map(Map.Entry::getKey)\n+                        .filter(dateResolvedMatcher)\n+                        .collect(Collectors.toSet());\n+\n+                try {\n+                    matchingAllIndices = Arrays.asList(resolver.concreteIndexNames(state, indicesOptions, localRequestedPatterns.toArray(new String[0])));\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Resolved pattern {} to {}\", localRequestedPatterns, matchingAllIndices);\n+                    }\n+                } catch (IndexNotFoundException e1) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No such indices for pattern {}, use raw value\", localRequestedPatterns);\n+                    }\n \n-        if (isLocalAll(requestedPatterns0)) {\n-            if (log.isTraceEnabled()) {\n-                log.trace(Arrays.toString(requestedPatterns0) + \" is an LOCAL ALL pattern\");\n+                    matchingAllIndices = dateResolvedLocalRequestedPatterns;\n+                }\n             }\n-            matchingAliases = Resolved.All_SET;\n-            matchingAllIndices = Resolved.All_SET;\n \n-        } else if (!remoteIndices.isEmpty() && localRequestedPatterns.isEmpty()) {\n             if (log.isTraceEnabled()) {\n-                log.trace(Arrays.toString(requestedPatterns0) + \" is an LOCAL EMPTY request\");\n+                log.trace(\"Resolved patterns {} for {} ({}) to [aliases {}, allIndices {}, originalRequested{}, remote indices {}]\",\n+                        original, name, this.name, matchingAliases, matchingAllIndices, Arrays.toString(original), remoteIndices);\n             }\n-            matchingAllIndices = Collections.emptySet();\n-            matchingAliases = Collections.emptySet();\n+\n+            resolveTo(matchingAliases, matchingAllIndices, original, remoteIndices);\n+\n         }\n \n-        else {\n-            final ClusterState state = clusterService.state();\n-            final Set<String> dateResolvedLocalRequestedPatterns = localRequestedPatterns\n-                            .stream()\n-                            .map(resolver::resolveDateMathExpression)\n-                            .collect(Collectors.toSet());\n-            final WildcardMatcher dateResolvedMatcher = WildcardMatcher.from(dateResolvedLocalRequestedPatterns);\n-            //fill matchingAliases\n-            final Map<String, IndexAbstraction> lookup = state.metadata().getIndicesLookup();\n-            matchingAliases = lookup.entrySet()\n-                    .stream()\n-                    .filter(e -> e.getValue().getType() == ALIAS)\n-                    .map(Map.Entry::getKey)\n-                    .filter(dateResolvedMatcher)\n-                    .collect(Collectors.toSet());\n-\n-            try {\n-                matchingAllIndices = Arrays.asList(resolver.concreteIndexNames(state, indicesOptions, localRequestedPatterns.toArray(new String[0])));\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Resolved pattern {} to {}\", localRequestedPatterns, matchingAllIndices);\n-                }\n-            } catch (IndexNotFoundException e1) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"No such indices for pattern {}, use raw value\", localRequestedPatterns);\n-                }\n+        private void resolveToLocalAll() {\n+            aliases.add(Resolved.ANY);\n+            allIndices.add(Resolved.ANY);\n+            originalRequested.add(Resolved.ANY);\n+        }\n \n-                matchingAllIndices = dateResolvedLocalRequestedPatterns;\n-            }\n+        private void resolveTo(Iterable<String> matchingAliases, Iterable<String> matchingAllIndices, String[] original, Iterable<String> remoteIndices) {\n+            aliases.addAll(matchingAliases);\n+            allIndices.addAll(matchingAllIndices);\n+            originalRequested.add(original);\n+            this.remoteIndices.addAll(remoteIndices);\n         }\n \n-        return new Resolved(matchingAliases, matchingAllIndices, Arrays.asList(requestedPatterns0), remoteIndices);\n+        @Override\n+        public String[] provide(String[] original, Object localRequest, boolean supportsReplace) {\n+            final IndicesOptions indicesOptions = indicesOptionsFrom(localRequest);\n+            final boolean enableCrossClusterResolution = localRequest instanceof FieldCapabilitiesRequest || localRequest instanceof SearchRequest;\n+            // skip the whole thing if we have seen this exact resolveIndexPatterns request\n+            if (alreadyResolved.add(new MultiKey(indicesOptions, enableCrossClusterResolution, original))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQwMzMzMw==", "bodyText": "Good catch. Wrapped original in MultiKey for proper Array comparison.", "url": "https://github.com/opensearch-project/security/pull/929#discussion_r561403333", "createdAt": "2021-01-21T00:01:26Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "diffHunk": "@@ -158,106 +152,165 @@ private static final boolean isLocalAll(final String... requestedPatterns) {\n         return false;\n     }\n \n-    private Resolved resolveIndexPatterns(final IndicesOptions indicesOptions, final boolean enableCrossClusterResolution, final String... requestedPatterns0) {\n+    private class ResolvedIndicesProvider implements IndicesProvider {\n+        private final ImmutableSet.Builder<String> aliases;\n+        private final ImmutableSet.Builder<String> allIndices;\n+        private final ImmutableSet.Builder<String> originalRequested;\n+        private final ImmutableSet.Builder<String> remoteIndices;\n+        // set of previously resolved index requests to avoid resolving\n+        // the same index more than once while processing bulk requests\n+        private final Set<MultiKey> alreadyResolved;\n+        private final String name;\n \n-        if(log.isTraceEnabled()) {\n-            log.trace(\"resolve requestedPatterns: \"+ Arrays.toString(requestedPatterns0));\n+        ResolvedIndicesProvider(Object request) {\n+            aliases = ImmutableSet.builder();\n+            allIndices = ImmutableSet.builder();\n+            originalRequested = ImmutableSet.builder();\n+            remoteIndices = ImmutableSet.builder();\n+            alreadyResolved = new HashSet<>();\n+            name = request.getClass().getSimpleName();\n         }\n \n-        if (isAllWithNoRemote(requestedPatterns0)) {\n-            if (log.isTraceEnabled()) {\n-                log.trace(Arrays.toString(requestedPatterns0) + \" is an ALL pattern without any remote indices\");\n+        private void resolveIndexPatterns(final String name, final IndicesOptions indicesOptions, final boolean enableCrossClusterResolution, final String[] original) {\n+\n+            if(log.isTraceEnabled()) {\n+                log.trace(\"resolve requestedPatterns: \"+ Arrays.toString(original));\n             }\n-            return Resolved._LOCAL_ALL;\n-        }\n \n-        Set<String> remoteIndices;\n-        final List<String> localRequestedPatterns = new ArrayList<>(Arrays.asList(requestedPatterns0));\n+            if (isAllWithNoRemote(original)) {\n+                if (log.isTraceEnabled()) {\n+                    log.trace(Arrays.toString(original) + \" is an ALL pattern without any remote indices\");\n+                }\n+                resolveToLocalAll();\n+                return;\n+            }\n+\n+            Set<String> remoteIndices;\n+            final List<String> localRequestedPatterns = new ArrayList<>(Arrays.asList(original));\n+\n+            final RemoteClusterService remoteClusterService = OpenDistroSecurityPlugin.GuiceHolder.getRemoteClusterService();\n \n-        final RemoteClusterService remoteClusterService = OpenDistroSecurityPlugin.GuiceHolder.getRemoteClusterService();\n+            if(remoteClusterService.isCrossClusterSearchEnabled() && enableCrossClusterResolution) {\n+                remoteIndices = new HashSet<>();\n+                final Map<String, OriginalIndices> remoteClusterIndices = OpenDistroSecurityPlugin.GuiceHolder.getRemoteClusterService()\n+                        .groupIndices(indicesOptions, original, idx -> resolver.hasIndexAbstraction(idx, clusterService.state()));\n+                final Set<String> remoteClusters = remoteClusterIndices.keySet().stream()\n+                        .filter(k->!RemoteClusterService.LOCAL_CLUSTER_GROUP_KEY.equals(k)).collect(Collectors.toSet());\n+                for(String remoteCluster : remoteClusters) {\n+                    for(String remoteIndex : remoteClusterIndices.get(remoteCluster).indices()) {\n+                        remoteIndices.add(RemoteClusterService.buildRemoteIndexName(remoteCluster, remoteIndex));\n+                    }\n+                }\n \n-        if(remoteClusterService.isCrossClusterSearchEnabled() && enableCrossClusterResolution) {\n-            remoteIndices = new HashSet<>();\n-            final Map<String, OriginalIndices> remoteClusterIndices = OpenDistroSecurityPlugin.GuiceHolder.getRemoteClusterService()\n-                    .groupIndices(indicesOptions, requestedPatterns0, idx -> resolver.hasIndexAbstraction(idx, clusterService.state()));\n-            final Set<String> remoteClusters = remoteClusterIndices.keySet().stream()\n-                    .filter(k->!RemoteClusterService.LOCAL_CLUSTER_GROUP_KEY.equals(k)).collect(Collectors.toSet());\n-            for(String remoteCluster : remoteClusters) {\n-                for(String remoteIndex : remoteClusterIndices.get(remoteCluster).indices()) {\n-                    remoteIndices.add(RemoteClusterService.buildRemoteIndexName(remoteCluster, remoteIndex));\n+                final Iterator<String> iterator = localRequestedPatterns.iterator();\n+                while (iterator.hasNext()) {\n+                    final String[] split = iterator.next().split(String.valueOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR), 2);\n+                    final WildcardMatcher matcher = WildcardMatcher.from(split[0]);\n+                    if (split.length > 1 && matcher.matchAny(remoteClusters)) {\n+                        iterator.remove();\n+                    }\n                 }\n-            }\n \n-            final Iterator<String> iterator = localRequestedPatterns.iterator();\n-            while (iterator.hasNext()) {\n-                final String[] split = iterator.next().split(String.valueOf(RemoteClusterService.REMOTE_CLUSTER_INDEX_SEPARATOR), 2);\n-                final WildcardMatcher matcher = WildcardMatcher.from(split[0]);\n-                if (split.length > 1 && matcher.matchAny(remoteClusters)) {\n-                    iterator.remove();\n+                if (log.isTraceEnabled()) {\n+                    log.trace(\"CCS is enabled, we found this local patterns \" + localRequestedPatterns + \" and this remote patterns: \" + remoteIndices);\n                 }\n-            }\n \n-            if (log.isTraceEnabled()) {\n-                log.trace(\"CCS is enabled, we found this local patterns \" + localRequestedPatterns + \" and this remote patterns: \" + remoteIndices);\n+            } else {\n+                remoteIndices = Collections.emptySet();\n             }\n \n-        } else {\n-            remoteIndices = Collections.emptySet();\n-        }\n+            final Collection<String> matchingAliases;\n+            Collection<String> matchingAllIndices;\n+\n+            if (isLocalAll(original)) {\n+                if (log.isTraceEnabled()) {\n+                    log.trace(Arrays.toString(original) + \" is an LOCAL ALL pattern\");\n+                }\n+                matchingAliases = Resolved.All_SET;\n+                matchingAllIndices = Resolved.All_SET;\n \n-        final Collection<String> matchingAliases;\n-        Collection<String> matchingAllIndices;\n+            } else if (!remoteIndices.isEmpty() && localRequestedPatterns.isEmpty()) {\n+                if (log.isTraceEnabled()) {\n+                    log.trace(Arrays.toString(original) + \" is an LOCAL EMPTY request\");\n+                }\n+                matchingAllIndices = Collections.emptySet();\n+                matchingAliases = Collections.emptySet();\n+            }\n+\n+            else {\n+                final ClusterState state = clusterService.state();\n+                final Set<String> dateResolvedLocalRequestedPatterns = localRequestedPatterns\n+                                .stream()\n+                                .map(resolver::resolveDateMathExpression)\n+                                .collect(Collectors.toSet());\n+                final WildcardMatcher dateResolvedMatcher = WildcardMatcher.from(dateResolvedLocalRequestedPatterns);\n+                //fill matchingAliases\n+                final Map<String, IndexAbstraction> lookup = state.metadata().getIndicesLookup();\n+                matchingAliases = lookup.entrySet()\n+                        .stream()\n+                        .filter(e -> e.getValue().getType() == ALIAS)\n+                        .map(Map.Entry::getKey)\n+                        .filter(dateResolvedMatcher)\n+                        .collect(Collectors.toSet());\n+\n+                try {\n+                    matchingAllIndices = Arrays.asList(resolver.concreteIndexNames(state, indicesOptions, localRequestedPatterns.toArray(new String[0])));\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Resolved pattern {} to {}\", localRequestedPatterns, matchingAllIndices);\n+                    }\n+                } catch (IndexNotFoundException e1) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"No such indices for pattern {}, use raw value\", localRequestedPatterns);\n+                    }\n \n-        if (isLocalAll(requestedPatterns0)) {\n-            if (log.isTraceEnabled()) {\n-                log.trace(Arrays.toString(requestedPatterns0) + \" is an LOCAL ALL pattern\");\n+                    matchingAllIndices = dateResolvedLocalRequestedPatterns;\n+                }\n             }\n-            matchingAliases = Resolved.All_SET;\n-            matchingAllIndices = Resolved.All_SET;\n \n-        } else if (!remoteIndices.isEmpty() && localRequestedPatterns.isEmpty()) {\n             if (log.isTraceEnabled()) {\n-                log.trace(Arrays.toString(requestedPatterns0) + \" is an LOCAL EMPTY request\");\n+                log.trace(\"Resolved patterns {} for {} ({}) to [aliases {}, allIndices {}, originalRequested{}, remote indices {}]\",\n+                        original, name, this.name, matchingAliases, matchingAllIndices, Arrays.toString(original), remoteIndices);\n             }\n-            matchingAllIndices = Collections.emptySet();\n-            matchingAliases = Collections.emptySet();\n+\n+            resolveTo(matchingAliases, matchingAllIndices, original, remoteIndices);\n+\n         }\n \n-        else {\n-            final ClusterState state = clusterService.state();\n-            final Set<String> dateResolvedLocalRequestedPatterns = localRequestedPatterns\n-                            .stream()\n-                            .map(resolver::resolveDateMathExpression)\n-                            .collect(Collectors.toSet());\n-            final WildcardMatcher dateResolvedMatcher = WildcardMatcher.from(dateResolvedLocalRequestedPatterns);\n-            //fill matchingAliases\n-            final Map<String, IndexAbstraction> lookup = state.metadata().getIndicesLookup();\n-            matchingAliases = lookup.entrySet()\n-                    .stream()\n-                    .filter(e -> e.getValue().getType() == ALIAS)\n-                    .map(Map.Entry::getKey)\n-                    .filter(dateResolvedMatcher)\n-                    .collect(Collectors.toSet());\n-\n-            try {\n-                matchingAllIndices = Arrays.asList(resolver.concreteIndexNames(state, indicesOptions, localRequestedPatterns.toArray(new String[0])));\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"Resolved pattern {} to {}\", localRequestedPatterns, matchingAllIndices);\n-                }\n-            } catch (IndexNotFoundException e1) {\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"No such indices for pattern {}, use raw value\", localRequestedPatterns);\n-                }\n+        private void resolveToLocalAll() {\n+            aliases.add(Resolved.ANY);\n+            allIndices.add(Resolved.ANY);\n+            originalRequested.add(Resolved.ANY);\n+        }\n \n-                matchingAllIndices = dateResolvedLocalRequestedPatterns;\n-            }\n+        private void resolveTo(Iterable<String> matchingAliases, Iterable<String> matchingAllIndices, String[] original, Iterable<String> remoteIndices) {\n+            aliases.addAll(matchingAliases);\n+            allIndices.addAll(matchingAllIndices);\n+            originalRequested.add(original);\n+            this.remoteIndices.addAll(remoteIndices);\n         }\n \n-        return new Resolved(matchingAliases, matchingAllIndices, Arrays.asList(requestedPatterns0), remoteIndices);\n+        @Override\n+        public String[] provide(String[] original, Object localRequest, boolean supportsReplace) {\n+            final IndicesOptions indicesOptions = indicesOptionsFrom(localRequest);\n+            final boolean enableCrossClusterResolution = localRequest instanceof FieldCapabilitiesRequest || localRequest instanceof SearchRequest;\n+            // skip the whole thing if we have seen this exact resolveIndexPatterns request\n+            if (alreadyResolved.add(new MultiKey(indicesOptions, enableCrossClusterResolution, original))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ5MzYwNg=="}, "originalCommit": null, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyOTM3NzE1OnYy", "diffSide": "LEFT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQyMTowNDo1MVrOIWh4uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMFQxNjo1MDoyNFrOIXIBxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ5NDc3Nw==", "bodyText": "Why is Serializable, Writeable dropped ?", "url": "https://github.com/opensearch-project/security/pull/929#discussion_r560494777", "createdAt": "2021-01-19T21:04:51Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "diffHunk": "@@ -280,112 +333,41 @@ public boolean replace(final TransportRequest request, boolean retainMode, Strin\n         }, false);\n     }\n \n-    private static final class IndexResolveKey {\n-        private final IndicesOptions opts;\n-        private final boolean enableCrossClusterResolution;\n-        private final String[] original;\n-        public IndexResolveKey(IndicesOptions opts, boolean enableCrossClusterResolution, String[] original) {\n-            this.opts = opts;\n-            this.enableCrossClusterResolution = enableCrossClusterResolution;\n-            this.original = original;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            IndexResolveKey that = (IndexResolveKey) o;\n-            return enableCrossClusterResolution == that.enableCrossClusterResolution &&\n-                    opts.equals(that.opts) &&\n-                    Arrays.equals(original, that.original);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Boolean.hashCode(enableCrossClusterResolution) + 31 * opts.hashCode() + 127*Arrays.hashCode(original);\n-        }\n-    }\n-\n     public Resolved resolveRequest(final Object request) {\n         if(log.isDebugEnabled()) {\n             log.debug(\"Resolve aliases, indices and types from {}\", request.getClass().getSimpleName());\n         }\n \n-        final Resolved.Builder resolvedBuilder = new Resolved.Builder();\n-        final AtomicBoolean isIndicesRequest = new AtomicBoolean();\n-        // set of previously resolved index requests to avoid resolving\n-        // the same index more than once while processing bulk requests\n-        final Set<IndexResolveKey> alreadyResolved = new HashSet<>();\n-\n-        getOrReplaceAllIndices(request, (original, localRequest, supportsReplace) -> {\n-            final IndicesOptions indicesOptions = indicesOptionsFrom(localRequest);\n-            final boolean enableCrossClusterResolution = localRequest instanceof FieldCapabilitiesRequest || localRequest instanceof SearchRequest;\n-            final IndexResolveKey key = new IndexResolveKey(indicesOptions, enableCrossClusterResolution, original);\n-            // skip the whole thing if we have seen this exact resolveIndexPatterns request\n-            if (!alreadyResolved.contains(key)) {\n-                final Resolved iResolved = resolveIndexPatterns(key.opts, key.enableCrossClusterResolution, key.original);\n-                alreadyResolved.add(key);\n-                resolvedBuilder.add(iResolved);\n-                isIndicesRequest.set(true);\n-\n-                if (log.isTraceEnabled()) {\n-                    log.trace(\"Resolved patterns {} for {} ({}) to {}\", original, localRequest.getClass().getSimpleName(), request.getClass().getSimpleName(), iResolved);\n-                }\n-            }\n-            return IndicesProvider.NOOP;\n-        }, false);\n-\n-        if(!isIndicesRequest.get()) {\n-            //not an indices request\n-            return Resolved._LOCAL_ALL;\n-        }\n+        final ResolvedIndicesProvider resolvedIndicesProvider = new ResolvedIndicesProvider(request);\n \n-        if(log.isTraceEnabled()) {\n-            log.trace(\"Finally resolved for {}: {}\", request.getClass().getSimpleName(), resolvedBuilder.build());\n-        }\n+        getOrReplaceAllIndices(request, resolvedIndicesProvider, false);\n \n-        return resolvedBuilder.build();\n+        return resolvedIndicesProvider.resolved();\n     }\n \n-    public final static class Resolved implements Serializable, Writeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTExOTY4Nw==", "bodyText": "Resolved is never passed over the wire, so it does not need to be Serializable and/or Writeable.", "url": "https://github.com/opensearch-project/security/pull/929#discussion_r561119687", "createdAt": "2021-01-20T16:50:24Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "diffHunk": "@@ -280,112 +333,41 @@ public boolean replace(final TransportRequest request, boolean retainMode, Strin\n         }, false);\n     }\n \n-    private static final class IndexResolveKey {\n-        private final IndicesOptions opts;\n-        private final boolean enableCrossClusterResolution;\n-        private final String[] original;\n-        public IndexResolveKey(IndicesOptions opts, boolean enableCrossClusterResolution, String[] original) {\n-            this.opts = opts;\n-            this.enableCrossClusterResolution = enableCrossClusterResolution;\n-            this.original = original;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            IndexResolveKey that = (IndexResolveKey) o;\n-            return enableCrossClusterResolution == that.enableCrossClusterResolution &&\n-                    opts.equals(that.opts) &&\n-                    Arrays.equals(original, that.original);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Boolean.hashCode(enableCrossClusterResolution) + 31 * opts.hashCode() + 127*Arrays.hashCode(original);\n-        }\n-    }\n-\n     public Resolved resolveRequest(final Object request) {\n         if(log.isDebugEnabled()) {\n             log.debug(\"Resolve aliases, indices and types from {}\", request.getClass().getSimpleName());\n         }\n \n-        final Resolved.Builder resolvedBuilder = new Resolved.Builder();\n-        final AtomicBoolean isIndicesRequest = new AtomicBoolean();\n-        // set of previously resolved index requests to avoid resolving\n-        // the same index more than once while processing bulk requests\n-        final Set<IndexResolveKey> alreadyResolved = new HashSet<>();\n-\n-        getOrReplaceAllIndices(request, (original, localRequest, supportsReplace) -> {\n-            final IndicesOptions indicesOptions = indicesOptionsFrom(localRequest);\n-            final boolean enableCrossClusterResolution = localRequest instanceof FieldCapabilitiesRequest || localRequest instanceof SearchRequest;\n-            final IndexResolveKey key = new IndexResolveKey(indicesOptions, enableCrossClusterResolution, original);\n-            // skip the whole thing if we have seen this exact resolveIndexPatterns request\n-            if (!alreadyResolved.contains(key)) {\n-                final Resolved iResolved = resolveIndexPatterns(key.opts, key.enableCrossClusterResolution, key.original);\n-                alreadyResolved.add(key);\n-                resolvedBuilder.add(iResolved);\n-                isIndicesRequest.set(true);\n-\n-                if (log.isTraceEnabled()) {\n-                    log.trace(\"Resolved patterns {} for {} ({}) to {}\", original, localRequest.getClass().getSimpleName(), request.getClass().getSimpleName(), iResolved);\n-                }\n-            }\n-            return IndicesProvider.NOOP;\n-        }, false);\n-\n-        if(!isIndicesRequest.get()) {\n-            //not an indices request\n-            return Resolved._LOCAL_ALL;\n-        }\n+        final ResolvedIndicesProvider resolvedIndicesProvider = new ResolvedIndicesProvider(request);\n \n-        if(log.isTraceEnabled()) {\n-            log.trace(\"Finally resolved for {}: {}\", request.getClass().getSimpleName(), resolvedBuilder.build());\n-        }\n+        getOrReplaceAllIndices(request, resolvedIndicesProvider, false);\n \n-        return resolvedBuilder.build();\n+        return resolvedIndicesProvider.resolved();\n     }\n \n-    public final static class Resolved implements Serializable, Writeable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ5NDc3Nw=="}, "originalCommit": null, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU2NzQ0ODIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQxOTozMzo1MVrOIcHnbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOFQyMjo0MjozMVrOIcN0kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1NTgyMQ==", "bodyText": "Why we choose MultiKey to use here?", "url": "https://github.com/opensearch-project/security/pull/929#discussion_r566355821", "createdAt": "2021-01-28T19:33:51Z", "author": {"login": "cliu123"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "diffHunk": "@@ -158,106 +152,165 @@ private static final boolean isLocalAll(final String... requestedPatterns) {\n         return false;\n     }\n \n-    private Resolved resolveIndexPatterns(final IndicesOptions indicesOptions, final boolean enableCrossClusterResolution, final String... requestedPatterns0) {\n+    private class ResolvedIndicesProvider implements IndicesProvider {\n+        private final ImmutableSet.Builder<String> aliases;\n+        private final ImmutableSet.Builder<String> allIndices;\n+        private final ImmutableSet.Builder<String> originalRequested;\n+        private final ImmutableSet.Builder<String> remoteIndices;\n+        // set of previously resolved index requests to avoid resolving\n+        // the same index more than once while processing bulk requests\n+        private final Set<MultiKey> alreadyResolved;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba296b07ea88403bc82d28458752b7008517228e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjQ1NzQ4OA==", "bodyText": "As it provides the required functionality without any additional dependencies and simplifies the code.", "url": "https://github.com/opensearch-project/security/pull/929#discussion_r566457488", "createdAt": "2021-01-28T22:42:31Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/resolver/IndexResolverReplacer.java", "diffHunk": "@@ -158,106 +152,165 @@ private static final boolean isLocalAll(final String... requestedPatterns) {\n         return false;\n     }\n \n-    private Resolved resolveIndexPatterns(final IndicesOptions indicesOptions, final boolean enableCrossClusterResolution, final String... requestedPatterns0) {\n+    private class ResolvedIndicesProvider implements IndicesProvider {\n+        private final ImmutableSet.Builder<String> aliases;\n+        private final ImmutableSet.Builder<String> allIndices;\n+        private final ImmutableSet.Builder<String> originalRequested;\n+        private final ImmutableSet.Builder<String> remoteIndices;\n+        // set of previously resolved index requests to avoid resolving\n+        // the same index more than once while processing bulk requests\n+        private final Set<MultiKey> alreadyResolved;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjM1NTgyMQ=="}, "originalCommit": {"oid": "ba296b07ea88403bc82d28458752b7008517228e"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2208, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}