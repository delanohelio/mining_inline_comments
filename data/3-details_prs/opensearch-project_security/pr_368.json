{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNjYxOTc2", "number": 368, "title": "Refactor compliance config", "bodyText": "Issue #313\nChanges:\n\n\nconstructor based instantiation\n\n\nadded tests\n\n\nmoved externalConfigLogged and environment out of compliance config as they are storing specific startup state and should not be part of compliance config\n\n\nmoved out functionality to check if index is immutable using index resolver (removed index resolver dependency from config)\n\n\nSimilar PR: https://github.com/opendistro-for-elasticsearch/security/pull/306", "createdAt": "2020-04-09T21:48:56Z", "url": "https://github.com/opensearch-project/security/pull/368", "merged": true, "mergeCommit": {"oid": "d65094877e94673e581a326c8b77d1f8c39b7dd9"}, "closed": true, "closedAt": "2020-04-20T17:29:40Z", "author": {"login": "sujithvm"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcW169XgH2gAyNDAxNjYxOTc2OmNlYWU3YTkwZGM5YTllODE2ZTBlY2E4NDExNDFjZDQ3NmViMmQyMGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZigfbgFqTM5NjY2MTk3NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/ceae7a90dc9a9e816e0eca841141cd476eb2d20c", "committedDate": "2020-04-12T08:21:47Z", "message": "Refactor compliance config"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMzY2NTk1", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-392366595", "createdAt": "2020-04-13T19:11:33Z", "commit": {"oid": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToxMTozM1rOGExpEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOToxMTozM1rOGExpEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2MDgxOA==", "bodyText": "I see you have changed values with the class member variables. Why opposite here?", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407660818", "createdAt": "2020-04-13T19:11:33Z", "author": {"login": "palashhedau"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -41,209 +56,302 @@\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n \n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.ElasticsearchException;\n-import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n-import org.joda.time.DateTime;\n-import org.joda.time.DateTimeZone;\n-import org.joda.time.format.DateTimeFormat;\n-import org.joda.time.format.DateTimeFormatter;\n-\n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n-import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n-import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n-import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n-\n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n-    private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n+\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {\n             final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n+            if (split.isEmpty()) {\n                 continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n+            } else if (split.size() == 1) {\n+                this.readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n             } else {\n                 Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n+                this.readEnabledFields.put(split.get(0), _fields);\n             }\n         }\n \n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndices);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n+\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n-        return this.enabled;\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n+        return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c"}, "originalPosition": 289}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMzg2OTYy", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-392386962", "createdAt": "2020-04-13T19:44:21Z", "commit": {"oid": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTo0NDoyMVrOGEysBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxOTo0NDoyMVrOGEysBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY3Nzk1OQ==", "bodyText": "Please avoid reordering of imports.", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407677959", "createdAt": "2020-04-13T19:44:21Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -30,6 +30,21 @@\n \n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ceae7a90dc9a9e816e0eca841141cd476eb2d20c"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "386c749bda35c01b02003b827c6cd9b105598784", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/386c749bda35c01b02003b827c6cd9b105598784", "committedDate": "2020-04-13T19:45:47Z", "message": "Use class member variable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDExMDQ5", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-392411049", "createdAt": "2020-04-13T20:21:43Z", "commit": {"oid": "386c749bda35c01b02003b827c6cd9b105598784"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "754b209fe115330a13a900a3769ba03a262886ab", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/754b209fe115330a13a900a3769ba03a262886ab", "committedDate": "2020-04-13T22:48:39Z", "message": "revert back re-ordering of imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjAwMzM4", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-392600338", "createdAt": "2020-04-14T04:46:53Z", "commit": {"oid": "754b209fe115330a13a900a3769ba03a262886ab"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNDo0Njo1NFrOGE-E_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNDo0Njo1NFrOGE-E_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg2NDU3NA==", "bodyText": "move check complianceConfig != null  to isIndexImmutable().", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r407864574", "createdAt": "2020-04-14T04:46:54Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if(complianceConfig != null && isIndexImmutable(request)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "754b209fe115330a13a900a3769ba03a262886ab"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/ecdf7e66dd1e129ab35018a02ff58eb1e3adf633", "committedDate": "2020-04-14T06:41:41Z", "message": "Move compliance config null check into isIndexImmutable func"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyOTU0OTQz", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-392954943", "createdAt": "2020-04-14T13:59:43Z", "commit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMzo1OTo0M1rOGFQCFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMzo1OTo0M1rOGFQCFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE1ODc0Mw==", "bodyText": "Possible race condition, two threads may race for externalConfigLogged.", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408158743", "createdAt": "2020-04-14T13:59:43Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -1010,10 +1015,10 @@ public void onNodeStarted() {\n         }\n         final Set<ModuleInfo> securityModules = ReflectionHelper.getModulesLoaded();\n         log.info(\"{} Open Distro Security modules loaded so far: {}\", securityModules.size(), securityModules);\n-        if(complianceConfig != null && complianceConfig.isEnabled() && complianceConfig.isLogExternalConfig() && !complianceConfig.isExternalConfigLogged()) {\n-        \tlog.info(\"logging external config\");\n-        \tauditLog.logExternalConfig(complianceConfig.getSettings(), complianceConfig.getEnvironment());\n-            complianceConfig.setExternalConfigLogged(true);\n+        if(complianceConfig != null && complianceConfig.isEnabled() && complianceConfig.shouldLogExternalConfig() && !externalConfigLogged) {\n+            log.info(\"logging external config\");\n+            auditLog.logExternalConfig(settings, environment);\n+            externalConfigLogged = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyOTczODkw", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-392973890", "createdAt": "2020-04-14T14:19:13Z", "commit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDoxOToxNFrOGFQ8Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDoxOToxNFrOGFQ8Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MzY1OQ==", "bodyText": "nit: move to enclosing if", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408173659", "createdAt": "2020-04-14T14:19:14Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -311,7 +316,7 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n                 || request instanceof IndicesAliasesRequest //TODO only remove index\n                 ) {\n             \n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyOTc1MzI0", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-392975324", "createdAt": "2020-04-14T14:20:46Z", "commit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDoyMDo0NlrOGFRA0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDoyMDo0NlrOGFRA0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3NDgwMw==", "bodyText": "nit: move to enclosing if", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408174803", "createdAt": "2020-04-14T14:20:46Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyOTk5MTQw", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-392999140", "createdAt": "2020-04-14T14:44:32Z", "commit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo0NDozMlrOGFSKCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo0NDozMlrOGFSKCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5MzU0Nw==", "bodyText": "nit: consider isRequestIndexImmutable", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408193547", "createdAt": "2020-04-14T14:44:32Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n         \n         return false;\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isIndexImmutable(Object request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMDAxMTQ3", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-393001147", "createdAt": "2020-04-14T14:46:30Z", "commit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo0NjozMFrOGFSQKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo0NjozMFrOGFSQKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5NTExMw==", "bodyText": "Actually this check is redundant. There is the same condition on line 198 before checkImmutableIndices() call.", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408195113", "createdAt": "2020-04-14T14:46:30Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n         \n         return false;\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isIndexImmutable(Object request) {\n+        if (complianceConfig == null || !complianceConfig.isEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMDEwNDYw", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-393010460", "createdAt": "2020-04-14T14:55:32Z", "commit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo1NTozM1rOGFStsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNDo1NTozM1rOGFStsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIwMjY3Mw==", "bodyText": "Should this be part of the check on line 198? You can check that immutableIndicesPatterns is not empty once for BulkShardRequest and assume that it is not empty here or pass it to checkImmutableIndices().", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r408202673", "createdAt": "2020-04-14T14:55:33Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/filter/OpenDistroSecurityFilter.java", "diffHunk": "@@ -330,12 +335,27 @@ private boolean checkImmutableIndices(Object request, ActionListener listener) {\n         }\n         \n         if(request instanceof IndexRequest) {\n-            if(complianceConfig != null && complianceConfig.isIndexImmutable(request)) {\n+            if (isIndexImmutable(request)) {\n                 ((IndexRequest) request).opType(OpType.CREATE);\n             }\n         }\n         \n         return false;\n     }\n \n-}\n\\ No newline at end of file\n+    private boolean isIndexImmutable(Object request) {\n+        if (complianceConfig == null || !complianceConfig.isEnabled()) {\n+            return false;\n+        }\n+\n+        final Set<String> immutableIndicesPatterns = complianceConfig.getImmutableIndicesPatterns();\n+        if (immutableIndicesPatterns.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecdf7e66dd1e129ab35018a02ff58eb1e3adf633"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/1e9b7bbb4990e9daf957ab1c304662f94cf4f13d", "committedDate": "2020-04-15T02:58:59Z", "message": "Address code reviews"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjgzODc1", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395683875", "createdAt": "2020-04-17T18:32:16Z", "commit": {"oid": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODozMjoxNlrOGHY18w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODozMjoxNlrOGHY18w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwMDI0Mw==", "bodyText": "Consider:\n        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n        }\n        try {\n            ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(saltAsString);\n            byteBuffer.get(salt16);\n            if (byteBuffer.remaining() > 0) {\n                log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n            }\n        } catch (BufferUnderflowException e) {\n            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\", e);\n        }\n\nPlease add test cases for salt.", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410400243", "createdAt": "2020-04-17T18:32:16Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzI3MzAz", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395727303", "createdAt": "2020-04-17T19:44:17Z", "commit": {"oid": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0NDoxN1rOGHa6SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0NDoxN1rOGHa6SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNDEyMQ==", "bodyText": "Consider:\n        this.readEnabledFields = watchedReadFields.stream()\n                .map(watchedReadField -> watchedReadField.split(\",\"))\n                .filter(split -> split.length != 0)\n                .collect(Collectors.toMap(\n                        split -> split[0],\n                        split -> split.length == 1 ?\n                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n                ));", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410434121", "createdAt": "2020-04-17T19:44:17Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9b7bbb4990e9daf957ab1c304662f94cf4f13d"}, "originalPosition": 131}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/9cac07bcbd203f2ee90acbfae5e75592080ac27e", "committedDate": "2020-04-17T19:48:30Z", "message": "Fetch current compliance config from auditlog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Nzc0NDYw", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395774460", "createdAt": "2020-04-17T21:09:45Z", "commit": {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTowOTo0NlrOGHdMDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTowOTo0NlrOGHdMDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTQzNg==", "bodyText": "Should it be Set<String> watchedWriteIndicesPatterns to be consistent with Set<String> immutableIndicesPatterns?", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410471436", "createdAt": "2020-04-17T21:09:46Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzgwMTUz", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395780153", "createdAt": "2020-04-17T21:21:27Z", "commit": {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToyMToyN1rOGHdd5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToyMToyN1rOGHdd5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3NjAwNQ==", "bodyText": "nit: please change cache to a more descriptive name.", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410476005", "createdAt": "2020-04-17T21:21:27Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27d15469e0c14fd342441f62200adfd654e5323a", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/27d15469e0c14fd342441f62200adfd654e5323a", "committedDate": "2020-04-17T21:43:37Z", "message": "address code reviews\n\nFix non null"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODA0NjE2", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395804616", "createdAt": "2020-04-17T22:18:39Z", "commit": {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjoxODozOVrOGHet7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjoxODozOVrOGHet7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NjQ5NQ==", "bodyText": "I don't think that copy/clone is necessary, but if it is, I would rather use Arrays.copyOf().", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410496495", "createdAt": "2020-04-17T22:18:39Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {\n             final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n+            if (split.isEmpty()) {\n                 continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n+            } else if (split.size() == 1) {\n+                this.readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n             } else {\n                 Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n+                this.readEnabledFields.put(split.get(0), _fields);\n             }\n         }\n \n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndices);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n+\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n+\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return salt16.clone();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e"}, "originalPosition": 309}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODA1Mjgx", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395805281", "createdAt": "2020-04-17T22:20:38Z", "commit": {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjoyMDozOVrOGHewNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjoyMDozOVrOGHewNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NzA3Nw==", "bodyText": "Consider:\n        return readEnabledFields.entrySet().stream()\n                .filter(entry -> WildcardMatcher.match(entry.getKey(), index))\n                .flatMap(entry -> entry.getValue().stream())\n                .collect(Collectors.toSet());\n\nThere is no point of adding null or empty indexPattern to readEnabledFields, add it as a filter to the constructor.", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410497077", "createdAt": "2020-04-17T22:20:39Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -45,205 +45,315 @@\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndices;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n+    private final LoadingCache<String, Set<String>> cache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndices,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndices = watchedWriteIndices;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n+        for (String watchedReadField : watchedReadFields) {\n             final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n+            if (split.isEmpty()) {\n                 continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n+            } else if (split.size() == 1) {\n+                this.readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n             } else {\n                 Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n+                this.readEnabledFields.put(split.get(0), _fields);\n             }\n         }\n \n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndices);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n+\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n+\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return salt16.clone();\n+    }\n+\n+    /**\n+     * This function is used for caching the fields\n+     * @param index index to check for fields\n+     * @return set of fields which is used by cache\n+     */\n+    private Set<String> getFieldsForIndex(String index) {\n+        if (index == null) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n-            return Collections.EMPTY_SET;\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n-                return Collections.EMPTY_SET;\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+                return Collections.emptySet();\n             }\n         }\n \n         final Set<String> tmp = new HashSet<String>(100);\n-        for(String indexPattern: readEnabledFields.keySet()) {\n-            if(indexPattern != null && !indexPattern.isEmpty() && WildcardMatcher.match(indexPattern, index)) {\n+        for (String indexPattern : readEnabledFields.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9cac07bcbd203f2ee90acbfae5e75592080ac27e"}, "originalPosition": 340}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8aa0b0a7808adf463c7811313142895ccbeaa0b9", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/8aa0b0a7808adf463c7811313142895ccbeaa0b9", "committedDate": "2020-04-17T22:50:49Z", "message": "address code reviews"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODE1NTE0", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395815514", "createdAt": "2020-04-17T22:53:48Z", "commit": {"oid": "27d15469e0c14fd342441f62200adfd654e5323a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjo1Mzo0OFrOGHfSMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjo1Mzo0OFrOGHfSMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTc3Ng==", "bodyText": "private volatile or private final AtomicReference", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410505776", "createdAt": "2020-04-17T22:53:48Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java", "diffHunk": "@@ -87,6 +87,7 @@\n     private final Settings settings;\n     private final AuditConfig.Filter auditConfigFilter;\n     private final String opendistrosecurityIndex;\n+    protected ComplianceConfig complianceConfig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27d15469e0c14fd342441f62200adfd654e5323a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODE2NDc2", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395816476", "createdAt": "2020-04-17T22:57:24Z", "commit": {"oid": "8aa0b0a7808adf463c7811313142895ccbeaa0b9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjo1NzoyNVrOGHfVWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjo1NzoyNVrOGHfVWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNjU4NQ==", "bodyText": "getCurrentComplianceConfig -> getComplianceConfig", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410506585", "createdAt": "2020-04-17T22:57:25Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java", "diffHunk": "@@ -69,13 +69,15 @@\n     void logSSLException(TransportRequest request, Throwable t, String action, Task task);\n     void logSSLException(RestRequest request, Throwable t);\n \n-    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues, ComplianceConfig complianceConfig);\n-    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result, ComplianceConfig complianceConfig);\n+    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues);\n+    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result);\n     void logDocumentDeleted(ShardId shardId, Delete delete, DeleteResult result);\n     void logExternalConfig(Settings settings, Environment environment);\n     \n     // compliance config\n     void setComplianceConfig(ComplianceConfig complianceConfig);\n+\n+    ComplianceConfig getCurrentComplianceConfig();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aa0b0a7808adf463c7811313142895ccbeaa0b9"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f118d8ca5ec55ee20cda0fb93080283cb170f872", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/f118d8ca5ec55ee20cda0fb93080283cb170f872", "committedDate": "2020-04-17T23:44:35Z", "message": "address code review - use volatile for compliance config"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODI3OTE3", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395827917", "createdAt": "2020-04-17T23:44:49Z", "commit": {"oid": "8aa0b0a7808adf463c7811313142895ccbeaa0b9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMzo0NDo0OVrOGHf97g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMzo0NDo0OVrOGHf97g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxNjk3NA==", "bodyText": "Is it necessary to have setComplianceConfig() method? Can it be instantiated inside AbstractAuditLog constructor?", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410516974", "createdAt": "2020-04-17T23:44:49Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/AuditLog.java", "diffHunk": "@@ -69,13 +69,15 @@\n     void logSSLException(TransportRequest request, Throwable t, String action, Task task);\n     void logSSLException(RestRequest request, Throwable t);\n \n-    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues, ComplianceConfig complianceConfig);\n-    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result, ComplianceConfig complianceConfig);\n+    void logDocumentRead(String index, String id, ShardId shardId, Map<String, String> fieldNameValues);\n+    void logDocumentWritten(ShardId shardId, GetResult originalIndex, Index currentIndex, IndexResult result);\n     void logDocumentDeleted(ShardId shardId, Delete delete, DeleteResult result);\n     void logExternalConfig(Settings settings, Environment environment);\n     \n     // compliance config\n     void setComplianceConfig(ComplianceConfig complianceConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aa0b0a7808adf463c7811313142895ccbeaa0b9"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "039cbb512fed692151bfebe74121e0466d9b4426", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/039cbb512fed692151bfebe74121e0466d9b4426", "committedDate": "2020-04-18T00:09:57Z", "message": "Address code reviews - use auditLog getComplianceConfig()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODM0MzE5", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395834319", "createdAt": "2020-04-18T00:19:52Z", "commit": {"oid": "039cbb512fed692151bfebe74121e0466d9b4426"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxOTo1MlrOGHgVOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxOTo1MlrOGHgVOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkzNw==", "bodyText": "It should be private. If necessary, there is public getter.", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410522937", "createdAt": "2020-04-18T00:19:52Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/impl/AbstractAuditLog.java", "diffHunk": "@@ -87,6 +87,7 @@\n     private final Settings settings;\n     private final AuditConfig.Filter auditConfigFilter;\n     private final String opendistrosecurityIndex;\n+    protected volatile ComplianceConfig complianceConfig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "039cbb512fed692151bfebe74121e0466d9b4426"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b3f743f226d46372e95f363db243080b0406694", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/3b3f743f226d46372e95f363db243080b0406694", "committedDate": "2020-04-18T01:13:59Z", "message": "remove setComplianceConfig"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODc0NzEz", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395874713", "createdAt": "2020-04-18T02:53:15Z", "commit": {"oid": "3b3f743f226d46372e95f363db243080b0406694"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMjo1MzoxNVrOGHjfBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMjo1NDo0MFrOGHjhUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU3NDU5Nw==", "bodyText": "Consider:\n            log.warn(\"Failed to get index {} fields enabled for read from cache. Bypassing cache.\", index, e);\n            return getFieldsForIndex(index).isEmpty();", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410574597", "createdAt": "2020-04-18T02:53:15Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -31,292 +31,354 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndicesPatterns;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields;\n+    private final LoadingCache<String, Set<String>> readEnabledFieldsCache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndicesPatterns,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndicesPatterns = watchedWriteIndicesPatterns;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n-            final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n-                continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n-            } else {\n-                Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n-            }\n-        }\n-\n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        this.readEnabledFields = watchedReadFields.stream()\n+                .map(watchedReadField -> watchedReadField.split(\",\"))\n+                .filter(split -> split.length != 0 && !Strings.isNullOrEmpty(split[0]))\n+                .collect(Collectors.toMap(\n+                        split -> split[0],\n+                        split -> split.length == 1 ?\n+                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n+                ));\n+\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.readEnabledFieldsCache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndicesPatterns);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n+\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n-        }\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return Arrays.copyOf(salt16, salt16.length);\n+    }\n+\n+    /**\n+     * This function is used for caching the fields\n+     * @param index index to check for fields\n+     * @return set of fields which is used by cache\n+     */\n+    private Set<String> getFieldsForIndex(String index) {\n+        if (index == null) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n-                return Collections.EMPTY_SET;\n-            }\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+            return Collections.emptySet();\n         }\n \n-        final Set<String> tmp = new HashSet<String>(100);\n-        for(String indexPattern: readEnabledFields.keySet()) {\n-            if(indexPattern != null && !indexPattern.isEmpty() && WildcardMatcher.match(indexPattern, index)) {\n-                tmp.addAll(readEnabledFields.get(indexPattern));\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+                return Collections.emptySet();\n             }\n         }\n-        return tmp;\n+\n+        return readEnabledFields.entrySet().stream()\n+                .filter(entry -> WildcardMatcher.match(entry.getKey(), index))\n+                .flatMap(entry -> entry.getValue().stream())\n+                .collect(Collectors.toSet());\n     }\n \n+    /**\n+     * Get the index name with date pattern for rolling indexes\n+     * @param indexPattern index pattern\n+     * @param index index\n+     * @return index name\n+     */\n     private String getExpandedIndexName(DateTimeFormatter indexPattern, String index) {\n-        if(indexPattern == null) {\n+        if (indexPattern == null) {\n             return index;\n         }\n         return indexPattern.print(DateTime.now(DateTimeZone.UTC));\n     }\n \n-    //do not check for isEnabled\n+    /**\n+     * Check if write history is enabled for the index.\n+     * Does not check for compliance here.\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean writeHistoryEnabledForIndex(String index) {\n-\n-        if(index == null) {\n+        if (index == null) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-\n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+        // if the index is used for audit logging, return false\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n             return false;\n         }\n-\n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+        // if the index is used for audit logging (rolling index name), return false\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n                 return false;\n             }\n         }\n-\n-        return WildcardMatcher.matchAny(watchedWriteIndices, index);\n+        return WildcardMatcher.matchAny(watchedWriteIndicesPatterns, index);\n     }\n \n-    //no patterns here as parameters\n-    //check for isEnabled\n+    /**\n+     * Check if read compliance history is enabled for given index\n+     * Checks if compliance is enabled\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean readHistoryEnabledForIndex(String index) {\n-        \n-        if(!this.enabled) {\n+        if (!this.isEnabled()) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-        \n         try {\n-            return !cache.get(index).isEmpty();\n+            return !readEnabledFieldsCache.get(index).isEmpty();\n         } catch (ExecutionException e) {\n             log.error(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3f743f226d46372e95f363db243080b0406694"}, "originalPosition": 448}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU3NTE4NA==", "bodyText": "Consider:\n            log.warn(\"Failed to get index {} fields enabled for read from cache. Bypassing cache.\", index, e);\n            fields = getFieldsForIndex(index);", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410575184", "createdAt": "2020-04-18T02:54:40Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -31,292 +31,354 @@\n package com.amazon.opendistroforelasticsearch.security.compliance;\n \n import java.nio.charset.StandardCharsets;\n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n-import org.elasticsearch.env.Environment;\n import org.joda.time.DateTime;\n import org.joda.time.DateTimeZone;\n import org.joda.time.format.DateTimeFormat;\n import org.joda.time.format.DateTimeFormatter;\n \n-import com.amazon.opendistroforelasticsearch.security.auditlog.AuditLog;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer.Resolved;\n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n import com.google.common.cache.CacheBuilder;\n import com.google.common.cache.CacheLoader;\n import com.google.common.cache.LoadingCache;\n+import com.google.common.collect.ImmutableSet;\n \n-\n+/**\n+ * This class represents all configurations for compliance.\n+ * DLS/FLS uses this configuration for filtering and anonymizing fields.\n+ * Audit Logger uses this configuration to post compliance audit logs.\n+ */\n public class ComplianceConfig {\n \n-    private final Logger log = LogManager.getLogger(getClass());\n-    private final Settings settings;\n-\tprivate final Map<String, Set<String>> readEnabledFields = new HashMap<>(100);\n-    private final List<String> watchedWriteIndices;\n-    private DateTimeFormatter auditLogPattern = null;\n-    private String auditLogIndex = null;\n-    private final boolean logDiffsForWrite;\n-    private final boolean logWriteMetadataOnly;\n-    private final boolean logReadMetadataOnly;\n+    private static final Logger log = LogManager.getLogger(ComplianceConfig.class);\n+    private static final int SALT_SIZE = 16;\n+    private static final int CACHE_SIZE = 1000;\n+    private static final String INTERNAL_ELASTICSEARCH = \"internal_elasticsearch\";\n+\n     private final boolean logExternalConfig;\n     private final boolean logInternalConfig;\n-    private final LoadingCache<String, Set<String>> cache;\n+    private final boolean logReadMetadataOnly;\n+    private final boolean logWriteMetadataOnly;\n+    private final boolean logDiffsForWrite;\n+    private final List<String> watchedWriteIndicesPatterns;\n     private final Set<String> immutableIndicesPatterns;\n-    private final byte[] salt16;\n     private final String opendistrosecurityIndex;\n-    private final IndexResolverReplacer irr;\n-    private final Environment environment;\n-    private final AuditLog auditLog;\n+\n+    private final Map<String, Set<String>> readEnabledFields;\n+    private final LoadingCache<String, Set<String>> readEnabledFieldsCache;\n+    private final byte[] salt16;\n+    private final DateTimeFormatter auditLogPattern;\n+    private final String auditLogIndex;\n     private volatile boolean enabled = true;\n-    private volatile boolean externalConfigLogged = false;\n-\n-    public ComplianceConfig(final Environment environment, final IndexResolverReplacer irr, final AuditLog auditLog) {\n-        super();\n-        this.settings = environment.settings();\n-        this.environment = environment;\n-        this.irr = irr;\n-        this.auditLog = auditLog;\n-        final List<String> watchedReadFields = this.settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n-                Collections.emptyList(), false);\n \n-        watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n-        logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n-        logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n-        logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n-        logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n-        logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n-        immutableIndicesPatterns = new HashSet<String>(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n-        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n-        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+    private ComplianceConfig(\n+            final boolean logExternalConfig,\n+            final boolean logInternalConfig,\n+            final boolean logReadMetadataOnly,\n+            final boolean logWriteMetadataOnly,\n+            final boolean logDiffsForWrite,\n+            final List<String> watchedReadFields,\n+            final List<String> watchedWriteIndicesPatterns,\n+            final Set<String> immutableIndicesPatterns,\n+            final String saltAsString,\n+            final String opendistrosecurityIndex,\n+            final String destinationType,\n+            final String destinationIndex) {\n+        this.logExternalConfig = logExternalConfig;\n+        this.logInternalConfig = logInternalConfig;\n+        this.logReadMetadataOnly = logReadMetadataOnly;\n+        this.logWriteMetadataOnly = logWriteMetadataOnly;\n+        this.logDiffsForWrite = logDiffsForWrite;\n+        this.watchedWriteIndicesPatterns = watchedWriteIndicesPatterns;\n+        this.immutableIndicesPatterns = immutableIndicesPatterns;\n+        this.opendistrosecurityIndex = opendistrosecurityIndex;\n \n-        if(saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n-            log.warn(\"If you plan to use field masking pls configure \"+ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" to be a random string of 16 chars length identical on all nodes\");\n+        final byte[] saltAsBytes = saltAsString.getBytes(StandardCharsets.UTF_8);\n+        if (saltAsString.equals(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT)) {\n+            log.warn(\"If you plan to use field masking pls configure compliance salt {} to be a random string of 16 chars length identical on all nodes\", saltAsString);\n         }\n-        \n-        if(saltAsBytes.length < 16) {\n-            throw new ElasticsearchException(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" must at least contain 16 bytes\");\n+        if (saltAsBytes.length < SALT_SIZE) {\n+            throw new ElasticsearchException(\"Provided compliance salt \" + saltAsString + \" must at least contain 16 bytes\");\n         }\n-        \n-        if(saltAsBytes.length > 16) {\n-            log.warn(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT+\" is greater than 16 bytes. Only the first 16 bytes are used for salting\");\n+        if (saltAsBytes.length > SALT_SIZE) {\n+            log.warn(\"Provided compliance salt {} is greater than 16 bytes. Only the first 16 bytes are used for salting\", saltAsString);\n         }\n-        \n-        salt16 = Arrays.copyOf(saltAsBytes, 16);\n-        this.opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n-        \n+        this.salt16 = Arrays.copyOf(saltAsBytes, SALT_SIZE);\n+\n         //opendistro_security.compliance.pii_fields:\n         //  - indexpattern,fieldpattern,fieldpattern,....\n-        for(String watchedReadField: watchedReadFields) {\n-            final List<String> split = new ArrayList<>(Arrays.asList(watchedReadField.split(\",\")));\n-            if(split.isEmpty()) {\n-                continue;\n-            } else if(split.size() == 1) {\n-                readEnabledFields.put(split.get(0), Collections.singleton(\"*\"));\n-            } else {\n-                Set<String> _fields = new HashSet<String>(split.subList(1, split.size()));\n-                readEnabledFields.put(split.get(0), _fields);\n-            }\n-        }\n-\n-        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n-        if(\"internal_elasticsearch\".equalsIgnoreCase(type)) {\n-            final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX,\"'security-auditlog-'YYYY.MM.dd\");\n+        this.readEnabledFields = watchedReadFields.stream()\n+                .map(watchedReadField -> watchedReadField.split(\",\"))\n+                .filter(split -> split.length != 0 && !Strings.isNullOrEmpty(split[0]))\n+                .collect(Collectors.toMap(\n+                        split -> split[0],\n+                        split -> split.length == 1 ?\n+                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n+                ));\n+\n+        DateTimeFormatter auditLogPattern = null;\n+        String auditLogIndex = null;\n+        if (INTERNAL_ELASTICSEARCH.equalsIgnoreCase(destinationType)) {\n             try {\n-                auditLogPattern = DateTimeFormat.forPattern(index); //throws IllegalArgumentException if no pattern\n+                auditLogPattern = DateTimeFormat.forPattern(destinationIndex); //throws IllegalArgumentException if no pattern\n             } catch (IllegalArgumentException e) {\n                 //no pattern\n-                auditLogIndex = index;\n+                auditLogIndex = destinationIndex;\n             } catch (Exception e) {\n-                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", index, e);\n+                log.error(\"Unable to check if auditlog index {} is part of compliance setup\", destinationIndex, e);\n             }\n         }\n+        this.auditLogPattern = auditLogPattern;\n+        this.auditLogIndex = auditLogIndex;\n \n-        log.info(\"PII configuration [auditLogPattern={},  auditLogIndex={}]: {}\", auditLogPattern, auditLogIndex, readEnabledFields);\n-\n-\n-        cache = CacheBuilder.newBuilder()\n-                .maximumSize(1000)\n+        this.readEnabledFieldsCache = CacheBuilder.newBuilder()\n+                .maximumSize(CACHE_SIZE)\n                 .build(new CacheLoader<String, Set<String>>() {\n                     @Override\n                     public Set<String> load(String index) throws Exception {\n-                        return getFieldsForIndex0(index);\n+                        return getFieldsForIndex(index);\n                     }\n                 });\n     }\n \n-    public boolean isLogExternalConfig() {\n-\t\treturn logExternalConfig;\n-\t}\n+    public void log(Logger logger) {\n+        logger.info(\"Auditing of external configuration is {}.\", logExternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing of internal configuration is {}.\", logInternalConfig ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing only metadata information for read request is {}.\", logReadMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for read requests.\", readEnabledFields);\n+        logger.info(\"Auditing only metadata information for write request is {}.\", logWriteMetadataOnly ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing diffs for write requests is {}.\", logDiffsForWrite ? \"enabled\" : \"disabled\");\n+        logger.info(\"Auditing will watch {} for write requests.\", watchedWriteIndicesPatterns);\n+        logger.info(\"{} indices are made immutable.\", immutableIndicesPatterns);\n+        logger.info(\"{} is used as internal security index.\", opendistrosecurityIndex);\n+        logger.info(\"Internal index used for posting audit logs is {}\", auditLogIndex);\n+    }\n \n-\tpublic boolean isExternalConfigLogged() {\n-\t\treturn externalConfigLogged;\n-\t}\n+    /**\n+     * Create compliance configuration from Settings defined in elasticsearch.yml\n+     * @param settings settings\n+     * @return compliance configuration\n+     */\n+    public static ComplianceConfig from(Settings settings) {\n+        final boolean logExternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_EXTERNAL_CONFIG_ENABLED, false);\n+        final boolean logInternalConfig = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED, false);\n+        final boolean logReadMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_METADATA_ONLY, false);\n+        final boolean logWriteMetadataOnly = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_METADATA_ONLY, false);\n+        final boolean logDiffsForWrite = settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_LOG_DIFFS, false);\n+        final List<String> watchedReadFields = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_READ_WATCHED_FIELDS,\n+                Collections.emptyList(), false);\n+        final List<String> watchedWriteIndices = settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_WRITE_WATCHED_INDICES, Collections.emptyList());\n+        final Set<String> immutableIndicesPatterns = ImmutableSet.copyOf(settings.getAsList(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_IMMUTABLE_INDICES, Collections.emptyList()));\n+        final String saltAsString = settings.get(ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT, ConfigConstants.OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT);\n+        final String opendistrosecurityIndex = settings.get(ConfigConstants.OPENDISTRO_SECURITY_CONFIG_INDEX_NAME, ConfigConstants.OPENDISTRO_SECURITY_DEFAULT_CONFIG_INDEX);\n+        final String type = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_TYPE_DEFAULT, null);\n+        final String index = settings.get(ConfigConstants.OPENDISTRO_SECURITY_AUDIT_CONFIG_DEFAULT_PREFIX + ConfigConstants.OPENDISTRO_SECURITY_AUDIT_ES_INDEX, \"'security-auditlog-'YYYY.MM.dd\");\n+\n+        return new ComplianceConfig(\n+                logExternalConfig,\n+                logInternalConfig,\n+                logReadMetadataOnly,\n+                logWriteMetadataOnly,\n+                logDiffsForWrite,\n+                watchedReadFields,\n+                watchedWriteIndices,\n+                immutableIndicesPatterns,\n+                saltAsString,\n+                opendistrosecurityIndex,\n+                type,\n+                index);\n+    }\n+\n+    /**\n+     * Checks if config defined in elasticsearch config directory must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogExternalConfig() {\n+        return logExternalConfig;\n+    }\n \n-\tpublic void setExternalConfigLogged(boolean externalConfigLogged) {\n-\t\tthis.externalConfigLogged = externalConfigLogged;\n-\t}\n+    /**\n+     * Checks if internal config must be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogInternalConfig() {\n+        return logInternalConfig;\n+    }\n \n-\tpublic boolean isEnabled() {\n+    /**\n+     * Checks if compliance is enabled\n+     * @return true/false\n+     */\n+    public boolean isEnabled() {\n         return this.enabled;\n     }\n \n-    //cached\n-    @SuppressWarnings(\"unchecked\")\n-    private Set<String> getFieldsForIndex0(String index) {\n+    /**\n+     * Checks if logs diffs must be recorded for write requests\n+     * Log metadata only for write requests must be disabled\n+     * @return true/false\n+     */\n+    public boolean shouldLogDiffsForWrite() {\n+        return !shouldLogWriteMetadataOnly() && logDiffsForWrite;\n+    }\n \n-        if(index == null) {\n-            return Collections.EMPTY_SET;\n-        }\n+    /**\n+     * Checks if only metadata for write requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogWriteMetadataOnly() {\n+        return logWriteMetadataOnly;\n+    }\n \n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n-            return Collections.EMPTY_SET;\n+    /**\n+     * Checks if only metadata for read requests should be logged\n+     * @return true/false\n+     */\n+    public boolean shouldLogReadMetadataOnly() {\n+        return logReadMetadataOnly;\n+    }\n+\n+    /**\n+     * Get set of immutable index pattern\n+     * @return set of index patterns\n+     */\n+    public Set<String> getImmutableIndicesPatterns() {\n+        return immutableIndicesPatterns;\n+    }\n+\n+    /**\n+     * Get the salt in bytes for filed anonymization\n+     * @return salt in bytes\n+     */\n+    public byte[] getSalt16() {\n+        return Arrays.copyOf(salt16, salt16.length);\n+    }\n+\n+    /**\n+     * This function is used for caching the fields\n+     * @param index index to check for fields\n+     * @return set of fields which is used by cache\n+     */\n+    private Set<String> getFieldsForIndex(String index) {\n+        if (index == null) {\n+            return Collections.emptySet();\n         }\n \n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n-                return Collections.EMPTY_SET;\n-            }\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+            return Collections.emptySet();\n         }\n \n-        final Set<String> tmp = new HashSet<String>(100);\n-        for(String indexPattern: readEnabledFields.keySet()) {\n-            if(indexPattern != null && !indexPattern.isEmpty() && WildcardMatcher.match(indexPattern, index)) {\n-                tmp.addAll(readEnabledFields.get(indexPattern));\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+                return Collections.emptySet();\n             }\n         }\n-        return tmp;\n+\n+        return readEnabledFields.entrySet().stream()\n+                .filter(entry -> WildcardMatcher.match(entry.getKey(), index))\n+                .flatMap(entry -> entry.getValue().stream())\n+                .collect(Collectors.toSet());\n     }\n \n+    /**\n+     * Get the index name with date pattern for rolling indexes\n+     * @param indexPattern index pattern\n+     * @param index index\n+     * @return index name\n+     */\n     private String getExpandedIndexName(DateTimeFormatter indexPattern, String index) {\n-        if(indexPattern == null) {\n+        if (indexPattern == null) {\n             return index;\n         }\n         return indexPattern.print(DateTime.now(DateTimeZone.UTC));\n     }\n \n-    //do not check for isEnabled\n+    /**\n+     * Check if write history is enabled for the index.\n+     * Does not check for compliance here.\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean writeHistoryEnabledForIndex(String index) {\n-\n-        if(index == null) {\n+        if (index == null) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-\n-        if(auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n+        // if the index is used for audit logging, return false\n+        if (auditLogIndex != null && auditLogIndex.equalsIgnoreCase(index)) {\n             return false;\n         }\n-\n-        if(auditLogPattern != null) {\n-            if(index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n+        // if the index is used for audit logging (rolling index name), return false\n+        if (auditLogPattern != null) {\n+            if (index.equalsIgnoreCase(getExpandedIndexName(auditLogPattern, null))) {\n                 return false;\n             }\n         }\n-\n-        return WildcardMatcher.matchAny(watchedWriteIndices, index);\n+        return WildcardMatcher.matchAny(watchedWriteIndicesPatterns, index);\n     }\n \n-    //no patterns here as parameters\n-    //check for isEnabled\n+    /**\n+     * Check if read compliance history is enabled for given index\n+     * Checks if compliance is enabled\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean readHistoryEnabledForIndex(String index) {\n-        \n-        if(!this.enabled) {\n+        if (!this.isEnabled()) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-        \n         try {\n-            return !cache.get(index).isEmpty();\n+            return !readEnabledFieldsCache.get(index).isEmpty();\n         } catch (ExecutionException e) {\n             log.error(e);\n             return true;\n         }\n     }\n \n-    //no patterns here as parameters\n-    //check for isEnabled\n+    /**\n+     * Check if read compliance history is enabled for given index\n+     * Checks if compliance is enabled\n+     * @param index index\n+     * @return true/false\n+     */\n     public boolean readHistoryEnabledForField(String index, String field) {\n-        \n-        if(!this.enabled) {\n+        if (!this.isEnabled()) {\n             return false;\n         }\n-        \n-        if(opendistrosecurityIndex.equals(index)) {\n+        // if open distro index (internal index) check if internal config logging is enabled\n+        if (opendistrosecurityIndex.equals(index)) {\n             return logInternalConfig;\n         }\n-        \n         try {\n-            final Set<String> fields = cache.get(index);\n-            if(fields.isEmpty()) {\n+            final Set<String> fields = readEnabledFieldsCache.get(index);\n+            if (fields.isEmpty()) {\n                 return false;\n             }\n-\n             return WildcardMatcher.matchAny(fields, field);\n         } catch (ExecutionException e) {\n             log.error(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3f743f226d46372e95f363db243080b0406694"}, "originalPosition": 484}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85291e8e7cb67e13808080725cb078b3e28a69ec", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/85291e8e7cb67e13808080725cb078b3e28a69ec", "committedDate": "2020-04-18T03:09:17Z", "message": "address code review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODc5NjYw", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395879660", "createdAt": "2020-04-18T04:14:53Z", "commit": {"oid": "3b3f743f226d46372e95f363db243080b0406694"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwNDoxNDo1M1rOGHlfoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwNDoxNDo1M1rOGHlfoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwNzUyMQ==", "bodyText": "complianceDisabled -> isComplienceConfigEnabled (true -> enabled)", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410607521", "createdAt": "2020-04-18T04:14:53Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java", "diffHunk": "@@ -65,22 +63,18 @@ public AuditMessageRouter(final Settings settings, final Client clientProvider,\n \t\t}\n \t}\n \n-\tpublic void setComplianceConfig(ComplianceConfig complianceConfig) {\n-\t\tthis.complianceConfig = complianceConfig;\n-\t}\n-\n \tpublic boolean isEnabled() {\n \t\treturn this.enabled;\n \t}\n \n-\tpublic final void route(final AuditMessage msg) {\n+\tpublic final void route(final AuditMessage msg, final boolean complianceDisabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b3f743f226d46372e95f363db243080b0406694"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODc5ODg0", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395879884", "createdAt": "2020-04-18T04:18:58Z", "commit": {"oid": "85291e8e7cb67e13808080725cb078b3e28a69ec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwNDoxODo1OFrOGHlmgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwNDoxODo1OFrOGHlmgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDYwOTI4Mw==", "bodyText": "keep public final void route(final AuditMessage msg) and use the most common default to call route(msg, ...)", "url": "https://github.com/opensearch-project/security/pull/368#discussion_r410609283", "createdAt": "2020-04-18T04:18:58Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/auditlog/routing/AuditMessageRouter.java", "diffHunk": "@@ -65,22 +63,18 @@ public AuditMessageRouter(final Settings settings, final Client clientProvider,\n \t\t}\n \t}\n \n-\tpublic void setComplianceConfig(ComplianceConfig complianceConfig) {\n-\t\tthis.complianceConfig = complianceConfig;\n-\t}\n-\n \tpublic boolean isEnabled() {\n \t\treturn this.enabled;\n \t}\n \n-\tpublic final void route(final AuditMessage msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85291e8e7cb67e13808080725cb078b3e28a69ec"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07c85006481dabe045a39c569035c2ba5a7d2245", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/07c85006481dabe045a39c569035c2ba5a7d2245", "committedDate": "2020-04-18T04:36:50Z", "message": "Use is compliance enabled"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "391cb4ad5179046f530d5507a19547bf817c592e", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/391cb4ad5179046f530d5507a19547bf817c592e", "committedDate": "2020-04-18T20:04:00Z", "message": "Update byte buffer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f032e0ed642e3559c6782675356e0b6ff3e5953b", "author": {"user": {"login": "vrozov", "name": "Vlad Rozov"}}, "url": "https://github.com/opensearch-project/security/commit/f032e0ed642e3559c6782675356e0b6ff3e5953b", "committedDate": "2020-04-18T20:06:23Z", "message": "code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36a20c42570969b77de30b3ba268471636b419f6", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/36a20c42570969b77de30b3ba268471636b419f6", "committedDate": "2020-04-18T20:23:42Z", "message": "fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6507fa9f0f85db02286be5825c7c21cef618fb15", "author": {"user": {"login": "sujithvm", "name": "Sujith Vadakkepat"}}, "url": "https://github.com/opensearch-project/security/commit/6507fa9f0f85db02286be5825c7c21cef618fb15", "committedDate": "2020-04-18T20:59:12Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2116cd01e9c25688419ce16d3b58943b486f1713", "author": {"user": {"login": "vrozov", "name": "Vlad Rozov"}}, "url": "https://github.com/opensearch-project/security/commit/2116cd01e9c25688419ce16d3b58943b486f1713", "committedDate": "2020-04-18T22:54:16Z", "message": "fixing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a217b0d8ec560ef98314fb15afabe24338fa684", "author": {"user": {"login": "vrozov", "name": "Vlad Rozov"}}, "url": "https://github.com/opensearch-project/security/commit/3a217b0d8ec560ef98314fb15afabe24338fa684", "committedDate": "2020-04-18T22:58:01Z", "message": "fixing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07a7b8cfe8dc01684755cf3e228d72b021ea9915", "author": {"user": {"login": "vrozov", "name": "Vlad Rozov"}}, "url": "https://github.com/opensearch-project/security/commit/07a7b8cfe8dc01684755cf3e228d72b021ea9915", "committedDate": "2020-04-19T03:06:52Z", "message": "code review (#57)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTczNzg4", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-395973788", "createdAt": "2020-04-19T04:07:55Z", "commit": {"oid": "07a7b8cfe8dc01684755cf3e228d72b021ea9915"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NjYxOTc1", "url": "https://github.com/opensearch-project/security/pull/368#pullrequestreview-396661975", "createdAt": "2020-04-20T17:26:27Z", "commit": {"oid": "07a7b8cfe8dc01684755cf3e228d72b021ea9915"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2871, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}