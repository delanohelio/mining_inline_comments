{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1ODIzNjM3", "number": 458, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjo1NzowNFrOD8Q8jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoyNToxMFrOD9pyjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTE4Nzk5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjo1NzowNFrOGVGWtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwMzozNzoxOVrOGXOs3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NzM5Ng==", "bodyText": "Can we eliminate the patterns.length == 1 check and just use return from(Arrays.stream(patterns), caseSensitive); for a non-null case?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r424777396", "createdAt": "2020-05-13T22:57:04Z", "author": {"login": "debjanibnrj"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();\n+            if (t instanceof String) {\n+                return from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n         }\n-\n-        return false;\n+        return from(collection.stream(), caseSensitive);\n     }\n \n-    public static String[] matches(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        final List<String> ret = new ArrayList<String>(candidate.length);\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                ret.add(string);\n-            }\n+    public static WildcardMatcher from(String[] patterns, boolean caseSensitive) {\n+        if (patterns == null || patterns.length == 0) {\n+            return NONE;\n+        } else if (patterns.length == 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxMTI5NQ==", "bodyText": "The check can be eliminated, but will lead to less efficient code of creating stream, collecting it to a set (with a single element) and still returning that element as the result.", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427011295", "createdAt": "2020-05-19T03:37:19Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();\n+            if (t instanceof String) {\n+                return from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n         }\n-\n-        return false;\n+        return from(collection.stream(), caseSensitive);\n     }\n \n-    public static String[] matches(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        final List<String> ret = new ArrayList<String>(candidate.length);\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                ret.add(string);\n-            }\n+    public static WildcardMatcher from(String[] patterns, boolean caseSensitive) {\n+        if (patterns == null || patterns.length == 0) {\n+            return NONE;\n+        } else if (patterns.length == 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NzM5Ng=="}, "originalCommit": null, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODE3OTYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODoxNzowOFrOGXCeDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODoxNzowOFrOGXCeDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgxMDg5NQ==", "bodyText": "Not used. Can we remove it?\nOr if retaining it for utils what does \"set of string to modify\" mean ?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r426810895", "createdAt": "2020-05-18T18:17:08Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();\n+            if (t instanceof String) {\n+                return from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n         }\n-\n-        return false;\n+        return from(collection.stream(), caseSensitive);\n     }\n \n-    public static String[] matches(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        final List<String> ret = new ArrayList<String>(candidate.length);\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                ret.add(string);\n-            }\n+    public static WildcardMatcher from(String[] patterns, boolean caseSensitive) {\n+        if (patterns == null || patterns.length == 0) {\n+            return NONE;\n+        } else if (patterns.length == 1) {\n+            return from(patterns[0], caseSensitive);\n         }\n-\n-        return ret.toArray(new String[0]);\n+        return from(Arrays.stream(patterns), caseSensitive);\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Stream<String> patterns) {\n+        return from(patterns, true);\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Collection<?> patterns) {\n+        return from(patterns, true);\n     }\n \n+    public static WildcardMatcher from(String... patterns) {\n+        return from(patterns, true);\n+    }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n+    public WildcardMatcher concat(Stream<WildcardMatcher> matchers) {\n+        return new WildcardMatcher.MatcherCombiner(Stream.concat(matchers, Stream.of(this)).collect(ImmutableSet.toImmutableSet()));\n+    }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(Collection<WildcardMatcher> matchers) {\n+        if (matchers.isEmpty()) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(matchers.stream());\n     }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(candidates.size());\n-\n-        for (String string: candidates) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(WildcardMatcher... matchers) {\n+        if (matchers.length == 0) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(Arrays.stream(matchers));\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final Collection<String> candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.size());\n-\n-        for (final String string: candidate) {\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAny(Stream<String> candidates) {\n+        return candidates.anyMatch(this);\n+    }\n \n-        return matches;\n+    public boolean matchAny(Collection<String> candidates) {\n+        return matchAny(candidates.stream());\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final Collection<String> candidate) {\n+    public boolean matchAny(String[] candidates) {\n+        return matchAny(Arrays.stream(candidates));\n+    }\n \n-        final List<String> matches = new ArrayList<String>(candidate.size());\n+    public boolean matchAll(Stream<String> candidates) {\n+        return candidates.allMatch(this);\n+    }\n \n-        for (final String string: candidate) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAll(Collection<String> candidates) {\n+        return matchAll(candidates.stream());\n+    }\n \n-        return matches;\n+    public boolean matchAll(String[] candidates) {\n+        return matchAll(Arrays.stream(candidates));\n     }\n-    \n-    public static Optional<String> getFirstMatchingPattern(final Collection<String> pattern, final String candidate) {\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                return Optional.of(p);\n-            }\n-        }\n+    public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+        return candidates.filter(this).collect(collector);\n+    }\n \n-        return Optional.empty();\n+    public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(candidate.stream(), collector);\n     }\n \n+    public <T extends Collection<String>> T getMatchAny(final String[] candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(Arrays.stream(candidate), collector);\n+    }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final String candidate) {\n+    public Optional<WildcardMatcher> findFirst(final String candidate) {\n+        return Optional.ofNullable(test(candidate) ? this : null);\n+    }\n \n-        final List<String> matches = new ArrayList<String>(pattern.size());\n+    public static List<WildcardMatcher> matchers(Collection<String> patterns) {\n+        return patterns.stream().map(p -> WildcardMatcher.from(p, true))\n+                .collect(Collectors.toList());\n+    }\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                matches.add(p);\n+    public static boolean allMatches(final Collection<WildcardMatcher> matchers, final Collection<String> candidate) {\n+        int matchedPatternNum = 0;\n+        for (WildcardMatcher matcher : matchers) {\n+            if (matcher.matchAny(candidate)) {\n+                matchedPatternNum++;\n             }\n         }\n-\n-        return matches;\n+        return matchedPatternNum == matchers.size() && matchers.size() > 0;\n     }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(pattern.size());\n-\n-        for (String c : candidates) {\n-            matches.addAll(getAllMatchingPatterns(pattern, c));\n-        }\n-\n-        return matches;\n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> matchers, final String candidate) {\n+        return matchers.stream().filter(p -> p.test(candidate)).map(Objects::toString).collect(Collectors.toList());\n     }\n \n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> pattern, final Collection<String> candidates) {\n+        return pattern.stream().filter(p -> p.matchAny(candidates)).map(Objects::toString).collect(Collectors.toList());\n+    }\n \n     /**\n-     * returns true if the candidate matches at least one pattern\n      *\n-     * @param pattern\n-     * @param candidate\n+     * @param set of string to modify\n+     * @param matcher WildcardMatcher matcher to use to filter\n      * @return\n      */\n-    public static boolean matchAny(final String pattern[], final String candidate) {\n-\n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (match(string, candidate)) {\n-                return true;\n+    public static boolean WildcardMatcherRetainInSet(Set<String> set, WildcardMatcher matcher) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 520}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODI0MDE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/Base64Helper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozNjoyNFrOGXDEAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozNjoyNFrOGXDEAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgyMDYwOQ==", "bodyText": "Use ImmutableSet ?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r426820609", "createdAt": "2020-05-18T18:36:24Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/Base64Helper.java", "diffHunk": "@@ -38,23 +44,94 @@\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamClass;\n+import java.io.OutputStream;\n import java.io.Serializable;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n-import java.util.ArrayList;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n import java.util.Collection;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n \n import org.elasticsearch.ElasticsearchException;\n \n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n import com.amazon.opendistroforelasticsearch.security.user.User;\n import com.google.common.io.BaseEncoding;\n \n public class Base64Helper {\n \n+    private static final Set<Class<?>> SAFE_CLASSES = new HashSet<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODI0MTQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/Base64Helper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozNjo1MVrOGXDE2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozNjo1MVrOGXDE2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgyMDgyNg==", "bodyText": "use ImmutableList ?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r426820826", "createdAt": "2020-05-18T18:36:51Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/Base64Helper.java", "diffHunk": "@@ -38,23 +44,94 @@\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamClass;\n+import java.io.OutputStream;\n import java.io.Serializable;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n-import java.util.ArrayList;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n import java.util.Collection;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n \n import org.elasticsearch.ElasticsearchException;\n \n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n import com.amazon.opendistroforelasticsearch.security.user.User;\n import com.google.common.io.BaseEncoding;\n \n public class Base64Helper {\n \n+    private static final Set<Class<?>> SAFE_CLASSES = new HashSet<>(\n+        Arrays.asList(\n+            String.class,\n+            SocketAddress.class,\n+            InetSocketAddress.class,\n+            Pattern.class,\n+            User.class,\n+            SourceFieldsContext.class,\n+            LdapUser.class,\n+            SearchEntry.class,\n+            LdapEntry.class,\n+            AbstractLdapBean.class,\n+            LdapAttribute.class\n+        )\n+    );\n+\n+    private static final List<Class<?>> SAFE_ASSIGNABLE_FROM_CLASSES = Arrays.asList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODI0NzM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/Base64Helper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozODo1MlrOGXDIxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozODo1MlrOGXDIxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgyMTgzMA==", "bodyText": "Is this related to Wildcard matching ? or we can have separate PR ?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r426821830", "createdAt": "2020-05-18T18:38:52Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/Base64Helper.java", "diffHunk": "@@ -38,23 +44,94 @@\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamClass;\n+import java.io.OutputStream;\n import java.io.Serializable;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n-import java.util.ArrayList;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n import java.util.Collection;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n \n import org.elasticsearch.ElasticsearchException;\n \n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n import com.amazon.opendistroforelasticsearch.security.user.User;\n import com.google.common.io.BaseEncoding;\n \n public class Base64Helper {\n \n+    private static final Set<Class<?>> SAFE_CLASSES = new HashSet<>(\n+        Arrays.asList(\n+            String.class,\n+            SocketAddress.class,\n+            InetSocketAddress.class,\n+            Pattern.class,\n+            User.class,\n+            SourceFieldsContext.class,\n+            LdapUser.class,\n+            SearchEntry.class,\n+            LdapEntry.class,\n+            AbstractLdapBean.class,\n+            LdapAttribute.class\n+        )\n+    );\n+\n+    private static final List<Class<?>> SAFE_ASSIGNABLE_FROM_CLASSES = Arrays.asList(\n+        InetAddress.class,\n+        Number.class,\n+        Collection.class,\n+        Map.class,\n+        Enum.class\n+    );\n+\n+    private static final Set<String> SAFE_CLASS_NAMES = new HashSet<>(\n+        Arrays.asList(\n+            \"org.ldaptive.LdapAttribute$LdapAttributeValues\"\n+        )\n+    );\n+\n+    private static boolean isSafeClass(Class cls) {\n+        return cls.isArray() ||\n+            SAFE_CLASSES.contains(cls) ||\n+            SAFE_CLASS_NAMES.contains(cls.getName()) ||\n+            SAFE_ASSIGNABLE_FROM_CLASSES.stream().anyMatch(c -> c.isAssignableFrom(cls));\n+    }\n+\n+    private final static class SafeObjectOutputStream extends ObjectOutputStream {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODI0ODIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/Base64Helper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozOToxM1rOGXDJXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODozOToxM1rOGXDJXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgyMTk4MA==", "bodyText": "Use ImmutableSet ?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r426821980", "createdAt": "2020-05-18T18:39:13Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/Base64Helper.java", "diffHunk": "@@ -38,23 +44,94 @@\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.ObjectStreamClass;\n+import java.io.OutputStream;\n import java.io.Serializable;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.SocketAddress;\n-import java.util.ArrayList;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n import java.util.Collection;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n \n import org.elasticsearch.ElasticsearchException;\n \n-import com.amazon.opendistroforelasticsearch.security.resolver.IndexResolverReplacer;\n import com.amazon.opendistroforelasticsearch.security.user.User;\n import com.google.common.io.BaseEncoding;\n \n public class Base64Helper {\n \n+    private static final Set<Class<?>> SAFE_CLASSES = new HashSet<>(\n+        Arrays.asList(\n+            String.class,\n+            SocketAddress.class,\n+            InetSocketAddress.class,\n+            Pattern.class,\n+            User.class,\n+            SourceFieldsContext.class,\n+            LdapUser.class,\n+            SearchEntry.class,\n+            LdapEntry.class,\n+            AbstractLdapBean.class,\n+            LdapAttribute.class\n+        )\n+    );\n+\n+    private static final List<Class<?>> SAFE_ASSIGNABLE_FROM_CLASSES = Arrays.asList(\n+        InetAddress.class,\n+        Number.class,\n+        Collection.class,\n+        Map.class,\n+        Enum.class\n+    );\n+\n+    private static final Set<String> SAFE_CLASS_NAMES = new HashSet<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODMwNjI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODo1NzowN1rOGXDt5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo0NToxM1rOGXx8YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzMTMzNA==", "bodyText": "Right now MatcherCombiner does a matchAny by default. Is it possible to configure it to do a matchAll?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r426831334", "createdAt": "2020-05-18T18:57:07Z", "author": {"login": "debjanibnrj"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();\n+            if (t instanceof String) {\n+                return from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n         }\n-\n-        return false;\n+        return from(collection.stream(), caseSensitive);\n     }\n \n-    public static String[] matches(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        final List<String> ret = new ArrayList<String>(candidate.length);\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                ret.add(string);\n-            }\n+    public static WildcardMatcher from(String[] patterns, boolean caseSensitive) {\n+        if (patterns == null || patterns.length == 0) {\n+            return NONE;\n+        } else if (patterns.length == 1) {\n+            return from(patterns[0], caseSensitive);\n         }\n-\n-        return ret.toArray(new String[0]);\n+        return from(Arrays.stream(patterns), caseSensitive);\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Stream<String> patterns) {\n+        return from(patterns, true);\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Collection<?> patterns) {\n+        return from(patterns, true);\n     }\n \n+    public static WildcardMatcher from(String... patterns) {\n+        return from(patterns, true);\n+    }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n+    public WildcardMatcher concat(Stream<WildcardMatcher> matchers) {\n+        return new WildcardMatcher.MatcherCombiner(Stream.concat(matchers, Stream.of(this)).collect(ImmutableSet.toImmutableSet()));\n+    }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(Collection<WildcardMatcher> matchers) {\n+        if (matchers.isEmpty()) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(matchers.stream());\n     }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(candidates.size());\n-\n-        for (String string: candidates) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(WildcardMatcher... matchers) {\n+        if (matchers.length == 0) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(Arrays.stream(matchers));\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final Collection<String> candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.size());\n-\n-        for (final String string: candidate) {\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAny(Stream<String> candidates) {\n+        return candidates.anyMatch(this);\n+    }\n \n-        return matches;\n+    public boolean matchAny(Collection<String> candidates) {\n+        return matchAny(candidates.stream());\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final Collection<String> candidate) {\n+    public boolean matchAny(String[] candidates) {\n+        return matchAny(Arrays.stream(candidates));\n+    }\n \n-        final List<String> matches = new ArrayList<String>(candidate.size());\n+    public boolean matchAll(Stream<String> candidates) {\n+        return candidates.allMatch(this);\n+    }\n \n-        for (final String string: candidate) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAll(Collection<String> candidates) {\n+        return matchAll(candidates.stream());\n+    }\n \n-        return matches;\n+    public boolean matchAll(String[] candidates) {\n+        return matchAll(Arrays.stream(candidates));\n     }\n-    \n-    public static Optional<String> getFirstMatchingPattern(final Collection<String> pattern, final String candidate) {\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                return Optional.of(p);\n-            }\n-        }\n+    public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+        return candidates.filter(this).collect(collector);\n+    }\n \n-        return Optional.empty();\n+    public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(candidate.stream(), collector);\n     }\n \n+    public <T extends Collection<String>> T getMatchAny(final String[] candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(Arrays.stream(candidate), collector);\n+    }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final String candidate) {\n+    public Optional<WildcardMatcher> findFirst(final String candidate) {\n+        return Optional.ofNullable(test(candidate) ? this : null);\n+    }\n \n-        final List<String> matches = new ArrayList<String>(pattern.size());\n+    public static List<WildcardMatcher> matchers(Collection<String> patterns) {\n+        return patterns.stream().map(p -> WildcardMatcher.from(p, true))\n+                .collect(Collectors.toList());\n+    }\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                matches.add(p);\n+    public static boolean allMatches(final Collection<WildcardMatcher> matchers, final Collection<String> candidate) {\n+        int matchedPatternNum = 0;\n+        for (WildcardMatcher matcher : matchers) {\n+            if (matcher.matchAny(candidate)) {\n+                matchedPatternNum++;\n             }\n         }\n-\n-        return matches;\n+        return matchedPatternNum == matchers.size() && matchers.size() > 0;\n     }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(pattern.size());\n-\n-        for (String c : candidates) {\n-            matches.addAll(getAllMatchingPatterns(pattern, c));\n-        }\n-\n-        return matches;\n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> matchers, final String candidate) {\n+        return matchers.stream().filter(p -> p.test(candidate)).map(Objects::toString).collect(Collectors.toList());\n     }\n \n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> pattern, final Collection<String> candidates) {\n+        return pattern.stream().filter(p -> p.matchAny(candidates)).map(Objects::toString).collect(Collectors.toList());\n+    }\n \n     /**\n-     * returns true if the candidate matches at least one pattern\n      *\n-     * @param pattern\n-     * @param candidate\n+     * @param set of string to modify\n+     * @param matcher WildcardMatcher matcher to use to filter\n      * @return\n      */\n-    public static boolean matchAny(final String pattern[], final String candidate) {\n-\n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (match(string, candidate)) {\n-                return true;\n+    public static boolean WildcardMatcherRetainInSet(Set<String> set, WildcardMatcher matcher) {\n+        if(set == null || set.isEmpty()) {\n+            return false;\n+        }\n+        \n+        boolean modified = false;\n+        Iterator<String> it = set.iterator();\n+        while(it.hasNext()) {\n+            String v = it.next();\n+            if(!matcher.test(v)) {\n+                it.remove();\n+                modified = true;\n             }\n         }\n-\n-        return false;\n+        return modified;\n     }\n \n-    /**\n-     * returns true if the candidate matches at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String candidate) {\n \n-        for (String string: pattern) {\n-            if (match(string, candidate)) {\n-                return true;\n-            }\n-        }\n+    //\n+    // --- Implementation specializations ---\n+    //\n+    // Casefolding matcher - sits on top of case-sensitive matcher \n+    // and proxies toLower() of input string to the wrapped matcher\n+    private static final class CasefoldingMatcher extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final WildcardMatcher inner;\n \n-    public static boolean match(final String pattern, final String candidate) {\n-        return match(pattern, candidate, false);\n-    }\n+        public CasefoldingMatcher(String pattern, Function<String, WildcardMatcher> simpleWildcardMatcher) {\n+            this.inner = simpleWildcardMatcher.apply(pattern.toLowerCase());\n+        }\n \n-    public static boolean match(String pattern, String candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return inner.test(candidate.toLowerCase());\n+        }\n \n-        if (pattern == null || candidate == null) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            CasefoldingMatcher that = (CasefoldingMatcher) o;\n+            return inner.equals(that.inner);\n         }\n \n-        if(ignoreCase) {\n-            pattern = pattern.toLowerCase();\n-            candidate = candidate.toLowerCase();\n+        @Override\n+        public int hashCode() {\n+            return inner.hashCode();\n         }\n \n-        if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n-            // regex\n-            return Pattern.matches(\"^\"+pattern.substring(1, pattern.length() - 1)+\"$\", candidate);\n-        } else if (pattern.length() == 1 && pattern.charAt(0) == '*') {\n-            return true;\n-        } else if (pattern.indexOf('?') == NOT_FOUND && pattern.indexOf('*') == NOT_FOUND) {\n-            return pattern.equals(candidate);\n-        } else {\n-            return simpleWildcardMatch(pattern, candidate);\n+        @Override\n+        public String toString() {\n+            return inner.toString();\n         }\n     }\n \n-    public static boolean containsWildcard(final String pattern) {\n-        if (pattern != null\n-                && (pattern.indexOf(\"*\") > NOT_FOUND || pattern.indexOf(\"?\") > NOT_FOUND || (pattern.startsWith(\"/\") && pattern\n-                        .endsWith(\"/\")))) {\n-            return true;\n-        }\n+    public static final class Exact extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final String pattern;\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRemoveFromSet(Set<String> set, String stringContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        private Exact(String pattern) {\n+            this.pattern = pattern;\n         }\n-        if(!containsWildcard(stringContainingWc) && set.contains(stringContainingWc)) {\n-            return set.remove(stringContainingWc);\n-        } else {\n-            boolean modified = false;\n-            Set<String> copy = new HashSet<>(set);\n \n-            for(String it: copy) {\n-                if(WildcardMatcher.match(stringContainingWc, it)) {\n-                    modified = set.remove(it) || modified;\n-                }\n-            }\n-            return modified;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.equals(candidate);\n         }\n-    }\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRetainInSet(Set<String> set, String[] setContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Exact that = (Exact) o;\n+            return pattern.equals(that.pattern);\n         }\n-        boolean modified = false;\n-        Set<String> copy = new HashSet<>(set);\n \n-        for(String it: copy) {\n-            if(!WildcardMatcher.matchAny(setContainingWc, it)) {\n-                modified = set.remove(it) || modified;\n-            }\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n         }\n-        return modified;\n-    }\n \n+        @Override\n+        public String toString() {\n+            return pattern;\n+        }\n+    }\n \n-    //All code below is copied (and slightly modified) from Apache Commons IO\n+    // RegexMatcher uses JDK Pattern to test for matching,\n+    // assumes \"/<regex>/\" strings as input pattern\n+    private static final class RegexMatcher extends WildcardMatcher {\n \n-    /*\n-     * Licensed to the Apache Software Foundation (ASF) under one or more\n-     * contributor license agreements.  See the NOTICE file distributed with\n-     * this work for additional information regarding copyright ownership.\n-     * The ASF licenses this file to You under the Apache License, Version 2.0\n-     * (the \"License\"); you may not use this file except in compliance with\n-     * the License.  You may obtain a copy of the License at\n-     *\n-     *      http://www.apache.org/licenses/LICENSE-2.0\n-     *\n-     * Unless required by applicable law or agreed to in writing, software\n-     * distributed under the License is distributed on an \"AS IS\" BASIS,\n-     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-     * See the License for the specific language governing permissions and\n-     * limitations under the License.\n-     */\n+        private final Pattern pattern;\n \n+        private RegexMatcher(String pattern, boolean caseSensitive) {\n+            Preconditions.checkArgument(pattern.length() > 1 && pattern.startsWith(\"/\") && pattern.endsWith(\"/\"));\n+            final String stripSlashesPattern = pattern.substring(1, pattern.length() - 1);\n+            this.pattern = caseSensitive ? Pattern.compile(stripSlashesPattern) : Pattern.compile(stripSlashesPattern, Pattern.CASE_INSENSITIVE);\n+        }\n \n-    /**\n-     * Checks a filename to see if it matches the specified wildcard matcher\n-     * allowing control over case-sensitivity.\n-     * <p>\n-     * The wildcard matcher uses the characters '?' and '*' to represent a\n-     * single or multiple (zero or more) wildcard characters.\n-     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n-     *\n-     * @param candidate  the filename to match on\n-     * @param pattern  the wildcard string to match against\n-     * @return true if the filename matches the wilcard string\n-     * @since 1.3\n-     */\n-    private static boolean simpleWildcardMatch(final String pattern, final String candidate) {\n-        if (candidate == null && pattern == null) {\n-            return true;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.matcher(candidate).matches();\n         }\n-        if (candidate == null || pattern == null) {\n-            return false;\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            RegexMatcher that = (RegexMatcher) o;\n+            return pattern.pattern().equals(that.pattern.pattern());\n         }\n \n-        final String[] wcs = splitOnTokens(pattern);\n-        boolean anyChars = false;\n-        int textIdx = 0;\n-        int wcsIdx = 0;\n-        final Stack<int[]> backtrack = new Stack<>();\n+        @Override\n+        public int hashCode() {\n+            return pattern.pattern().hashCode();\n+        }\n \n-        // loop around a backtrack stack, to handle complex * matching\n-        do {\n-            if (backtrack.size() > 0) {\n-                final int[] array = backtrack.pop();\n-                wcsIdx = array[0];\n-                textIdx = array[1];\n-                anyChars = true;\n-            }\n+        @Override\n+        public String toString(){ return \"/\" + pattern.pattern() + \"/\"; }\n+    }\n \n-            // loop whilst tokens and text left to process\n-            while (wcsIdx < wcs.length) {\n+    // Simple implementation of WildcardMatcher matcher with * and ? without\n+    // using exlicit stack or recursion (as long as we don't need sub-matches it does work)\n+    // allows us to save on resources and heap allocations unless Regex is required\n+    private static final class SimpleMatcher extends WildcardMatcher {\n \n-                if (wcs[wcsIdx].equals(\"?\")) {\n-                    // ? so move to next text char\n-                    textIdx++;\n-                    if (textIdx > candidate.length()) {\n-                        break;\n-                    }\n-                    anyChars = false;\n+        private final String pattern;\n \n-                } else if (wcs[wcsIdx].equals(\"*\")) {\n-                    // set any chars status\n-                    anyChars = true;\n-                    if (wcsIdx == wcs.length - 1) {\n-                        textIdx = candidate.length();\n-                    }\n+        SimpleMatcher(String pattern) {\n+            this.pattern = pattern;\n+        }\n \n+        @Override\n+        public boolean test(String candidate) {\n+            int i = 0;\n+            int j = 0;\n+            int n = candidate.length();\n+            int m = pattern.length();\n+            int text_backup = -1;\n+            int wild_backup = -1;\n+            while (i < n) {\n+                if (j < m && pattern.charAt(j) == '*') {\n+                    text_backup = i;\n+                    wild_backup = ++j;\n+                } else if (j < m && (pattern.charAt(j) == '?' || pattern.charAt(j) == candidate.charAt(i))) {\n+                    i++;\n+                    j++;\n                 } else {\n-                    // matching text token\n-                    if (anyChars) {\n-                        // any chars then try to locate text token\n-                        textIdx = checkIndexOf(candidate, textIdx, wcs[wcsIdx]);\n-                        if (textIdx == NOT_FOUND) {\n-                            // token not found\n-                            break;\n-                        }\n-                        final int repeat = checkIndexOf(candidate, textIdx + 1, wcs[wcsIdx]);\n-                        if (repeat >= 0) {\n-                            backtrack.push(new int[] {wcsIdx, repeat});\n-                        }\n-                    } else {\n-                        // matching from current position\n-                        if (!checkRegionMatches(candidate, textIdx, wcs[wcsIdx])) {\n-                            // couldnt match token\n-                            break;\n-                        }\n-                    }\n-\n-                    // matched text token, move text index to end of matched token\n-                    textIdx += wcs[wcsIdx].length();\n-                    anyChars = false;\n+                    if (wild_backup == -1) return false;\n+                    i = ++text_backup;\n+                    j = wild_backup;\n                 }\n-\n-                wcsIdx++;\n             }\n+            while (j < m && pattern.charAt(j) == '*') j++;\n+            return j >= m;\n+        }\n \n-            // full match\n-            if (wcsIdx == wcs.length && textIdx == candidate.length()) {\n-                return true;\n-            }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            SimpleMatcher that = (SimpleMatcher) o;\n+            return pattern.equals(that.pattern);\n+        }\n \n-        } while (backtrack.size() > 0);\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n+        }\n \n-        return false;\n+        @Override\n+        public String toString(){ return pattern; }\n     }\n \n-    /**\n-     * Splits a string into a number of tokens.\n-     * The text is split by '?' and '*'.\n-     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n-     *\n-     * @param text  the text to split\n-     * @return the array of tokens, never null\n-     */\n-    private static String[] splitOnTokens(final String text) {\n-        // used by wildcardMatch\n-        // package level so a unit test may run on this\n-\n-        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n-            return new String[] { text };\n-        }\n-\n-        final char[] array = text.toCharArray();\n-        final ArrayList<String> list = new ArrayList<>();\n-        final StringBuilder buffer = new StringBuilder();\n-        char prevChar = 0;\n-        for (final char ch : array) {\n-            if (ch == '?' || ch == '*') {\n-                if (buffer.length() != 0) {\n-                    list.add(buffer.toString());\n-                    buffer.setLength(0);\n-                }\n-                if (ch == '?') {\n-                    list.add(\"?\");\n-                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n-                    list.add(\"*\");\n-                }\n-            } else {\n-                buffer.append(ch);\n-            }\n-            prevChar = ch;\n+    // MatcherCombiner is a combination of a set of matchers\n+    // matches if any of the set do\n+    // Empty MultiMatcher always returns false\n+    private static final class MatcherCombiner extends WildcardMatcher {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 907}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxMjQzMw==", "bodyText": "Where such matcher will be used?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427012433", "createdAt": "2020-05-19T03:41:22Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();\n+            if (t instanceof String) {\n+                return from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n         }\n-\n-        return false;\n+        return from(collection.stream(), caseSensitive);\n     }\n \n-    public static String[] matches(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        final List<String> ret = new ArrayList<String>(candidate.length);\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                ret.add(string);\n-            }\n+    public static WildcardMatcher from(String[] patterns, boolean caseSensitive) {\n+        if (patterns == null || patterns.length == 0) {\n+            return NONE;\n+        } else if (patterns.length == 1) {\n+            return from(patterns[0], caseSensitive);\n         }\n-\n-        return ret.toArray(new String[0]);\n+        return from(Arrays.stream(patterns), caseSensitive);\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Stream<String> patterns) {\n+        return from(patterns, true);\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Collection<?> patterns) {\n+        return from(patterns, true);\n     }\n \n+    public static WildcardMatcher from(String... patterns) {\n+        return from(patterns, true);\n+    }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n+    public WildcardMatcher concat(Stream<WildcardMatcher> matchers) {\n+        return new WildcardMatcher.MatcherCombiner(Stream.concat(matchers, Stream.of(this)).collect(ImmutableSet.toImmutableSet()));\n+    }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(Collection<WildcardMatcher> matchers) {\n+        if (matchers.isEmpty()) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(matchers.stream());\n     }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(candidates.size());\n-\n-        for (String string: candidates) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(WildcardMatcher... matchers) {\n+        if (matchers.length == 0) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(Arrays.stream(matchers));\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final Collection<String> candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.size());\n-\n-        for (final String string: candidate) {\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAny(Stream<String> candidates) {\n+        return candidates.anyMatch(this);\n+    }\n \n-        return matches;\n+    public boolean matchAny(Collection<String> candidates) {\n+        return matchAny(candidates.stream());\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final Collection<String> candidate) {\n+    public boolean matchAny(String[] candidates) {\n+        return matchAny(Arrays.stream(candidates));\n+    }\n \n-        final List<String> matches = new ArrayList<String>(candidate.size());\n+    public boolean matchAll(Stream<String> candidates) {\n+        return candidates.allMatch(this);\n+    }\n \n-        for (final String string: candidate) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAll(Collection<String> candidates) {\n+        return matchAll(candidates.stream());\n+    }\n \n-        return matches;\n+    public boolean matchAll(String[] candidates) {\n+        return matchAll(Arrays.stream(candidates));\n     }\n-    \n-    public static Optional<String> getFirstMatchingPattern(final Collection<String> pattern, final String candidate) {\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                return Optional.of(p);\n-            }\n-        }\n+    public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+        return candidates.filter(this).collect(collector);\n+    }\n \n-        return Optional.empty();\n+    public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(candidate.stream(), collector);\n     }\n \n+    public <T extends Collection<String>> T getMatchAny(final String[] candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(Arrays.stream(candidate), collector);\n+    }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final String candidate) {\n+    public Optional<WildcardMatcher> findFirst(final String candidate) {\n+        return Optional.ofNullable(test(candidate) ? this : null);\n+    }\n \n-        final List<String> matches = new ArrayList<String>(pattern.size());\n+    public static List<WildcardMatcher> matchers(Collection<String> patterns) {\n+        return patterns.stream().map(p -> WildcardMatcher.from(p, true))\n+                .collect(Collectors.toList());\n+    }\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                matches.add(p);\n+    public static boolean allMatches(final Collection<WildcardMatcher> matchers, final Collection<String> candidate) {\n+        int matchedPatternNum = 0;\n+        for (WildcardMatcher matcher : matchers) {\n+            if (matcher.matchAny(candidate)) {\n+                matchedPatternNum++;\n             }\n         }\n-\n-        return matches;\n+        return matchedPatternNum == matchers.size() && matchers.size() > 0;\n     }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(pattern.size());\n-\n-        for (String c : candidates) {\n-            matches.addAll(getAllMatchingPatterns(pattern, c));\n-        }\n-\n-        return matches;\n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> matchers, final String candidate) {\n+        return matchers.stream().filter(p -> p.test(candidate)).map(Objects::toString).collect(Collectors.toList());\n     }\n \n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> pattern, final Collection<String> candidates) {\n+        return pattern.stream().filter(p -> p.matchAny(candidates)).map(Objects::toString).collect(Collectors.toList());\n+    }\n \n     /**\n-     * returns true if the candidate matches at least one pattern\n      *\n-     * @param pattern\n-     * @param candidate\n+     * @param set of string to modify\n+     * @param matcher WildcardMatcher matcher to use to filter\n      * @return\n      */\n-    public static boolean matchAny(final String pattern[], final String candidate) {\n-\n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (match(string, candidate)) {\n-                return true;\n+    public static boolean WildcardMatcherRetainInSet(Set<String> set, WildcardMatcher matcher) {\n+        if(set == null || set.isEmpty()) {\n+            return false;\n+        }\n+        \n+        boolean modified = false;\n+        Iterator<String> it = set.iterator();\n+        while(it.hasNext()) {\n+            String v = it.next();\n+            if(!matcher.test(v)) {\n+                it.remove();\n+                modified = true;\n             }\n         }\n-\n-        return false;\n+        return modified;\n     }\n \n-    /**\n-     * returns true if the candidate matches at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String candidate) {\n \n-        for (String string: pattern) {\n-            if (match(string, candidate)) {\n-                return true;\n-            }\n-        }\n+    //\n+    // --- Implementation specializations ---\n+    //\n+    // Casefolding matcher - sits on top of case-sensitive matcher \n+    // and proxies toLower() of input string to the wrapped matcher\n+    private static final class CasefoldingMatcher extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final WildcardMatcher inner;\n \n-    public static boolean match(final String pattern, final String candidate) {\n-        return match(pattern, candidate, false);\n-    }\n+        public CasefoldingMatcher(String pattern, Function<String, WildcardMatcher> simpleWildcardMatcher) {\n+            this.inner = simpleWildcardMatcher.apply(pattern.toLowerCase());\n+        }\n \n-    public static boolean match(String pattern, String candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return inner.test(candidate.toLowerCase());\n+        }\n \n-        if (pattern == null || candidate == null) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            CasefoldingMatcher that = (CasefoldingMatcher) o;\n+            return inner.equals(that.inner);\n         }\n \n-        if(ignoreCase) {\n-            pattern = pattern.toLowerCase();\n-            candidate = candidate.toLowerCase();\n+        @Override\n+        public int hashCode() {\n+            return inner.hashCode();\n         }\n \n-        if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n-            // regex\n-            return Pattern.matches(\"^\"+pattern.substring(1, pattern.length() - 1)+\"$\", candidate);\n-        } else if (pattern.length() == 1 && pattern.charAt(0) == '*') {\n-            return true;\n-        } else if (pattern.indexOf('?') == NOT_FOUND && pattern.indexOf('*') == NOT_FOUND) {\n-            return pattern.equals(candidate);\n-        } else {\n-            return simpleWildcardMatch(pattern, candidate);\n+        @Override\n+        public String toString() {\n+            return inner.toString();\n         }\n     }\n \n-    public static boolean containsWildcard(final String pattern) {\n-        if (pattern != null\n-                && (pattern.indexOf(\"*\") > NOT_FOUND || pattern.indexOf(\"?\") > NOT_FOUND || (pattern.startsWith(\"/\") && pattern\n-                        .endsWith(\"/\")))) {\n-            return true;\n-        }\n+    public static final class Exact extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final String pattern;\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRemoveFromSet(Set<String> set, String stringContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        private Exact(String pattern) {\n+            this.pattern = pattern;\n         }\n-        if(!containsWildcard(stringContainingWc) && set.contains(stringContainingWc)) {\n-            return set.remove(stringContainingWc);\n-        } else {\n-            boolean modified = false;\n-            Set<String> copy = new HashSet<>(set);\n \n-            for(String it: copy) {\n-                if(WildcardMatcher.match(stringContainingWc, it)) {\n-                    modified = set.remove(it) || modified;\n-                }\n-            }\n-            return modified;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.equals(candidate);\n         }\n-    }\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRetainInSet(Set<String> set, String[] setContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Exact that = (Exact) o;\n+            return pattern.equals(that.pattern);\n         }\n-        boolean modified = false;\n-        Set<String> copy = new HashSet<>(set);\n \n-        for(String it: copy) {\n-            if(!WildcardMatcher.matchAny(setContainingWc, it)) {\n-                modified = set.remove(it) || modified;\n-            }\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n         }\n-        return modified;\n-    }\n \n+        @Override\n+        public String toString() {\n+            return pattern;\n+        }\n+    }\n \n-    //All code below is copied (and slightly modified) from Apache Commons IO\n+    // RegexMatcher uses JDK Pattern to test for matching,\n+    // assumes \"/<regex>/\" strings as input pattern\n+    private static final class RegexMatcher extends WildcardMatcher {\n \n-    /*\n-     * Licensed to the Apache Software Foundation (ASF) under one or more\n-     * contributor license agreements.  See the NOTICE file distributed with\n-     * this work for additional information regarding copyright ownership.\n-     * The ASF licenses this file to You under the Apache License, Version 2.0\n-     * (the \"License\"); you may not use this file except in compliance with\n-     * the License.  You may obtain a copy of the License at\n-     *\n-     *      http://www.apache.org/licenses/LICENSE-2.0\n-     *\n-     * Unless required by applicable law or agreed to in writing, software\n-     * distributed under the License is distributed on an \"AS IS\" BASIS,\n-     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-     * See the License for the specific language governing permissions and\n-     * limitations under the License.\n-     */\n+        private final Pattern pattern;\n \n+        private RegexMatcher(String pattern, boolean caseSensitive) {\n+            Preconditions.checkArgument(pattern.length() > 1 && pattern.startsWith(\"/\") && pattern.endsWith(\"/\"));\n+            final String stripSlashesPattern = pattern.substring(1, pattern.length() - 1);\n+            this.pattern = caseSensitive ? Pattern.compile(stripSlashesPattern) : Pattern.compile(stripSlashesPattern, Pattern.CASE_INSENSITIVE);\n+        }\n \n-    /**\n-     * Checks a filename to see if it matches the specified wildcard matcher\n-     * allowing control over case-sensitivity.\n-     * <p>\n-     * The wildcard matcher uses the characters '?' and '*' to represent a\n-     * single or multiple (zero or more) wildcard characters.\n-     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n-     *\n-     * @param candidate  the filename to match on\n-     * @param pattern  the wildcard string to match against\n-     * @return true if the filename matches the wilcard string\n-     * @since 1.3\n-     */\n-    private static boolean simpleWildcardMatch(final String pattern, final String candidate) {\n-        if (candidate == null && pattern == null) {\n-            return true;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.matcher(candidate).matches();\n         }\n-        if (candidate == null || pattern == null) {\n-            return false;\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            RegexMatcher that = (RegexMatcher) o;\n+            return pattern.pattern().equals(that.pattern.pattern());\n         }\n \n-        final String[] wcs = splitOnTokens(pattern);\n-        boolean anyChars = false;\n-        int textIdx = 0;\n-        int wcsIdx = 0;\n-        final Stack<int[]> backtrack = new Stack<>();\n+        @Override\n+        public int hashCode() {\n+            return pattern.pattern().hashCode();\n+        }\n \n-        // loop around a backtrack stack, to handle complex * matching\n-        do {\n-            if (backtrack.size() > 0) {\n-                final int[] array = backtrack.pop();\n-                wcsIdx = array[0];\n-                textIdx = array[1];\n-                anyChars = true;\n-            }\n+        @Override\n+        public String toString(){ return \"/\" + pattern.pattern() + \"/\"; }\n+    }\n \n-            // loop whilst tokens and text left to process\n-            while (wcsIdx < wcs.length) {\n+    // Simple implementation of WildcardMatcher matcher with * and ? without\n+    // using exlicit stack or recursion (as long as we don't need sub-matches it does work)\n+    // allows us to save on resources and heap allocations unless Regex is required\n+    private static final class SimpleMatcher extends WildcardMatcher {\n \n-                if (wcs[wcsIdx].equals(\"?\")) {\n-                    // ? so move to next text char\n-                    textIdx++;\n-                    if (textIdx > candidate.length()) {\n-                        break;\n-                    }\n-                    anyChars = false;\n+        private final String pattern;\n \n-                } else if (wcs[wcsIdx].equals(\"*\")) {\n-                    // set any chars status\n-                    anyChars = true;\n-                    if (wcsIdx == wcs.length - 1) {\n-                        textIdx = candidate.length();\n-                    }\n+        SimpleMatcher(String pattern) {\n+            this.pattern = pattern;\n+        }\n \n+        @Override\n+        public boolean test(String candidate) {\n+            int i = 0;\n+            int j = 0;\n+            int n = candidate.length();\n+            int m = pattern.length();\n+            int text_backup = -1;\n+            int wild_backup = -1;\n+            while (i < n) {\n+                if (j < m && pattern.charAt(j) == '*') {\n+                    text_backup = i;\n+                    wild_backup = ++j;\n+                } else if (j < m && (pattern.charAt(j) == '?' || pattern.charAt(j) == candidate.charAt(i))) {\n+                    i++;\n+                    j++;\n                 } else {\n-                    // matching text token\n-                    if (anyChars) {\n-                        // any chars then try to locate text token\n-                        textIdx = checkIndexOf(candidate, textIdx, wcs[wcsIdx]);\n-                        if (textIdx == NOT_FOUND) {\n-                            // token not found\n-                            break;\n-                        }\n-                        final int repeat = checkIndexOf(candidate, textIdx + 1, wcs[wcsIdx]);\n-                        if (repeat >= 0) {\n-                            backtrack.push(new int[] {wcsIdx, repeat});\n-                        }\n-                    } else {\n-                        // matching from current position\n-                        if (!checkRegionMatches(candidate, textIdx, wcs[wcsIdx])) {\n-                            // couldnt match token\n-                            break;\n-                        }\n-                    }\n-\n-                    // matched text token, move text index to end of matched token\n-                    textIdx += wcs[wcsIdx].length();\n-                    anyChars = false;\n+                    if (wild_backup == -1) return false;\n+                    i = ++text_backup;\n+                    j = wild_backup;\n                 }\n-\n-                wcsIdx++;\n             }\n+            while (j < m && pattern.charAt(j) == '*') j++;\n+            return j >= m;\n+        }\n \n-            // full match\n-            if (wcsIdx == wcs.length && textIdx == candidate.length()) {\n-                return true;\n-            }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            SimpleMatcher that = (SimpleMatcher) o;\n+            return pattern.equals(that.pattern);\n+        }\n \n-        } while (backtrack.size() > 0);\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n+        }\n \n-        return false;\n+        @Override\n+        public String toString(){ return pattern; }\n     }\n \n-    /**\n-     * Splits a string into a number of tokens.\n-     * The text is split by '?' and '*'.\n-     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n-     *\n-     * @param text  the text to split\n-     * @return the array of tokens, never null\n-     */\n-    private static String[] splitOnTokens(final String text) {\n-        // used by wildcardMatch\n-        // package level so a unit test may run on this\n-\n-        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n-            return new String[] { text };\n-        }\n-\n-        final char[] array = text.toCharArray();\n-        final ArrayList<String> list = new ArrayList<>();\n-        final StringBuilder buffer = new StringBuilder();\n-        char prevChar = 0;\n-        for (final char ch : array) {\n-            if (ch == '?' || ch == '*') {\n-                if (buffer.length() != 0) {\n-                    list.add(buffer.toString());\n-                    buffer.setLength(0);\n-                }\n-                if (ch == '?') {\n-                    list.add(\"?\");\n-                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n-                    list.add(\"*\");\n-                }\n-            } else {\n-                buffer.append(ch);\n-            }\n-            prevChar = ch;\n+    // MatcherCombiner is a combination of a set of matchers\n+    // matches if any of the set do\n+    // Empty MultiMatcher always returns false\n+    private static final class MatcherCombiner extends WildcardMatcher {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzMTMzNA=="}, "originalCommit": null, "originalPosition": 907}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MTkwNg==", "bodyText": "Have seen matchAll mentioned here and here.", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427451906", "createdAt": "2020-05-19T16:51:54Z", "author": {"login": "debjanibnrj"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();\n+            if (t instanceof String) {\n+                return from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n         }\n-\n-        return false;\n+        return from(collection.stream(), caseSensitive);\n     }\n \n-    public static String[] matches(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        final List<String> ret = new ArrayList<String>(candidate.length);\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                ret.add(string);\n-            }\n+    public static WildcardMatcher from(String[] patterns, boolean caseSensitive) {\n+        if (patterns == null || patterns.length == 0) {\n+            return NONE;\n+        } else if (patterns.length == 1) {\n+            return from(patterns[0], caseSensitive);\n         }\n-\n-        return ret.toArray(new String[0]);\n+        return from(Arrays.stream(patterns), caseSensitive);\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Stream<String> patterns) {\n+        return from(patterns, true);\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Collection<?> patterns) {\n+        return from(patterns, true);\n     }\n \n+    public static WildcardMatcher from(String... patterns) {\n+        return from(patterns, true);\n+    }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n+    public WildcardMatcher concat(Stream<WildcardMatcher> matchers) {\n+        return new WildcardMatcher.MatcherCombiner(Stream.concat(matchers, Stream.of(this)).collect(ImmutableSet.toImmutableSet()));\n+    }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(Collection<WildcardMatcher> matchers) {\n+        if (matchers.isEmpty()) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(matchers.stream());\n     }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(candidates.size());\n-\n-        for (String string: candidates) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(WildcardMatcher... matchers) {\n+        if (matchers.length == 0) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(Arrays.stream(matchers));\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final Collection<String> candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.size());\n-\n-        for (final String string: candidate) {\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAny(Stream<String> candidates) {\n+        return candidates.anyMatch(this);\n+    }\n \n-        return matches;\n+    public boolean matchAny(Collection<String> candidates) {\n+        return matchAny(candidates.stream());\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final Collection<String> candidate) {\n+    public boolean matchAny(String[] candidates) {\n+        return matchAny(Arrays.stream(candidates));\n+    }\n \n-        final List<String> matches = new ArrayList<String>(candidate.size());\n+    public boolean matchAll(Stream<String> candidates) {\n+        return candidates.allMatch(this);\n+    }\n \n-        for (final String string: candidate) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAll(Collection<String> candidates) {\n+        return matchAll(candidates.stream());\n+    }\n \n-        return matches;\n+    public boolean matchAll(String[] candidates) {\n+        return matchAll(Arrays.stream(candidates));\n     }\n-    \n-    public static Optional<String> getFirstMatchingPattern(final Collection<String> pattern, final String candidate) {\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                return Optional.of(p);\n-            }\n-        }\n+    public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+        return candidates.filter(this).collect(collector);\n+    }\n \n-        return Optional.empty();\n+    public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(candidate.stream(), collector);\n     }\n \n+    public <T extends Collection<String>> T getMatchAny(final String[] candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(Arrays.stream(candidate), collector);\n+    }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final String candidate) {\n+    public Optional<WildcardMatcher> findFirst(final String candidate) {\n+        return Optional.ofNullable(test(candidate) ? this : null);\n+    }\n \n-        final List<String> matches = new ArrayList<String>(pattern.size());\n+    public static List<WildcardMatcher> matchers(Collection<String> patterns) {\n+        return patterns.stream().map(p -> WildcardMatcher.from(p, true))\n+                .collect(Collectors.toList());\n+    }\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                matches.add(p);\n+    public static boolean allMatches(final Collection<WildcardMatcher> matchers, final Collection<String> candidate) {\n+        int matchedPatternNum = 0;\n+        for (WildcardMatcher matcher : matchers) {\n+            if (matcher.matchAny(candidate)) {\n+                matchedPatternNum++;\n             }\n         }\n-\n-        return matches;\n+        return matchedPatternNum == matchers.size() && matchers.size() > 0;\n     }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(pattern.size());\n-\n-        for (String c : candidates) {\n-            matches.addAll(getAllMatchingPatterns(pattern, c));\n-        }\n-\n-        return matches;\n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> matchers, final String candidate) {\n+        return matchers.stream().filter(p -> p.test(candidate)).map(Objects::toString).collect(Collectors.toList());\n     }\n \n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> pattern, final Collection<String> candidates) {\n+        return pattern.stream().filter(p -> p.matchAny(candidates)).map(Objects::toString).collect(Collectors.toList());\n+    }\n \n     /**\n-     * returns true if the candidate matches at least one pattern\n      *\n-     * @param pattern\n-     * @param candidate\n+     * @param set of string to modify\n+     * @param matcher WildcardMatcher matcher to use to filter\n      * @return\n      */\n-    public static boolean matchAny(final String pattern[], final String candidate) {\n-\n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (match(string, candidate)) {\n-                return true;\n+    public static boolean WildcardMatcherRetainInSet(Set<String> set, WildcardMatcher matcher) {\n+        if(set == null || set.isEmpty()) {\n+            return false;\n+        }\n+        \n+        boolean modified = false;\n+        Iterator<String> it = set.iterator();\n+        while(it.hasNext()) {\n+            String v = it.next();\n+            if(!matcher.test(v)) {\n+                it.remove();\n+                modified = true;\n             }\n         }\n-\n-        return false;\n+        return modified;\n     }\n \n-    /**\n-     * returns true if the candidate matches at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String candidate) {\n \n-        for (String string: pattern) {\n-            if (match(string, candidate)) {\n-                return true;\n-            }\n-        }\n+    //\n+    // --- Implementation specializations ---\n+    //\n+    // Casefolding matcher - sits on top of case-sensitive matcher \n+    // and proxies toLower() of input string to the wrapped matcher\n+    private static final class CasefoldingMatcher extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final WildcardMatcher inner;\n \n-    public static boolean match(final String pattern, final String candidate) {\n-        return match(pattern, candidate, false);\n-    }\n+        public CasefoldingMatcher(String pattern, Function<String, WildcardMatcher> simpleWildcardMatcher) {\n+            this.inner = simpleWildcardMatcher.apply(pattern.toLowerCase());\n+        }\n \n-    public static boolean match(String pattern, String candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return inner.test(candidate.toLowerCase());\n+        }\n \n-        if (pattern == null || candidate == null) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            CasefoldingMatcher that = (CasefoldingMatcher) o;\n+            return inner.equals(that.inner);\n         }\n \n-        if(ignoreCase) {\n-            pattern = pattern.toLowerCase();\n-            candidate = candidate.toLowerCase();\n+        @Override\n+        public int hashCode() {\n+            return inner.hashCode();\n         }\n \n-        if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n-            // regex\n-            return Pattern.matches(\"^\"+pattern.substring(1, pattern.length() - 1)+\"$\", candidate);\n-        } else if (pattern.length() == 1 && pattern.charAt(0) == '*') {\n-            return true;\n-        } else if (pattern.indexOf('?') == NOT_FOUND && pattern.indexOf('*') == NOT_FOUND) {\n-            return pattern.equals(candidate);\n-        } else {\n-            return simpleWildcardMatch(pattern, candidate);\n+        @Override\n+        public String toString() {\n+            return inner.toString();\n         }\n     }\n \n-    public static boolean containsWildcard(final String pattern) {\n-        if (pattern != null\n-                && (pattern.indexOf(\"*\") > NOT_FOUND || pattern.indexOf(\"?\") > NOT_FOUND || (pattern.startsWith(\"/\") && pattern\n-                        .endsWith(\"/\")))) {\n-            return true;\n-        }\n+    public static final class Exact extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final String pattern;\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRemoveFromSet(Set<String> set, String stringContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        private Exact(String pattern) {\n+            this.pattern = pattern;\n         }\n-        if(!containsWildcard(stringContainingWc) && set.contains(stringContainingWc)) {\n-            return set.remove(stringContainingWc);\n-        } else {\n-            boolean modified = false;\n-            Set<String> copy = new HashSet<>(set);\n \n-            for(String it: copy) {\n-                if(WildcardMatcher.match(stringContainingWc, it)) {\n-                    modified = set.remove(it) || modified;\n-                }\n-            }\n-            return modified;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.equals(candidate);\n         }\n-    }\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRetainInSet(Set<String> set, String[] setContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Exact that = (Exact) o;\n+            return pattern.equals(that.pattern);\n         }\n-        boolean modified = false;\n-        Set<String> copy = new HashSet<>(set);\n \n-        for(String it: copy) {\n-            if(!WildcardMatcher.matchAny(setContainingWc, it)) {\n-                modified = set.remove(it) || modified;\n-            }\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n         }\n-        return modified;\n-    }\n \n+        @Override\n+        public String toString() {\n+            return pattern;\n+        }\n+    }\n \n-    //All code below is copied (and slightly modified) from Apache Commons IO\n+    // RegexMatcher uses JDK Pattern to test for matching,\n+    // assumes \"/<regex>/\" strings as input pattern\n+    private static final class RegexMatcher extends WildcardMatcher {\n \n-    /*\n-     * Licensed to the Apache Software Foundation (ASF) under one or more\n-     * contributor license agreements.  See the NOTICE file distributed with\n-     * this work for additional information regarding copyright ownership.\n-     * The ASF licenses this file to You under the Apache License, Version 2.0\n-     * (the \"License\"); you may not use this file except in compliance with\n-     * the License.  You may obtain a copy of the License at\n-     *\n-     *      http://www.apache.org/licenses/LICENSE-2.0\n-     *\n-     * Unless required by applicable law or agreed to in writing, software\n-     * distributed under the License is distributed on an \"AS IS\" BASIS,\n-     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-     * See the License for the specific language governing permissions and\n-     * limitations under the License.\n-     */\n+        private final Pattern pattern;\n \n+        private RegexMatcher(String pattern, boolean caseSensitive) {\n+            Preconditions.checkArgument(pattern.length() > 1 && pattern.startsWith(\"/\") && pattern.endsWith(\"/\"));\n+            final String stripSlashesPattern = pattern.substring(1, pattern.length() - 1);\n+            this.pattern = caseSensitive ? Pattern.compile(stripSlashesPattern) : Pattern.compile(stripSlashesPattern, Pattern.CASE_INSENSITIVE);\n+        }\n \n-    /**\n-     * Checks a filename to see if it matches the specified wildcard matcher\n-     * allowing control over case-sensitivity.\n-     * <p>\n-     * The wildcard matcher uses the characters '?' and '*' to represent a\n-     * single or multiple (zero or more) wildcard characters.\n-     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n-     *\n-     * @param candidate  the filename to match on\n-     * @param pattern  the wildcard string to match against\n-     * @return true if the filename matches the wilcard string\n-     * @since 1.3\n-     */\n-    private static boolean simpleWildcardMatch(final String pattern, final String candidate) {\n-        if (candidate == null && pattern == null) {\n-            return true;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.matcher(candidate).matches();\n         }\n-        if (candidate == null || pattern == null) {\n-            return false;\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            RegexMatcher that = (RegexMatcher) o;\n+            return pattern.pattern().equals(that.pattern.pattern());\n         }\n \n-        final String[] wcs = splitOnTokens(pattern);\n-        boolean anyChars = false;\n-        int textIdx = 0;\n-        int wcsIdx = 0;\n-        final Stack<int[]> backtrack = new Stack<>();\n+        @Override\n+        public int hashCode() {\n+            return pattern.pattern().hashCode();\n+        }\n \n-        // loop around a backtrack stack, to handle complex * matching\n-        do {\n-            if (backtrack.size() > 0) {\n-                final int[] array = backtrack.pop();\n-                wcsIdx = array[0];\n-                textIdx = array[1];\n-                anyChars = true;\n-            }\n+        @Override\n+        public String toString(){ return \"/\" + pattern.pattern() + \"/\"; }\n+    }\n \n-            // loop whilst tokens and text left to process\n-            while (wcsIdx < wcs.length) {\n+    // Simple implementation of WildcardMatcher matcher with * and ? without\n+    // using exlicit stack or recursion (as long as we don't need sub-matches it does work)\n+    // allows us to save on resources and heap allocations unless Regex is required\n+    private static final class SimpleMatcher extends WildcardMatcher {\n \n-                if (wcs[wcsIdx].equals(\"?\")) {\n-                    // ? so move to next text char\n-                    textIdx++;\n-                    if (textIdx > candidate.length()) {\n-                        break;\n-                    }\n-                    anyChars = false;\n+        private final String pattern;\n \n-                } else if (wcs[wcsIdx].equals(\"*\")) {\n-                    // set any chars status\n-                    anyChars = true;\n-                    if (wcsIdx == wcs.length - 1) {\n-                        textIdx = candidate.length();\n-                    }\n+        SimpleMatcher(String pattern) {\n+            this.pattern = pattern;\n+        }\n \n+        @Override\n+        public boolean test(String candidate) {\n+            int i = 0;\n+            int j = 0;\n+            int n = candidate.length();\n+            int m = pattern.length();\n+            int text_backup = -1;\n+            int wild_backup = -1;\n+            while (i < n) {\n+                if (j < m && pattern.charAt(j) == '*') {\n+                    text_backup = i;\n+                    wild_backup = ++j;\n+                } else if (j < m && (pattern.charAt(j) == '?' || pattern.charAt(j) == candidate.charAt(i))) {\n+                    i++;\n+                    j++;\n                 } else {\n-                    // matching text token\n-                    if (anyChars) {\n-                        // any chars then try to locate text token\n-                        textIdx = checkIndexOf(candidate, textIdx, wcs[wcsIdx]);\n-                        if (textIdx == NOT_FOUND) {\n-                            // token not found\n-                            break;\n-                        }\n-                        final int repeat = checkIndexOf(candidate, textIdx + 1, wcs[wcsIdx]);\n-                        if (repeat >= 0) {\n-                            backtrack.push(new int[] {wcsIdx, repeat});\n-                        }\n-                    } else {\n-                        // matching from current position\n-                        if (!checkRegionMatches(candidate, textIdx, wcs[wcsIdx])) {\n-                            // couldnt match token\n-                            break;\n-                        }\n-                    }\n-\n-                    // matched text token, move text index to end of matched token\n-                    textIdx += wcs[wcsIdx].length();\n-                    anyChars = false;\n+                    if (wild_backup == -1) return false;\n+                    i = ++text_backup;\n+                    j = wild_backup;\n                 }\n-\n-                wcsIdx++;\n             }\n+            while (j < m && pattern.charAt(j) == '*') j++;\n+            return j >= m;\n+        }\n \n-            // full match\n-            if (wcsIdx == wcs.length && textIdx == candidate.length()) {\n-                return true;\n-            }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            SimpleMatcher that = (SimpleMatcher) o;\n+            return pattern.equals(that.pattern);\n+        }\n \n-        } while (backtrack.size() > 0);\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n+        }\n \n-        return false;\n+        @Override\n+        public String toString(){ return pattern; }\n     }\n \n-    /**\n-     * Splits a string into a number of tokens.\n-     * The text is split by '?' and '*'.\n-     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n-     *\n-     * @param text  the text to split\n-     * @return the array of tokens, never null\n-     */\n-    private static String[] splitOnTokens(final String text) {\n-        // used by wildcardMatch\n-        // package level so a unit test may run on this\n-\n-        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n-            return new String[] { text };\n-        }\n-\n-        final char[] array = text.toCharArray();\n-        final ArrayList<String> list = new ArrayList<>();\n-        final StringBuilder buffer = new StringBuilder();\n-        char prevChar = 0;\n-        for (final char ch : array) {\n-            if (ch == '?' || ch == '*') {\n-                if (buffer.length() != 0) {\n-                    list.add(buffer.toString());\n-                    buffer.setLength(0);\n-                }\n-                if (ch == '?') {\n-                    list.add(\"?\");\n-                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n-                    list.add(\"*\");\n-                }\n-            } else {\n-                buffer.append(ch);\n-            }\n-            prevChar = ch;\n+    // MatcherCombiner is a combination of a set of matchers\n+    // matches if any of the set do\n+    // Empty MultiMatcher always returns false\n+    private static final class MatcherCombiner extends WildcardMatcher {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzMTMzNA=="}, "originalCommit": null, "originalPosition": 907}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4MjQ1Nw==", "bodyText": "It is a different matchAll. It is true if all candidates matches a pattern or patterns in case of MatcherCombiner, compared to a candidate matching all patterns or matching any pattern.", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427582457", "createdAt": "2020-05-19T20:33:37Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();\n+            if (t instanceof String) {\n+                return from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n         }\n-\n-        return false;\n+        return from(collection.stream(), caseSensitive);\n     }\n \n-    public static String[] matches(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        final List<String> ret = new ArrayList<String>(candidate.length);\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                ret.add(string);\n-            }\n+    public static WildcardMatcher from(String[] patterns, boolean caseSensitive) {\n+        if (patterns == null || patterns.length == 0) {\n+            return NONE;\n+        } else if (patterns.length == 1) {\n+            return from(patterns[0], caseSensitive);\n         }\n-\n-        return ret.toArray(new String[0]);\n+        return from(Arrays.stream(patterns), caseSensitive);\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Stream<String> patterns) {\n+        return from(patterns, true);\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Collection<?> patterns) {\n+        return from(patterns, true);\n     }\n \n+    public static WildcardMatcher from(String... patterns) {\n+        return from(patterns, true);\n+    }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n+    public WildcardMatcher concat(Stream<WildcardMatcher> matchers) {\n+        return new WildcardMatcher.MatcherCombiner(Stream.concat(matchers, Stream.of(this)).collect(ImmutableSet.toImmutableSet()));\n+    }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(Collection<WildcardMatcher> matchers) {\n+        if (matchers.isEmpty()) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(matchers.stream());\n     }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(candidates.size());\n-\n-        for (String string: candidates) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(WildcardMatcher... matchers) {\n+        if (matchers.length == 0) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(Arrays.stream(matchers));\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final Collection<String> candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.size());\n-\n-        for (final String string: candidate) {\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAny(Stream<String> candidates) {\n+        return candidates.anyMatch(this);\n+    }\n \n-        return matches;\n+    public boolean matchAny(Collection<String> candidates) {\n+        return matchAny(candidates.stream());\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final Collection<String> candidate) {\n+    public boolean matchAny(String[] candidates) {\n+        return matchAny(Arrays.stream(candidates));\n+    }\n \n-        final List<String> matches = new ArrayList<String>(candidate.size());\n+    public boolean matchAll(Stream<String> candidates) {\n+        return candidates.allMatch(this);\n+    }\n \n-        for (final String string: candidate) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAll(Collection<String> candidates) {\n+        return matchAll(candidates.stream());\n+    }\n \n-        return matches;\n+    public boolean matchAll(String[] candidates) {\n+        return matchAll(Arrays.stream(candidates));\n     }\n-    \n-    public static Optional<String> getFirstMatchingPattern(final Collection<String> pattern, final String candidate) {\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                return Optional.of(p);\n-            }\n-        }\n+    public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+        return candidates.filter(this).collect(collector);\n+    }\n \n-        return Optional.empty();\n+    public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(candidate.stream(), collector);\n     }\n \n+    public <T extends Collection<String>> T getMatchAny(final String[] candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(Arrays.stream(candidate), collector);\n+    }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final String candidate) {\n+    public Optional<WildcardMatcher> findFirst(final String candidate) {\n+        return Optional.ofNullable(test(candidate) ? this : null);\n+    }\n \n-        final List<String> matches = new ArrayList<String>(pattern.size());\n+    public static List<WildcardMatcher> matchers(Collection<String> patterns) {\n+        return patterns.stream().map(p -> WildcardMatcher.from(p, true))\n+                .collect(Collectors.toList());\n+    }\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                matches.add(p);\n+    public static boolean allMatches(final Collection<WildcardMatcher> matchers, final Collection<String> candidate) {\n+        int matchedPatternNum = 0;\n+        for (WildcardMatcher matcher : matchers) {\n+            if (matcher.matchAny(candidate)) {\n+                matchedPatternNum++;\n             }\n         }\n-\n-        return matches;\n+        return matchedPatternNum == matchers.size() && matchers.size() > 0;\n     }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(pattern.size());\n-\n-        for (String c : candidates) {\n-            matches.addAll(getAllMatchingPatterns(pattern, c));\n-        }\n-\n-        return matches;\n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> matchers, final String candidate) {\n+        return matchers.stream().filter(p -> p.test(candidate)).map(Objects::toString).collect(Collectors.toList());\n     }\n \n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> pattern, final Collection<String> candidates) {\n+        return pattern.stream().filter(p -> p.matchAny(candidates)).map(Objects::toString).collect(Collectors.toList());\n+    }\n \n     /**\n-     * returns true if the candidate matches at least one pattern\n      *\n-     * @param pattern\n-     * @param candidate\n+     * @param set of string to modify\n+     * @param matcher WildcardMatcher matcher to use to filter\n      * @return\n      */\n-    public static boolean matchAny(final String pattern[], final String candidate) {\n-\n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (match(string, candidate)) {\n-                return true;\n+    public static boolean WildcardMatcherRetainInSet(Set<String> set, WildcardMatcher matcher) {\n+        if(set == null || set.isEmpty()) {\n+            return false;\n+        }\n+        \n+        boolean modified = false;\n+        Iterator<String> it = set.iterator();\n+        while(it.hasNext()) {\n+            String v = it.next();\n+            if(!matcher.test(v)) {\n+                it.remove();\n+                modified = true;\n             }\n         }\n-\n-        return false;\n+        return modified;\n     }\n \n-    /**\n-     * returns true if the candidate matches at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String candidate) {\n \n-        for (String string: pattern) {\n-            if (match(string, candidate)) {\n-                return true;\n-            }\n-        }\n+    //\n+    // --- Implementation specializations ---\n+    //\n+    // Casefolding matcher - sits on top of case-sensitive matcher \n+    // and proxies toLower() of input string to the wrapped matcher\n+    private static final class CasefoldingMatcher extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final WildcardMatcher inner;\n \n-    public static boolean match(final String pattern, final String candidate) {\n-        return match(pattern, candidate, false);\n-    }\n+        public CasefoldingMatcher(String pattern, Function<String, WildcardMatcher> simpleWildcardMatcher) {\n+            this.inner = simpleWildcardMatcher.apply(pattern.toLowerCase());\n+        }\n \n-    public static boolean match(String pattern, String candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return inner.test(candidate.toLowerCase());\n+        }\n \n-        if (pattern == null || candidate == null) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            CasefoldingMatcher that = (CasefoldingMatcher) o;\n+            return inner.equals(that.inner);\n         }\n \n-        if(ignoreCase) {\n-            pattern = pattern.toLowerCase();\n-            candidate = candidate.toLowerCase();\n+        @Override\n+        public int hashCode() {\n+            return inner.hashCode();\n         }\n \n-        if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n-            // regex\n-            return Pattern.matches(\"^\"+pattern.substring(1, pattern.length() - 1)+\"$\", candidate);\n-        } else if (pattern.length() == 1 && pattern.charAt(0) == '*') {\n-            return true;\n-        } else if (pattern.indexOf('?') == NOT_FOUND && pattern.indexOf('*') == NOT_FOUND) {\n-            return pattern.equals(candidate);\n-        } else {\n-            return simpleWildcardMatch(pattern, candidate);\n+        @Override\n+        public String toString() {\n+            return inner.toString();\n         }\n     }\n \n-    public static boolean containsWildcard(final String pattern) {\n-        if (pattern != null\n-                && (pattern.indexOf(\"*\") > NOT_FOUND || pattern.indexOf(\"?\") > NOT_FOUND || (pattern.startsWith(\"/\") && pattern\n-                        .endsWith(\"/\")))) {\n-            return true;\n-        }\n+    public static final class Exact extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final String pattern;\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRemoveFromSet(Set<String> set, String stringContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        private Exact(String pattern) {\n+            this.pattern = pattern;\n         }\n-        if(!containsWildcard(stringContainingWc) && set.contains(stringContainingWc)) {\n-            return set.remove(stringContainingWc);\n-        } else {\n-            boolean modified = false;\n-            Set<String> copy = new HashSet<>(set);\n \n-            for(String it: copy) {\n-                if(WildcardMatcher.match(stringContainingWc, it)) {\n-                    modified = set.remove(it) || modified;\n-                }\n-            }\n-            return modified;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.equals(candidate);\n         }\n-    }\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRetainInSet(Set<String> set, String[] setContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Exact that = (Exact) o;\n+            return pattern.equals(that.pattern);\n         }\n-        boolean modified = false;\n-        Set<String> copy = new HashSet<>(set);\n \n-        for(String it: copy) {\n-            if(!WildcardMatcher.matchAny(setContainingWc, it)) {\n-                modified = set.remove(it) || modified;\n-            }\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n         }\n-        return modified;\n-    }\n \n+        @Override\n+        public String toString() {\n+            return pattern;\n+        }\n+    }\n \n-    //All code below is copied (and slightly modified) from Apache Commons IO\n+    // RegexMatcher uses JDK Pattern to test for matching,\n+    // assumes \"/<regex>/\" strings as input pattern\n+    private static final class RegexMatcher extends WildcardMatcher {\n \n-    /*\n-     * Licensed to the Apache Software Foundation (ASF) under one or more\n-     * contributor license agreements.  See the NOTICE file distributed with\n-     * this work for additional information regarding copyright ownership.\n-     * The ASF licenses this file to You under the Apache License, Version 2.0\n-     * (the \"License\"); you may not use this file except in compliance with\n-     * the License.  You may obtain a copy of the License at\n-     *\n-     *      http://www.apache.org/licenses/LICENSE-2.0\n-     *\n-     * Unless required by applicable law or agreed to in writing, software\n-     * distributed under the License is distributed on an \"AS IS\" BASIS,\n-     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-     * See the License for the specific language governing permissions and\n-     * limitations under the License.\n-     */\n+        private final Pattern pattern;\n \n+        private RegexMatcher(String pattern, boolean caseSensitive) {\n+            Preconditions.checkArgument(pattern.length() > 1 && pattern.startsWith(\"/\") && pattern.endsWith(\"/\"));\n+            final String stripSlashesPattern = pattern.substring(1, pattern.length() - 1);\n+            this.pattern = caseSensitive ? Pattern.compile(stripSlashesPattern) : Pattern.compile(stripSlashesPattern, Pattern.CASE_INSENSITIVE);\n+        }\n \n-    /**\n-     * Checks a filename to see if it matches the specified wildcard matcher\n-     * allowing control over case-sensitivity.\n-     * <p>\n-     * The wildcard matcher uses the characters '?' and '*' to represent a\n-     * single or multiple (zero or more) wildcard characters.\n-     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n-     *\n-     * @param candidate  the filename to match on\n-     * @param pattern  the wildcard string to match against\n-     * @return true if the filename matches the wilcard string\n-     * @since 1.3\n-     */\n-    private static boolean simpleWildcardMatch(final String pattern, final String candidate) {\n-        if (candidate == null && pattern == null) {\n-            return true;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.matcher(candidate).matches();\n         }\n-        if (candidate == null || pattern == null) {\n-            return false;\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            RegexMatcher that = (RegexMatcher) o;\n+            return pattern.pattern().equals(that.pattern.pattern());\n         }\n \n-        final String[] wcs = splitOnTokens(pattern);\n-        boolean anyChars = false;\n-        int textIdx = 0;\n-        int wcsIdx = 0;\n-        final Stack<int[]> backtrack = new Stack<>();\n+        @Override\n+        public int hashCode() {\n+            return pattern.pattern().hashCode();\n+        }\n \n-        // loop around a backtrack stack, to handle complex * matching\n-        do {\n-            if (backtrack.size() > 0) {\n-                final int[] array = backtrack.pop();\n-                wcsIdx = array[0];\n-                textIdx = array[1];\n-                anyChars = true;\n-            }\n+        @Override\n+        public String toString(){ return \"/\" + pattern.pattern() + \"/\"; }\n+    }\n \n-            // loop whilst tokens and text left to process\n-            while (wcsIdx < wcs.length) {\n+    // Simple implementation of WildcardMatcher matcher with * and ? without\n+    // using exlicit stack or recursion (as long as we don't need sub-matches it does work)\n+    // allows us to save on resources and heap allocations unless Regex is required\n+    private static final class SimpleMatcher extends WildcardMatcher {\n \n-                if (wcs[wcsIdx].equals(\"?\")) {\n-                    // ? so move to next text char\n-                    textIdx++;\n-                    if (textIdx > candidate.length()) {\n-                        break;\n-                    }\n-                    anyChars = false;\n+        private final String pattern;\n \n-                } else if (wcs[wcsIdx].equals(\"*\")) {\n-                    // set any chars status\n-                    anyChars = true;\n-                    if (wcsIdx == wcs.length - 1) {\n-                        textIdx = candidate.length();\n-                    }\n+        SimpleMatcher(String pattern) {\n+            this.pattern = pattern;\n+        }\n \n+        @Override\n+        public boolean test(String candidate) {\n+            int i = 0;\n+            int j = 0;\n+            int n = candidate.length();\n+            int m = pattern.length();\n+            int text_backup = -1;\n+            int wild_backup = -1;\n+            while (i < n) {\n+                if (j < m && pattern.charAt(j) == '*') {\n+                    text_backup = i;\n+                    wild_backup = ++j;\n+                } else if (j < m && (pattern.charAt(j) == '?' || pattern.charAt(j) == candidate.charAt(i))) {\n+                    i++;\n+                    j++;\n                 } else {\n-                    // matching text token\n-                    if (anyChars) {\n-                        // any chars then try to locate text token\n-                        textIdx = checkIndexOf(candidate, textIdx, wcs[wcsIdx]);\n-                        if (textIdx == NOT_FOUND) {\n-                            // token not found\n-                            break;\n-                        }\n-                        final int repeat = checkIndexOf(candidate, textIdx + 1, wcs[wcsIdx]);\n-                        if (repeat >= 0) {\n-                            backtrack.push(new int[] {wcsIdx, repeat});\n-                        }\n-                    } else {\n-                        // matching from current position\n-                        if (!checkRegionMatches(candidate, textIdx, wcs[wcsIdx])) {\n-                            // couldnt match token\n-                            break;\n-                        }\n-                    }\n-\n-                    // matched text token, move text index to end of matched token\n-                    textIdx += wcs[wcsIdx].length();\n-                    anyChars = false;\n+                    if (wild_backup == -1) return false;\n+                    i = ++text_backup;\n+                    j = wild_backup;\n                 }\n-\n-                wcsIdx++;\n             }\n+            while (j < m && pattern.charAt(j) == '*') j++;\n+            return j >= m;\n+        }\n \n-            // full match\n-            if (wcsIdx == wcs.length && textIdx == candidate.length()) {\n-                return true;\n-            }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            SimpleMatcher that = (SimpleMatcher) o;\n+            return pattern.equals(that.pattern);\n+        }\n \n-        } while (backtrack.size() > 0);\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n+        }\n \n-        return false;\n+        @Override\n+        public String toString(){ return pattern; }\n     }\n \n-    /**\n-     * Splits a string into a number of tokens.\n-     * The text is split by '?' and '*'.\n-     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n-     *\n-     * @param text  the text to split\n-     * @return the array of tokens, never null\n-     */\n-    private static String[] splitOnTokens(final String text) {\n-        // used by wildcardMatch\n-        // package level so a unit test may run on this\n-\n-        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n-            return new String[] { text };\n-        }\n-\n-        final char[] array = text.toCharArray();\n-        final ArrayList<String> list = new ArrayList<>();\n-        final StringBuilder buffer = new StringBuilder();\n-        char prevChar = 0;\n-        for (final char ch : array) {\n-            if (ch == '?' || ch == '*') {\n-                if (buffer.length() != 0) {\n-                    list.add(buffer.toString());\n-                    buffer.setLength(0);\n-                }\n-                if (ch == '?') {\n-                    list.add(\"?\");\n-                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n-                    list.add(\"*\");\n-                }\n-            } else {\n-                buffer.append(ch);\n-            }\n-            prevChar = ch;\n+    // MatcherCombiner is a combination of a set of matchers\n+    // matches if any of the set do\n+    // Empty MultiMatcher always returns false\n+    private static final class MatcherCombiner extends WildcardMatcher {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzMTMzNA=="}, "originalCommit": null, "originalPosition": 907}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4ODcwNQ==", "bodyText": "Thanks for the clarification.", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427588705", "createdAt": "2020-05-19T20:45:13Z", "author": {"login": "debjanibnrj"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();\n+            if (t instanceof String) {\n+                return from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n         }\n-\n-        return false;\n+        return from(collection.stream(), caseSensitive);\n     }\n \n-    public static String[] matches(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        final List<String> ret = new ArrayList<String>(candidate.length);\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                ret.add(string);\n-            }\n+    public static WildcardMatcher from(String[] patterns, boolean caseSensitive) {\n+        if (patterns == null || patterns.length == 0) {\n+            return NONE;\n+        } else if (patterns.length == 1) {\n+            return from(patterns[0], caseSensitive);\n         }\n-\n-        return ret.toArray(new String[0]);\n+        return from(Arrays.stream(patterns), caseSensitive);\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Stream<String> patterns) {\n+        return from(patterns, true);\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Collection<?> patterns) {\n+        return from(patterns, true);\n     }\n \n+    public static WildcardMatcher from(String... patterns) {\n+        return from(patterns, true);\n+    }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n+    public WildcardMatcher concat(Stream<WildcardMatcher> matchers) {\n+        return new WildcardMatcher.MatcherCombiner(Stream.concat(matchers, Stream.of(this)).collect(ImmutableSet.toImmutableSet()));\n+    }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(Collection<WildcardMatcher> matchers) {\n+        if (matchers.isEmpty()) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(matchers.stream());\n     }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(candidates.size());\n-\n-        for (String string: candidates) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(WildcardMatcher... matchers) {\n+        if (matchers.length == 0) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(Arrays.stream(matchers));\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final Collection<String> candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.size());\n-\n-        for (final String string: candidate) {\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAny(Stream<String> candidates) {\n+        return candidates.anyMatch(this);\n+    }\n \n-        return matches;\n+    public boolean matchAny(Collection<String> candidates) {\n+        return matchAny(candidates.stream());\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final Collection<String> candidate) {\n+    public boolean matchAny(String[] candidates) {\n+        return matchAny(Arrays.stream(candidates));\n+    }\n \n-        final List<String> matches = new ArrayList<String>(candidate.size());\n+    public boolean matchAll(Stream<String> candidates) {\n+        return candidates.allMatch(this);\n+    }\n \n-        for (final String string: candidate) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAll(Collection<String> candidates) {\n+        return matchAll(candidates.stream());\n+    }\n \n-        return matches;\n+    public boolean matchAll(String[] candidates) {\n+        return matchAll(Arrays.stream(candidates));\n     }\n-    \n-    public static Optional<String> getFirstMatchingPattern(final Collection<String> pattern, final String candidate) {\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                return Optional.of(p);\n-            }\n-        }\n+    public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+        return candidates.filter(this).collect(collector);\n+    }\n \n-        return Optional.empty();\n+    public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(candidate.stream(), collector);\n     }\n \n+    public <T extends Collection<String>> T getMatchAny(final String[] candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(Arrays.stream(candidate), collector);\n+    }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final String candidate) {\n+    public Optional<WildcardMatcher> findFirst(final String candidate) {\n+        return Optional.ofNullable(test(candidate) ? this : null);\n+    }\n \n-        final List<String> matches = new ArrayList<String>(pattern.size());\n+    public static List<WildcardMatcher> matchers(Collection<String> patterns) {\n+        return patterns.stream().map(p -> WildcardMatcher.from(p, true))\n+                .collect(Collectors.toList());\n+    }\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                matches.add(p);\n+    public static boolean allMatches(final Collection<WildcardMatcher> matchers, final Collection<String> candidate) {\n+        int matchedPatternNum = 0;\n+        for (WildcardMatcher matcher : matchers) {\n+            if (matcher.matchAny(candidate)) {\n+                matchedPatternNum++;\n             }\n         }\n-\n-        return matches;\n+        return matchedPatternNum == matchers.size() && matchers.size() > 0;\n     }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(pattern.size());\n-\n-        for (String c : candidates) {\n-            matches.addAll(getAllMatchingPatterns(pattern, c));\n-        }\n-\n-        return matches;\n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> matchers, final String candidate) {\n+        return matchers.stream().filter(p -> p.test(candidate)).map(Objects::toString).collect(Collectors.toList());\n     }\n \n+    public static List<String> getAllMatchingPatterns(final Collection<WildcardMatcher> pattern, final Collection<String> candidates) {\n+        return pattern.stream().filter(p -> p.matchAny(candidates)).map(Objects::toString).collect(Collectors.toList());\n+    }\n \n     /**\n-     * returns true if the candidate matches at least one pattern\n      *\n-     * @param pattern\n-     * @param candidate\n+     * @param set of string to modify\n+     * @param matcher WildcardMatcher matcher to use to filter\n      * @return\n      */\n-    public static boolean matchAny(final String pattern[], final String candidate) {\n-\n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (match(string, candidate)) {\n-                return true;\n+    public static boolean WildcardMatcherRetainInSet(Set<String> set, WildcardMatcher matcher) {\n+        if(set == null || set.isEmpty()) {\n+            return false;\n+        }\n+        \n+        boolean modified = false;\n+        Iterator<String> it = set.iterator();\n+        while(it.hasNext()) {\n+            String v = it.next();\n+            if(!matcher.test(v)) {\n+                it.remove();\n+                modified = true;\n             }\n         }\n-\n-        return false;\n+        return modified;\n     }\n \n-    /**\n-     * returns true if the candidate matches at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String candidate) {\n \n-        for (String string: pattern) {\n-            if (match(string, candidate)) {\n-                return true;\n-            }\n-        }\n+    //\n+    // --- Implementation specializations ---\n+    //\n+    // Casefolding matcher - sits on top of case-sensitive matcher \n+    // and proxies toLower() of input string to the wrapped matcher\n+    private static final class CasefoldingMatcher extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final WildcardMatcher inner;\n \n-    public static boolean match(final String pattern, final String candidate) {\n-        return match(pattern, candidate, false);\n-    }\n+        public CasefoldingMatcher(String pattern, Function<String, WildcardMatcher> simpleWildcardMatcher) {\n+            this.inner = simpleWildcardMatcher.apply(pattern.toLowerCase());\n+        }\n \n-    public static boolean match(String pattern, String candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return inner.test(candidate.toLowerCase());\n+        }\n \n-        if (pattern == null || candidate == null) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            CasefoldingMatcher that = (CasefoldingMatcher) o;\n+            return inner.equals(that.inner);\n         }\n \n-        if(ignoreCase) {\n-            pattern = pattern.toLowerCase();\n-            candidate = candidate.toLowerCase();\n+        @Override\n+        public int hashCode() {\n+            return inner.hashCode();\n         }\n \n-        if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n-            // regex\n-            return Pattern.matches(\"^\"+pattern.substring(1, pattern.length() - 1)+\"$\", candidate);\n-        } else if (pattern.length() == 1 && pattern.charAt(0) == '*') {\n-            return true;\n-        } else if (pattern.indexOf('?') == NOT_FOUND && pattern.indexOf('*') == NOT_FOUND) {\n-            return pattern.equals(candidate);\n-        } else {\n-            return simpleWildcardMatch(pattern, candidate);\n+        @Override\n+        public String toString() {\n+            return inner.toString();\n         }\n     }\n \n-    public static boolean containsWildcard(final String pattern) {\n-        if (pattern != null\n-                && (pattern.indexOf(\"*\") > NOT_FOUND || pattern.indexOf(\"?\") > NOT_FOUND || (pattern.startsWith(\"/\") && pattern\n-                        .endsWith(\"/\")))) {\n-            return true;\n-        }\n+    public static final class Exact extends WildcardMatcher {\n \n-        return false;\n-    }\n+        private final String pattern;\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRemoveFromSet(Set<String> set, String stringContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        private Exact(String pattern) {\n+            this.pattern = pattern;\n         }\n-        if(!containsWildcard(stringContainingWc) && set.contains(stringContainingWc)) {\n-            return set.remove(stringContainingWc);\n-        } else {\n-            boolean modified = false;\n-            Set<String> copy = new HashSet<>(set);\n \n-            for(String it: copy) {\n-                if(WildcardMatcher.match(stringContainingWc, it)) {\n-                    modified = set.remove(it) || modified;\n-                }\n-            }\n-            return modified;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.equals(candidate);\n         }\n-    }\n \n-    /**\n-     *\n-     * @param set will be modified\n-     * @param stringContainingWc\n-     * @return\n-     */\n-    public static boolean wildcardRetainInSet(Set<String> set, String[] setContainingWc) {\n-        if(set == null || set.isEmpty()) {\n-            return false;\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Exact that = (Exact) o;\n+            return pattern.equals(that.pattern);\n         }\n-        boolean modified = false;\n-        Set<String> copy = new HashSet<>(set);\n \n-        for(String it: copy) {\n-            if(!WildcardMatcher.matchAny(setContainingWc, it)) {\n-                modified = set.remove(it) || modified;\n-            }\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n         }\n-        return modified;\n-    }\n \n+        @Override\n+        public String toString() {\n+            return pattern;\n+        }\n+    }\n \n-    //All code below is copied (and slightly modified) from Apache Commons IO\n+    // RegexMatcher uses JDK Pattern to test for matching,\n+    // assumes \"/<regex>/\" strings as input pattern\n+    private static final class RegexMatcher extends WildcardMatcher {\n \n-    /*\n-     * Licensed to the Apache Software Foundation (ASF) under one or more\n-     * contributor license agreements.  See the NOTICE file distributed with\n-     * this work for additional information regarding copyright ownership.\n-     * The ASF licenses this file to You under the Apache License, Version 2.0\n-     * (the \"License\"); you may not use this file except in compliance with\n-     * the License.  You may obtain a copy of the License at\n-     *\n-     *      http://www.apache.org/licenses/LICENSE-2.0\n-     *\n-     * Unless required by applicable law or agreed to in writing, software\n-     * distributed under the License is distributed on an \"AS IS\" BASIS,\n-     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-     * See the License for the specific language governing permissions and\n-     * limitations under the License.\n-     */\n+        private final Pattern pattern;\n \n+        private RegexMatcher(String pattern, boolean caseSensitive) {\n+            Preconditions.checkArgument(pattern.length() > 1 && pattern.startsWith(\"/\") && pattern.endsWith(\"/\"));\n+            final String stripSlashesPattern = pattern.substring(1, pattern.length() - 1);\n+            this.pattern = caseSensitive ? Pattern.compile(stripSlashesPattern) : Pattern.compile(stripSlashesPattern, Pattern.CASE_INSENSITIVE);\n+        }\n \n-    /**\n-     * Checks a filename to see if it matches the specified wildcard matcher\n-     * allowing control over case-sensitivity.\n-     * <p>\n-     * The wildcard matcher uses the characters '?' and '*' to represent a\n-     * single or multiple (zero or more) wildcard characters.\n-     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n-     *\n-     * @param candidate  the filename to match on\n-     * @param pattern  the wildcard string to match against\n-     * @return true if the filename matches the wilcard string\n-     * @since 1.3\n-     */\n-    private static boolean simpleWildcardMatch(final String pattern, final String candidate) {\n-        if (candidate == null && pattern == null) {\n-            return true;\n+        @Override\n+        public boolean test(String candidate) {\n+            return pattern.matcher(candidate).matches();\n         }\n-        if (candidate == null || pattern == null) {\n-            return false;\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            RegexMatcher that = (RegexMatcher) o;\n+            return pattern.pattern().equals(that.pattern.pattern());\n         }\n \n-        final String[] wcs = splitOnTokens(pattern);\n-        boolean anyChars = false;\n-        int textIdx = 0;\n-        int wcsIdx = 0;\n-        final Stack<int[]> backtrack = new Stack<>();\n+        @Override\n+        public int hashCode() {\n+            return pattern.pattern().hashCode();\n+        }\n \n-        // loop around a backtrack stack, to handle complex * matching\n-        do {\n-            if (backtrack.size() > 0) {\n-                final int[] array = backtrack.pop();\n-                wcsIdx = array[0];\n-                textIdx = array[1];\n-                anyChars = true;\n-            }\n+        @Override\n+        public String toString(){ return \"/\" + pattern.pattern() + \"/\"; }\n+    }\n \n-            // loop whilst tokens and text left to process\n-            while (wcsIdx < wcs.length) {\n+    // Simple implementation of WildcardMatcher matcher with * and ? without\n+    // using exlicit stack or recursion (as long as we don't need sub-matches it does work)\n+    // allows us to save on resources and heap allocations unless Regex is required\n+    private static final class SimpleMatcher extends WildcardMatcher {\n \n-                if (wcs[wcsIdx].equals(\"?\")) {\n-                    // ? so move to next text char\n-                    textIdx++;\n-                    if (textIdx > candidate.length()) {\n-                        break;\n-                    }\n-                    anyChars = false;\n+        private final String pattern;\n \n-                } else if (wcs[wcsIdx].equals(\"*\")) {\n-                    // set any chars status\n-                    anyChars = true;\n-                    if (wcsIdx == wcs.length - 1) {\n-                        textIdx = candidate.length();\n-                    }\n+        SimpleMatcher(String pattern) {\n+            this.pattern = pattern;\n+        }\n \n+        @Override\n+        public boolean test(String candidate) {\n+            int i = 0;\n+            int j = 0;\n+            int n = candidate.length();\n+            int m = pattern.length();\n+            int text_backup = -1;\n+            int wild_backup = -1;\n+            while (i < n) {\n+                if (j < m && pattern.charAt(j) == '*') {\n+                    text_backup = i;\n+                    wild_backup = ++j;\n+                } else if (j < m && (pattern.charAt(j) == '?' || pattern.charAt(j) == candidate.charAt(i))) {\n+                    i++;\n+                    j++;\n                 } else {\n-                    // matching text token\n-                    if (anyChars) {\n-                        // any chars then try to locate text token\n-                        textIdx = checkIndexOf(candidate, textIdx, wcs[wcsIdx]);\n-                        if (textIdx == NOT_FOUND) {\n-                            // token not found\n-                            break;\n-                        }\n-                        final int repeat = checkIndexOf(candidate, textIdx + 1, wcs[wcsIdx]);\n-                        if (repeat >= 0) {\n-                            backtrack.push(new int[] {wcsIdx, repeat});\n-                        }\n-                    } else {\n-                        // matching from current position\n-                        if (!checkRegionMatches(candidate, textIdx, wcs[wcsIdx])) {\n-                            // couldnt match token\n-                            break;\n-                        }\n-                    }\n-\n-                    // matched text token, move text index to end of matched token\n-                    textIdx += wcs[wcsIdx].length();\n-                    anyChars = false;\n+                    if (wild_backup == -1) return false;\n+                    i = ++text_backup;\n+                    j = wild_backup;\n                 }\n-\n-                wcsIdx++;\n             }\n+            while (j < m && pattern.charAt(j) == '*') j++;\n+            return j >= m;\n+        }\n \n-            // full match\n-            if (wcsIdx == wcs.length && textIdx == candidate.length()) {\n-                return true;\n-            }\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            SimpleMatcher that = (SimpleMatcher) o;\n+            return pattern.equals(that.pattern);\n+        }\n \n-        } while (backtrack.size() > 0);\n+        @Override\n+        public int hashCode() {\n+            return pattern.hashCode();\n+        }\n \n-        return false;\n+        @Override\n+        public String toString(){ return pattern; }\n     }\n \n-    /**\n-     * Splits a string into a number of tokens.\n-     * The text is split by '?' and '*'.\n-     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n-     *\n-     * @param text  the text to split\n-     * @return the array of tokens, never null\n-     */\n-    private static String[] splitOnTokens(final String text) {\n-        // used by wildcardMatch\n-        // package level so a unit test may run on this\n-\n-        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n-            return new String[] { text };\n-        }\n-\n-        final char[] array = text.toCharArray();\n-        final ArrayList<String> list = new ArrayList<>();\n-        final StringBuilder buffer = new StringBuilder();\n-        char prevChar = 0;\n-        for (final char ch : array) {\n-            if (ch == '?' || ch == '*') {\n-                if (buffer.length() != 0) {\n-                    list.add(buffer.toString());\n-                    buffer.setLength(0);\n-                }\n-                if (ch == '?') {\n-                    list.add(\"?\");\n-                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n-                    list.add(\"*\");\n-                }\n-            } else {\n-                buffer.append(ch);\n-            }\n-            prevChar = ch;\n+    // MatcherCombiner is a combination of a set of matchers\n+    // matches if any of the set do\n+    // Empty MultiMatcher always returns false\n+    private static final class MatcherCombiner extends WildcardMatcher {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzMTMzNA=="}, "originalCommit": null, "originalPosition": 907}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODMxNTAwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODo1OTo0NVrOGXDzew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODo1OTo0NVrOGXDzew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgzMjc2Mw==", "bodyText": "We can use allMatch ? something like\nmatchers.stream().allMatch(m -> m.matchAny(candidate))", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r426832763", "createdAt": "2020-05-18T18:59:45Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();\n+            if (t instanceof String) {\n+                return from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n         }\n-\n-        return false;\n+        return from(collection.stream(), caseSensitive);\n     }\n \n-    public static String[] matches(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        final List<String> ret = new ArrayList<String>(candidate.length);\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                ret.add(string);\n-            }\n+    public static WildcardMatcher from(String[] patterns, boolean caseSensitive) {\n+        if (patterns == null || patterns.length == 0) {\n+            return NONE;\n+        } else if (patterns.length == 1) {\n+            return from(patterns[0], caseSensitive);\n         }\n-\n-        return ret.toArray(new String[0]);\n+        return from(Arrays.stream(patterns), caseSensitive);\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Stream<String> patterns) {\n+        return from(patterns, true);\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n-\n-        return matches;\n+    public static WildcardMatcher from(Collection<?> patterns) {\n+        return from(patterns, true);\n     }\n \n+    public static WildcardMatcher from(String... patterns) {\n+        return from(patterns, true);\n+    }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, final String[] candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.length);\n+    public WildcardMatcher concat(Stream<WildcardMatcher> matchers) {\n+        return new WildcardMatcher.MatcherCombiner(Stream.concat(matchers, Stream.of(this)).collect(ImmutableSet.toImmutableSet()));\n+    }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(Collection<WildcardMatcher> matchers) {\n+        if (matchers.isEmpty()) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(matchers.stream());\n     }\n \n-    public static List<String> getMatchAny(final Collection<String> patterns, Collection<String> candidates) {\n-\n-        final List<String> matches = new ArrayList<String>(candidates.size());\n-\n-        for (String string: candidates) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n+    public WildcardMatcher concat(WildcardMatcher... matchers) {\n+        if (matchers.length == 0) {\n+            return this;\n         }\n-\n-        return matches;\n+        return concat(Arrays.stream(matchers));\n     }\n \n-    public static List<String> getMatchAny(final String pattern, final Collection<String> candidate) {\n-\n-        final List<String> matches = new ArrayList<String>(candidate.size());\n-\n-        for (final String string: candidate) {\n-            if (match(pattern, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAny(Stream<String> candidates) {\n+        return candidates.anyMatch(this);\n+    }\n \n-        return matches;\n+    public boolean matchAny(Collection<String> candidates) {\n+        return matchAny(candidates.stream());\n     }\n \n-    public static List<String> getMatchAny(final String[] patterns, final Collection<String> candidate) {\n+    public boolean matchAny(String[] candidates) {\n+        return matchAny(Arrays.stream(candidates));\n+    }\n \n-        final List<String> matches = new ArrayList<String>(candidate.size());\n+    public boolean matchAll(Stream<String> candidates) {\n+        return candidates.allMatch(this);\n+    }\n \n-        for (final String string: candidate) {\n-            if (matchAny(patterns, string)) {\n-                matches.add(string);\n-            }\n-        }\n+    public boolean matchAll(Collection<String> candidates) {\n+        return matchAll(candidates.stream());\n+    }\n \n-        return matches;\n+    public boolean matchAll(String[] candidates) {\n+        return matchAll(Arrays.stream(candidates));\n     }\n-    \n-    public static Optional<String> getFirstMatchingPattern(final Collection<String> pattern, final String candidate) {\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                return Optional.of(p);\n-            }\n-        }\n+    public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+        return candidates.filter(this).collect(collector);\n+    }\n \n-        return Optional.empty();\n+    public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(candidate.stream(), collector);\n     }\n \n+    public <T extends Collection<String>> T getMatchAny(final String[] candidate, Collector<String, ?, T> collector) {\n+        return getMatchAny(Arrays.stream(candidate), collector);\n+    }\n \n-    public static List<String> getAllMatchingPatterns(final Collection<String> pattern, final String candidate) {\n+    public Optional<WildcardMatcher> findFirst(final String candidate) {\n+        return Optional.ofNullable(test(candidate) ? this : null);\n+    }\n \n-        final List<String> matches = new ArrayList<String>(pattern.size());\n+    public static List<WildcardMatcher> matchers(Collection<String> patterns) {\n+        return patterns.stream().map(p -> WildcardMatcher.from(p, true))\n+                .collect(Collectors.toList());\n+    }\n \n-        for (String p : pattern) {\n-            if (match(p, candidate)) {\n-                matches.add(p);\n+    public static boolean allMatches(final Collection<WildcardMatcher> matchers, final Collection<String> candidate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 476}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTUwMTE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNDowODo0N1rOGXPJmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjo0NzoyMVrOGXpaZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODY1MA==", "bodyText": "nit: use collection.get(0) ?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427018650", "createdAt": "2020-05-19T04:08:47Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0ODkzNA==", "bodyText": "Collection does not allow random access.", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427448934", "createdAt": "2020-05-19T16:47:21Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {\n+        if (pattern.equals(\"*\")) {\n+            return ANY;\n+        } else if (pattern.startsWith(\"/\") && pattern.endsWith(\"/\")) {\n+            return new RegexMatcher(pattern, caseSensitive);\n+        } else if (pattern.indexOf('?') >= 0 || pattern.indexOf('*') >= 0) {\n+            return caseSensitive ?  new SimpleMatcher(pattern) : new CasefoldingMatcher(pattern,  SimpleMatcher::new);\n+        }\n+        else {\n+            return caseSensitive ? new Exact(pattern) : new CasefoldingMatcher(pattern, Exact::new);\n+        }\n     }\n \n-    public static boolean matchAny(final String pattern, final String[] candidate) {\n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final String pattern, final Collection<String> candidate) {\n-        return matchAny(pattern, candidate, false);\n+    public static WildcardMatcher from(String pattern) {\n+        return from(pattern, true);\n     }\n \n-    /**\n-     * return true if at least one candidate matches the given pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String pattern, final String[] candidate, boolean ignoreCase) {\n-\n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (match(pattern, string, ignoreCase)) {\n-                return true;\n+    // This may in future use more optimized techniques to combine multiple WildcardMatchers in a single automaton\n+    public static <T> WildcardMatcher from(Stream<T> stream, boolean caseSensitive) {\n+        Collection<WildcardMatcher> matchers = stream.map(t -> {\n+            if (t instanceof String) {\n+                return WildcardMatcher.from(((String) t), caseSensitive);\n+            } else if (t instanceof WildcardMatcher) {\n+                return ((WildcardMatcher) t);\n             }\n-        }\n-\n-        return false;\n-    }\n-\n-    public static boolean matchAny(final String pattern, final Collection<String> candidates, boolean ignoreCase) {\n-\n-        for (String candidate: candidates) {\n-            if (match(pattern, candidate, ignoreCase)) {\n-                return true;\n+            throw new UnsupportedOperationException(\"WildcardMatcher can't be constructed from \" + t.getClass().getSimpleName());\n+        })\n+        .collect(ImmutableSet.toImmutableSet());\n+\n+        if (matchers.isEmpty()) {\n+            return NONE;\n+        } else if (matchers.size() == 1) {\n+            return matchers.stream().findFirst().get();\n+        }\n+        return new MatcherCombiner(matchers);\n+    }\n+\n+    public static <T> WildcardMatcher from(Collection<T> collection, boolean caseSensitive) {\n+        if (collection == null || collection.isEmpty()) {\n+            return NONE;\n+        } else if (collection.size() == 1) {\n+            T t = collection.stream().findFirst().get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODY1MA=="}, "originalCommit": null, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTU5NzYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNToxMTo1MFrOGXQFbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzo1NjowMFrOGapw8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAzMzk2Ng==", "bodyText": "Wondering if its better to make a matcher here or in the cache ? \ud83e\udd14", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427033966", "createdAt": "2020-05-19T05:11:50Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -127,10 +127,10 @@ private ComplianceConfig(\n         this.readEnabledFields = watchedReadFields.stream()\n                 .map(watchedReadField -> watchedReadField.split(\",\"))\n                 .filter(split -> split.length != 0 && !Strings.isNullOrEmpty(split[0]))\n-                .collect(Collectors.toMap(\n-                        split -> split[0],\n+                .collect(ImmutableMap.toImmutableMap(\n+                        split -> WildcardMatcher.from(split[0]),\n                         split -> split.length == 1 ?\n-                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n+                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(ImmutableSet.toImmutableSet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYwMDQzMw==", "bodyText": "Do you mean inside getFieldsForIndex()? I don't think that lazy initialization of readEnabledFields is a better choice here as it will require synchronization.", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r430600433", "createdAt": "2020-05-26T17:56:00Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/compliance/ComplianceConfig.java", "diffHunk": "@@ -127,10 +127,10 @@ private ComplianceConfig(\n         this.readEnabledFields = watchedReadFields.stream()\n                 .map(watchedReadField -> watchedReadField.split(\",\"))\n                 .filter(split -> split.length != 0 && !Strings.isNullOrEmpty(split[0]))\n-                .collect(Collectors.toMap(\n-                        split -> split[0],\n+                .collect(ImmutableMap.toImmutableMap(\n+                        split -> WildcardMatcher.from(split[0]),\n                         split -> split.length == 1 ?\n-                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(Collectors.toSet())\n+                                Collections.singleton(\"*\") : Arrays.stream(split).skip(1).collect(ImmutableSet.toImmutableSet())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAzMzk2Ng=="}, "originalCommit": null, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTcxMjk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoxMjoyOVrOGXRM3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxOTo0MTozNFrOGatnvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MjI1NQ==", "bodyText": "Is the main benefit of doing this to avoid recompilation of patterns which are expensive especially regexes ?\nBut elasticsearch patterns use only wildcard match (specifically *) and other chars are restricted including ? https://www.elastic.co/guide/en/kibana/current/index-patterns.html . Do we also want to restrict patterns similar to what elasticsearch supports as almost all the patterns we have are also wildcards?\nI see the SimpleMatcher which does actual wildcard matching still using pattern iteration for matching *. Wondering if I m missing any other benefits  ?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427052255", "createdAt": "2020-05-19T06:12:29Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY2MzYxMw==", "bodyText": "Please check usage of RegexMatcher", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r430663613", "createdAt": "2020-05-26T19:41:34Z", "author": {"login": "vrozov"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/WildcardMatcher.java", "diffHunk": "@@ -30,626 +30,503 @@\n \n package com.amazon.opendistroforelasticsearch.security.support;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n-import java.util.HashSet;\n import java.util.List;\n+import java.util.Objects;\n import java.util.Optional;\n import java.util.Set;\n-import java.util.Stack;\n+import java.util.Iterator;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n import java.util.regex.Pattern;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-public class WildcardMatcher {\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n \n-    private static final int NOT_FOUND = -1;\n+public abstract class WildcardMatcher implements Predicate<String> {\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern (case sensitive)\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate) {\n+    public static final WildcardMatcher ANY = new WildcardMatcher() {\n \n-        return matchAny(pattern, candidate, false);\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return true;\n+        }\n \n-        return matchAny(pattern, candidate, false);\n-    }\n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final String[] pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return true;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return true;\n         }\n \n-        return false;\n-    }\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return true;\n+        }\n \n-    /**\n-     * returns true if at least one candidate match at least one pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @param ignoreCase\n-     * @return\n-     */\n-    public static boolean matchAny(final Collection<String> pattern, final String[] candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return candidates.collect(collector);\n         }\n \n-        return false;\n-    }\n-    \n-    public static boolean matchAny(final Collection<String> pattern, final Collection<String> candidate, boolean ignoreCase) {\n+        @Override\n+        public boolean test(String candidate) {\n+            return true;\n+        }\n \n-        for (String string: pattern) {\n-            if (matchAny(string, candidate, ignoreCase)) {\n-                return true;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"*\";\n         }\n+    };\n \n-        return false;\n-    }\n+    public static final WildcardMatcher NONE = new WildcardMatcher() {\n \n-    /**\n-     * return true if all candidates find a matching pattern\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean matchAll(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAny(Stream<String> candidates) {\n+            return false;\n+        }\n \n+        @Override\n+        public boolean matchAny(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < candidate.length; i++) {\n-            final String string = candidate[i];\n-            if (!matchAny(pattern, string)) {\n-                return false;\n-            }\n+        @Override\n+        public boolean matchAny(String[] candidates) {\n+            return false;\n         }\n \n-        return true;\n-    }\n+        @Override\n+        public boolean matchAll(Stream<String> candidates) {\n+            return false;\n+        }\n \n-    /**\n-     *\n-     * @param pattern\n-     * @param candidate\n-     * @return\n-     */\n-    public static boolean allPatternsMatched(final String[] pattern, final String[] candidate) {\n+        @Override\n+        public boolean matchAll(Collection<String> candidates) {\n+            return false;\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean matchAll(String[] candidates) {\n+            return false;\n+        }\n \n-        for (int i = 0; i < pattern.length; i++) {\n-            final String string = pattern[i];\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Stream<String> candidates, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n         }\n \n-        return matchedPatternNum == pattern.length && pattern.length > 0;\n-    }\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(Collection<String> candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-    public static boolean allPatternsMatched(final Collection<String> pattern, final Collection<String> candidate) {\n+        @Override\n+        public <T extends Collection<String>> T getMatchAny(String[] candidate, Collector<String, ?, T> collector) {\n+            return Stream.<String>empty().collect(collector);\n+        }\n \n-        int matchedPatternNum = 0;\n+        @Override\n+        public boolean test(String candidate) {\n+            return false;\n+        }\n \n-        for (String string:pattern) {\n-            if (matchAny(string, candidate)) {\n-                matchedPatternNum++;\n-            }\n+        @Override\n+        public String toString() {\n+            return \"<NONE>\";\n         }\n+    };\n \n-        return matchedPatternNum == pattern.size() && pattern.size() > 0;\n+    public static WildcardMatcher from(String pattern, boolean caseSensitive) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MjI1NQ=="}, "originalCommit": null, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTc0NDEzOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/transport/DefaultInterClusterRequestEvaluator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoyNToxMFrOGXRfag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoyNToxMFrOGXRfag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NzAwMg==", "bodyText": "avoid re-imports ?", "url": "https://github.com/opensearch-project/security/pull/458#discussion_r427057002", "createdAt": "2020-05-19T06:25:10Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/transport/DefaultInterClusterRequestEvaluator.java", "diffHunk": "@@ -51,19 +47,24 @@\n \n import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n import com.amazon.opendistroforelasticsearch.security.support.WildcardMatcher;\n+import com.amazon.opendistroforelasticsearch.security.securityconf.DynamicConfigFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2443, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}