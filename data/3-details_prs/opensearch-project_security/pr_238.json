{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3NDI0MTQ4", "number": 238, "title": "Adding capability to hot reload ssl certificates", "bodyText": "* Added api PUT /_opendistro/_security/sslcerts/reload which reinitializes keystore\n    * Added api GET /_opendistro/_security/nodecerts which gets transport public key information\n    * Updated DefaultODSKeyStore to update, set and get transport layer certificates\n    * Added unit tests\n\n\nDescription:\nThis feature allows super admin users to \"hot reload\" their expired SSL certificates without restarting their clusters. This API is very sensitive so currently it only allows users to replace their expired certificates with valid certificates issued with the same Issuer/Subject DN and SAN.\nThis API assumes that new certificates are in the same location specified by the security configurations in elasticsearch.yml (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/) and the same TLS configuration values hold for the new certificates.\nTo enable this feature add the following property to your elasticsearch.yml file -\nopendistro_security.ssl_cert_reload_enabled: true\n\nThis property is disabled by default.\n\nAPI Reference:\nPUT /_opendistro/_security/api/ssl/{certType}/reloadcerts\nDescription: This API updates SSL transport and http certificate information and is accessible by super admins only.\nRequest:\n\nPUT /_opendistro/_security/api/ssl/transport/reloadcerts\nPUT /_opendistro/_security/api/ssl/http/reloadcerts\n\nResponse:\n { \"message\": \"successfully updated transport certs\"}\n\nGET /_opendistro/_security/api/ssl/certs\nDescription: This API returns SSL transport and http certificate information and is accessible by super admins only.\nRequest:\n\nGET /_opendistro/_security/api/ssl/certs\n\nResponse:\n {\n   \"transport_certificates_list\":[\n      {\n         \"issuer_dn\":\"CN=Example Com Inc. Signing CA,OU=Example Com Inc. Signing CA,O=Example Com Inc.,DC=example,DC=com\",\n         \"subject_dn\":\"CN=node-1.example.com,OU=SSL,O=Test,L=Test,C=DE\",\n         \"san\":\"[localhost]\",\n         \"not_before\":\"2020-02-17T16:19:25Z\",\n         \"not_after\":\"2022-02-16T16:19:25Z\"\n      }\n   ],\n   \"http_certificates_list\":[\n      {\n         \"issuer_dn\":\"CN=Example Com Inc. Signing CA,OU=Example Com Inc. Signing CA,O=Example Com Inc.,DC=example,DC=com\",\n         \"subject_dn\":\"CN=node-1.example.com,OU=SSL,O=Test,L=Test,C=DE\",\n         \"san\":\"[localhost]\",\n         \"not_before\":\"2020-02-17T16:19:25Z\",\n         \"not_after\":\"2022-02-16T16:19:25Z\"\n      }\n   ]\n}", "createdAt": "2020-02-19T22:14:57Z", "url": "https://github.com/opensearch-project/security/pull/238", "merged": true, "mergeCommit": {"oid": "24fab5e8e8e18ce96b450a703cc25c8d5f201840"}, "closed": true, "closedAt": "2020-03-03T21:46:30Z", "author": {"login": "debjanibnrj"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHipxYgFqTM2MzYxMjA5MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKIYEHgBqjMwOTM3NjQ3Mzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNjEyMDkw", "url": "https://github.com/opensearch-project/security/pull/238#pullrequestreview-363612090", "createdAt": "2020-02-24T18:40:41Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODo0MDo0MVrOFtrffA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOToyMToyM1rOFtswbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjgxMg==", "bodyText": "Why is the advantage of having a setting for this? Any harm in enabling hot reload by default?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383442812", "createdAt": "2020-02-24T18:40:41Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -207,28 +210,40 @@ private static boolean isDisabled(final Settings settings) {\n     private static boolean isSslOnlyMode(final Settings settings) {\n         return settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_ONLY, false);\n     }\n-    \n+\n+    /**\n+     * SSL Cert will be reloadable if security is enabled and we are not in sslOnly mode\n+     * @param settings Elastic configuration settings\n+     * @return true if ssl cert reload is enabled else false\n+     */\n+    private static boolean isSslCertReloadable(final Settings settings) {\n+        return !isDisabled(settings) && !isSslOnlyMode(settings) && settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_CERT_RELOAD, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NTczMg==", "bodyText": "Still return 200 if keystore is not initialized? 500 error?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383445732", "createdAt": "2020-02-24T18:46:21Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecerts endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecerts\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecerts\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=node-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            final X509Certificate[] localCertificates = odsks.getTransportCerts();\n+                            builder.startObject();\n+                            if (localCertificates != null) {\n+                                builder.startArray(\"node_cert_list\");\n+                                for (X509Certificate localCertificate : localCertificates) {\n+                                    builder.startObject();\n+                                    builder.field(\"issuer_dn\", localCertificate.getIssuerDN().getName());\n+                                    builder.field(\"subject_dn\", localCertificate.getSubjectDN().toString());\n+                                    builder.field(\"not_before\", localCertificate.getNotBefore());\n+                                    builder.field(\"not_after\", localCertificate.getNotAfter());\n+                                    builder.endObject();\n+                                }\n+                                builder.endArray();\n+                            }\n+                            builder.endObject();\n+                        } else {\n+                            builder.field(\"message\", \"keystore is not initialized\");\n+                        }\n+\n+                        response = new BytesRestResponse(RestStatus.OK, builder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0ODM0Nw==", "bodyText": "What is the difference in creating api action through extending BaseRestHandler vs the other dlic/rest/api/ actions we have? Had refactored registerHandler to be in separate overridden function.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383448347", "createdAt": "2020-02-24T18:51:28Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecerts endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecerts\", this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MDYwMg==", "bodyText": "Just for my understanding - is this action limited to super admins? Any chance client will use this information eg: admin roles", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383450602", "createdAt": "2020-02-24T18:55:49Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecerts endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecerts\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecerts\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=node-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MTI1Ng==", "bodyText": "If we are sending only information in the response, how about we have info in the path.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383451256", "createdAt": "2020-02-24T18:57:07Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecerts endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecerts\", this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MjAzMg==", "bodyText": "Update the documentation for sslcerts/reload", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383452032", "createdAt": "2020-02-24T18:58:32Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,\n+                               final RestController restController,\n+                               final OpenDistroSecurityKeyStore odsks,\n+                               final ThreadPool threadPool,\n+                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"/_opendistro/_security/sslcerts/reload\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/nodecerts", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MjU0OA==", "bodyText": "Same as above. Throw error response if keystore is not initialized?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383452548", "createdAt": "2020-02-24T18:59:26Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,\n+                               final RestController restController,\n+                               final OpenDistroSecurityKeyStore odsks,\n+                               final ThreadPool threadPool,\n+                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"/_opendistro/_security/sslcerts/reload\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/nodecerts\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated certs successfully\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        if (odsks != null) {\n+                            odsks.initSSLConfig();\n+                            builder.field(\"message\", \"updated certs successfully\");\n+                        } else {\n+                            builder.field( \"message\", \"keystore is not initialized\");\n+                        }\n+                        builder.endObject();\n+                        response = new BytesRestResponse(RestStatus.OK, builder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1NDE0NA==", "bodyText": "Move or consolidate this into PemKeyReader helper file?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383454144", "createdAt": "2020-02-24T19:02:33Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/util/SSLCertificateHelper.java", "diffHunk": "@@ -142,7 +147,19 @@ public static PrivateKey exportDecryptedKey(final KeyStore ks, final String alia\n \n         return null;\n     }\n-    \n+\n+    /**\n+     * Helper function to translate file format to X509Certificate\n+     * @param file Public Key File\n+     * @return X509Formatted File\n+     */\n+    public static X509Certificate convertFileToX509Certificate(File file) throws CertificateException, FileNotFoundException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MzUzMw==", "bodyText": "Trying to understand - we are comparing the set of new certs DNs vs current set DNs? Slightly confused by statement same Issuer DN.  Shouldnt it all be the same ?\n\nNot familiar with how DNs work.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383463533", "createdAt": "2020-02-24T19:21:23Z", "author": {"login": "sujithvm"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +230,324 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                try {\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n                 }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+                validateNewTransportCerts(transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n             }\n+\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ SSLCertificateHelper.convertFileToX509Certificate(pemCertFile) };\n+\n+                validateNewTransportCerts(transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);\n+                transportServerSslContext = buildSSLServerContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+            }\n+\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n+                + \" must be set if transport ssl is reqested.\");\n         }\n+    }\n \n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n+    /**\n+     * Initializes certs used for client https communication\n+     */\n+    private void initHttpCerts() {\n+        final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+            null);\n+        final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n+            null);\n+        final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n \n-        if (!client && httpSSLEnabled) {\n+        if (rawKeystoreFilePath != null) {\n \n-            final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                    null);\n-            final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n-                    null);\n-            final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-            if (rawKeystoreFilePath != null) {\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n-\n-                log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n-                            + \" must be set if https is reqested.\");\n-                }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n-                        throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n-                                + \" must be set if http ssl and client auth is reqested.\");\n-                    }\n+            log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n+                    + \" must be set if https is reqested.\");\n+            }\n+\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n \n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n+                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n+                        + \" must be set if http ssl and client auth is reqested.\");\n                 }\n \n-                try {\n+            }\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n-                        ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                : keystorePassword.toCharArray());\n-                    }\n+            try {\n \n-                    final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n+                    ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+                }\n \n-                    if (httpKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n \n-                    if (httpKeystoreCert != null && httpKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < httpKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = httpKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"HTTP keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    X509Certificate[] trustedHTTPCertificates = null;\n+                if (httpKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n+                X509Certificate[] trustedHTTPCertificates = null;\n \n-                        final String truststoreFilePath = resolve(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n \n-                        final String truststoreType = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n-                        final String truststorePassword = settings.get(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n-                                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                        final String truststoreAlias = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+                    final String truststoreFilePath = resolve(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n \n-                        final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                        try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n-                            ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n-                        }\n-                        trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                    final String truststoreType = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n+                    final String truststorePassword = settings.get(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n+                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+                    final String truststoreAlias = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+\n+                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                    try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n+                        ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n                     }\n+                    trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                }\n \n-                    httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+                httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n \n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n-                            e);\n-                }\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n+                    e);\n+            }\n+\n+        } else if (rawPemCertFilePath != null) {\n \n-            } else if (rawPemCertFilePath != null) {\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n+                false);\n \n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n-                        false);\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+\n+            try {\n+                httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n+                    trustedCas == null ? null : new File(trustedCas),\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    // if(trustedCas == null ||\n-                    // trustedCas.equals(env.config-File().toAbsolutePath().toString())) {\n-                    // throw new\n-                    // ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH\n-                    // + \" must be set if http ssl and client auth is reqested.\");\n-                    // }\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n+                + \" must be set if http ssl is reqested.\");\n+        }\n+    }\n \n-                    checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+    /**\n+     * Cert Issuer DN must be the same\n+     * @param newCerts Array of X509Certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewTransportCerts(final X509Certificate[] newCerts) throws Exception {\n \n-                }\n+        // First time we init certs ignore validity check\n+        if (transportCerts == null) {\n+            return;\n+        }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+        // Check if new X509 certs have been issued by the same Issuer DN", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 539}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODI3Mzgw", "url": "https://github.com/opensearch-project/security/pull/238#pullrequestreview-363827380", "createdAt": "2020-02-25T02:06:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMjowNjoxNVrOFt2XFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzo1NzoxMFrOFuZr6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMDg4Ng==", "bodyText": "why this class is part of rest? Should it be transport?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383620886", "createdAt": "2020-02-25T02:06:15Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -48,6 +48,8 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import com.amazon.opendistroforelasticsearch.security.ssl.rest.SSLCertReloadAction;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMjcwNQ==", "bodyText": "should we rename it to transportCertReloadable ? (as this is related to transport cert and not rest one ).", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383622705", "createdAt": "2020-02-25T02:13:43Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -167,6 +169,7 @@\n     private static final String KEYWORD = \".keyword\";\n     private final boolean dlsFlsAvailable;\n     private final Constructor<?> dlsFlsConstructor;\n+    private boolean sslCertReloadable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNjMyMA==", "bodyText": "same here", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384106320", "createdAt": "2020-02-25T20:24:37Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -48,6 +48,8 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import com.amazon.opendistroforelasticsearch.security.ssl.rest.SSLCertReloadAction;\n+import com.amazon.opendistroforelasticsearch.security.ssl.rest.NodeCertInfoAction;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNzk5NQ==", "bodyText": "@sujithvm  As @debjanibnrj mentioned, this flag is specially introduced to for users how do not want to expose this endpoint even for super admin and do now want hot-reload functionality due to their on-premise or infra security restriction.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384107995", "createdAt": "2020-02-25T20:28:03Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -207,28 +210,40 @@ private static boolean isDisabled(final Settings settings) {\n     private static boolean isSslOnlyMode(final Settings settings) {\n         return settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_ONLY, false);\n     }\n-    \n+\n+    /**\n+     * SSL Cert will be reloadable if security is enabled and we are not in sslOnly mode\n+     * @param settings Elastic configuration settings\n+     * @return true if ssl cert reload is enabled else false\n+     */\n+    private static boolean isSslCertReloadable(final Settings settings) {\n+        return !isDisabled(settings) && !isSslOnlyMode(settings) && settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_CERT_RELOAD, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjgxMg=="}, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwODY3Mw==", "bodyText": "Should we rename it to transport? OPENDISTRO_SECURITY_TRANSPORT_CERT_RELOAD or OPENDISTRO_SECURITY_TRANSPORT_SSL_CERT_RELOAD", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384108673", "createdAt": "2020-02-25T20:29:29Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -951,6 +969,7 @@ public Settings additionalSettings() {\n             settings.add(Setting.boolSetting(ConfigConstants.OPENDISTRO_SECURITY_UNSUPPORTED_ALLOW_NOW_IN_DLS, false, Property.NodeScope, Property.Filtered));\n             settings.add(Setting.boolSetting(ConfigConstants.OPENDISTRO_SECURITY_UNSUPPORTED_RESTAPI_ALLOW_SECURITYCONFIG_MODIFICATION, false, Property.NodeScope, Property.Filtered));\n             settings.add(Setting.boolSetting(ConfigConstants.OPENDISTRO_SECURITY_UNSUPPORTED_ACCEPT_INVALID_CONFIG, false, Property.NodeScope, Property.Filtered));\n+            settings.add(Setting.boolSetting(ConfigConstants.OPENDISTRO_SECURITY_SSL_CERT_RELOAD, false, Property.NodeScope, Property.Filtered));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1MjY5Mw==", "bodyText": "Node can have multiple type of certs (rest, transport and admin).  Should we be more specific in response to differentiate this?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384152693", "createdAt": "2020-02-25T22:00:34Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecertsinfo\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecertsinfo\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1NDc3NA==", "bodyText": "Are we audit logging this API calls? Most probably it should go under compliance logging.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384154774", "createdAt": "2020-02-25T22:04:52Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1OTgxMQ==", "bodyText": "we should be defining here.. if it is rest or transport cert. (Ideally we should return details of both cert types)\nAnd we should hide admin cert details? (Just a thought to keep admin cert more secure)", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384159811", "createdAt": "2020-02-25T22:16:03Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecertsinfo\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecertsinfo\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=node-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Super admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            final X509Certificate[] localCertificates = odsks.getTransportCerts();\n+                            if (localCertificates != null) {\n+                                builder.startArray(\"node_cert_list\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MTI5NA==", "bodyText": "Do we get all field always even if cert is private or self signed cert (may be some of those filed might be optional) ? Will it get some default null / empty string value?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384161294", "createdAt": "2020-02-25T22:19:33Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecertsinfo\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecertsinfo\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=node-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Super admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            final X509Certificate[] localCertificates = odsks.getTransportCerts();\n+                            if (localCertificates != null) {\n+                                builder.startArray(\"node_cert_list\");\n+                                for (X509Certificate localCertificate : localCertificates) {\n+                                    builder.startObject();\n+                                    builder.field(\"issuer_dn\", localCertificate.getIssuerDN().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjUwOA==", "bodyText": "this API should be audit/compliance logged as well.  It should goes under compliance section as it is making changes to security parameter. May be we need to define new action for logging this.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384162508", "createdAt": "2020-02-25T22:22:07Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NTA1Ng==", "bodyText": "Is there a way we can specify action/type (rest or transport) into request? may be as an argument?\nWe should also have a way to mention which cert we are renewing. Is it transport or rest? Ideally, we should also support hot reloading (renewing) for rest layer cert for better user experience.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384165056", "createdAt": "2020-02-25T22:28:04Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,\n+                               final RestController restController,\n+                               final OpenDistroSecurityKeyStore odsks,\n+                               final ThreadPool threadPool,\n+                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"/_opendistro/_security/sslcerts/reload\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/sslcerts/reload\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated certs successfully\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3Mzc2Ng==", "bodyText": "This detail is good. And we should also explicitly mention following things in documentation of this API/ comments/ description of this PR.\nTo keep sensitive certificate hot reload secure, this API will only allow renewing/replacing expired cert issued by same issuer and issued for the same domain/subject name.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384173766", "createdAt": "2020-02-25T22:47:53Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3NTkxMw==", "bodyText": "Should we say Renewal (as we are not allowing any other cert reload different than current in use) ?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384175913", "createdAt": "2020-02-25T22:52:43Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,\n+                               final RestController restController,\n+                               final OpenDistroSecurityKeyStore odsks,\n+                               final ThreadPool threadPool,\n+                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"/_opendistro/_security/sslcerts/reload\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/sslcerts/reload\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated certs successfully\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        if (odsks != null) {\n+                            odsks.initSSLConfig();\n+                            builder.field(\"message\", \"updated certs successfully\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.OK, builder);\n+                        } else {\n+                            builder.field( \"message\", \"keystore is not initialized\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                        }\n+                    } catch (final Exception e1) {\n+                        builder = channel.newBuilder();\n+                        builder.startObject();\n+                        builder.field(\"error\", e1.toString());\n+                        builder.endObject();\n+                        response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                    } finally {\n+                        if (builder != null) {\n+                            builder.close();\n+                        }\n+                    }\n+                }\n+                channel.sendResponse(response);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"SSL Cert Reload Action\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3NjY5Nw==", "bodyText": "[Debatable] ssl_cert_reload  --> ssl_cert_hot_renewal (can be use same flag for both rest and transport cert)", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384176697", "createdAt": "2020-02-25T22:54:43Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/ConfigConstants.java", "diffHunk": "@@ -209,9 +209,8 @@\n     public static final String OPENDISTRO_SECURITY_COMPLIANCE_SALT = \"opendistro_security.compliance.salt\";\n     public static final String OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT = \"e1ukloTsQlOgPquJ\";//16 chars\n     public static final String OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED  = \"opendistro_security.compliance.history.internal_config_enabled\";\n-\n+    public static final String OPENDISTRO_SECURITY_SSL_CERT_RELOAD = \"opendistro_security.ssl_cert_reload\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MDE1OA==", "bodyText": "why do we need these attributes separately? Can't we read them from cert using ssl library?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384190158", "createdAt": "2020-02-25T23:29:40Z", "author": {"login": "hardik-k-shah"}, "path": "src/test/resources/ssl/reload/node-new.crt.pem", "diffHunk": "@@ -0,0 +1,88 @@\n+Bag Attributes", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NzUwOQ==", "bodyText": "Should we also validate expiry? (expiry of a new cert should be later than old cert)", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384197509", "createdAt": "2020-02-25T23:51:10Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -522,14 +531,43 @@ public SSLEngine createServerTransportSSLEngine() throws SSLException {\n         final SSLEngine engine = transportServerSslContext.newEngine(PooledByteBufAllocator.DEFAULT);\n         engine.setEnabledProtocols(getEnabledSSLProtocols(this.sslTransportServerProvider, false));\n         return engine;\n+    }\n \n+    /**\n+     * Cert Issuer, Subject and Principal DN must be the same\n+     * @param newCerts Array of X509Certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewTransportCerts(final X509Certificate[] newCerts) throws Exception {\n+\n+        // First time we init certs ignore validity check\n+        if (transportCerts == null) {\n+            return;\n+        }\n+\n+        // Check if new X509 certs have been issued by the same Issuer DN - Subject DN - Principal\n+\n+        // Create a sorted array of string with format IssuerDN/SubjectDN/Principal\n+        final List<String> currentCertDNList = Arrays.stream(transportCerts)\n+            .map(c -> c.getIssuerDN()+\"/\"+c.getSubjectDN()+\"/\"+c.getIssuerX500Principal().getName())\n+            .sorted()\n+            .collect(Collectors.toList());\n+        final List<String> newCertDNList = Arrays.stream(newCerts)\n+            .map(c -> c.getIssuerDN()+\"/\"+c.getSubjectDN()+\"/\"+c.getIssuerX500Principal().getName())\n+            .sorted()\n+            .collect(Collectors.toList());\n+\n+        // Both arrays must be equal\n+        if (!currentCertDNList.equals(newCertDNList)) {\n+            throw new Exception(\"DNs of new cert do not match\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 531}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5ODUzMg==", "bodyText": "is it possible to move line 319 to 326 into another function and reuse that code for 344 to avoid duplicity ? You need to handle password requirement with conditions.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384198532", "createdAt": "2020-02-25T23:54:15Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -290,71 +293,77 @@ private void initSSLConfig() {\n                         /*\n                          * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n                          * x509Certificate = transportKeystoreCert[i];\n-                         * \n+                         *\n                          * if(x509Certificate != null) {\n                          * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n                          * getSubjectX500Principal()); } }\n                          */\n                     } else {\n                         throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                            \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                     }\n \n                     final KeyStore ts = KeyStore.getInstance(truststoreType);\n                     ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+                        (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n \n                     final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+                        .exportRootCertificates(ts, truststoreAlias);\n+\n \n                     if (trustedTransportCertificates == null) {\n                         throw new ElasticsearchException(\"No truststore configured for server\");\n                     }\n \n+                    validateNewTransportCerts(transportKeystoreCert);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5OTY1OA==", "bodyText": "We should also see if we can remove duplicity between initTransportCert() and initHTTPCert()", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384199658", "createdAt": "2020-02-25T23:57:10Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -290,71 +293,77 @@ private void initSSLConfig() {\n                         /*\n                          * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n                          * x509Certificate = transportKeystoreCert[i];\n-                         * \n+                         *\n                          * if(x509Certificate != null) {\n                          * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n                          * getSubjectX500Principal()); } }\n                          */\n                     } else {\n                         throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                            \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                     }\n \n                     final KeyStore ts = KeyStore.getInstance(truststoreType);\n                     ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+                        (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n \n                     final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+                        .exportRootCertificates(ts, truststoreAlias);\n+\n \n                     if (trustedTransportCertificates == null) {\n                         throw new ElasticsearchException(\"No truststore configured for server\");\n                     }\n \n+                    validateNewTransportCerts(transportKeystoreCert);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5ODUzMg=="}, "originalCommit": null, "originalPosition": 260}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NDE2MzU1", "url": "https://github.com/opensearch-project/security/pull/238#pullrequestreview-364416355", "createdAt": "2020-02-25T20:13:01Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMDoxMzowMVrOFuTpbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjoyOTo0OFrOFwEp_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMDcxNg==", "bodyText": "Shouldn't the name of this class be similar to API \"NodeCertsInfoAction\" (with plural \"Certs\") ?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384100716", "createdAt": "2020-02-25T20:13:01Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMzExNA==", "bodyText": "Same question as in previous action. Shouldn't \"Cert\" be plural in the name to keep it consistent with the API url?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384103114", "createdAt": "2020-02-25T20:17:54Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNTUxMA==", "bodyText": "You removed the check \".length > 0\". Why ? Shouldn't we throw exceptions if \"transportKeystoreCert\" is empty ( [] ) ?\nSimilar comment for the other \"if\" blocks where you removed \"length > 0\" checks.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384135510", "createdAt": "2020-02-25T21:26:11Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +231,319 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0MTM4Mw==", "bodyText": "Needs review", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384141383", "createdAt": "2020-02-25T21:38:22Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +231,319 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                try {\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n                 }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+                validateNewTransportCerts(transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n             }\n-        }\n \n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+\n+                validateNewTransportCerts(transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0NTQxOA==", "bodyText": "Do we need some logging ? is this the right exceptio n?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384145418", "createdAt": "2020-02-25T21:46:08Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +231,319 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                try {\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n                 }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+                validateNewTransportCerts(transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n             }\n-        }\n \n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+\n+                validateNewTransportCerts(transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);\n+                transportServerSslContext = buildSSLServerContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-        if (!client && httpSSLEnabled) {\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n+                + \" must be set if transport ssl is reqested.\");\n+        }\n+    }\n \n-            final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                    null);\n-            final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n-                    null);\n-            final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n+    /**\n+     * Initializes certs used for client https communication\n+     */\n+    private void initHttpCerts() {\n+        final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+            null);\n+        final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n+            null);\n+        final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n \n-            if (rawKeystoreFilePath != null) {\n+        if (rawKeystoreFilePath != null) {\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n-\n-                log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n-                            + \" must be set if https is reqested.\");\n-                }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n-                        throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n-                                + \" must be set if http ssl and client auth is reqested.\");\n-                    }\n \n-                }\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n \n-                try {\n+            log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n-                        ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                : keystorePassword.toCharArray());\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n+                    + \" must be set if https is reqested.\");\n+            }\n \n-                    final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n \n-                    if (httpKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n+                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n+                        + \" must be set if http ssl and client auth is reqested.\");\n+                }\n \n-                    if (httpKeystoreCert != null && httpKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < httpKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = httpKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"HTTP keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            }\n \n-                    X509Certificate[] trustedHTTPCertificates = null;\n+            try {\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n+                    ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+                }\n \n-                        final String truststoreFilePath = resolve(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n+                final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n \n-                        final String truststoreType = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n-                        final String truststorePassword = settings.get(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n-                                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                        final String truststoreAlias = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+                if (httpKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                        final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                        try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n-                            ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n-                        }\n-                        trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n-                    }\n+                if (httpKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+                X509Certificate[] trustedHTTPCertificates = null;\n \n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n-                            e);\n-                }\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n \n-            } else if (rawPemCertFilePath != null) {\n+                    final String truststoreFilePath = resolve(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n \n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n-                        false);\n+                    final String truststoreType = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n+                    final String truststorePassword = settings.get(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n+                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+                    final String truststoreAlias = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                    try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n+                        ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n+                    }\n+                    trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                }\n \n-                    // if(trustedCas == null ||\n-                    // trustedCas.equals(env.config-File().toAbsolutePath().toString())) {\n-                    // throw new\n-                    // ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH\n-                    // + \" must be set if http ssl and client auth is reqested.\");\n-                    // }\n+                httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n \n-                    checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n+                    e);\n+            }\n \n-                }\n+        } else if (rawPemCertFilePath != null) {\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n+                false);\n \n-                try {\n-                    httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            trustedCas == null ? null : new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n-                }\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n-                        + \" must be set if http ssl is reqested.\");\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+\n+            try {\n+                httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n+                    trustedCas == null ? null : new File(trustedCas),\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n             }\n \n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n+                + \" must be set if http ssl is reqested.\");\n         }\n     }\n \n-    public SSLEngine createHTTPSSLEngine() throws SSLException {\n+    /**\n+     * Cert Issuer, Subject and Principal DN must be the same\n+     * @param newCerts Array of X509Certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewTransportCerts(final X509Certificate[] newCerts) throws Exception {\n+\n+        // First time we init certs ignore validity check\n+        if (transportCerts == null) {\n+            return;\n+        }\n+\n+        // Check if new X509 certs have been issued by the same Issuer DN - Subject DN - Principal\n+\n+        // Create a sorted array of string with format IssuerDN/SubjectDN/Principal\n+        final List<String> currentCertDNList = Arrays.stream(transportCerts)\n+            .map(c -> c.getIssuerDN()+\"/\"+c.getSubjectDN()+\"/\"+c.getIssuerX500Principal().getName())\n+            .sorted()\n+            .collect(Collectors.toList());\n+        final List<String> newCertDNList = Arrays.stream(newCerts)\n+            .map(c -> c.getIssuerDN()+\"/\"+c.getSubjectDN()+\"/\"+c.getIssuerX500Principal().getName())\n+            .sorted()\n+            .collect(Collectors.toList());\n+\n+        // Both arrays must be equal\n+       if (!currentCertDNList.equals(newCertDNList)) {\n+           throw new Exception(\"DNs of new cert do not match\");\n+       }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 580}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0NjIzOQ==", "bodyText": "Seeing second time", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384146239", "createdAt": "2020-02-25T21:47:49Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +231,319 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                try {\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n                 }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+                validateNewTransportCerts(transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNTEzNw==", "bodyText": "Do we need to check isDisabled and isSSLOnlyMode here ?\nIn the constructor of the class you already set \"sslCertReloadEnabled = false\" if any of the above flags are true.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385915137", "createdAt": "2020-02-28T20:48:34Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -207,28 +210,40 @@ private static boolean isDisabled(final Settings settings) {\n     private static boolean isSslOnlyMode(final Settings settings) {\n         return settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_ONLY, false);\n     }\n-    \n+\n+    /**\n+     * SSL Cert Reload will be enabled only if security is not disabled and not in we are not using sslOnly mode.\n+     * @param settings Elastic configuration settings\n+     * @return true if ssl cert reload is enabled else false\n+     */\n+    private static boolean isSslCertReloadEnabled(final Settings settings) {\n+        return !isDisabled(settings) && !isSslOnlyMode(settings) && settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_CERT_RELOAD_ENABLED, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzMjA1NQ==", "bodyText": "minor: I would name this with \"..Certs..\" (plural), similar to the api \"../certs\" .\nSimilar comment for the other Action classes and test classes.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385932055", "createdAt": "2020-02-28T21:32:25Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLCertInfoAction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get SSL certificate information related to http and transport encryption.\n+ * Only super admin users are allowed to access this API.\n+ * Currently this action serves GET request for _opendistro/_security/api/ssl/certs endpoint\n+ */\n+public class OpenDistroSecuritySSLCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public OpenDistroSecuritySSLCertInfoAction(final Settings settings,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNDkxNw==", "bodyText": "Shouldn't this be cert.getNotAfter() != null ?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385934917", "createdAt": "2020-02-28T21:39:58Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLCertInfoAction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get SSL certificate information related to http and transport encryption.\n+ * Only super admin users are allowed to access this API.\n+ * Currently this action serves GET request for _opendistro/_security/api/ssl/certs endpoint\n+ */\n+public class OpenDistroSecuritySSLCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public OpenDistroSecuritySSLCertInfoAction(final Settings settings,\n+                                               final RestController restController,\n+                                               final OpenDistroSecurityKeyStore odsks,\n+                                               final ThreadPool threadPool,\n+                                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/api/ssl/certs\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch transport certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/api/ssl/certs\n+     *\n+     * Sample response:\n+     * {\n+     *   \"http_certificates_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=transport-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *  \"transport_certificates_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=transport-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *      }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+\n+                // Check for Super admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN, builder);\n+                } else {\n+                    try {\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            builder.startObject();\n+                            builder.field(\"http_certificates_list\", generateCertDetailList(odsks.getHttpCerts()));\n+                            builder.field(\"transport_certificates_list\", generateCertDetailList(odsks.getTransportCerts()));\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.OK, builder);\n+                        } else {\n+                            builder.startObject();\n+                            builder.field(\"message\", \"keystore is not initialized\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                        }\n+                    } catch (final Exception e1) {\n+                        log.error(\"Error handle request \" + e1, e1);\n+                        builder = channel.newBuilder();\n+                        builder.startObject();\n+                        builder.field(\"error\", e1.toString());\n+                        builder.endObject();\n+                        response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                    } finally {\n+                        if (builder != null) {\n+                            builder.close();\n+                        }\n+                    }\n+                }\n+                channel.sendResponse(response);\n+            }\n+\n+            /**\n+             * Helper that construct list of certificate details.\n+             * @param certs list of certificates.\n+             * @return Array containing certificate details.\n+             */\n+            private List<Map<String, String>> generateCertDetailList(final X509Certificate[] certs) {\n+                if (certs == null) {\n+                    return null;\n+                }\n+                return Arrays.stream(certs)\n+                    .map(cert -> {\n+                        final String issuerDn = cert != null && cert.getIssuerX500Principal() != null ? cert.getIssuerX500Principal().getName(): \"\";\n+                        final String subjectDn = cert != null && cert.getSubjectX500Principal() != null ? cert.getSubjectX500Principal().getName(): \"\";\n+                        final String notBefore = cert != null && cert.getNotBefore() != null ? cert.getNotBefore().toInstant().toString(): \"\";\n+                        final String notAfter = cert != null && cert.getIssuerX500Principal() != null ? cert.getNotAfter().toInstant().toString(): \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNjkyNw==", "bodyText": "You might want to convert this string to lowercase \".toLowerCase()\". And in case if there is any way to send parameters with spaces at the beginning or end of string, you might also consider using \".trim()\".", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385936927", "createdAt": "2020-02-28T21:45:23Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLReloadCertAction.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.DefaultObjectMapper;\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.dlic.rest.support.Utils;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reload SSL certificates.\n+ * Can be used to reload SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * To keep sensitive certificate reload secure, this API will only allow hot reload\n+ * with certificates issued by the same Issuer and Subject DN with expiry dates after the current one.\n+ * Currently this action serves PUT request for /_opendistro/_security/ssl/http/reloadcerts or /_opendistro/_security/ssl/transport/reloadcerts endpoint\n+ */\n+public class OpenDistroSecuritySSLReloadCertAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public OpenDistroSecuritySSLReloadCertAction(final Settings settings,\n+                                                 final RestController restController,\n+                                                 final OpenDistroSecurityKeyStore odsks,\n+                                                 final ThreadPool threadPool,\n+                                                 final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"_opendistro/_security/api/ssl/{certType}/reloadcerts/\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/api/ssl/transport/reloadcerts\n+     * PUT _opendistro/_security/api/ssl/http/reloadcerts\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated http certs\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            final String certType = request.param(\"certType\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzg1NA==", "bodyText": "Can we test some exceptions to see what information are we exposing ? (Similar for the other action)", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385937854", "createdAt": "2020-02-28T21:47:52Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLReloadCertAction.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.DefaultObjectMapper;\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.dlic.rest.support.Utils;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reload SSL certificates.\n+ * Can be used to reload SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * To keep sensitive certificate reload secure, this API will only allow hot reload\n+ * with certificates issued by the same Issuer and Subject DN with expiry dates after the current one.\n+ * Currently this action serves PUT request for /_opendistro/_security/ssl/http/reloadcerts or /_opendistro/_security/ssl/transport/reloadcerts endpoint\n+ */\n+public class OpenDistroSecuritySSLReloadCertAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public OpenDistroSecuritySSLReloadCertAction(final Settings settings,\n+                                                 final RestController restController,\n+                                                 final OpenDistroSecurityKeyStore odsks,\n+                                                 final ThreadPool threadPool,\n+                                                 final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"_opendistro/_security/api/ssl/{certType}/reloadcerts/\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/api/ssl/transport/reloadcerts\n+     * PUT _opendistro/_security/api/ssl/http/reloadcerts\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated http certs\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            final String certType = request.param(\"certType\");\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+\n+                // Check for Super admin user\n+                final User user = (User) threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user ==null||!adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN, \"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        if (odsks != null) {\n+                            switch (certType) {\n+                                case \"http\":\n+                                    odsks.initHttpSSLConfig();\n+                                    builder.field(\"message\", \"updated http certs\");\n+                                    builder.endObject();\n+                                    response = new BytesRestResponse(RestStatus.OK, builder);\n+                                    break;\n+                                case \"transport\":\n+                                    odsks.initTransportSSLConfig();\n+                                    builder.field(\"message\", \"updated transport certs\");\n+                                    builder.endObject();\n+                                    response = new BytesRestResponse(RestStatus.OK, builder);\n+                                    break;\n+                                default:\n+                                    builder.field(\"message\", \"invalid uri path, please use /_opendistro/_security/api/ssl/http/reload or \" +\n+                                        \"/_opendistro/_security/api/ssl/transport/reload\");\n+                                    builder.endObject();\n+                                    response = new BytesRestResponse(RestStatus.FORBIDDEN, builder);\n+                                    break;\n+                            }\n+                        } else {\n+                            builder.field(\"message\", \"keystore is not initialized\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                        }\n+                    } catch (final Exception e1) {\n+                        builder = channel.newBuilder();\n+                        builder.startObject();\n+                        builder.field(\"error\", e1.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NzgzMw==", "bodyText": "What if currentX509Certs is an empty list ?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385947833", "createdAt": "2020-02-28T22:16:48Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -223,313 +229,374 @@ private void initSSLConfig() {\n             log.info(\"No config directory, key- and truststore files are resolved absolutely\");\n         } else {\n             log.info(\"Config directory is {}/, from there the key- and truststore files are resolved relatively\",\n-                    env.configFile().toAbsolutePath());\n+                env.configFile().toAbsolutePath());\n         }\n \n+\n         if (transportSSLEnabled) {\n+            initTransportSSLConfig();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-            if (rawKeyStoreFilePath != null) {\n+        if (!client && httpSSLEnabled) {\n+            initHttpSSLConfig();\n+        }\n+    }\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    public void initTransportSSLConfig() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+\n+        if (rawKeyStoreFilePath != null) {\n+\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n+\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n+\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n+\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                try {\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n+                }\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                validateNewCerts(transportCerts, transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            }\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+\n+                validateNewCerts(transportCerts, transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);\n+                transportServerSslContext = buildSSLServerContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n+                + \" must be set if transport ssl is reqested.\");\n+        }\n+    }\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+    /**\n+     * Initializes certs used for client https communication\n+     */\n+    public void initHttpSSLConfig() {\n+        final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+            null);\n+        final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n+            null);\n+        final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+        if (rawKeystoreFilePath != null) {\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n-                }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-            } else if (rawPemCertFilePath != null) {\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n \n-                try {\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n-                }\n+            log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n+                    + \" must be set if https is reqested.\");\n             }\n-        }\n-\n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-        if (!client && httpSSLEnabled) {\n-\n-            final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                    null);\n-            final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n-                    null);\n-            final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n-\n-            if (rawKeystoreFilePath != null) {\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n-\n-                log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n-                            + \" must be set if https is reqested.\");\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n+                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n+                        + \" must be set if http ssl and client auth is reqested.\");\n                 }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            }\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n-                        throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n-                                + \" must be set if http ssl and client auth is reqested.\");\n-                    }\n+            try {\n \n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n+                    ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n                 }\n \n-                try {\n-\n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n-                        ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                : keystorePassword.toCharArray());\n-                    }\n+                final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n \n-                    final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n-\n-                    if (httpKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    if (httpKeystoreCert != null && httpKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < httpKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = httpKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"HTTP keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    X509Certificate[] trustedHTTPCertificates = null;\n+                X509Certificate[] trustedHTTPCertificates = null;\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n \n-                        final String truststoreFilePath = resolve(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n+                    final String truststoreFilePath = resolve(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n \n-                        final String truststoreType = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n-                        final String truststorePassword = settings.get(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n-                                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                        final String truststoreAlias = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+                    final String truststoreType = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n+                    final String truststorePassword = settings.get(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n+                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+                    final String truststoreAlias = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n \n-                        final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                        try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n-                            ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n-                        }\n-                        trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                    try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n+                        ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n                     }\n-\n-                    httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n-                            e);\n+                    trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                validateNewCerts(httpCerts, httpKeystoreCert);\n+                setHttpSSLCerts(httpKeystoreCert);\n+                httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n \n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n-                        false);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n+                    e);\n+            }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+        } else if (rawPemCertFilePath != null) {\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n+                false);\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            }\n \n-                    // if(trustedCas == null ||\n-                    // trustedCas.equals(env.config-File().toAbsolutePath().toString())) {\n-                    // throw new\n-                    // ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH\n-                    // + \" must be set if http ssl and client auth is reqested.\");\n-                    // }\n+            try {\n+                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n+                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+                final X509Certificate[] httpKeystoreCert = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+                validateNewCerts(httpCerts, httpKeystoreCert);\n+                setHttpSSLCerts(httpKeystoreCert);\n+                httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n+                    trustedCas == null ? null : new File(trustedCas),\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n+                + \" must be set if http ssl is reqested.\");\n+        }\n+    }\n \n-                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+    /**\n+     * For new X509 cert to be valid Issuer, Subject DN must be the same and\n+     * new certificates should expire after current ones.\n+     * @param currentX509Certs  Array of current x509 certificates\n+     * @param newX509Certs      Array of x509 certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewCerts(final X509Certificate[] currentX509Certs, final X509Certificate[] newX509Certs) throws Exception {\n \n-                try {\n-                    httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            trustedCas == null ? null : new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n-                }\n+        // First time we init certs ignore validity check\n+        if (currentX509Certs == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 656}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1MjI1NQ==", "bodyText": "What if \"buildSSLServerContext\" is crashing due to some issue . Do we still want to show this certificate ?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385952255", "createdAt": "2020-02-28T22:29:48Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -223,313 +229,374 @@ private void initSSLConfig() {\n             log.info(\"No config directory, key- and truststore files are resolved absolutely\");\n         } else {\n             log.info(\"Config directory is {}/, from there the key- and truststore files are resolved relatively\",\n-                    env.configFile().toAbsolutePath());\n+                env.configFile().toAbsolutePath());\n         }\n \n+\n         if (transportSSLEnabled) {\n+            initTransportSSLConfig();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-            if (rawKeyStoreFilePath != null) {\n+        if (!client && httpSSLEnabled) {\n+            initHttpSSLConfig();\n+        }\n+    }\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    public void initTransportSSLConfig() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+\n+        if (rawKeyStoreFilePath != null) {\n+\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n+\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n+\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n+\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                try {\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n+                }\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                validateNewCerts(transportCerts, transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 283}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzEwMzkw", "url": "https://github.com/opensearch-project/security/pull/238#pullrequestreview-366710390", "createdAt": "2020-02-28T21:58:29Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMTo1ODoyOVrOFwEA3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjoyMTo1OFrOFwEfrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0MTcyNA==", "bodyText": "will SAN (Subject Alternative name) be a part of subjectDn?  If not, we should add SAN check also.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385941724", "createdAt": "2020-02-28T21:58:29Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -223,313 +229,374 @@ private void initSSLConfig() {\n             log.info(\"No config directory, key- and truststore files are resolved absolutely\");\n         } else {\n             log.info(\"Config directory is {}/, from there the key- and truststore files are resolved relatively\",\n-                    env.configFile().toAbsolutePath());\n+                env.configFile().toAbsolutePath());\n         }\n \n+\n         if (transportSSLEnabled) {\n+            initTransportSSLConfig();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-            if (rawKeyStoreFilePath != null) {\n+        if (!client && httpSSLEnabled) {\n+            initHttpSSLConfig();\n+        }\n+    }\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    public void initTransportSSLConfig() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+\n+        if (rawKeyStoreFilePath != null) {\n+\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n+\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n+\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n+\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                try {\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n+                }\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                validateNewCerts(transportCerts, transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            }\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+\n+                validateNewCerts(transportCerts, transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);\n+                transportServerSslContext = buildSSLServerContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n+                + \" must be set if transport ssl is reqested.\");\n+        }\n+    }\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+    /**\n+     * Initializes certs used for client https communication\n+     */\n+    public void initHttpSSLConfig() {\n+        final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+            null);\n+        final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n+            null);\n+        final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+        if (rawKeystoreFilePath != null) {\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n-                }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-            } else if (rawPemCertFilePath != null) {\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n \n-                try {\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n-                }\n+            log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n+                    + \" must be set if https is reqested.\");\n             }\n-        }\n-\n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-        if (!client && httpSSLEnabled) {\n-\n-            final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                    null);\n-            final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n-                    null);\n-            final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n-\n-            if (rawKeystoreFilePath != null) {\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n-\n-                log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n-                            + \" must be set if https is reqested.\");\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n+                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n+                        + \" must be set if http ssl and client auth is reqested.\");\n                 }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            }\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n-                        throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n-                                + \" must be set if http ssl and client auth is reqested.\");\n-                    }\n+            try {\n \n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n+                    ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n                 }\n \n-                try {\n-\n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n-                        ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                : keystorePassword.toCharArray());\n-                    }\n+                final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n \n-                    final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n-\n-                    if (httpKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    if (httpKeystoreCert != null && httpKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < httpKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = httpKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"HTTP keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    X509Certificate[] trustedHTTPCertificates = null;\n+                X509Certificate[] trustedHTTPCertificates = null;\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n \n-                        final String truststoreFilePath = resolve(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n+                    final String truststoreFilePath = resolve(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n \n-                        final String truststoreType = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n-                        final String truststorePassword = settings.get(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n-                                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                        final String truststoreAlias = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+                    final String truststoreType = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n+                    final String truststorePassword = settings.get(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n+                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+                    final String truststoreAlias = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n \n-                        final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                        try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n-                            ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n-                        }\n-                        trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                    try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n+                        ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n                     }\n-\n-                    httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n-                            e);\n+                    trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                validateNewCerts(httpCerts, httpKeystoreCert);\n+                setHttpSSLCerts(httpKeystoreCert);\n+                httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n \n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n-                        false);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n+                    e);\n+            }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+        } else if (rawPemCertFilePath != null) {\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n+                false);\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            }\n \n-                    // if(trustedCas == null ||\n-                    // trustedCas.equals(env.config-File().toAbsolutePath().toString())) {\n-                    // throw new\n-                    // ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH\n-                    // + \" must be set if http ssl and client auth is reqested.\");\n-                    // }\n+            try {\n+                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n+                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+                final X509Certificate[] httpKeystoreCert = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+                validateNewCerts(httpCerts, httpKeystoreCert);\n+                setHttpSSLCerts(httpKeystoreCert);\n+                httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n+                    trustedCas == null ? null : new File(trustedCas),\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n+                + \" must be set if http ssl is reqested.\");\n+        }\n+    }\n \n-                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+    /**\n+     * For new X509 cert to be valid Issuer, Subject DN must be the same and\n+     * new certificates should expire after current ones.\n+     * @param currentX509Certs  Array of current x509 certificates\n+     * @param newX509Certs      Array of x509 certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewCerts(final X509Certificate[] currentX509Certs, final X509Certificate[] newX509Certs) throws Exception {\n \n-                try {\n-                    httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            trustedCas == null ? null : new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n-                }\n+        // First time we init certs ignore validity check\n+        if (currentX509Certs == null) {\n+            return;\n+        }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n-                        + \" must be set if http ssl is reqested.\");\n-            }\n+        // Check if new X509 certs have valid expiry date\n+        if (!hasValidExpiryDates(currentX509Certs, newX509Certs)) {\n+            throw new Exception(\"New certificates expire before the current ones.\");\n+        }\n \n+        // Check if new X509 certs have valid IssuerDN/SubjectDN\n+        if (!hasValidDNs(currentX509Certs, newX509Certs)) {\n+            throw new Exception(\"New Certs do not have valid Issuer and Subject DN.\");\n         }\n     }\n \n-    public SSLEngine createHTTPSSLEngine() throws SSLException {\n+    /**\n+     * Check if new X509 certs have same IssuerDN/SubjectDN as current certificates.\n+     * @param currentX509Certs Array of current X509Certificates.\n+     * @param newX509Certs Array of new X509Certificates.\n+     * @return true if all Issuer DN and Subject DN pairs match; false otherwise.\n+     * @throws Exception if certificate is invalid.\n+     */\n+    private boolean hasValidDNs(final X509Certificate[] currentX509Certs, final X509Certificate[] newX509Certs) {\n+\n+        final Function<? super X509Certificate, String> formatDNString = cert -> {\n+            final String issuerDn = cert !=null && cert.getIssuerX500Principal() != null ? cert.getIssuerX500Principal().getName() : \"\";\n+            final String subjectDn = cert !=null && cert.getSubjectX500Principal() != null ? cert.getSubjectX500Principal().getName() : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 688}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0OTYxMg==", "bodyText": "We should also add SAN field.", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385949612", "createdAt": "2020-02-28T22:21:58Z", "author": {"login": "hardik-k-shah"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLCertInfoAction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get SSL certificate information related to http and transport encryption.\n+ * Only super admin users are allowed to access this API.\n+ * Currently this action serves GET request for _opendistro/_security/api/ssl/certs endpoint\n+ */\n+public class OpenDistroSecuritySSLCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public OpenDistroSecuritySSLCertInfoAction(final Settings settings,\n+                                               final RestController restController,\n+                                               final OpenDistroSecurityKeyStore odsks,\n+                                               final ThreadPool threadPool,\n+                                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/api/ssl/certs\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch transport certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/api/ssl/certs\n+     *\n+     * Sample response:", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzY2MzMy", "url": "https://github.com/opensearch-project/security/pull/238#pullrequestreview-366766332", "createdAt": "2020-02-29T01:40:04Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwMTo0MDowNVrOFwG6Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwMTo0MDowNVrOFwG6Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4OTE0Mg==", "bodyText": "Earlier we were allowing transport client creation with an empty truststore file. I added a stronger validation for truststore validation so right now we will prevent transport client and OpenDistroPlugin will not load, hence cause this IllegalStateException", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385989142", "createdAt": "2020-02-29T01:40:05Z", "author": {"login": "debjanibnrj"}, "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/ssl/SSLTest.java", "diffHunk": "@@ -633,7 +633,7 @@ public void testNodeClientSSL() throws Exception {\n \n     @Test\n     public void testTransportClientSSLFail() throws Exception {\n-        thrown.expect(NoNodeAvailableException.class);\n+        thrown.expect(IllegalStateException.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Nzc3Mzcw", "url": "https://github.com/opensearch-project/security/pull/238#pullrequestreview-366777370", "createdAt": "2020-02-29T04:51:07Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNDo1MTowOFrOFwHpbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNDo1Mzo0M1rOFwHp5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwMTI2Mg==", "bodyText": "You don't need to check if it's non-null, since you already checked it in the first part.\nJava will only execute the second part of \"OR\" only if the first condition is true.\n(trustedTransportCertificates == null || trustedTransportCertificates.length == 0", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r386001262", "createdAt": "2020-02-29T04:51:08Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -223,313 +230,385 @@ private void initSSLConfig() {\n             log.info(\"No config directory, key- and truststore files are resolved absolutely\");\n         } else {\n             log.info(\"Config directory is {}/, from there the key- and truststore files are resolved relatively\",\n-                    env.configFile().toAbsolutePath());\n+                env.configFile().toAbsolutePath());\n         }\n \n+\n         if (transportSSLEnabled) {\n+            initTransportSSLConfig();\n+        }\n+\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpSSLConfig();\n+        }\n+    }\n \n-            if (rawKeyStoreFilePath != null) {\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    public void initTransportSSLConfig() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+\n+        if (rawKeyStoreFilePath != null) {\n+\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n+\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n+\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+                if (transportKeystoreCert == null || (transportKeystoreCert != null && transportKeystoreCert.length == 0)) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                try {\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                if (trustedTransportCertificates == null || (trustedTransportCertificates != null && trustedTransportCertificates.length == 0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 279}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwMTM4MA==", "bodyText": "This doesn't seem to do anything. Is this intended to just print an exception and continue ? Did you plan to stop executing the code that follows after this? Also, should it be print or logging.error(..) ?", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r386001380", "createdAt": "2020-02-29T04:53:43Z", "author": {"login": "dinusX"}, "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLCertsInfoAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.CertificateParsingException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get SSL certificate information related to http and transport encryption.\n+ * Only super admin users are allowed to access this API.\n+ * Currently this action serves GET request for _opendistro/_security/api/ssl/certs endpoint\n+ */\n+public class OpenDistroSecuritySSLCertsInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public OpenDistroSecuritySSLCertsInfoAction(final Settings settings,\n+                                                final RestController restController,\n+                                                final OpenDistroSecurityKeyStore odsks,\n+                                                final ThreadPool threadPool,\n+                                                final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/api/ssl/certs\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch transport certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/api/ssl/certs\n+     *\n+     * Sample response:\n+     * {\n+     *   \"http_certificates_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=transport-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *  \"transport_certificates_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=transport-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *      }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+\n+                // Check for Super admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN, builder);\n+                } else {\n+                    try {\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            builder.startObject();\n+                            builder.field(\"http_certificates_list\", generateCertDetailList(odsks.getHttpCerts()));\n+                            builder.field(\"transport_certificates_list\", generateCertDetailList(odsks.getTransportCerts()));\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.OK, builder);\n+                        } else {\n+                            builder.startObject();\n+                            builder.field(\"message\", \"keystore is not initialized\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                        }\n+                    } catch (final Exception e1) {\n+                        log.error(\"Error handle request \" + e1, e1);\n+                        builder = channel.newBuilder();\n+                        builder.startObject();\n+                        builder.field(\"error\", e1.toString());\n+                        builder.endObject();\n+                        response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                    } finally {\n+                        if (builder != null) {\n+                            builder.close();\n+                        }\n+                    }\n+                }\n+                channel.sendResponse(response);\n+            }\n+\n+            /**\n+             * Helper that construct list of certificate details.\n+             * @param certs list of certificates.\n+             * @return Array containing certificate details.\n+             */\n+            private List<Map<String, String>> generateCertDetailList(final X509Certificate[] certs) {\n+                if (certs == null) {\n+                    return null;\n+                }\n+                return Arrays.stream(certs)\n+                    .map(cert -> {\n+                        final String issuerDn = cert != null && cert.getIssuerX500Principal() != null ? cert.getIssuerX500Principal().getName(): \"\";\n+                        final String subjectDn = cert != null && cert.getSubjectX500Principal() != null ? cert.getSubjectX500Principal().getName(): \"\";\n+\n+                        try {\n+                            Collection<List<?>> sans = cert.getSubjectAlternativeNames();\n+                        } catch (CertificateParsingException e) {\n+                            e.printStackTrace();\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 151}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MjA1NTcx", "url": "https://github.com/opensearch-project/security/pull/238#pullrequestreview-368205571", "createdAt": "2020-03-03T18:07:15Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c585c238ea4f2db20ea5a6442a9cad5adf12ae4c", "author": {"user": {"login": "debjanibnrj", "name": "Debjani Banerjee"}}, "url": "https://github.com/opensearch-project/security/commit/c585c238ea4f2db20ea5a6442a9cad5adf12ae4c", "committedDate": "2020-03-03T18:46:30Z", "message": "Adding capability to hot reload ssl certificates\n        * Added api PUT /_opendistro/_security/ssl/{certType}/reloadcerts which reinitializes http or transport keystore\n        * Added api GET /_opendistro/_security/ssl/certs which returns public key details for http and transport certificates\n        * Updated DefaultODSKeyStore to update, set and get http and transport layer certificates\n        * Added unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MzAwMzI5", "url": "https://github.com/opensearch-project/security/pull/238#pullrequestreview-368300329", "createdAt": "2020-03-03T20:28:35Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "c585c238ea4f2db20ea5a6442a9cad5adf12ae4c", "author": {"user": {"login": "debjanibnrj", "name": "Debjani Banerjee"}}, "url": "https://github.com/opensearch-project/security/commit/c585c238ea4f2db20ea5a6442a9cad5adf12ae4c", "committedDate": "2020-03-03T18:46:30Z", "message": "Adding capability to hot reload ssl certificates\n        * Added api PUT /_opendistro/_security/ssl/{certType}/reloadcerts which reinitializes http or transport keystore\n        * Added api GET /_opendistro/_security/ssl/certs which returns public key details for http and transport certificates\n        * Updated DefaultODSKeyStore to update, set and get http and transport layer certificates\n        * Added unit tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2992, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}