{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNzcyODU3", "number": 1384, "title": "[SDL-0301] SDL Device Listener", "bodyText": "Fixes #1348\nThis PR is ready for review.\nRisk\nThis PR makes minor API changes.\nTesting Plan\n\n I have verified that I have not introduced new warnings in this PR (or explain why below)\n I have run the unit tests with this PR\n I have tested this PR against a  TDK and verified behavior (if applicable, if not applicable, explain why below).\n I have tested Android. Java SE, and Java EE are unaffected\n\nUnit Tests\n\nSmoke tests are the most important piece of this PR. It is difficult to simulate much of the transport sequence so in depth tests have been provided here. Most of the logic also occurs privately.\n\nSmoke Tests\nBasic Functionality Tests\nFirst Connection (Success)\n\nTurn bluetooth off on phone.\nInstall Hello SDL and ensure it is the only SDL app installed.\nMake sure to clear storage for Hello SDL under settings.\nTurn on bluetooth adapter on phone.\nAllow BT to connect (A2DP); pair with IVI if necessary.\nObserve through logs that the SDL Listener was started and is currently listening on an RFCOMM channel.\nIVI should connect with SDL Listener's RFCOMM channel, this will cause the listener to close the connection and attempt to start the router service.\nObserve the router service notification appears as an indication the service has started\nThe IVI should hopefully then connect with the router service's RFCOMM channel and the normal connection flow should occur.\n\nSecond Connection When First Connection was Successful\n\nEnsure bluetooth is off on phone after performing the first test.\nEnsure only hello SDL app is installed.\nTurn on bluetooth adapter on phone and observe that the BT A2DP profile connects.\nAfter the previous step, the router service should immediately start and its notification should be shown in the notification tray.\nThe IVI should hopefully then connect with the router service's RFCOMM channel and the normal connection flow should occur.\n\nSecond Connection When First Connection was NOT Successful\n\nEnsure bluetooth is off on phone after performing the first test.\nEnsure only hello SDL app is installed.\nTurn on bluetooth adapter on phone and observe that the BT A2DP profile connects.\nObserve through logs that the SDL Listener was started and is currently listening on an RFCOMM channel, however, on the subsequent calls this class will only listen for 15 seconds.\nEither of two scenarios will occur:\n\nIf the IVI system does not connect, the listener should close itself and no service should be started.\nIf the IVI system does connect to the SDL Device Listener's RFCOMM channel, the flow should be as described in Test 1 Starting at Step 7.\n\n\n\nTest with Non SDL Device (Bluetooth headphones)\n\nTurn bluetooth off on phone.\nInstall Hello SDL and ensure it is the only SDL app installed.\nMake sure to clear storage for Hello SDL under settings.\nTurn on bluetooth adapter on phone.\nAllow BT to connect (A2DP); pair with IVI if necessary.\nObserve through logs that the SDL Listener was started and is currently listening on an RFCOMM channel.\nAfter 30 seconds, observer through logs that the SDL Device Listener didn't successfully connect its RFCOMM channel with the connected BT device and has closed down.\nDisconnect or turn off the non-SDL Device (headphones)\nTurn on the non-SDL device and repeat steps 6-8. This time step 7 should be 15 seconds.\n\nMultiple App Tests\nHello SDL and app with library version 4.11.1\n\nTurn off bluetooth on the phone\nAdd a log message in the SdlBroadcastReceiver in the method wakeUpRouterService. This should go after the synchronized call on DEVICE_LISTENER_LOCK. After this lock, the code will only continue past if the SDL Device Listener feature is unable to be used.\nInstall Hello SDL and a second debugging app.\n\nEnsure the second app has the SDL library version of 4.11.1. This is to ensure it has a router service version that is less than 13. In 4.11.1 it should be 12\n\n\nTurn on bluetooth adapter on phone, pair with IVI system if necessary, and then observe that the BT A2DP profile connects.\nObserve the phone logs to see the previously added log is printed out and the router service is started. This indicates the SDL Device Listener feature is skipped because of older app library behavior.\n\nHello SDL and second app with this branch\nThis test should be ran multiple times\n\nTurn off bluetooth on the phone and turn on the IVI system\nInstall Hello SDL and a second debugging app.\n\nEnsure the second app is built using this branch.\n\n\nClear storage and cache for both apps\nTurn on bluetooth adapter on phone, pair with IVI system if necessary, and then observe that the BT A2DP profile connects.\nObserve that only one of the two apps starts an instance of SDL Device Listener\nEither of two scenarios will occur:\n1. If the IVI system does not connect, the listener should close itself and no service should be started.\n2. If the IVI system does connect to the SDL Device Listener's RFCOMM channel, the flow should be as described in Test 1 Starting at Step 7.\n\nHello SDL and second app with this branch but newer router service\n\nTurn off bluetooth on the phone and turn on the IVI system\nInstall Hello SDL and a second debugging app.\n\nEnsure the second app is built using this branch.\nChange the manifest router service version to greater than or equal to 14\n\n\nClear storage and cache for both apps\nTurn on bluetooth adapter on phone, pair with IVI system if necessary, and then observe that the BT A2DP profile connects.\nObserve that the second app starts an instance of SDL Device Listener\nEither of two scenarios will occur:\n1. If the IVI system does not connect, the listener should close itself and no service should be started.\n2. If the IVI system does connect to the SDL Device Listener's RFCOMM channel, the flow should be as described in Test 1 Starting at Step 7.\n\nHello SDL and second app with this branch, save successful connection\n\nTurn off bluetooth on the phone and turn on the IVI system\nInstall Hello SDL and a second debugging app.\n\nEnsure the second app is built using this branch.\n\n\nClear storage and cache for both apps\nTurn on bluetooth adapter on phone, pair with IVI system if necessary, and then observe that the BT A2DP profile connects.\nObserve that only one of the two apps starts an instance of SDL Device Listener\nEither of two scenarios will occur:\n1. If the IVI system does not connect, the listener should close itself and no service should be started.\n2. If the IVI system does connect to the SDL Device Listener's RFCOMM channel, the flow should be as described in Test 1 Starting at Step 7.\nTake note of which app started the SDL Device Listener and the SDL router service.\nTurn off bluetooth on the phone.\nUninstall the app that started the SDL Device Listener and SDL Router Service\nTurn on bluetooth adapter on phone and observe that the BT A2DP profile connects.\nAfter the previous step, the router service should immediately start and its notification should be shown in the notification tray.\nThe IVI should hopefully then connect with the router service's RFCOMM channel and the normal connection flow should occur.\n\nAdditional Test Considerations\n\nShould test USB connection works as expected still as a sanity check. The logic for starting the router service for USB are not directly affected, but still important to check.\n\nSummary\nWith this implementation the router service should not start until the bluetooth device has been confirmed to be an SDL device. This is done by opening an RFCOMM channel from the broadcast receiver that listens first. Only after a successful connection there will it start the router service. The caveat to this feature is that it is breaking behavior from previous library versions. Therefore, a check must be done against all other SDL apps that they have been updated to this version of the router service. If they have not, the old flow will continue, but if they are this feature will be enabled.\nChangelog\nEnhancements\n\nSdlDeviceListener class was added and implemented in supporting proposal SDL-0301\n\nCLA\n\n I have signed the CLA", "createdAt": "2020-06-12T16:14:17Z", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384", "merged": true, "mergeCommit": {"oid": "b85d06a5abf7c0a4d111fd8b7c5f4128d8cc27d4"}, "closed": true, "closedAt": "2020-06-29T14:35:10Z", "author": {"login": "joeygrover"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqkO9AgH2gAyNDMzNzcyODU3Ojg4ZGY2NWQ0ZTdhYjdiZmE2ZmNiODcyMzNlMzliMGUwOWJiOWRkMGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwCAOPAFqTQzOTIwNzIwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "88df65d4e7ab7bfa6fcb87233e39b0e09bb9dd0a", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/88df65d4e7ab7bfa6fcb87233e39b0e09bb9dd0a", "committedDate": "2020-06-12T15:03:49Z", "message": "Limit exception stacktrace print in BT transport"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfcdd324cdb9a2a84e237726ca6032d96f4cced0", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/dfcdd324cdb9a2a84e237726ca6032d96f4cced0", "committedDate": "2020-06-12T15:04:17Z", "message": "Increment router service version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1aa070be0804493907d2852a98b887b5c0b65398", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/1aa070be0804493907d2852a98b887b5c0b65398", "committedDate": "2020-06-12T15:04:57Z", "message": "Add SdlDeviceListener"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7306e2b8100d047a72dc3637d0ac3ac01c787a0e", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/7306e2b8100d047a72dc3637d0ac3ac01c787a0e", "committedDate": "2020-06-12T15:05:04Z", "message": "Implement SdlDeviceListener"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01a47b11cc3abe1185177bd0d6f9a1c260ac09ae", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/01a47b11cc3abe1185177bd0d6f9a1c260ac09ae", "committedDate": "2020-06-12T15:21:50Z", "message": "Make RS go to foreground if confirmed device"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ddcd5851ea909915d2d6bfeeb54358fc78e0555", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3ddcd5851ea909915d2d6bfeeb54358fc78e0555", "committedDate": "2020-06-12T15:32:22Z", "message": "Merge branch 'develop' of https://github.com/smartdevicelink/sdl_android into feature/sdl_0301_sdl_device_listener"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba9d5518690be28c82ae94b0d188343c75c39a4a", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ba9d5518690be28c82ae94b0d188343c75c39a4a", "committedDate": "2020-06-12T16:13:48Z", "message": "Update formatting in SdlDeviceListener"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2ODEwNDgx", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#pullrequestreview-436810481", "createdAt": "2020-06-24T16:25:27Z", "commit": {"oid": "ba9d5518690be28c82ae94b0d188343c75c39a4a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNjoyNToyN1rOGoZysQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOToxMjowN1rOGofibw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxODgwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param address the mac address of the device in quesiton\n          \n          \n            \n                 * @param address the mac address of the device in question", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#discussion_r445018801", "createdAt": "2020-06-24T16:25:27Z", "author": {"login": "bilal-alsharifi"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/transport/utl/SdlDeviceListener.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+\n+package com.smartdevicelink.transport.utl;\n+\n+import android.bluetooth.BluetoothDevice;\n+import android.content.Context;\n+import android.content.SharedPreferences;\n+import android.os.Handler;\n+import android.os.Looper;\n+import android.os.Message;\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.transport.MultiplexBaseTransport;\n+import com.smartdevicelink.transport.MultiplexBluetoothTransport;\n+import com.smartdevicelink.transport.SdlRouterService;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.SdlAppInfo;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+\n+\n+public class SdlDeviceListener {\n+\n+    private static final String TAG = \"SdlListener\";\n+    private static final int MIN_VERSION_REQUIRED = 13;\n+    private static final String SDL_DEVICE_STATUS_SHARED_PREFS = \"sdl.device.status\";\n+    private static final Object LOCK = new Object(), RUNNING_LOCK = new Object();\n+\n+    private final WeakReference<Context> contextWeakReference;\n+    private final Callback callback;\n+    private final BluetoothDevice connectedDevice;\n+    private MultiplexBluetoothTransport bluetoothTransport;\n+    private TransportHandler bluetoothHandler;\n+    private Handler timeoutHandler;\n+    private Runnable timeoutRunner;\n+    private boolean isRunning = false;\n+\n+\n+    public SdlDeviceListener(Context context, BluetoothDevice device, Callback callback) {\n+        this.contextWeakReference = new WeakReference<>(context);\n+        this.connectedDevice = device;\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * This will start the SDL Device Listener with two paths. The first path will be a check\n+     * against the supplied bluetooth device to see if it has already successfully connected as an\n+     * SDL device. If it has, the supplied callback will be called immediately. If the device hasn't\n+     * connected as an SDL device before, the SDL Device Listener will then open up an RFCOMM channel\n+     * using the SDL UUID and await a potential connection. A timeout is used to ensure this only\n+     * listens for a finite amount of time. If this is the first time the device has been seen, this\n+     * will listen for 30 seconds, if it is not, this will listen for 15 seconds instead.\n+     */\n+    public void start() {\n+        if (hasSDLConnected(contextWeakReference.get(), connectedDevice.getAddress())) {\n+            DebugTool.logInfo(TAG + \": Confirmed SDL device, should start router service\");\n+            //This device has connected to SDL previously, it is ok to start the RS right now\n+            callback.onTransportConnected(contextWeakReference.get(), connectedDevice);\n+            return;\n+        }\n+        synchronized (RUNNING_LOCK) {\n+            isRunning = true;\n+            // set timeout = if first time seeing BT device, 30s, if not 15s\n+            int timeout = isFirstStatusCheck(connectedDevice.getAddress()) ? 30000 : 15000;\n+            //Set our preference as false for this device for now\n+            setSDLConnectedStatus(contextWeakReference.get(), connectedDevice.getAddress(), false);\n+            bluetoothHandler = new TransportHandler(this);\n+            bluetoothTransport = new MultiplexBluetoothTransport(bluetoothHandler);\n+            bluetoothTransport.start();\n+            timeoutRunner = new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (bluetoothTransport != null) {\n+                        int state = bluetoothTransport.getState();\n+                        if (state != MultiplexBluetoothTransport.STATE_CONNECTED) {\n+                            DebugTool.logInfo(TAG + \": No bluetooth connection made\");\n+                            bluetoothTransport.stop();\n+                        } //else BT is connected; it will close itself through callbacks\n+                    }\n+                }\n+            };\n+            timeoutHandler = new Handler(Looper.getMainLooper());\n+            timeoutHandler.postDelayed(timeoutRunner, timeout);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if this instance is in the middle of running or not\n+     *\n+     * @return if this is already in the process of running\n+     */\n+    public boolean isRunning() {\n+        synchronized (RUNNING_LOCK) {\n+            return isRunning;\n+        }\n+    }\n+\n+    private static class TransportHandler extends Handler {\n+\n+        final WeakReference<SdlDeviceListener> provider;\n+\n+        TransportHandler(SdlDeviceListener provider) {\n+            this.provider = new WeakReference<>(provider);\n+        }\n+\n+        @Override\n+        public void handleMessage(@NonNull Message msg) {\n+            if (this.provider.get() == null) {\n+                return;\n+            }\n+            SdlDeviceListener sdlListener = this.provider.get();\n+            switch (msg.what) {\n+\n+                case SdlRouterService.MESSAGE_STATE_CHANGE:\n+                    switch (msg.arg1) {\n+                        case MultiplexBaseTransport.STATE_CONNECTED:\n+                            sdlListener.setSDLConnectedStatus(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice.getAddress(), true);\n+                            boolean keepConnectionOpen = sdlListener.callback.onTransportConnected(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice);\n+                            if (!keepConnectionOpen) {\n+                                sdlListener.bluetoothTransport.stop();\n+                                sdlListener.bluetoothTransport = null;\n+                                sdlListener.timeoutHandler.removeCallbacks(sdlListener.timeoutRunner);\n+                            }\n+                            break;\n+                        case MultiplexBaseTransport.STATE_NONE:\n+                            // We've just lost the connection\n+                            sdlListener.callback.onTransportDisconnected(sdlListener.connectedDevice);\n+                            break;\n+                        case MultiplexBaseTransport.STATE_ERROR:\n+                            sdlListener.callback.onTransportError(sdlListener.connectedDevice);\n+                            break;\n+                    }\n+                    break;\n+\n+                case com.smartdevicelink.transport.SdlRouterService.MESSAGE_READ:\n+                    break;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Set the connection establishment status of the particular device\n+     *\n+     * @param address         address of the device in quesiton\n+     * @param hasSDLConnected true if a connection has been established, false if not\n+     */\n+    public static void setSDLConnectedStatus(Context context, String address, boolean hasSDLConnected) {\n+        synchronized (LOCK) {\n+            if (context != null) {\n+                DebugTool.logInfo(TAG + \": Saving connected status - \" + address + \" : \" + hasSDLConnected);\n+                SharedPreferences preferences = context.getSharedPreferences(SDL_DEVICE_STATUS_SHARED_PREFS, Context.MODE_PRIVATE);\n+                if (preferences.contains(address) && hasSDLConnected == preferences.getBoolean(address, false)) {\n+                    //The same key/value exists in our shared preferences. No reason to write again.\n+                    return;\n+                }\n+                SharedPreferences.Editor editor = preferences.edit();\n+                editor.putBoolean(address, hasSDLConnected);\n+                editor.commit();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks to see if a device address has connected to SDL before.\n+     *\n+     * @param address the mac address of the device in quesiton", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba9d5518690be28c82ae94b0d188343c75c39a4a"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxOTAwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param address the mac address of the device in quesiton\n          \n          \n            \n                 * @param address the mac address of the device in question", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#discussion_r445019003", "createdAt": "2020-06-24T16:25:46Z", "author": {"login": "bilal-alsharifi"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/transport/utl/SdlDeviceListener.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+\n+package com.smartdevicelink.transport.utl;\n+\n+import android.bluetooth.BluetoothDevice;\n+import android.content.Context;\n+import android.content.SharedPreferences;\n+import android.os.Handler;\n+import android.os.Looper;\n+import android.os.Message;\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.transport.MultiplexBaseTransport;\n+import com.smartdevicelink.transport.MultiplexBluetoothTransport;\n+import com.smartdevicelink.transport.SdlRouterService;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.SdlAppInfo;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+\n+\n+public class SdlDeviceListener {\n+\n+    private static final String TAG = \"SdlListener\";\n+    private static final int MIN_VERSION_REQUIRED = 13;\n+    private static final String SDL_DEVICE_STATUS_SHARED_PREFS = \"sdl.device.status\";\n+    private static final Object LOCK = new Object(), RUNNING_LOCK = new Object();\n+\n+    private final WeakReference<Context> contextWeakReference;\n+    private final Callback callback;\n+    private final BluetoothDevice connectedDevice;\n+    private MultiplexBluetoothTransport bluetoothTransport;\n+    private TransportHandler bluetoothHandler;\n+    private Handler timeoutHandler;\n+    private Runnable timeoutRunner;\n+    private boolean isRunning = false;\n+\n+\n+    public SdlDeviceListener(Context context, BluetoothDevice device, Callback callback) {\n+        this.contextWeakReference = new WeakReference<>(context);\n+        this.connectedDevice = device;\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * This will start the SDL Device Listener with two paths. The first path will be a check\n+     * against the supplied bluetooth device to see if it has already successfully connected as an\n+     * SDL device. If it has, the supplied callback will be called immediately. If the device hasn't\n+     * connected as an SDL device before, the SDL Device Listener will then open up an RFCOMM channel\n+     * using the SDL UUID and await a potential connection. A timeout is used to ensure this only\n+     * listens for a finite amount of time. If this is the first time the device has been seen, this\n+     * will listen for 30 seconds, if it is not, this will listen for 15 seconds instead.\n+     */\n+    public void start() {\n+        if (hasSDLConnected(contextWeakReference.get(), connectedDevice.getAddress())) {\n+            DebugTool.logInfo(TAG + \": Confirmed SDL device, should start router service\");\n+            //This device has connected to SDL previously, it is ok to start the RS right now\n+            callback.onTransportConnected(contextWeakReference.get(), connectedDevice);\n+            return;\n+        }\n+        synchronized (RUNNING_LOCK) {\n+            isRunning = true;\n+            // set timeout = if first time seeing BT device, 30s, if not 15s\n+            int timeout = isFirstStatusCheck(connectedDevice.getAddress()) ? 30000 : 15000;\n+            //Set our preference as false for this device for now\n+            setSDLConnectedStatus(contextWeakReference.get(), connectedDevice.getAddress(), false);\n+            bluetoothHandler = new TransportHandler(this);\n+            bluetoothTransport = new MultiplexBluetoothTransport(bluetoothHandler);\n+            bluetoothTransport.start();\n+            timeoutRunner = new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (bluetoothTransport != null) {\n+                        int state = bluetoothTransport.getState();\n+                        if (state != MultiplexBluetoothTransport.STATE_CONNECTED) {\n+                            DebugTool.logInfo(TAG + \": No bluetooth connection made\");\n+                            bluetoothTransport.stop();\n+                        } //else BT is connected; it will close itself through callbacks\n+                    }\n+                }\n+            };\n+            timeoutHandler = new Handler(Looper.getMainLooper());\n+            timeoutHandler.postDelayed(timeoutRunner, timeout);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if this instance is in the middle of running or not\n+     *\n+     * @return if this is already in the process of running\n+     */\n+    public boolean isRunning() {\n+        synchronized (RUNNING_LOCK) {\n+            return isRunning;\n+        }\n+    }\n+\n+    private static class TransportHandler extends Handler {\n+\n+        final WeakReference<SdlDeviceListener> provider;\n+\n+        TransportHandler(SdlDeviceListener provider) {\n+            this.provider = new WeakReference<>(provider);\n+        }\n+\n+        @Override\n+        public void handleMessage(@NonNull Message msg) {\n+            if (this.provider.get() == null) {\n+                return;\n+            }\n+            SdlDeviceListener sdlListener = this.provider.get();\n+            switch (msg.what) {\n+\n+                case SdlRouterService.MESSAGE_STATE_CHANGE:\n+                    switch (msg.arg1) {\n+                        case MultiplexBaseTransport.STATE_CONNECTED:\n+                            sdlListener.setSDLConnectedStatus(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice.getAddress(), true);\n+                            boolean keepConnectionOpen = sdlListener.callback.onTransportConnected(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice);\n+                            if (!keepConnectionOpen) {\n+                                sdlListener.bluetoothTransport.stop();\n+                                sdlListener.bluetoothTransport = null;\n+                                sdlListener.timeoutHandler.removeCallbacks(sdlListener.timeoutRunner);\n+                            }\n+                            break;\n+                        case MultiplexBaseTransport.STATE_NONE:\n+                            // We've just lost the connection\n+                            sdlListener.callback.onTransportDisconnected(sdlListener.connectedDevice);\n+                            break;\n+                        case MultiplexBaseTransport.STATE_ERROR:\n+                            sdlListener.callback.onTransportError(sdlListener.connectedDevice);\n+                            break;\n+                    }\n+                    break;\n+\n+                case com.smartdevicelink.transport.SdlRouterService.MESSAGE_READ:\n+                    break;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Set the connection establishment status of the particular device\n+     *\n+     * @param address         address of the device in quesiton\n+     * @param hasSDLConnected true if a connection has been established, false if not\n+     */\n+    public static void setSDLConnectedStatus(Context context, String address, boolean hasSDLConnected) {\n+        synchronized (LOCK) {\n+            if (context != null) {\n+                DebugTool.logInfo(TAG + \": Saving connected status - \" + address + \" : \" + hasSDLConnected);\n+                SharedPreferences preferences = context.getSharedPreferences(SDL_DEVICE_STATUS_SHARED_PREFS, Context.MODE_PRIVATE);\n+                if (preferences.contains(address) && hasSDLConnected == preferences.getBoolean(address, false)) {\n+                    //The same key/value exists in our shared preferences. No reason to write again.\n+                    return;\n+                }\n+                SharedPreferences.Editor editor = preferences.edit();\n+                editor.putBoolean(address, hasSDLConnected);\n+                editor.commit();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks to see if a device address has connected to SDL before.\n+     *\n+     * @param address the mac address of the device in quesiton\n+     * @return if this is the first status check of this device\n+     */\n+    private boolean isFirstStatusCheck(String address) {\n+        synchronized (LOCK) {\n+            Context context = contextWeakReference.get();\n+            if (context != null) {\n+                SharedPreferences preferences = context.getSharedPreferences(SDL_DEVICE_STATUS_SHARED_PREFS, Context.MODE_PRIVATE);\n+                return !preferences.contains(address);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Checks to see if a device address has connected to SDL before.\n+     *\n+     * @param address the mac address of the device in quesiton", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba9d5518690be28c82ae94b0d188343c75c39a4a"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxOTI0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param address         address of the device in quesiton\n          \n          \n            \n                 * @param address         address of the device in question", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#discussion_r445019246", "createdAt": "2020-06-24T16:26:08Z", "author": {"login": "bilal-alsharifi"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/transport/utl/SdlDeviceListener.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+\n+package com.smartdevicelink.transport.utl;\n+\n+import android.bluetooth.BluetoothDevice;\n+import android.content.Context;\n+import android.content.SharedPreferences;\n+import android.os.Handler;\n+import android.os.Looper;\n+import android.os.Message;\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.transport.MultiplexBaseTransport;\n+import com.smartdevicelink.transport.MultiplexBluetoothTransport;\n+import com.smartdevicelink.transport.SdlRouterService;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.SdlAppInfo;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+\n+\n+public class SdlDeviceListener {\n+\n+    private static final String TAG = \"SdlListener\";\n+    private static final int MIN_VERSION_REQUIRED = 13;\n+    private static final String SDL_DEVICE_STATUS_SHARED_PREFS = \"sdl.device.status\";\n+    private static final Object LOCK = new Object(), RUNNING_LOCK = new Object();\n+\n+    private final WeakReference<Context> contextWeakReference;\n+    private final Callback callback;\n+    private final BluetoothDevice connectedDevice;\n+    private MultiplexBluetoothTransport bluetoothTransport;\n+    private TransportHandler bluetoothHandler;\n+    private Handler timeoutHandler;\n+    private Runnable timeoutRunner;\n+    private boolean isRunning = false;\n+\n+\n+    public SdlDeviceListener(Context context, BluetoothDevice device, Callback callback) {\n+        this.contextWeakReference = new WeakReference<>(context);\n+        this.connectedDevice = device;\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * This will start the SDL Device Listener with two paths. The first path will be a check\n+     * against the supplied bluetooth device to see if it has already successfully connected as an\n+     * SDL device. If it has, the supplied callback will be called immediately. If the device hasn't\n+     * connected as an SDL device before, the SDL Device Listener will then open up an RFCOMM channel\n+     * using the SDL UUID and await a potential connection. A timeout is used to ensure this only\n+     * listens for a finite amount of time. If this is the first time the device has been seen, this\n+     * will listen for 30 seconds, if it is not, this will listen for 15 seconds instead.\n+     */\n+    public void start() {\n+        if (hasSDLConnected(contextWeakReference.get(), connectedDevice.getAddress())) {\n+            DebugTool.logInfo(TAG + \": Confirmed SDL device, should start router service\");\n+            //This device has connected to SDL previously, it is ok to start the RS right now\n+            callback.onTransportConnected(contextWeakReference.get(), connectedDevice);\n+            return;\n+        }\n+        synchronized (RUNNING_LOCK) {\n+            isRunning = true;\n+            // set timeout = if first time seeing BT device, 30s, if not 15s\n+            int timeout = isFirstStatusCheck(connectedDevice.getAddress()) ? 30000 : 15000;\n+            //Set our preference as false for this device for now\n+            setSDLConnectedStatus(contextWeakReference.get(), connectedDevice.getAddress(), false);\n+            bluetoothHandler = new TransportHandler(this);\n+            bluetoothTransport = new MultiplexBluetoothTransport(bluetoothHandler);\n+            bluetoothTransport.start();\n+            timeoutRunner = new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (bluetoothTransport != null) {\n+                        int state = bluetoothTransport.getState();\n+                        if (state != MultiplexBluetoothTransport.STATE_CONNECTED) {\n+                            DebugTool.logInfo(TAG + \": No bluetooth connection made\");\n+                            bluetoothTransport.stop();\n+                        } //else BT is connected; it will close itself through callbacks\n+                    }\n+                }\n+            };\n+            timeoutHandler = new Handler(Looper.getMainLooper());\n+            timeoutHandler.postDelayed(timeoutRunner, timeout);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if this instance is in the middle of running or not\n+     *\n+     * @return if this is already in the process of running\n+     */\n+    public boolean isRunning() {\n+        synchronized (RUNNING_LOCK) {\n+            return isRunning;\n+        }\n+    }\n+\n+    private static class TransportHandler extends Handler {\n+\n+        final WeakReference<SdlDeviceListener> provider;\n+\n+        TransportHandler(SdlDeviceListener provider) {\n+            this.provider = new WeakReference<>(provider);\n+        }\n+\n+        @Override\n+        public void handleMessage(@NonNull Message msg) {\n+            if (this.provider.get() == null) {\n+                return;\n+            }\n+            SdlDeviceListener sdlListener = this.provider.get();\n+            switch (msg.what) {\n+\n+                case SdlRouterService.MESSAGE_STATE_CHANGE:\n+                    switch (msg.arg1) {\n+                        case MultiplexBaseTransport.STATE_CONNECTED:\n+                            sdlListener.setSDLConnectedStatus(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice.getAddress(), true);\n+                            boolean keepConnectionOpen = sdlListener.callback.onTransportConnected(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice);\n+                            if (!keepConnectionOpen) {\n+                                sdlListener.bluetoothTransport.stop();\n+                                sdlListener.bluetoothTransport = null;\n+                                sdlListener.timeoutHandler.removeCallbacks(sdlListener.timeoutRunner);\n+                            }\n+                            break;\n+                        case MultiplexBaseTransport.STATE_NONE:\n+                            // We've just lost the connection\n+                            sdlListener.callback.onTransportDisconnected(sdlListener.connectedDevice);\n+                            break;\n+                        case MultiplexBaseTransport.STATE_ERROR:\n+                            sdlListener.callback.onTransportError(sdlListener.connectedDevice);\n+                            break;\n+                    }\n+                    break;\n+\n+                case com.smartdevicelink.transport.SdlRouterService.MESSAGE_READ:\n+                    break;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Set the connection establishment status of the particular device\n+     *\n+     * @param address         address of the device in quesiton", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba9d5518690be28c82ae94b0d188343c75c39a4a"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjk0Mw==", "bodyText": "if I install the app while BT is already on, the connectedDevice comes as null so the app crashes with this exception\njava.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.String android.bluetooth.BluetoothDevice.getAddress()' on a null object reference\n        at com.smartdevicelink.transport.utl.SdlDeviceListener.start(SdlDeviceListener.java:88)\n        at com.smartdevicelink.transport.SdlBroadcastReceiver$2.onComplete(SdlBroadcastReceiver.java:298)\n        at com.smartdevicelink.util.ServiceFinder.onFinished(ServiceFinder.java:124)\n        at com.smartdevicelink.util.ServiceFinder.access$000(ServiceFinder.java:58)\n        at com.smartdevicelink.util.ServiceFinder$1.run(ServiceFinder.java:84)\n        at android.os.Handler.handleCallback(Handler.java:883)\n        at android.os.Handler.dispatchMessage(Handler.java:100)\n        at android.os.Looper.loop(Looper.java:214)\n        at android.app.ActivityThread.main(ActivityThread.java:7356)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#discussion_r445112943", "createdAt": "2020-06-24T19:12:07Z", "author": {"login": "bilal-alsharifi"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/transport/utl/SdlDeviceListener.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+\n+package com.smartdevicelink.transport.utl;\n+\n+import android.bluetooth.BluetoothDevice;\n+import android.content.Context;\n+import android.content.SharedPreferences;\n+import android.os.Handler;\n+import android.os.Looper;\n+import android.os.Message;\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.transport.MultiplexBaseTransport;\n+import com.smartdevicelink.transport.MultiplexBluetoothTransport;\n+import com.smartdevicelink.transport.SdlRouterService;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.SdlAppInfo;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+\n+\n+public class SdlDeviceListener {\n+\n+    private static final String TAG = \"SdlListener\";\n+    private static final int MIN_VERSION_REQUIRED = 13;\n+    private static final String SDL_DEVICE_STATUS_SHARED_PREFS = \"sdl.device.status\";\n+    private static final Object LOCK = new Object(), RUNNING_LOCK = new Object();\n+\n+    private final WeakReference<Context> contextWeakReference;\n+    private final Callback callback;\n+    private final BluetoothDevice connectedDevice;\n+    private MultiplexBluetoothTransport bluetoothTransport;\n+    private TransportHandler bluetoothHandler;\n+    private Handler timeoutHandler;\n+    private Runnable timeoutRunner;\n+    private boolean isRunning = false;\n+\n+\n+    public SdlDeviceListener(Context context, BluetoothDevice device, Callback callback) {\n+        this.contextWeakReference = new WeakReference<>(context);\n+        this.connectedDevice = device;\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * This will start the SDL Device Listener with two paths. The first path will be a check\n+     * against the supplied bluetooth device to see if it has already successfully connected as an\n+     * SDL device. If it has, the supplied callback will be called immediately. If the device hasn't\n+     * connected as an SDL device before, the SDL Device Listener will then open up an RFCOMM channel\n+     * using the SDL UUID and await a potential connection. A timeout is used to ensure this only\n+     * listens for a finite amount of time. If this is the first time the device has been seen, this\n+     * will listen for 30 seconds, if it is not, this will listen for 15 seconds instead.\n+     */\n+    public void start() {\n+        if (hasSDLConnected(contextWeakReference.get(), connectedDevice.getAddress())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba9d5518690be28c82ae94b0d188343c75c39a4a"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd30aba86f46a4d297da0f0a1c5a655033d5cbd4", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/bd30aba86f46a4d297da0f0a1c5a655033d5cbd4", "committedDate": "2020-06-24T19:56:20Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Bilal Alsharifi <599206+bilal-alsharifi@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1516c073d2dbc30d905220985e2dc3df91d4ab2c", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/1516c073d2dbc30d905220985e2dc3df91d4ab2c", "committedDate": "2020-06-24T20:49:10Z", "message": "Add null check for BT device in SdlDeviceListener"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NzI0ODM1", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#pullrequestreview-437724835", "createdAt": "2020-06-25T17:50:12Z", "commit": {"oid": "1516c073d2dbc30d905220985e2dc3df91d4ab2c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjA3MjAy", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#pullrequestreview-439207202", "createdAt": "2020-06-29T14:34:30Z", "commit": {"oid": "1516c073d2dbc30d905220985e2dc3df91d4ab2c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2181, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}