{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4MDM5Mjk5", "number": 1555, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOToxNTo1MFrOFGWt9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNVQyMTowMDo1NVrOFe179w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjA3OTkxOnYy", "diffSide": "RIGHT", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/screen/AlertManagerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOToxNTo1MFrOIHVHNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOToxNTo1MFrOIHVHNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU1Njg1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertFalse(alertManager.currentAlertPermissionStatus);\n          \n          \n            \n                    assertFalse(alertManager.isAlertRPCAllowed);\n          \n      \n    \n    \n  \n\nMissed during a refactor", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r544556853", "createdAt": "2020-12-16T19:15:50Z", "author": {"login": "RHenigan"}, "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/screen/AlertManagerTest.java", "diffHunk": "@@ -0,0 +1,170 @@\n+package com.smartdevicelink.managers.screen;\n+\n+import android.content.Context;\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import com.livio.taskmaster.Taskmaster;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.lifecycle.OnSystemCapabilityListener;\n+import com.smartdevicelink.managers.lifecycle.SystemCapabilityManager;\n+import com.smartdevicelink.managers.permission.OnPermissionChangeListener;\n+import com.smartdevicelink.managers.permission.PermissionManager;\n+import com.smartdevicelink.managers.permission.PermissionStatus;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.rpc.DisplayCapability;\n+import com.smartdevicelink.proxy.rpc.ImageField;\n+import com.smartdevicelink.proxy.rpc.SoftButtonCapabilities;\n+import com.smartdevicelink.proxy.rpc.TextField;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n+import com.smartdevicelink.proxy.rpc.enums.TextFieldName;\n+import com.smartdevicelink.test.TestValues;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class AlertManagerTest {\n+    AlertManager alertManager;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        Context mTestContext = getInstrumentation().getContext();\n+\n+        // mock things\n+        ISdl internalInterface = mock(ISdl.class);\n+        FileManager fileManager = mock(FileManager.class);\n+        PermissionManager permissionManager = mock(PermissionManager.class);\n+\n+        when(internalInterface.getPermissionManager()).thenReturn(permissionManager);\n+\n+        Taskmaster taskmaster = new Taskmaster.Builder().build();\n+        taskmaster.start();\n+        when(internalInterface.getTaskmaster()).thenReturn(taskmaster);\n+\n+        Answer<Void> permissionAnswer = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                OnPermissionChangeListener onPermissionChangeListener = (OnPermissionChangeListener) args[2];\n+                Map<FunctionID, PermissionStatus > allowedPermissions = new HashMap<>();\n+                int permissionGroupStatus = PermissionManager.PERMISSION_GROUP_STATUS_DISALLOWED;\n+                onPermissionChangeListener.onPermissionsChange(allowedPermissions,permissionGroupStatus);\n+                return null;\n+            }\n+        };\n+        doAnswer(permissionAnswer).when(permissionManager).addListener(any(List.class), anyInt(), any(OnPermissionChangeListener.class));\n+\n+        Answer<Void> onSystemCapabilityAnswer = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                OnSystemCapabilityListener onSystemCapabilityListener = (OnSystemCapabilityListener) args[1];\n+                WindowCapability windowCapability = getWindowCapability(3);\n+                DisplayCapability displayCapability = new DisplayCapability();\n+                displayCapability.setWindowCapabilities(Collections.singletonList(windowCapability));\n+                List<DisplayCapability> capabilities = Collections.singletonList(displayCapability);\n+                onSystemCapabilityListener.onCapabilityRetrieved(capabilities);\n+                return null;\n+            }\n+        };\n+\n+        SystemCapabilityManager systemCapabilityManager = mock(SystemCapabilityManager.class);\n+        doAnswer(onSystemCapabilityAnswer).when(systemCapabilityManager).addOnSystemCapabilityListener(eq(SystemCapabilityType.DISPLAYS), any(OnSystemCapabilityListener.class));\n+        doReturn(systemCapabilityManager).when(internalInterface).getSystemCapabilityManager();\n+\n+        alertManager = new AlertManager(internalInterface, fileManager);\n+    }\n+\n+    @Test\n+    public void testInstantiation() {\n+        assertNotNull(alertManager.defaultMainWindowCapability);\n+        assertNotNull(alertManager.nextCancelId);\n+        assertFalse(alertManager.currentAlertPermissionStatus);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9faa31b332a5b573d02d27131b69e86c5a45a947"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjA4NTUzOnYy", "diffSide": "RIGHT", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/screen/AlertManagerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOToxNzoxN1rOIHVKig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOToxNzoxN1rOIHVKig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU1NzcwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertNotNull(alertManager.defaultMainWindowCapability);\n          \n          \n            \n                    assertNotNull(alertManager.currentWindowCapability);\n          \n      \n    \n    \n  \n\nMissed during a refactor", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r544557706", "createdAt": "2020-12-16T19:17:17Z", "author": {"login": "RHenigan"}, "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/screen/AlertManagerTest.java", "diffHunk": "@@ -0,0 +1,170 @@\n+package com.smartdevicelink.managers.screen;\n+\n+import android.content.Context;\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import com.livio.taskmaster.Taskmaster;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.lifecycle.OnSystemCapabilityListener;\n+import com.smartdevicelink.managers.lifecycle.SystemCapabilityManager;\n+import com.smartdevicelink.managers.permission.OnPermissionChangeListener;\n+import com.smartdevicelink.managers.permission.PermissionManager;\n+import com.smartdevicelink.managers.permission.PermissionStatus;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.rpc.DisplayCapability;\n+import com.smartdevicelink.proxy.rpc.ImageField;\n+import com.smartdevicelink.proxy.rpc.SoftButtonCapabilities;\n+import com.smartdevicelink.proxy.rpc.TextField;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n+import com.smartdevicelink.proxy.rpc.enums.TextFieldName;\n+import com.smartdevicelink.test.TestValues;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class AlertManagerTest {\n+    AlertManager alertManager;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        Context mTestContext = getInstrumentation().getContext();\n+\n+        // mock things\n+        ISdl internalInterface = mock(ISdl.class);\n+        FileManager fileManager = mock(FileManager.class);\n+        PermissionManager permissionManager = mock(PermissionManager.class);\n+\n+        when(internalInterface.getPermissionManager()).thenReturn(permissionManager);\n+\n+        Taskmaster taskmaster = new Taskmaster.Builder().build();\n+        taskmaster.start();\n+        when(internalInterface.getTaskmaster()).thenReturn(taskmaster);\n+\n+        Answer<Void> permissionAnswer = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                OnPermissionChangeListener onPermissionChangeListener = (OnPermissionChangeListener) args[2];\n+                Map<FunctionID, PermissionStatus > allowedPermissions = new HashMap<>();\n+                int permissionGroupStatus = PermissionManager.PERMISSION_GROUP_STATUS_DISALLOWED;\n+                onPermissionChangeListener.onPermissionsChange(allowedPermissions,permissionGroupStatus);\n+                return null;\n+            }\n+        };\n+        doAnswer(permissionAnswer).when(permissionManager).addListener(any(List.class), anyInt(), any(OnPermissionChangeListener.class));\n+\n+        Answer<Void> onSystemCapabilityAnswer = new Answer<Void>() {\n+            @Override\n+            public Void answer(InvocationOnMock invocation) {\n+                Object[] args = invocation.getArguments();\n+                OnSystemCapabilityListener onSystemCapabilityListener = (OnSystemCapabilityListener) args[1];\n+                WindowCapability windowCapability = getWindowCapability(3);\n+                DisplayCapability displayCapability = new DisplayCapability();\n+                displayCapability.setWindowCapabilities(Collections.singletonList(windowCapability));\n+                List<DisplayCapability> capabilities = Collections.singletonList(displayCapability);\n+                onSystemCapabilityListener.onCapabilityRetrieved(capabilities);\n+                return null;\n+            }\n+        };\n+\n+        SystemCapabilityManager systemCapabilityManager = mock(SystemCapabilityManager.class);\n+        doAnswer(onSystemCapabilityAnswer).when(systemCapabilityManager).addOnSystemCapabilityListener(eq(SystemCapabilityType.DISPLAYS), any(OnSystemCapabilityListener.class));\n+        doReturn(systemCapabilityManager).when(internalInterface).getSystemCapabilityManager();\n+\n+        alertManager = new AlertManager(internalInterface, fileManager);\n+    }\n+\n+    @Test\n+    public void testInstantiation() {\n+        assertNotNull(alertManager.defaultMainWindowCapability);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9faa31b332a5b573d02d27131b69e86c5a45a947"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzgyOTM3OnYy", "diffSide": "RIGHT", "path": "base/src/main/java/com/smartdevicelink/managers/screen/PresentAlertOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDo1OToxMVrOIIIj7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNDozODowOFrOITngWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5OTc5MA==", "bodyText": "Duplicate line", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r545399790", "createdAt": "2020-12-17T20:59:11Z", "author": {"login": "RHenigan"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/PresentAlertOperation.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import com.livio.taskmaster.Task;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.ManagerUtility;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.file.MultipleFileCompletionListener;\n+import com.smartdevicelink.managers.file.filetypes.SdlArtwork;\n+import com.smartdevicelink.managers.file.filetypes.SdlFile;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCResponse;\n+import com.smartdevicelink.proxy.rpc.Alert;\n+import com.smartdevicelink.proxy.rpc.AlertResponse;\n+import com.smartdevicelink.proxy.rpc.CancelInteraction;\n+import com.smartdevicelink.proxy.rpc.SoftButton;\n+import com.smartdevicelink.proxy.rpc.SoftButtonCapabilities;\n+import com.smartdevicelink.proxy.rpc.TTSChunk;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.listeners.OnRPCResponseListener;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Created by Julian Kast on 12/10/20.\n+ */\n+public class PresentAlertOperation extends Task {\n+    private static final String TAG = \"PresentAlertOperation\";\n+    private AlertView alertView;\n+    private AlertCompletionListener listener;\n+    private final WeakReference<ISdl> internalInterface;\n+    private final WeakReference<FileManager> fileManager;\n+    WindowCapability currentWindowCapability;\n+    private int cancelId;\n+    private List<SpeechCapabilities> speechCapabilities;\n+\n+    public PresentAlertOperation(ISdl internalInterface, AlertView alertView, WindowCapability currentCapabilities, List<SpeechCapabilities> speechCapabilities, FileManager fileManager, Integer cancelId, AlertCompletionListener listener) {\n+        super(\"PresentAlertOperation\");\n+        this.internalInterface = new WeakReference<>(internalInterface);\n+        this.fileManager = new WeakReference<>(fileManager);\n+        this.currentWindowCapability = currentCapabilities;\n+        this.speechCapabilities = speechCapabilities;\n+        this.alertView = alertView.clone();\n+        this.listener = listener;\n+        this.cancelId = cancelId;\n+\n+        this.alertView.canceledListener = new AlertCanceledListener() {\n+            @Override\n+            public void onAlertCanceled() {\n+                cancelAlert();\n+            }\n+        };\n+        alertView.canceledListener = this.alertView.canceledListener;\n+    }\n+\n+    @Override\n+    public void onExecute() {\n+        DebugTool.logInfo(TAG, \"Alert Operation: Executing present Alert operation\");\n+        start();\n+    }\n+\n+    private void start() {\n+        if (getState() == Task.CANCELED) {\n+            finishOperation(false, null);\n+            return;\n+        }\n+        if (!isValidAlertViewData(alertView)) {\n+            if (alertView.getAudio() != null && alertView.getAudio().getAudioFiles() != null && alertView.getAudio().getAudioFiles().size() > 0) {\n+                DebugTool.logError(TAG, \"The module does not support the use of only audio file data in an alert. \" +\n+                        \"The alert has no data and can not be sent to the module. \" +\n+                        \"The use of audio file data in an alert is only supported on modules supporting RPC Spec v5.0 or newer\");\n+            } else {\n+                DebugTool.logError(TAG, \"The alert data is invalid.\" +\n+                        \" At least either text, secondaryText or audio needs to be provided. \" +\n+                        \"Make sure to set at least the text, secondaryText or audio properties on the AlertView\");\n+            }\n+            finishOperation(false, null);\n+            return;\n+        }\n+        final DispatchGroup uploadFilesTask = new DispatchGroup();\n+\n+        uploadFilesTask.enter();\n+        uploadFilesTask.enter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e356c683ddcfe8730b6cc2d627d688b3362bd915"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQ0MTExNA==", "bodyText": "It is supposed to be like that, We enter the task twice, once for uploading Audio Files, and once for uploading images, once we leave the task twice, uploadFilesTask.notify runs.", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r557441114", "createdAt": "2021-01-14T14:38:08Z", "author": {"login": "JulianKast"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/PresentAlertOperation.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import com.livio.taskmaster.Task;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.ManagerUtility;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.file.MultipleFileCompletionListener;\n+import com.smartdevicelink.managers.file.filetypes.SdlArtwork;\n+import com.smartdevicelink.managers.file.filetypes.SdlFile;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCResponse;\n+import com.smartdevicelink.proxy.rpc.Alert;\n+import com.smartdevicelink.proxy.rpc.AlertResponse;\n+import com.smartdevicelink.proxy.rpc.CancelInteraction;\n+import com.smartdevicelink.proxy.rpc.SoftButton;\n+import com.smartdevicelink.proxy.rpc.SoftButtonCapabilities;\n+import com.smartdevicelink.proxy.rpc.TTSChunk;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.listeners.OnRPCResponseListener;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Created by Julian Kast on 12/10/20.\n+ */\n+public class PresentAlertOperation extends Task {\n+    private static final String TAG = \"PresentAlertOperation\";\n+    private AlertView alertView;\n+    private AlertCompletionListener listener;\n+    private final WeakReference<ISdl> internalInterface;\n+    private final WeakReference<FileManager> fileManager;\n+    WindowCapability currentWindowCapability;\n+    private int cancelId;\n+    private List<SpeechCapabilities> speechCapabilities;\n+\n+    public PresentAlertOperation(ISdl internalInterface, AlertView alertView, WindowCapability currentCapabilities, List<SpeechCapabilities> speechCapabilities, FileManager fileManager, Integer cancelId, AlertCompletionListener listener) {\n+        super(\"PresentAlertOperation\");\n+        this.internalInterface = new WeakReference<>(internalInterface);\n+        this.fileManager = new WeakReference<>(fileManager);\n+        this.currentWindowCapability = currentCapabilities;\n+        this.speechCapabilities = speechCapabilities;\n+        this.alertView = alertView.clone();\n+        this.listener = listener;\n+        this.cancelId = cancelId;\n+\n+        this.alertView.canceledListener = new AlertCanceledListener() {\n+            @Override\n+            public void onAlertCanceled() {\n+                cancelAlert();\n+            }\n+        };\n+        alertView.canceledListener = this.alertView.canceledListener;\n+    }\n+\n+    @Override\n+    public void onExecute() {\n+        DebugTool.logInfo(TAG, \"Alert Operation: Executing present Alert operation\");\n+        start();\n+    }\n+\n+    private void start() {\n+        if (getState() == Task.CANCELED) {\n+            finishOperation(false, null);\n+            return;\n+        }\n+        if (!isValidAlertViewData(alertView)) {\n+            if (alertView.getAudio() != null && alertView.getAudio().getAudioFiles() != null && alertView.getAudio().getAudioFiles().size() > 0) {\n+                DebugTool.logError(TAG, \"The module does not support the use of only audio file data in an alert. \" +\n+                        \"The alert has no data and can not be sent to the module. \" +\n+                        \"The use of audio file data in an alert is only supported on modules supporting RPC Spec v5.0 or newer\");\n+            } else {\n+                DebugTool.logError(TAG, \"The alert data is invalid.\" +\n+                        \" At least either text, secondaryText or audio needs to be provided. \" +\n+                        \"Make sure to set at least the text, secondaryText or audio properties on the AlertView\");\n+            }\n+            finishOperation(false, null);\n+            return;\n+        }\n+        final DispatchGroup uploadFilesTask = new DispatchGroup();\n+\n+        uploadFilesTask.enter();\n+        uploadFilesTask.enter();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5OTc5MA=="}, "originalCommit": {"oid": "e356c683ddcfe8730b6cc2d627d688b3362bd915"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzOTQ4MjQ2OnYy", "diffSide": "RIGHT", "path": "base/src/main/java/com/smartdevicelink/managers/screen/AlertView.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQyMToyMTozNFrOImaNoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQyMToyMTozNFrOImaNoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzE0NjI3Mg==", "bodyText": "Do we need a setter for show wait indicator?", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r577146272", "createdAt": "2021-02-16T21:21:34Z", "author": {"login": "RHenigan"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/AlertView.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import com.smartdevicelink.managers.file.filetypes.SdlArtwork;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AlertView implements Cloneable {\n+    \n+    private static Integer defaultTimeout = 5;\n+    private static final int TIMEOUT_MIN = 3;\n+    private static final int TIMEOUT_MAX = 10;\n+    private String text, secondaryText, tertiaryText;\n+    private Integer timeout;\n+    private AlertAudioData audio;\n+    private boolean showWaitIndicator;\n+    private List<SoftButtonObject> softButtons;\n+    private SdlArtwork icon;\n+    AlertCanceledListener canceledListener;\n+\n+\n+    private AlertView() {\n+        this.timeout = defaultTimeout;\n+    }\n+\n+    public static class Builder {\n+\n+        AlertView alertView;\n+\n+        public Builder() {\n+            alertView = new AlertView();\n+        }\n+\n+        /**\n+         * The primary line of text for display on the alert. If fewer than three alert lines are available\n+         * on the head unit, the screen manager will automatically concatenate some of the lines together.\n+         */\n+        public Builder setText(String text) {\n+            this.alertView.text = text;\n+            return this;\n+        }\n+\n+        /**\n+         * The secondary line of text for display on the alert. If fewer than three alert lines are available\n+         * on the head unit, the screen manager will automatically concatenate some of the lines together.\n+         */\n+        public Builder setSecondaryText(String secondaryText) {\n+            alertView.secondaryText = secondaryText;\n+            return this;\n+        }\n+\n+        /**\n+         * The tertiary line of text for display on the alert. If fewer than three alert lines are available\n+         * on the head unit, the screen manager will automatically concatenate some of the lines together.\n+         */\n+        public Builder setTertiaryText(String tertiaryText) {\n+            alertView.tertiaryText = tertiaryText;\n+            return this;\n+        }\n+\n+        /**\n+         * Timeout in seconds. Defaults to 0, which will use `defaultTimeout`. If this is set below the\n+         * minimum, it will be capped at 3 seconds. Minimum 3 seconds, maximum 10 seconds. If this is\n+         * set above the maximum, it will be capped at 10 seconds. Defaults to 0.\n+         *\n+         * Please note that if a button is added to the alert, the defaultTimeout and timeout values will be ignored.\n+         */\n+        public Builder setTimeout(Integer timeout) {\n+            alertView.timeout = timeout;\n+            return this;\n+        }\n+\n+        /**\n+         * If supported, the alert GUI will display some sort of indefinite waiting / refresh / loading\n+         * indicator animation. Defaults to NO.\n+         */\n+        public Builder setShowWaitIndicator(boolean showWaitIndicator) {\n+            alertView.showWaitIndicator = showWaitIndicator;\n+            return this;\n+        }\n+\n+        /**\n+         * Soft buttons the user may select to perform actions. Only one `SoftButtonState` per object\n+         * is supported; if any soft button object contains multiple states, an exception will be thrown.\n+         */\n+        public Builder setSoftButtons(List<SoftButtonObject> softButtons) {\n+            alertView.setSoftButtons(softButtons);\n+            return this;\n+        }\n+\n+        /**\n+         * Text spoken, file(s) played, and/or tone played when the alert appears\n+         */\n+        public Builder setAudio(AlertAudioData audio) {\n+            alertView.audio = audio;\n+            return this;\n+        }\n+\n+        /**\n+         * An artwork that will be displayed when the icon appears. This will be uploaded prior to the\n+         * appearance of the alert if necessary. This will not be uploaded if the head unit does not\n+         * declare support for alertIcon.\n+         */\n+        public Builder setIcon(SdlArtwork icon) {\n+            alertView.icon = icon;\n+            return this;\n+        }\n+\n+        /**\n+         * Set this to change the default timeout for all alerts. If a timeout is not set on an individual\n+         * alert object (or if it is set to 0.0), then it will use this timeout instead. See `timeout`\n+         * for more details. If this is not set by you, it will default to 5 seconds. The minimum is\n+         * 3 seconds, the maximum is 10 seconds. If this is set below the minimum, it will be capped\n+         * at 3 seconds. If this is set above the maximum, it will be capped at 10 seconds.\n+         */\n+        public Builder setDefaultTimeOut(int defaultTimeOut) {\n+            alertView.setDefaultTimeout(defaultTimeOut);\n+            return this;\n+        }\n+\n+        public AlertView build() {\n+            return alertView;\n+        }\n+    }\n+\n+    // Notifies the subscriber that the alert should be cancelled.\n+    public void cancel() {\n+        if (canceledListener == null) {\n+            return;\n+        }\n+        canceledListener.onAlertCanceled();\n+    }\n+\n+    public Integer getTimeout() {\n+        if (timeout == null) {\n+            timeout = defaultTimeout;\n+        } else if (timeout < TIMEOUT_MIN) {\n+            return TIMEOUT_MIN;\n+        } else if (timeout > TIMEOUT_MAX) {\n+            return TIMEOUT_MAX;\n+        }\n+        return timeout;\n+    }\n+\n+    public AlertAudioData getAudio() {\n+        return audio;\n+    }\n+\n+    public void setAudio(AlertAudioData audio) {\n+        this.audio = audio;\n+    }\n+\n+    public String getText() {\n+        return text;\n+    }\n+\n+    public void setText(String text) {\n+        this.text = text;\n+    }\n+\n+    public boolean isShowWaitIndicator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e39944e566ae5448386c4fcc9164d71884d520"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYzOTQ5NTQ1OnYy", "diffSide": "RIGHT", "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNlQyMToyNTozN1rOImaVpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QyMTowMDowN1rOInKoGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzE0ODMyNA==", "bodyText": "Is it possible for a single SpeechCapabilities to be returned and do we need to account for that similar to how we do in RegisterAppInterfaceResponse?\npublic List<SpeechCapabilities> getSpeechCapabilities() {\n        Object speechCapabilities = getObject(SpeechCapabilities.class, KEY_SPEECH_CAPABILITIES);\n        if (speechCapabilities instanceof List<?>) {\n            return (List<SpeechCapabilities>) speechCapabilities;\n        } else if (speechCapabilities instanceof SpeechCapabilities) {\n            // this is a known issue observed with some core implementations\n            List<SpeechCapabilities> newSpeechCapList = new ArrayList<>();\n            newSpeechCapList.add((SpeechCapabilities) speechCapabilities);\n            return newSpeechCapList;\n        }\n        return null;\n    }", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r577148324", "createdAt": "2021-02-16T21:25:37Z", "author": {"login": "RHenigan"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.livio.taskmaster.Queue;\n+import com.livio.taskmaster.Task;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.BaseSubManager;\n+import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.lifecycle.OnSystemCapabilityListener;\n+import com.smartdevicelink.managers.lifecycle.SystemCapabilityManager;\n+import com.smartdevicelink.managers.permission.OnPermissionChangeListener;\n+import com.smartdevicelink.managers.permission.PermissionElement;\n+import com.smartdevicelink.managers.permission.PermissionStatus;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCNotification;\n+import com.smartdevicelink.proxy.rpc.DisplayCapability;\n+import com.smartdevicelink.proxy.rpc.OnButtonEvent;\n+import com.smartdevicelink.proxy.rpc.OnButtonPress;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ButtonName;\n+import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n+import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+\n+abstract class BaseAlertManager extends BaseSubManager {\n+\n+    private static final String TAG = \"BaseAlertManager\";\n+    Queue transactionQueue;\n+    WindowCapability currentWindowCapability;\n+    private OnSystemCapabilityListener onSpeechCapabilityListener, onDisplaysCapabilityListener;\n+    List<SpeechCapabilities> speechCapabilities;\n+    private UUID permissionListener;\n+    boolean isAlertRPCAllowed = false;\n+    private final WeakReference<FileManager> fileManager;\n+    int nextCancelId;\n+    private final int alertCancelIdMin = 1;\n+    private final int alertCancelIdMax = 100;\n+    private CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+    OnRPCNotificationListener onButtonPressListener, onButtonEventListener;\n+\n+\n+    public BaseAlertManager(@NonNull ISdl internalInterface, @NonNull FileManager fileManager) {\n+        super(internalInterface);\n+        this.transactionQueue = newTransactionQueue();\n+        this.fileManager = new WeakReference<>(fileManager);\n+        nextCancelId = 0;\n+        this.softButtonObjects = new CopyOnWriteArrayList<>();\n+        addListeners();\n+    }\n+\n+    /**\n+     * Starts the manager\n+     * @param listener CompletionListener that is called once the BaseSubManager's state is READY, LIMITED, or ERROR\n+     */\n+    @Override\n+    public void start(CompletionListener listener) {\n+        transitionToState(READY);\n+        super.start(listener);\n+    }\n+\n+    /**\n+     * Clean up everything after the manager is no longer needed\n+     */\n+    @Override\n+    public void dispose() {\n+        currentWindowCapability = null;\n+        speechCapabilities = null;\n+        isAlertRPCAllowed = false;\n+        softButtonObjects = null;\n+\n+        if (transactionQueue != null) {\n+            transactionQueue.close();\n+            transactionQueue = null;\n+        }\n+\n+        // remove listeners\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.SPEECH, onSpeechCapabilityListener);\n+        }\n+        if (internalInterface.getPermissionManager() != null) {\n+            internalInterface.getPermissionManager().removeListener(permissionListener);\n+        }\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_PRESS, onButtonPressListener);\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_EVENT, onButtonEventListener);\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Creates a PresentAlertOperation and adds it to the transactionQueue\n+     *\n+     * @param alert    - AlertView object that contains alert information\n+     * @param listener - AlertCompletionListener that will notify the sender when Alert has completed\n+     */\n+    public void presentAlert(AlertView alert, AlertCompletionListener listener) {\n+        if (getState() == ERROR) {\n+            DebugTool.logWarning(TAG, \"Alert Manager In Error State\");\n+            return;\n+        }\n+\n+        // Check for softButtons and assign them ID's, Behavior mimic SoftButtonManager,\n+        // as in if invalid ID's are set, Alert will not show up.\n+        // It's best if ID's are not set custom and allow the screenManager to set them.\n+        if (alert.getSoftButtons() != null) {\n+            if (!BaseScreenManager.checkAndAssignButtonIds(alert.getSoftButtons(), BaseScreenManager.ManagerLocation.ALERT_MANAGER)) {\n+                DebugTool.logError(TAG, \"Attempted to set soft button objects for Alert, but multiple buttons had the same id.\");\n+                return;\n+            }\n+\n+            // Keep Track of SoftButtonObjects, to be able to Call their OnEventListeners\n+            CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+            if (alert.getSoftButtons() instanceof CopyOnWriteArrayList) {\n+                softButtonObjects = (CopyOnWriteArrayList<SoftButtonObject>) alert.getSoftButtons();\n+            } else {\n+                softButtonObjects = new CopyOnWriteArrayList<>(alert.getSoftButtons());\n+            }\n+            if (this.softButtonObjects.size() > 0) {\n+                for (SoftButtonObject object : softButtonObjects) {\n+                    if (softButtonObjects.contains(object)) {\n+                        continue;\n+                    }\n+                    this.softButtonObjects.add(object);\n+                }\n+            } else {\n+                this.softButtonObjects = softButtonObjects;\n+            }\n+        }\n+\n+        if (nextCancelId >= alertCancelIdMax) {\n+            nextCancelId = alertCancelIdMin;\n+        } else {\n+            nextCancelId++;\n+        }\n+\n+        PresentAlertOperation operation = new PresentAlertOperation(internalInterface, alert, currentWindowCapability, speechCapabilities, fileManager.get(), nextCancelId, listener);\n+        transactionQueue.add(operation, false);\n+\n+    }\n+\n+    private Queue newTransactionQueue() {\n+        Queue queue = internalInterface.getTaskmaster().createQueue(\"AlertManager\", 4, false);\n+        queue.pause();\n+        return queue;\n+    }\n+\n+    /**\n+     * Get the soft button objects list\n+     *\n+     * @return a List<SoftButtonObject>\n+     */\n+    protected List<SoftButtonObject> getSoftButtonObjects() {\n+        return softButtonObjects;\n+    }\n+\n+    /**\n+     * Get the SoftButtonObject that has the provided buttonId\n+     *\n+     * @param buttonId a int value that represents the id of the button\n+     * @return a SoftButtonObject\n+     */\n+    protected SoftButtonObject getSoftButtonObjectById(int buttonId) {\n+        for (SoftButtonObject softButtonObject : softButtonObjects) {\n+            if (softButtonObject.getButtonId() == buttonId) {\n+                return softButtonObject;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // Suspend the queue if the WindowCapabilities are null\n+    // OR if isAlertRPCAllowed is false\n+    private void updateTransactionQueueSuspended() {\n+        if (!isAlertRPCAllowed || currentWindowCapability == null) {\n+            DebugTool.logInfo(TAG, String.format(\"Suspending the transaction queue. Current permission status is false: %b, window capabilities are null: %b\", isAlertRPCAllowed, currentWindowCapability == null));\n+            transactionQueue.pause();\n+        } else {\n+            DebugTool.logInfo(TAG, \"Starting the transaction queue\");\n+            transactionQueue.resume();\n+        }\n+    }\n+\n+\n+    private void addListeners() {\n+        // Retrieves SpeechCapabilities of the system.\n+        onSpeechCapabilityListener = new OnSystemCapabilityListener() {\n+            @Override\n+            public void onCapabilityRetrieved(Object capability) {\n+                speechCapabilities = (List<SpeechCapabilities>) capability;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e39944e566ae5448386c4fcc9164d71884d520"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkzOTQ4Mw==", "bodyText": "I found a method in the SystemCapabilityManager that we use for DisplayCapabilities that will work here called convertToList", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r577939483", "createdAt": "2021-02-17T21:00:07Z", "author": {"login": "JulianKast"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.livio.taskmaster.Queue;\n+import com.livio.taskmaster.Task;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.BaseSubManager;\n+import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.lifecycle.OnSystemCapabilityListener;\n+import com.smartdevicelink.managers.lifecycle.SystemCapabilityManager;\n+import com.smartdevicelink.managers.permission.OnPermissionChangeListener;\n+import com.smartdevicelink.managers.permission.PermissionElement;\n+import com.smartdevicelink.managers.permission.PermissionStatus;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCNotification;\n+import com.smartdevicelink.proxy.rpc.DisplayCapability;\n+import com.smartdevicelink.proxy.rpc.OnButtonEvent;\n+import com.smartdevicelink.proxy.rpc.OnButtonPress;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ButtonName;\n+import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n+import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+\n+abstract class BaseAlertManager extends BaseSubManager {\n+\n+    private static final String TAG = \"BaseAlertManager\";\n+    Queue transactionQueue;\n+    WindowCapability currentWindowCapability;\n+    private OnSystemCapabilityListener onSpeechCapabilityListener, onDisplaysCapabilityListener;\n+    List<SpeechCapabilities> speechCapabilities;\n+    private UUID permissionListener;\n+    boolean isAlertRPCAllowed = false;\n+    private final WeakReference<FileManager> fileManager;\n+    int nextCancelId;\n+    private final int alertCancelIdMin = 1;\n+    private final int alertCancelIdMax = 100;\n+    private CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+    OnRPCNotificationListener onButtonPressListener, onButtonEventListener;\n+\n+\n+    public BaseAlertManager(@NonNull ISdl internalInterface, @NonNull FileManager fileManager) {\n+        super(internalInterface);\n+        this.transactionQueue = newTransactionQueue();\n+        this.fileManager = new WeakReference<>(fileManager);\n+        nextCancelId = 0;\n+        this.softButtonObjects = new CopyOnWriteArrayList<>();\n+        addListeners();\n+    }\n+\n+    /**\n+     * Starts the manager\n+     * @param listener CompletionListener that is called once the BaseSubManager's state is READY, LIMITED, or ERROR\n+     */\n+    @Override\n+    public void start(CompletionListener listener) {\n+        transitionToState(READY);\n+        super.start(listener);\n+    }\n+\n+    /**\n+     * Clean up everything after the manager is no longer needed\n+     */\n+    @Override\n+    public void dispose() {\n+        currentWindowCapability = null;\n+        speechCapabilities = null;\n+        isAlertRPCAllowed = false;\n+        softButtonObjects = null;\n+\n+        if (transactionQueue != null) {\n+            transactionQueue.close();\n+            transactionQueue = null;\n+        }\n+\n+        // remove listeners\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.SPEECH, onSpeechCapabilityListener);\n+        }\n+        if (internalInterface.getPermissionManager() != null) {\n+            internalInterface.getPermissionManager().removeListener(permissionListener);\n+        }\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_PRESS, onButtonPressListener);\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_EVENT, onButtonEventListener);\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Creates a PresentAlertOperation and adds it to the transactionQueue\n+     *\n+     * @param alert    - AlertView object that contains alert information\n+     * @param listener - AlertCompletionListener that will notify the sender when Alert has completed\n+     */\n+    public void presentAlert(AlertView alert, AlertCompletionListener listener) {\n+        if (getState() == ERROR) {\n+            DebugTool.logWarning(TAG, \"Alert Manager In Error State\");\n+            return;\n+        }\n+\n+        // Check for softButtons and assign them ID's, Behavior mimic SoftButtonManager,\n+        // as in if invalid ID's are set, Alert will not show up.\n+        // It's best if ID's are not set custom and allow the screenManager to set them.\n+        if (alert.getSoftButtons() != null) {\n+            if (!BaseScreenManager.checkAndAssignButtonIds(alert.getSoftButtons(), BaseScreenManager.ManagerLocation.ALERT_MANAGER)) {\n+                DebugTool.logError(TAG, \"Attempted to set soft button objects for Alert, but multiple buttons had the same id.\");\n+                return;\n+            }\n+\n+            // Keep Track of SoftButtonObjects, to be able to Call their OnEventListeners\n+            CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+            if (alert.getSoftButtons() instanceof CopyOnWriteArrayList) {\n+                softButtonObjects = (CopyOnWriteArrayList<SoftButtonObject>) alert.getSoftButtons();\n+            } else {\n+                softButtonObjects = new CopyOnWriteArrayList<>(alert.getSoftButtons());\n+            }\n+            if (this.softButtonObjects.size() > 0) {\n+                for (SoftButtonObject object : softButtonObjects) {\n+                    if (softButtonObjects.contains(object)) {\n+                        continue;\n+                    }\n+                    this.softButtonObjects.add(object);\n+                }\n+            } else {\n+                this.softButtonObjects = softButtonObjects;\n+            }\n+        }\n+\n+        if (nextCancelId >= alertCancelIdMax) {\n+            nextCancelId = alertCancelIdMin;\n+        } else {\n+            nextCancelId++;\n+        }\n+\n+        PresentAlertOperation operation = new PresentAlertOperation(internalInterface, alert, currentWindowCapability, speechCapabilities, fileManager.get(), nextCancelId, listener);\n+        transactionQueue.add(operation, false);\n+\n+    }\n+\n+    private Queue newTransactionQueue() {\n+        Queue queue = internalInterface.getTaskmaster().createQueue(\"AlertManager\", 4, false);\n+        queue.pause();\n+        return queue;\n+    }\n+\n+    /**\n+     * Get the soft button objects list\n+     *\n+     * @return a List<SoftButtonObject>\n+     */\n+    protected List<SoftButtonObject> getSoftButtonObjects() {\n+        return softButtonObjects;\n+    }\n+\n+    /**\n+     * Get the SoftButtonObject that has the provided buttonId\n+     *\n+     * @param buttonId a int value that represents the id of the button\n+     * @return a SoftButtonObject\n+     */\n+    protected SoftButtonObject getSoftButtonObjectById(int buttonId) {\n+        for (SoftButtonObject softButtonObject : softButtonObjects) {\n+            if (softButtonObject.getButtonId() == buttonId) {\n+                return softButtonObject;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // Suspend the queue if the WindowCapabilities are null\n+    // OR if isAlertRPCAllowed is false\n+    private void updateTransactionQueueSuspended() {\n+        if (!isAlertRPCAllowed || currentWindowCapability == null) {\n+            DebugTool.logInfo(TAG, String.format(\"Suspending the transaction queue. Current permission status is false: %b, window capabilities are null: %b\", isAlertRPCAllowed, currentWindowCapability == null));\n+            transactionQueue.pause();\n+        } else {\n+            DebugTool.logInfo(TAG, \"Starting the transaction queue\");\n+            transactionQueue.resume();\n+        }\n+    }\n+\n+\n+    private void addListeners() {\n+        // Retrieves SpeechCapabilities of the system.\n+        onSpeechCapabilityListener = new OnSystemCapabilityListener() {\n+            @Override\n+            public void onCapabilityRetrieved(Object capability) {\n+                speechCapabilities = (List<SpeechCapabilities>) capability;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzE0ODMyNA=="}, "originalCommit": {"oid": "91e39944e566ae5448386c4fcc9164d71884d520"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0Mzc1MTU0OnYy", "diffSide": "RIGHT", "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxNzozMjozMlrOInChYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QyMDozNToxN1rOInJwsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzgwNjY5MQ==", "bodyText": "id 4 is already being used by VoiceCommandManager and 5 is being used by FileManager should we update this one to 6?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Queue queue = internalInterface.getTaskmaster().createQueue(\"AlertManager\", 4, false);\n          \n          \n            \n                    Queue queue = internalInterface.getTaskmaster().createQueue(\"AlertManager\", 6, false);", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r577806691", "createdAt": "2021-02-17T17:32:32Z", "author": {"login": "RHenigan"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.livio.taskmaster.Queue;\n+import com.livio.taskmaster.Task;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.BaseSubManager;\n+import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.lifecycle.OnSystemCapabilityListener;\n+import com.smartdevicelink.managers.lifecycle.SystemCapabilityManager;\n+import com.smartdevicelink.managers.permission.OnPermissionChangeListener;\n+import com.smartdevicelink.managers.permission.PermissionElement;\n+import com.smartdevicelink.managers.permission.PermissionStatus;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCNotification;\n+import com.smartdevicelink.proxy.rpc.DisplayCapability;\n+import com.smartdevicelink.proxy.rpc.OnButtonEvent;\n+import com.smartdevicelink.proxy.rpc.OnButtonPress;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ButtonName;\n+import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n+import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+\n+abstract class BaseAlertManager extends BaseSubManager {\n+\n+    private static final String TAG = \"BaseAlertManager\";\n+    Queue transactionQueue;\n+    WindowCapability currentWindowCapability;\n+    private OnSystemCapabilityListener onSpeechCapabilityListener, onDisplaysCapabilityListener;\n+    List<SpeechCapabilities> speechCapabilities;\n+    private UUID permissionListener;\n+    boolean isAlertRPCAllowed = false;\n+    private final WeakReference<FileManager> fileManager;\n+    int nextCancelId;\n+    private final int alertCancelIdMin = 1;\n+    private final int alertCancelIdMax = 100;\n+    private CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+    OnRPCNotificationListener onButtonPressListener, onButtonEventListener;\n+\n+\n+    public BaseAlertManager(@NonNull ISdl internalInterface, @NonNull FileManager fileManager) {\n+        super(internalInterface);\n+        this.transactionQueue = newTransactionQueue();\n+        this.fileManager = new WeakReference<>(fileManager);\n+        nextCancelId = 0;\n+        this.softButtonObjects = new CopyOnWriteArrayList<>();\n+        addListeners();\n+    }\n+\n+    /**\n+     * Starts the manager\n+     * @param listener CompletionListener that is called once the BaseSubManager's state is READY, LIMITED, or ERROR\n+     */\n+    @Override\n+    public void start(CompletionListener listener) {\n+        transitionToState(READY);\n+        super.start(listener);\n+    }\n+\n+    /**\n+     * Clean up everything after the manager is no longer needed\n+     */\n+    @Override\n+    public void dispose() {\n+        currentWindowCapability = null;\n+        speechCapabilities = null;\n+        isAlertRPCAllowed = false;\n+        softButtonObjects = null;\n+\n+        if (transactionQueue != null) {\n+            transactionQueue.close();\n+            transactionQueue = null;\n+        }\n+\n+        // remove listeners\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.SPEECH, onSpeechCapabilityListener);\n+        }\n+        if (internalInterface.getPermissionManager() != null) {\n+            internalInterface.getPermissionManager().removeListener(permissionListener);\n+        }\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_PRESS, onButtonPressListener);\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_EVENT, onButtonEventListener);\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Creates a PresentAlertOperation and adds it to the transactionQueue\n+     *\n+     * @param alert    - AlertView object that contains alert information\n+     * @param listener - AlertCompletionListener that will notify the sender when Alert has completed\n+     */\n+    public void presentAlert(AlertView alert, AlertCompletionListener listener) {\n+        if (getState() == ERROR) {\n+            DebugTool.logWarning(TAG, \"Alert Manager In Error State\");\n+            return;\n+        }\n+\n+        // Check for softButtons and assign them ID's, Behavior mimic SoftButtonManager,\n+        // as in if invalid ID's are set, Alert will not show up.\n+        // It's best if ID's are not set custom and allow the screenManager to set them.\n+        if (alert.getSoftButtons() != null) {\n+            if (!BaseScreenManager.checkAndAssignButtonIds(alert.getSoftButtons(), BaseScreenManager.ManagerLocation.ALERT_MANAGER)) {\n+                DebugTool.logError(TAG, \"Attempted to set soft button objects for Alert, but multiple buttons had the same id.\");\n+                return;\n+            }\n+\n+            // Keep Track of SoftButtonObjects, to be able to Call their OnEventListeners\n+            CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+            if (alert.getSoftButtons() instanceof CopyOnWriteArrayList) {\n+                softButtonObjects = (CopyOnWriteArrayList<SoftButtonObject>) alert.getSoftButtons();\n+            } else {\n+                softButtonObjects = new CopyOnWriteArrayList<>(alert.getSoftButtons());\n+            }\n+            if (this.softButtonObjects.size() > 0) {\n+                for (SoftButtonObject object : softButtonObjects) {\n+                    if (softButtonObjects.contains(object)) {\n+                        continue;\n+                    }\n+                    this.softButtonObjects.add(object);\n+                }\n+            } else {\n+                this.softButtonObjects = softButtonObjects;\n+            }\n+        }\n+\n+        if (nextCancelId >= alertCancelIdMax) {\n+            nextCancelId = alertCancelIdMin;\n+        } else {\n+            nextCancelId++;\n+        }\n+\n+        PresentAlertOperation operation = new PresentAlertOperation(internalInterface, alert, currentWindowCapability, speechCapabilities, fileManager.get(), nextCancelId, listener);\n+        transactionQueue.add(operation, false);\n+\n+    }\n+\n+    private Queue newTransactionQueue() {\n+        Queue queue = internalInterface.getTaskmaster().createQueue(\"AlertManager\", 4, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e39944e566ae5448386c4fcc9164d71884d520"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzkyNTI5OQ==", "bodyText": "Agreed", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r577925299", "createdAt": "2021-02-17T20:35:17Z", "author": {"login": "JulianKast"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.livio.taskmaster.Queue;\n+import com.livio.taskmaster.Task;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.BaseSubManager;\n+import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.lifecycle.OnSystemCapabilityListener;\n+import com.smartdevicelink.managers.lifecycle.SystemCapabilityManager;\n+import com.smartdevicelink.managers.permission.OnPermissionChangeListener;\n+import com.smartdevicelink.managers.permission.PermissionElement;\n+import com.smartdevicelink.managers.permission.PermissionStatus;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCNotification;\n+import com.smartdevicelink.proxy.rpc.DisplayCapability;\n+import com.smartdevicelink.proxy.rpc.OnButtonEvent;\n+import com.smartdevicelink.proxy.rpc.OnButtonPress;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ButtonName;\n+import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n+import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+\n+abstract class BaseAlertManager extends BaseSubManager {\n+\n+    private static final String TAG = \"BaseAlertManager\";\n+    Queue transactionQueue;\n+    WindowCapability currentWindowCapability;\n+    private OnSystemCapabilityListener onSpeechCapabilityListener, onDisplaysCapabilityListener;\n+    List<SpeechCapabilities> speechCapabilities;\n+    private UUID permissionListener;\n+    boolean isAlertRPCAllowed = false;\n+    private final WeakReference<FileManager> fileManager;\n+    int nextCancelId;\n+    private final int alertCancelIdMin = 1;\n+    private final int alertCancelIdMax = 100;\n+    private CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+    OnRPCNotificationListener onButtonPressListener, onButtonEventListener;\n+\n+\n+    public BaseAlertManager(@NonNull ISdl internalInterface, @NonNull FileManager fileManager) {\n+        super(internalInterface);\n+        this.transactionQueue = newTransactionQueue();\n+        this.fileManager = new WeakReference<>(fileManager);\n+        nextCancelId = 0;\n+        this.softButtonObjects = new CopyOnWriteArrayList<>();\n+        addListeners();\n+    }\n+\n+    /**\n+     * Starts the manager\n+     * @param listener CompletionListener that is called once the BaseSubManager's state is READY, LIMITED, or ERROR\n+     */\n+    @Override\n+    public void start(CompletionListener listener) {\n+        transitionToState(READY);\n+        super.start(listener);\n+    }\n+\n+    /**\n+     * Clean up everything after the manager is no longer needed\n+     */\n+    @Override\n+    public void dispose() {\n+        currentWindowCapability = null;\n+        speechCapabilities = null;\n+        isAlertRPCAllowed = false;\n+        softButtonObjects = null;\n+\n+        if (transactionQueue != null) {\n+            transactionQueue.close();\n+            transactionQueue = null;\n+        }\n+\n+        // remove listeners\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.SPEECH, onSpeechCapabilityListener);\n+        }\n+        if (internalInterface.getPermissionManager() != null) {\n+            internalInterface.getPermissionManager().removeListener(permissionListener);\n+        }\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_PRESS, onButtonPressListener);\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_EVENT, onButtonEventListener);\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Creates a PresentAlertOperation and adds it to the transactionQueue\n+     *\n+     * @param alert    - AlertView object that contains alert information\n+     * @param listener - AlertCompletionListener that will notify the sender when Alert has completed\n+     */\n+    public void presentAlert(AlertView alert, AlertCompletionListener listener) {\n+        if (getState() == ERROR) {\n+            DebugTool.logWarning(TAG, \"Alert Manager In Error State\");\n+            return;\n+        }\n+\n+        // Check for softButtons and assign them ID's, Behavior mimic SoftButtonManager,\n+        // as in if invalid ID's are set, Alert will not show up.\n+        // It's best if ID's are not set custom and allow the screenManager to set them.\n+        if (alert.getSoftButtons() != null) {\n+            if (!BaseScreenManager.checkAndAssignButtonIds(alert.getSoftButtons(), BaseScreenManager.ManagerLocation.ALERT_MANAGER)) {\n+                DebugTool.logError(TAG, \"Attempted to set soft button objects for Alert, but multiple buttons had the same id.\");\n+                return;\n+            }\n+\n+            // Keep Track of SoftButtonObjects, to be able to Call their OnEventListeners\n+            CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+            if (alert.getSoftButtons() instanceof CopyOnWriteArrayList) {\n+                softButtonObjects = (CopyOnWriteArrayList<SoftButtonObject>) alert.getSoftButtons();\n+            } else {\n+                softButtonObjects = new CopyOnWriteArrayList<>(alert.getSoftButtons());\n+            }\n+            if (this.softButtonObjects.size() > 0) {\n+                for (SoftButtonObject object : softButtonObjects) {\n+                    if (softButtonObjects.contains(object)) {\n+                        continue;\n+                    }\n+                    this.softButtonObjects.add(object);\n+                }\n+            } else {\n+                this.softButtonObjects = softButtonObjects;\n+            }\n+        }\n+\n+        if (nextCancelId >= alertCancelIdMax) {\n+            nextCancelId = alertCancelIdMin;\n+        } else {\n+            nextCancelId++;\n+        }\n+\n+        PresentAlertOperation operation = new PresentAlertOperation(internalInterface, alert, currentWindowCapability, speechCapabilities, fileManager.get(), nextCancelId, listener);\n+        transactionQueue.add(operation, false);\n+\n+    }\n+\n+    private Queue newTransactionQueue() {\n+        Queue queue = internalInterface.getTaskmaster().createQueue(\"AlertManager\", 4, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzgwNjY5MQ=="}, "originalCommit": {"oid": "91e39944e566ae5448386c4fcc9164d71884d520"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDE4MTI1OnYy", "diffSide": "RIGHT", "path": "base/src/main/java/com/smartdevicelink/managers/screen/SoftButtonObject.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOToxMjoxNFrOInGuDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOToxMjoxNFrOInGuDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg3NTQ2OQ==", "bodyText": "Since this is still to be used by the BaseScreenManager should we make a note to make sure we change this to RestrictTo Library,  otherwise it might get removed when we clean up at the end of a future release", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r577875469", "createdAt": "2021-02-17T19:12:14Z", "author": {"login": "RHenigan"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/SoftButtonObject.java", "diffHunk": "@@ -295,12 +295,14 @@ public int getButtonId() {\n     }\n \n     /**\n+     * DO NOT USE! let the managers assign ID's\n      * Sets the id of the SoftButtonObject <br>\n      * <strong>Note: If the developer did not set buttonId, the manager will automatically assign an id before the SoftButtons are sent to the head unit.\n      * Please note that the manager may reuse ids from previous batch of SoftButtons that were already sent to the head unit</strong>\n      *\n      * @param buttonId an int value that represents the id of the SoftButtonObject\n      */\n+    @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e39944e566ae5448386c4fcc9164d71884d520"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0NDIzNDM2OnYy", "diffSide": "RIGHT", "path": "base/src/main/java/com/smartdevicelink/managers/screen/PresentAlertOperation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxOToyNjowOFrOInHPgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QyMToyMzo0OVrOInLhyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg4NDAzNQ==", "bodyText": "Do we need to add this check? I dont think it is actually being made", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r577884035", "createdAt": "2021-02-17T19:26:08Z", "author": {"login": "RHenigan"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/PresentAlertOperation.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import com.livio.taskmaster.Task;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.ManagerUtility;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.file.MultipleFileCompletionListener;\n+import com.smartdevicelink.managers.file.filetypes.SdlArtwork;\n+import com.smartdevicelink.managers.file.filetypes.SdlFile;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCResponse;\n+import com.smartdevicelink.proxy.rpc.Alert;\n+import com.smartdevicelink.proxy.rpc.AlertResponse;\n+import com.smartdevicelink.proxy.rpc.CancelInteraction;\n+import com.smartdevicelink.proxy.rpc.SoftButton;\n+import com.smartdevicelink.proxy.rpc.SoftButtonCapabilities;\n+import com.smartdevicelink.proxy.rpc.TTSChunk;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.listeners.OnRPCResponseListener;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Operation that handles uploading images and audio data needed by the alert and, once the data uploads are complete, sending the alert.\n+ * \n+ * Created by Julian Kast on 12/10/20.\n+ */\n+public class PresentAlertOperation extends Task {\n+    private static final String TAG = \"PresentAlertOperation\";\n+    private AlertView alertView;\n+    private AlertCompletionListener listener;\n+    private final WeakReference<ISdl> internalInterface;\n+    private final WeakReference<FileManager> fileManager;\n+    WindowCapability currentWindowCapability;\n+    private int cancelId;\n+    private List<SpeechCapabilities> speechCapabilities;\n+    boolean isAlertPresented;\n+    static int SOFTBUTTON_COUNT = 4;\n+\n+    public PresentAlertOperation(ISdl internalInterface, AlertView alertView, WindowCapability currentCapabilities, List<SpeechCapabilities> speechCapabilities, FileManager fileManager, Integer cancelId, AlertCompletionListener listener) {\n+        super(\"PresentAlertOperation\");\n+        this.internalInterface = new WeakReference<>(internalInterface);\n+        this.fileManager = new WeakReference<>(fileManager);\n+        this.currentWindowCapability = currentCapabilities;\n+        this.speechCapabilities = speechCapabilities;\n+        this.alertView = alertView.clone();\n+        this.listener = listener;\n+        this.cancelId = cancelId;\n+        this.isAlertPresented = false;\n+\n+        this.alertView.canceledListener = new AlertCanceledListener() {\n+            @Override\n+            public void onAlertCanceled() {\n+                cancelAlert();\n+            }\n+        };\n+        alertView.canceledListener = this.alertView.canceledListener;\n+    }\n+\n+    @Override\n+    public void onExecute() {\n+        DebugTool.logInfo(TAG, \"Alert Operation: Executing present Alert operation\");\n+        start();\n+    }\n+\n+    private void start() {\n+        if (getState() == Task.CANCELED) {\n+            finishOperation(false, null);\n+            return;\n+        }\n+        if (!isValidAlertViewData(alertView)) {\n+            if (alertView.getAudio() != null && alertView.getAudio().getAudioData().size() > 0) {\n+                DebugTool.logError(TAG, \"The module does not support the use of only audio file data in an alert. \" +\n+                        \"The alert has no data and can not be sent to the module. \" +\n+                        \"The use of audio file data in an alert is only supported on modules supporting RPC Spec v5.0 or newer\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e39944e566ae5448386c4fcc9164d71884d520"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzk1NDI1MA==", "bodyText": "Good catch, for this I had to fix isValidAlertViewData(alertView) to check for audio Files, so if not isValidAlertViewData and there is audio in the AlertView, then this is the case.", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r577954250", "createdAt": "2021-02-17T21:23:49Z", "author": {"login": "JulianKast"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/PresentAlertOperation.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import com.livio.taskmaster.Task;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.ManagerUtility;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.file.MultipleFileCompletionListener;\n+import com.smartdevicelink.managers.file.filetypes.SdlArtwork;\n+import com.smartdevicelink.managers.file.filetypes.SdlFile;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCResponse;\n+import com.smartdevicelink.proxy.rpc.Alert;\n+import com.smartdevicelink.proxy.rpc.AlertResponse;\n+import com.smartdevicelink.proxy.rpc.CancelInteraction;\n+import com.smartdevicelink.proxy.rpc.SoftButton;\n+import com.smartdevicelink.proxy.rpc.SoftButtonCapabilities;\n+import com.smartdevicelink.proxy.rpc.TTSChunk;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ImageFieldName;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.listeners.OnRPCResponseListener;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Operation that handles uploading images and audio data needed by the alert and, once the data uploads are complete, sending the alert.\n+ * \n+ * Created by Julian Kast on 12/10/20.\n+ */\n+public class PresentAlertOperation extends Task {\n+    private static final String TAG = \"PresentAlertOperation\";\n+    private AlertView alertView;\n+    private AlertCompletionListener listener;\n+    private final WeakReference<ISdl> internalInterface;\n+    private final WeakReference<FileManager> fileManager;\n+    WindowCapability currentWindowCapability;\n+    private int cancelId;\n+    private List<SpeechCapabilities> speechCapabilities;\n+    boolean isAlertPresented;\n+    static int SOFTBUTTON_COUNT = 4;\n+\n+    public PresentAlertOperation(ISdl internalInterface, AlertView alertView, WindowCapability currentCapabilities, List<SpeechCapabilities> speechCapabilities, FileManager fileManager, Integer cancelId, AlertCompletionListener listener) {\n+        super(\"PresentAlertOperation\");\n+        this.internalInterface = new WeakReference<>(internalInterface);\n+        this.fileManager = new WeakReference<>(fileManager);\n+        this.currentWindowCapability = currentCapabilities;\n+        this.speechCapabilities = speechCapabilities;\n+        this.alertView = alertView.clone();\n+        this.listener = listener;\n+        this.cancelId = cancelId;\n+        this.isAlertPresented = false;\n+\n+        this.alertView.canceledListener = new AlertCanceledListener() {\n+            @Override\n+            public void onAlertCanceled() {\n+                cancelAlert();\n+            }\n+        };\n+        alertView.canceledListener = this.alertView.canceledListener;\n+    }\n+\n+    @Override\n+    public void onExecute() {\n+        DebugTool.logInfo(TAG, \"Alert Operation: Executing present Alert operation\");\n+        start();\n+    }\n+\n+    private void start() {\n+        if (getState() == Task.CANCELED) {\n+            finishOperation(false, null);\n+            return;\n+        }\n+        if (!isValidAlertViewData(alertView)) {\n+            if (alertView.getAudio() != null && alertView.getAudio().getAudioData().size() > 0) {\n+                DebugTool.logError(TAG, \"The module does not support the use of only audio file data in an alert. \" +\n+                        \"The alert has no data and can not be sent to the module. \" +\n+                        \"The use of audio file data in an alert is only supported on modules supporting RPC Spec v5.0 or newer\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzg4NDAzNQ=="}, "originalCommit": {"oid": "91e39944e566ae5448386c4fcc9164d71884d520"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY3NzY5MDM3OnYy", "diffSide": "RIGHT", "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNVQxNjo0OTozMVrOIr_PRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNVQxNjo0OTozMVrOIr_PRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk5NTc4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (softButtonObjects.contains(object)) {\n          \n          \n            \n                                if (this.softButtonObjects.contains(object)) {", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r582995783", "createdAt": "2021-02-25T16:49:31Z", "author": {"login": "RHenigan"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.screen;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.livio.taskmaster.Queue;\n+import com.livio.taskmaster.Task;\n+import com.smartdevicelink.managers.AlertCompletionListener;\n+import com.smartdevicelink.managers.BaseSubManager;\n+import com.smartdevicelink.managers.CompletionListener;\n+import com.smartdevicelink.managers.ISdl;\n+import com.smartdevicelink.managers.file.FileManager;\n+import com.smartdevicelink.managers.lifecycle.OnSystemCapabilityListener;\n+import com.smartdevicelink.managers.lifecycle.SystemCapabilityManager;\n+import com.smartdevicelink.managers.permission.OnPermissionChangeListener;\n+import com.smartdevicelink.managers.permission.PermissionElement;\n+import com.smartdevicelink.managers.permission.PermissionStatus;\n+import com.smartdevicelink.protocol.enums.FunctionID;\n+import com.smartdevicelink.proxy.RPCNotification;\n+import com.smartdevicelink.proxy.rpc.DisplayCapability;\n+import com.smartdevicelink.proxy.rpc.OnButtonEvent;\n+import com.smartdevicelink.proxy.rpc.OnButtonPress;\n+import com.smartdevicelink.proxy.rpc.WindowCapability;\n+import com.smartdevicelink.proxy.rpc.enums.ButtonName;\n+import com.smartdevicelink.proxy.rpc.enums.PredefinedWindows;\n+import com.smartdevicelink.proxy.rpc.enums.SpeechCapabilities;\n+import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n+import com.smartdevicelink.proxy.rpc.listeners.OnRPCNotificationListener;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+\n+abstract class BaseAlertManager extends BaseSubManager {\n+\n+    private static final String TAG = \"BaseAlertManager\";\n+    Queue transactionQueue;\n+    WindowCapability currentWindowCapability;\n+    private OnSystemCapabilityListener onSpeechCapabilityListener, onDisplaysCapabilityListener;\n+    List<SpeechCapabilities> speechCapabilities;\n+    private UUID permissionListener;\n+    boolean isAlertRPCAllowed = false;\n+    private final WeakReference<FileManager> fileManager;\n+    int nextCancelId;\n+    private final int alertCancelIdMin = 1;\n+    private final int alertCancelIdMax = 100;\n+    private CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+    OnRPCNotificationListener onButtonPressListener, onButtonEventListener;\n+\n+\n+    public BaseAlertManager(@NonNull ISdl internalInterface, @NonNull FileManager fileManager) {\n+        super(internalInterface);\n+        this.transactionQueue = newTransactionQueue();\n+        this.fileManager = new WeakReference<>(fileManager);\n+        nextCancelId = 0;\n+        this.softButtonObjects = new CopyOnWriteArrayList<>();\n+        addListeners();\n+    }\n+\n+    /**\n+     * Starts the manager\n+     * @param listener CompletionListener that is called once the BaseSubManager's state is READY, LIMITED, or ERROR\n+     */\n+    @Override\n+    public void start(CompletionListener listener) {\n+        transitionToState(READY);\n+        super.start(listener);\n+    }\n+\n+    /**\n+     * Clean up everything after the manager is no longer needed\n+     */\n+    @Override\n+    public void dispose() {\n+        currentWindowCapability = null;\n+        speechCapabilities = null;\n+        isAlertRPCAllowed = false;\n+        softButtonObjects = null;\n+\n+        if (transactionQueue != null) {\n+            transactionQueue.close();\n+            transactionQueue = null;\n+        }\n+\n+        // remove listeners\n+        if (internalInterface.getSystemCapabilityManager() != null) {\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.DISPLAYS, onDisplaysCapabilityListener);\n+            internalInterface.getSystemCapabilityManager().removeOnSystemCapabilityListener(SystemCapabilityType.SPEECH, onSpeechCapabilityListener);\n+        }\n+        if (internalInterface.getPermissionManager() != null) {\n+            internalInterface.getPermissionManager().removeListener(permissionListener);\n+        }\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_PRESS, onButtonPressListener);\n+        internalInterface.removeOnRPCNotificationListener(FunctionID.ON_BUTTON_EVENT, onButtonEventListener);\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Creates a PresentAlertOperation and adds it to the transactionQueue\n+     *\n+     * @param alert    - AlertView object that contains alert information\n+     * @param listener - AlertCompletionListener that will notify the sender when Alert has completed\n+     */\n+    public void presentAlert(AlertView alert, AlertCompletionListener listener) {\n+        if (getState() == ERROR) {\n+            DebugTool.logWarning(TAG, \"Alert Manager In Error State\");\n+            return;\n+        }\n+\n+        // Check for softButtons and assign them ID's, Behavior mimic SoftButtonManager,\n+        // as in if invalid ID's are set, Alert will not show up.\n+        // It's best if ID's are not set custom and allow the screenManager to set them.\n+        if (alert.getSoftButtons() != null) {\n+            if (!BaseScreenManager.checkAndAssignButtonIds(alert.getSoftButtons(), BaseScreenManager.ManagerLocation.ALERT_MANAGER)) {\n+                DebugTool.logError(TAG, \"Attempted to set soft button objects for Alert, but multiple buttons had the same id.\");\n+                return;\n+            }\n+\n+            // Keep Track of SoftButtonObjects, to be able to Call their OnEventListeners\n+            CopyOnWriteArrayList<SoftButtonObject> softButtonObjects;\n+            if (alert.getSoftButtons() instanceof CopyOnWriteArrayList) {\n+                softButtonObjects = (CopyOnWriteArrayList<SoftButtonObject>) alert.getSoftButtons();\n+            } else {\n+                softButtonObjects = new CopyOnWriteArrayList<>(alert.getSoftButtons());\n+            }\n+            if (this.softButtonObjects.size() > 0) {\n+                for (SoftButtonObject object : softButtonObjects) {\n+                    if (softButtonObjects.contains(object)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a21cf2f701b0dca425310676da4cf9d51b91700"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY3ODg1MzAzOnYy", "diffSide": "RIGHT", "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNVQyMTowMDo1NVrOIsKv9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNVQyMTowMDo1NVrOIsKv9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MzE4NDM3Mw==", "bodyText": "the if check here is not needed,\nif remove() does not find the object the list is unchaged", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1555#discussion_r583184373", "createdAt": "2021-02-25T21:00:55Z", "author": {"login": "RHenigan"}, "path": "base/src/main/java/com/smartdevicelink/managers/screen/BaseAlertManager.java", "diffHunk": "@@ -177,11 +160,30 @@ public void presentAlert(AlertView alert, AlertCompletionListener listener) {\n             nextCancelId++;\n         }\n \n-        PresentAlertOperation operation = new PresentAlertOperation(internalInterface, alert, currentWindowCapability, speechCapabilities, fileManager.get(), nextCancelId, listener);\n+        PresentAlertOperation operation = new PresentAlertOperation(internalInterface, alert, currentWindowCapability, speechCapabilities, fileManager.get(), nextCancelId, listener, new AlertSoftButtonClearListener() {\n+            @Override\n+            public void onButtonClear(List<SoftButtonObject> softButtonObjectList) {\n+                // Stop keeping track of SoftButtonObject listeners as operation has finished\n+                for (SoftButtonObject object : softButtonObjectList) {\n+                    if (softButtonObjects.contains(object)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb8fa9abf55fbb206496d8696e6a79a38c54ba85"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4322, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}