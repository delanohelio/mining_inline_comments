{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5MjA4MDM5", "number": 1426, "title": "SdlSession Refactor", "bodyText": "This PR is ready for review.\nRisk\nThis PR makes major API changes.\nTesting Plan\n\n I have verified that I have not introduced new warnings in this PR (or explain why below)\n I have run the unit tests with this PR\n I have tested this PR against Core and verified behavior (if applicable, if not applicable, explain why below).\n I have tested Android, Java SE, and Java EE\n\nUnit Tests\nRefactored unit tests to support this change as well as updated some tests that seemed to fail beyond this change.\nSummary\n\nCreate  BaseSdlSession in shared code base\nExtend base class in JavaSE and Android projects\nRemoved SdlSession2 and started over on SdlSession for Android project\nRemoved classes that relied on old SdlSession class and methods\n\nChangelog\nBreaking Changes\n\nSdlSession2 was removed\nSdlConnection was removed\nWiProProtocol and AbstractProtocol were removed\nBTTransport and MultiplexTransport (old) were removed\n\nCLA\n\n I have signed the CLA", "createdAt": "2020-07-30T13:59:51Z", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426", "merged": true, "mergeCommit": {"oid": "ba4d587bc22d46771dd12a8db68e14cb95271cf7"}, "closed": true, "closedAt": "2020-08-04T20:56:03Z", "author": {"login": "joeygrover"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3IYUNgH2gAyNDU5MjA4MDM5OjlkMjRhMGU4N2Q4M2IzNTQ0YTRmZDRiYjIwOGJlYzMyNDc5ZTMyMmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7szU9AFqTQ2MTE1NjMwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9d24a0e87d83b3544a4fd4bb208bec32479e322c", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9d24a0e87d83b3544a4fd4bb208bec32479e322c", "committedDate": "2020-07-21T15:57:43Z", "message": "Refactor SdlSession2 into SdlSession with base"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0c4f50e409b486f524d7ded9d0dc6d8f4f875c3", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c0c4f50e409b486f524d7ded9d0dc6d8f4f875c3", "committedDate": "2020-07-21T15:58:38Z", "message": "Remove deprecated classes that used old SdlSession\n\nAlso remove deprecated classes that had to reference those deleted classes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a905bb89b9dd6737a6c92723baf53ce17a547914", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a905bb89b9dd6737a6c92723baf53ce17a547914", "committedDate": "2020-07-21T15:58:54Z", "message": "Fix unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "147f71a881d03b984497ac62519336ee7e667101", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/147f71a881d03b984497ac62519336ee7e667101", "committedDate": "2020-07-30T13:53:13Z", "message": "Merge branch 'develop' of https://github.com/smartdevicelink/sdl_android into feature/sdlsession_refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8080616efd531480981fb265b611e91dffa8489", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f8080616efd531480981fb265b611e91dffa8489", "committedDate": "2020-07-30T14:23:07Z", "message": "Add missing method to JavaSE SdlSession"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MzYzMzUz", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#pullrequestreview-459363353", "createdAt": "2020-07-31T18:04:53Z", "commit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "state": "COMMENTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODowNDo1M1rOG6RW-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxODo0OTowNlrOG7tFtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTAwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.smartdevicelink.protocol.ISdlProtocol;", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755001", "createdAt": "2020-07-31T18:04:53Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 877}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTExNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755117", "createdAt": "2020-07-31T18:05:06Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 883}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTI0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.smartdevicelink.transport.BaseTransportConfig;", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755249", "createdAt": "2020-07-31T18:05:22Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 894}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTM1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import java.util.ListIterator;", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755351", "createdAt": "2020-07-31T18:05:35Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 905}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTQzMw==", "bodyText": "Unused Import", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755433", "createdAt": "2020-07-31T18:05:49Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTAwMQ=="}, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 877}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NjkzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @SuppressWarnings({\"WeakerAccess\", \"deprecation\"})\n          \n      \n    \n    \n  \n\nI don't see the need to suppress theses warnings anymore.", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463756935", "createdAt": "2020-07-31T18:09:09Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+@SuppressWarnings({\"WeakerAccess\", \"deprecation\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 908}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2NDk3MQ==", "bodyText": "Should a card be added to address the TODO here and should we remove the TODO comment now?", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463764971", "createdAt": "2020-07-31T18:26:38Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+@SuppressWarnings({\"WeakerAccess\", \"deprecation\"})\n+public class SdlSession extends BaseSdlSession {\n+    private static final String TAG = \"SdlSession\";\n+\n+    WeakReference<Context> contextWeakReference;\n+    MediaStreamingStatus mediaStreamingStatus;\n+    boolean requiresAudioSupport = false;\n+\n+    public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config){\n+        super(listener,config);\n+        this.transportConfig = config;\n+        if(config != null){\n+            contextWeakReference = new WeakReference<>(config.getContext());\n+            this.requiresAudioSupport = Boolean.TRUE.equals(config.requiresAudioSupport()); //handle null case\n+\n+        }\n+        this.sessionListener = listener;\n+\n+    }\n+\n+    public SdlSession(ISdlConnectionListener listener, TCPTransportConfig config){ //TODO is it better to have two constructors or make it take BaseTransportConfig?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 928}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc3Mzg4MQ==", "bodyText": "Do we need to update this right now and does it need to go from 2017 - 2020 as a combination of the original SdlSession and SdlSession2", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463773881", "createdAt": "2020-07-31T18:47:03Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 841}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNDcwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config){\n          \n          \n            \n                public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config) {", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465134702", "createdAt": "2020-08-04T15:25:18Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+@SuppressWarnings({\"WeakerAccess\", \"deprecation\"})\n+public class SdlSession extends BaseSdlSession {\n+    private static final String TAG = \"SdlSession\";\n+\n+    WeakReference<Context> contextWeakReference;\n+    MediaStreamingStatus mediaStreamingStatus;\n+    boolean requiresAudioSupport = false;\n+\n+    public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 916}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNTkxMQ==", "bodyText": "This is a common issue in this class, should we run the formatter over the entire class now, or will this fall in the scope of another cleanup card", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465135911", "createdAt": "2020-08-04T15:27:00Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+@SuppressWarnings({\"WeakerAccess\", \"deprecation\"})\n+public class SdlSession extends BaseSdlSession {\n+    private static final String TAG = \"SdlSession\";\n+\n+    WeakReference<Context> contextWeakReference;\n+    MediaStreamingStatus mediaStreamingStatus;\n+    boolean requiresAudioSupport = false;\n+\n+    public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNDcwMg=="}, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 916}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA1Mw==", "bodyText": "Do we want to keep this commented out log statement in here for testing purposes?", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465144053", "createdAt": "2020-08-04T15:38:31Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+@SuppressWarnings({\"WeakerAccess\", \"deprecation\"})\n+public class SdlSession extends BaseSdlSession {\n+    private static final String TAG = \"SdlSession\";\n+\n+    WeakReference<Context> contextWeakReference;\n+    MediaStreamingStatus mediaStreamingStatus;\n+    boolean requiresAudioSupport = false;\n+\n+    public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config){\n+        super(listener,config);\n+        this.transportConfig = config;\n+        if(config != null){\n+            contextWeakReference = new WeakReference<>(config.getContext());\n+            this.requiresAudioSupport = Boolean.TRUE.equals(config.requiresAudioSupport()); //handle null case\n+\n+        }\n+        this.sessionListener = listener;\n+\n+    }\n+\n+    public SdlSession(ISdlConnectionListener listener, TCPTransportConfig config){ //TODO is it better to have two constructors or make it take BaseTransportConfig?\n+        super(listener, config);\n+        this.transportConfig = config;\n+        this.sessionListener = listener;\n+    }\n+\n+    protected SdlProtocolBase getSdlProtocolImplementation(){\n+        if(transportConfig instanceof  MultiplexTransportConfig) {\n+            return new SdlProtocol(this, (MultiplexTransportConfig)transportConfig);\n+        } else if(transportConfig instanceof  TCPTransportConfig) {\n+            return new SdlProtocol(this, (TCPTransportConfig)transportConfig);\n+        }\n+\n+        return null;\n+    }\n+\n+    boolean isAudioRequirementMet(){\n+        if(mediaStreamingStatus == null && contextWeakReference!= null && contextWeakReference.get() != null){\n+            mediaStreamingStatus = new MediaStreamingStatus(contextWeakReference.get(), new MediaStreamingStatus.Callback() {\n+                @Override\n+                public void onAudioNoLongerAvailable() {\n+                    close();\n+                    shutdown(\"Audio output no longer available\");\n+                }\n+            });\n+        }\n+\n+        // If requiresAudioSupport is false, or a supported audio output device is available\n+        return !requiresAudioSupport || mediaStreamingStatus.isAudioOutputAvailable();\n+\n+    }\n+\n+\n+    @SuppressWarnings(\"RedundantThrows\")\n+    @Override\n+    public void startSession() throws SdlException {\n+        if(!isAudioRequirementMet()){\n+            shutdown(\"Audio output not available\");\n+            return;\n+        }\n+\n+        sdlProtocol.start();\n+    }\n+\n+    @Override\n+    public TransportType getCurrentTransportType() {\n+        return TransportType.MULTIPLEX;\n+    }\n+\n+    @Override\n+    public void shutdown(String info){\n+        DebugTool.logInfo(TAG, \"Shutdown - \" + info);\n+        if(mediaStreamingStatus != null) {\n+            mediaStreamingStatus.clear();\n+        }\n+        super.shutdown(info);\n+\n+    }\n+\n+    /**\n+     * Get the current protocol version used by this session\n+     * @return Version that represents the Protocol version being used\n+     */\n+    @Override\n+    public Version getProtocolVersion(){\n+        if(sdlProtocol!=null){\n+            return sdlProtocol.getProtocolVersion();\n+        }\n+        return new Version(1,0,0);\n+    }\n+\n+\n+     /* ***********************************************************************************************************************************************************************\n+     * *****************************************************************  IProtocol Listener  ********************************************************************************\n+     *************************************************************************************************************************************************************************/\n+\n+    @Override\n+    public void onProtocolMessageBytesToSend(SdlPacket packet) {\n+        //Log.d(TAG, \"onProtocolMessageBytesToSend - \" + packet.getTransportType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 1006}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjI4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }else{\n          \n          \n            \n                    } else {", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465146281", "createdAt": "2020-08-04T15:41:49Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java", "diffHunk": "@@ -94,11 +93,11 @@ void initialize() {\n         }\n \n         if (_transportConfig != null && _transportConfig.getTransportType().equals(TransportType.MULTIPLEX)) {\n-            this.session = new SdlSession2(sdlConnectionListener, (MultiplexTransportConfig) _transportConfig);\n+            this.session = new SdlSession(sdlConnectionListener, (MultiplexTransportConfig) _transportConfig);\n         } else if (_transportConfig != null && _transportConfig.getTransportType().equals(TransportType.TCP)) {\n-            this.session = new SdlSession2(sdlConnectionListener, (TCPTransportConfig) _transportConfig);\n-        } else {\n-            this.session = SdlSession.createSession((byte) getProtocolVersion().getMajor(), sdlConnectionListener, _transportConfig);\n+            this.session = new SdlSession(sdlConnectionListener, (TCPTransportConfig) _transportConfig);\n+        }else{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t_session.endService(_serviceType,_rpcSessionID);\n          \n          \n            \n            \t\t\t_session.endService(_serviceType, _rpcSessionID);", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465152587", "createdAt": "2020-08-04T15:50:59Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/streaming/StreamPacketizer.java", "diffHunk": "@@ -185,13 +183,7 @@ public void run() {\n \t\t}\r\n \t\tfinally\r\n \t\t{\r\n-\t\t\tif(_session == null) {\r\n-\t\t\t\tif (sdlConnection != null) {\r\n-\t\t\t\t\tsdlConnection.endService(_serviceType, _rpcSessionID);\r\n-\t\t\t\t}\r\n-\t\t\t}else{\r\n-\t\t\t\t_session.endService(_serviceType,_rpcSessionID);\r\n-\t\t\t}\r\n+\t\t\t_session.endService(_serviceType,_rpcSessionID);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MzY5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.smartdevicelink.protocol.SdlProtocol;", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465153694", "createdAt": "2020-08-04T15:52:40Z", "author": {"login": "JulianKast"}, "path": "base/src/main/java/com/smartdevicelink/SdlConnection/BaseSdlSession.java", "diffHunk": "@@ -1,44 +1,12 @@\n-/*\n- * Copyright (c) 2019 Livio, Inc.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- * Redistributions of source code must retain the above copyright notice, this\n- * list of conditions and the following disclaimer.\n- *\n- * Redistributions in binary form must reproduce the above copyright notice,\n- * this list of conditions and the following\n- * disclaimer in the documentation and/or other materials provided with the\n- * distribution.\n- *\n- * Neither the name of the Livio Inc. nor the names of its contributors\n- * may be used to endorse or promote products derived from this software\n- * without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n package com.smartdevicelink.SdlConnection;\n \n-\n import com.smartdevicelink.exception.SdlException;\n import com.smartdevicelink.protocol.ISdlProtocol;\n import com.smartdevicelink.protocol.ProtocolMessage;\n import com.smartdevicelink.protocol.SdlPacket;\n-import com.smartdevicelink.protocol.enums.SessionType;\n import com.smartdevicelink.protocol.SdlProtocol;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0OTQ3Mg==", "bodyText": "This FIXME, is this talking about this SdlSession class?", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465249472", "createdAt": "2020-08-04T18:33:13Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n+       super(listener,config);\n+       //FIXME this class needs to move to JavaSE only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0OTc4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n          \n          \n            \n                public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config) {", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465249785", "createdAt": "2020-08-04T18:33:50Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0OTk3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (sessionType.eq(SessionType.RPC)){\n          \n          \n            \n                    if (sessionType.eq(SessionType.RPC)) {", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465249971", "createdAt": "2020-08-04T18:34:11Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n+       super(listener,config);\n+       //FIXME this class needs to move to JavaSE only\n+    }\n+\n+    @Override\n+    protected SdlProtocolBase getSdlProtocolImplementation() {\n+        return new SdlProtocol(this, transportConfig);\n+    }\n+\n+\n+    @Override\n+    public void onProtocolSessionStarted(SessionType sessionType,\n+                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\n+\n+        DebugTool.logInfo(TAG, \"Protocol session started\");\n+\n+        this.sessionId = sessionID;\n+        if (sessionType.eq(SessionType.RPC)){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1MDU3OQ==", "bodyText": "Should we add brackets to the if statement to be consistent?", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465250579", "createdAt": "2020-08-04T18:35:20Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n+       super(listener,config);\n+       //FIXME this class needs to move to JavaSE only\n+    }\n+\n+    @Override\n+    protected SdlProtocolBase getSdlProtocolImplementation() {\n+        return new SdlProtocol(this, transportConfig);\n+    }\n+\n+\n+    @Override\n+    public void onProtocolSessionStarted(SessionType sessionType,\n+                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\n+\n+        DebugTool.logInfo(TAG, \"Protocol session started\");\n+\n+        this.sessionId = sessionID;\n+        if (sessionType.eq(SessionType.RPC)){\n+            sessionHashId = hashID;\n+        }\n+        if (isEncrypted)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1MTEwNw==", "bodyText": "There are some added if statements and for loops that need this space added as well, should we fix theses now or run the formatted over them later?", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465251107", "createdAt": "2020-08-04T18:36:16Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0OTc4NQ=="}, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1MjIwOQ==", "bodyText": "Are we adding a Security Listener section or can these comments be removed", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465252209", "createdAt": "2020-08-04T18:38:19Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n+       super(listener,config);\n+       //FIXME this class needs to move to JavaSE only\n+    }\n+\n+    @Override\n+    protected SdlProtocolBase getSdlProtocolImplementation() {\n+        return new SdlProtocol(this, transportConfig);\n+    }\n+\n+\n+    @Override\n+    public void onProtocolSessionStarted(SessionType sessionType,\n+                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\n+\n+        DebugTool.logInfo(TAG, \"Protocol session started\");\n+\n+        this.sessionId = sessionID;\n+        if (sessionType.eq(SessionType.RPC)){\n+            sessionHashId = hashID;\n+        }\n+        if (isEncrypted)\n+            encryptedServices.addIfAbsent(sessionType);\n+        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\n+        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\n+            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\n+            for(ISdlServiceListener listener:listeners){\n+                listener.onServiceStarted(this, sessionType, isEncrypted);\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\n+                                       String correlationID) {\n+        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\n+        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\n+            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\n+            for(ISdlServiceListener listener:listeners){\n+                listener.onServiceEnded(this, sessionType);\n+            }\n+        }\n+        encryptedServices.remove(sessionType);\n+    }\n+\n+\n+    @Override\n+    public void onProtocolSessionEndedNACKed(SessionType sessionType,\n+                                             byte sessionID, String correlationID) {\n+        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\n+        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\n+            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\n+            for(ISdlServiceListener listener:listeners){\n+                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+\n+    /* ***********************************************************************************************************************************************************************\n+     * *****************************************************************  IProtocol Listener  ********************************************************************************\n+     *************************************************************************************************************************************************************************/\n+\n+     public void onProtocolSessionNACKed(SessionType sessionType, byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\n+        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\n+                sessionID, version, correlationID, rejectedParams);\n+        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\n+            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\n+            for(ISdlServiceListener listener:listeners){\n+                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NAKed\");\n+            }\n+        }\n+    }    /* ***********************************************************************************************************************************************************************\n+     * *****************************************************************  Security Listener  *********************************************************************************", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NjEyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t//", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465256122", "createdAt": "2020-08-04T18:45:46Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/transport/MultiplexTransportTest.java", "diffHunk": "@@ -58,55 +51,25 @@ public void onTransportError(String info, Exception e) {\n \t\t};\n \t\t\n \t}\n-\t\n-\t@Test\n-\tpublic void testThreadRecoverability(){\n-\t\tMultiplexTransportConfig config = new MultiplexTransportConfig(getTargetContext(),SdlUnitTestContants.TEST_APP_ID);\n-\t\t//\tpublic MultiplexTransport(MultiplexTransportConfig transportConfig, final ITransportListener transportListener){\n-\t\tMultiplexTransport trans = new MultiplexTransport(config,transportListener);\n-\t\t\n-\t\tassertTrue(trans.brokerThread.isAlive());\n-\t\tif(trans.brokerThread.broker==null){\n-\t\t\tsynchronized(trans.brokerThread){\n-\t\t\t\ttry {\n-\t\t\t\t\ttrans.brokerThread.wait(TIMEOUT);;\n-\t\t\t\t} catch (InterruptedException e) {\n-\t\t\t\t\te.printStackTrace();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tassertNotNull(trans.brokerThread.broker);\n-\t\t//Force this to true so we can test thread \n-\t\ttrans.brokerThread.connected = true;\n-\t\ttrans.brokerThread.broker.onHardwareDisconnected(TransportType.BLUETOOTH);\n-\t\t\n-\t\tassertNull(trans.brokerThread);\n-\t\t\n-\t\ttrans = new MultiplexTransport(config,transportListener);\n-\t\tassertTrue(trans.brokerThread.isAlive());\n-\n-\t\t// Send a null config object in the constructor and expect an IllegalArgumentException\n-\t\ttry {\n-\t\t\ttrans = new MultiplexTransport(null, transportListener);\n-\t\t} catch (IllegalArgumentException e) {\n-\t\t\tassertEquals(\"Null transportConfig in MultiplexTransport constructor\", e.getMessage());\n-\t\t} catch (NullPointerException e) {\n-\t\t\tAssert.fail(\"NPE in MultiplexTransport constructor\");\n-\t\t}\n-\t}\n-\n \t// test for setting error state.\n \t@Test\n \tpublic void testSetState() {\n-\t\tfinal Bundle bundle = new Bundle();\n \t\tMultiplexBluetoothTransport btTransport = new MultiplexBluetoothTransport(new Handler(Looper.getMainLooper()) {\n \t\t\t@Override\n \t\t\tpublic void handleMessage(Message message) {\n-\t\t\t\tassertTrue(message.getData().equals(bundle));\n+\t\t\t\tassertNotNull(message);\n+\t\t\t\tif (message.arg1 == MultiplexBaseTransport.STATE_ERROR) {\n+\t\t\t\t\tassertNotNull(message.getData());\n+\t\t\t\t\tassertEquals(MultiplexBaseTransport.REASON_SPP_ERROR, message.getData().getByte(MultiplexBaseTransport.ERROR_REASON_KEY));\n+\t\t\t\t} else {\n+\t\t\t\t\t//It will first listen before the error state\n+\t\t\t\t\tassertEquals(MultiplexBaseTransport.STATE_LISTEN, message.arg1);\n+\t\t\t\t}\n+\t\t\t\t//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NzkwOQ==", "bodyText": "Uncomment this and move it below\nsession.addServiceListener(SessionType.RPC, test);", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465257909", "createdAt": "2020-08-04T18:49:06Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/SdlConnection/SdlSessionTests.java", "diffHunk": "@@ -32,6 +37,7 @@ public void onServiceError(SdlSession session, SessionType type, String reason)\n \t\t\t}\n \t\t};\n \n+\t\t//assertNotNull(session.getServiceListeners());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8080616efd531480981fb265b611e91dffa8489"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a24042f65eb84e60db9302d59a6df1c321513442", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a24042f65eb84e60db9302d59a6df1c321513442", "committedDate": "2020-08-04T19:55:58Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0ce26d1b840fd90208466a75cf9b7a688b50740", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f0ce26d1b840fd90208466a75cf9b7a688b50740", "committedDate": "2020-08-04T20:00:42Z", "message": "Address comments on SdlSession"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTM5MjIx", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#pullrequestreview-461139221", "createdAt": "2020-08-04T20:13:28Z", "commit": {"oid": "f0ce26d1b840fd90208466a75cf9b7a688b50740"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMDoxMzoyOFrOG7v3-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMDoxMzoyOFrOG7v3-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwMzU0NA==", "bodyText": "I missed this on the first pass, Since we changed it in JavaSE, we should add brackets here as well", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465303544", "createdAt": "2020-08-04T20:13:28Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,338 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2017-2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+    private static final String TAG = \"SdlSession\";\n+\n+    WeakReference<Context> contextWeakReference;\n+    MediaStreamingStatus mediaStreamingStatus;\n+    boolean requiresAudioSupport = false;\n+\n+    public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config) {\n+        super(listener, config);\n+        this.transportConfig = config;\n+        if (config != null) {\n+            contextWeakReference = new WeakReference<>(config.getContext());\n+            this.requiresAudioSupport = Boolean.TRUE.equals(config.requiresAudioSupport()); //handle null case\n+\n+        }\n+        this.sessionListener = listener;\n+\n+    }\n+\n+    public SdlSession(ISdlConnectionListener listener, TCPTransportConfig config) {\n+        super(listener, config);\n+        this.transportConfig = config;\n+        this.sessionListener = listener;\n+    }\n+\n+    protected SdlProtocolBase getSdlProtocolImplementation() {\n+        if (transportConfig instanceof MultiplexTransportConfig) {\n+            return new SdlProtocol(this, (MultiplexTransportConfig) transportConfig);\n+        } else if (transportConfig instanceof TCPTransportConfig) {\n+            return new SdlProtocol(this, (TCPTransportConfig) transportConfig);\n+        }\n+\n+        return null;\n+    }\n+\n+    boolean isAudioRequirementMet() {\n+        if (mediaStreamingStatus == null && contextWeakReference != null && contextWeakReference.get() != null) {\n+            mediaStreamingStatus = new MediaStreamingStatus(contextWeakReference.get(), new MediaStreamingStatus.Callback() {\n+                @Override\n+                public void onAudioNoLongerAvailable() {\n+                    close();\n+                    shutdown(\"Audio output no longer available\");\n+                }\n+            });\n+        }\n+\n+        // If requiresAudioSupport is false, or a supported audio output device is available\n+        return !requiresAudioSupport || mediaStreamingStatus.isAudioOutputAvailable();\n+\n+    }\n+\n+\n+    @SuppressWarnings(\"RedundantThrows\")\n+    @Override\n+    public void startSession() throws SdlException {\n+        if (!isAudioRequirementMet()) {\n+            shutdown(\"Audio output not available\");\n+            return;\n+        }\n+\n+        sdlProtocol.start();\n+    }\n+\n+    @Override\n+    public TransportType getCurrentTransportType() {\n+        return TransportType.MULTIPLEX;\n+    }\n+\n+    @Override\n+    public void shutdown(String info) {\n+        DebugTool.logInfo(TAG, \"Shutdown - \" + info);\n+        if (mediaStreamingStatus != null) {\n+            mediaStreamingStatus.clear();\n+        }\n+        super.shutdown(info);\n+\n+    }\n+\n+    /**\n+     * Get the current protocol version used by this session\n+     *\n+     * @return Version that represents the Protocol version being used\n+     */\n+    @Override\n+    public Version getProtocolVersion() {\n+        if (sdlProtocol != null) {\n+            return sdlProtocol.getProtocolVersion();\n+        }\n+        return new Version(1, 0, 0);\n+    }\n+\n+\n+    /* ***********************************************************************************************************************************************************************\n+     * *****************************************************************  IProtocol Listener  ********************************************************************************\n+     *************************************************************************************************************************************************************************/\n+\n+    @Override\n+    public void onProtocolMessageBytesToSend(SdlPacket packet) {\n+        sdlProtocol.sendPacket(packet);\n+    }\n+\n+    @Override\n+    public void onProtocolSessionStarted(SessionType sessionType,\n+                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\n+\n+        DebugTool.logInfo(TAG, \"Protocol session started\");\n+\n+        this.sessionId = sessionID;\n+        if (sessionType.eq(SessionType.RPC)) {\n+            sessionHashId = hashID;\n+        }\n+        if (isEncrypted)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0ce26d1b840fd90208466a75cf9b7a688b50740"}, "originalPosition": 1015}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8423c0782778a7a02e7370e13d10a6ba9240db1e", "author": {"user": {"login": "joeygrover", "name": "Joey Grover"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/8423c0782778a7a02e7370e13d10a6ba9240db1e", "committedDate": "2020-08-04T20:23:22Z", "message": "Add brackets to singlel ine if"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTU2MzAw", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#pullrequestreview-461156300", "createdAt": "2020-08-04T20:39:30Z", "commit": {"oid": "8423c0782778a7a02e7370e13d10a6ba9240db1e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2054, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}