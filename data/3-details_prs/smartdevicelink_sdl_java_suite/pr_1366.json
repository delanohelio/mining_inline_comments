{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MzA1MzI0", "number": 1366, "title": "Use  LifecycleManager in Android", "bodyText": "Fixes #1365\nThis PR is ready for review.\nRisk\nThis PR makes minor API changes.\nTesting Plan\n\n I have verified that I have not introduced new warnings in this PR (or explain why below)\n I have run the unit tests with this PR\n I have tested this PR against Core and verified behavior (if applicable, if not applicable, explain why below).\n I have tested Android, Java SE, and Java EE\n\nUnit Tests\nUnit tests have been updated to use LifecycleManager instead of SdlProxyBase\nCore Tests\nIt is preferred to run most of the basic tests to make sure the new LifecycleManager is working as expected:\n\nTest connecting an Android app using all possible transports\nTest connecting a cloud app\nTest RPC encryption\nTest video and audio streaming\n\nCore version / branch / commit hash / module tested against: 6.1.0\nHMI name / version / branch / commit hash / module tested against: Generic HMI 0.8.0\nSummary\nThis PR includes the following changes:\n\nAdd LifecylceManager to Android and update SdlManager to use the new LifecylceManager\nRefactor LifecylceManager in both Android and JavaSE to put most of the common logic in BaseLifecylceManager\nRefactor SdlManager in both Android and JavaSE to put most of the common logic in BaseSdlManager\n\nCLA\n\n I have signed the CLA", "createdAt": "2020-05-29T20:12:50Z", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366", "merged": true, "mergeCommit": {"oid": "6b52e38eb9cb29e4c28e98191c312d2c1fd82607"}, "closed": true, "closedAt": "2020-06-12T15:06:37Z", "author": {"login": "bilal-alsharifi"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclxvVmAH2gAyNDI1MzA1MzI0OjkzMWFhMWJkYmUxNWFmMzM4YzE1OTNjNmQxZWMxODg1YjRkMGYyN2M=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqSqKrgH2gAyNDI1MzA1MzI0OjRjMDI1YTcyYzQ0YzUzYTdiOWZmNmZiZjg4YWFkNjJkMGE4NDA3NzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "931aa1bdbe15af338c1593c6d1ec1885b4d0f27c", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/931aa1bdbe15af338c1593c6d1ec1885b4d0f27c", "committedDate": "2020-05-28T17:58:20Z", "message": "Move code from LifecycleManager to BaseLifecycleManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54e6d7de2a3ee581a33e116412d93e6a83aff515", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/54e6d7de2a3ee581a33e116412d93e6a83aff515", "committedDate": "2020-05-28T18:17:54Z", "message": "Fix symlinks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95ece776d53caa5b5963af0f2338b7c8e76a3f6c", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/95ece776d53caa5b5963af0f2338b7c8e76a3f6c", "committedDate": "2020-05-28T19:18:59Z", "message": "Move constructor from BaseLifecycleManager to LifecycleManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59cb907de0b36d130086441ee356a51d4b478990", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/59cb907de0b36d130086441ee356a51d4b478990", "committedDate": "2020-05-28T19:31:56Z", "message": "Add Android LifecycleManager constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3bcebab830d465227c1c49f9207964880ea7737", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e3bcebab830d465227c1c49f9207964880ea7737", "committedDate": "2020-05-29T17:08:02Z", "message": "Setup Android SdlManager to use LifecycleManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b414208899ac8872b4bacf85c99cd2c14c467199", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/b414208899ac8872b4bacf85c99cd2c14c467199", "committedDate": "2020-05-29T17:08:24Z", "message": "Merge branch 'develop' into feature/android_lcm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e23c196821cd99acd2a3d9a7d61cb14770e4705", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/2e23c196821cd99acd2a3d9a7d61cb14770e4705", "committedDate": "2020-05-29T17:44:08Z", "message": "Update code formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3917c85a6a7e90716ed6f68f0bb1653441fd2169", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3917c85a6a7e90716ed6f68f0bb1653441fd2169", "committedDate": "2020-06-01T20:19:47Z", "message": "Check NPE in onProxyClosed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18f803e4d2fb505c17a35b778a3837351533d98b", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/18f803e4d2fb505c17a35b778a3837351533d98b", "committedDate": "2020-06-02T14:22:43Z", "message": "Update SdlManager javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e926f28f8f8a8f57a7559093c73a09b075b3d05", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/7e926f28f8f8a8f57a7559093c73a09b075b3d05", "committedDate": "2020-06-02T19:29:03Z", "message": "Add NAV & PCM dupport to EncryptionLifecycleManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c572b8b3581c45abcbd4c9dd3fbc0877841fb290", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c572b8b3581c45abcbd4c9dd3fbc0877841fb290", "committedDate": "2020-06-02T19:31:04Z", "message": "Merge branch 'develop' into feature/android_lcm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "050ae26425751b3beaa0995f3724c22ebe05351f", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/050ae26425751b3beaa0995f3724c22ebe05351f", "committedDate": "2020-06-02T19:53:26Z", "message": "Add basic NAV & PCM support to BaseLifecycleManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30cb9d76521d24b447de5ca389018852cb4ad0a0", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/30cb9d76521d24b447de5ca389018852cb4ad0a0", "committedDate": "2020-06-02T19:53:40Z", "message": "Merge branch 'develop' into feature/android_lcm"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2ee959c1d252d7ecc8537fcb108e8c57f162a8e", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f2ee959c1d252d7ecc8537fcb108e8c57f162a8e", "committedDate": "2020-06-03T14:42:36Z", "message": "Cleanup LCM"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afb592c0804c55be7a5ba395f181dc4d50d745f5", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/afb592c0804c55be7a5ba395f181dc4d50d745f5", "committedDate": "2020-06-03T17:32:26Z", "message": "Move NAV & PCM code to Android LifecycleManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dddd3f79355f707d223a2accf37d7d753369946b", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/dddd3f79355f707d223a2accf37d7d753369946b", "committedDate": "2020-06-03T17:39:17Z", "message": "Remove unused imports"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c28c2367b0eba1cc5b5ee9c572ba67518c5140b", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3c28c2367b0eba1cc5b5ee9c572ba67518c5140b", "committedDate": "2020-06-03T20:07:28Z", "message": "Fix potential NPE in hello sdl java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54706b28b458a3ce38247ee6f64a9641460b1595", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/54706b28b458a3ce38247ee6f64a9641460b1595", "committedDate": "2020-06-03T21:05:55Z", "message": "Update formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88b02528208efdc6c6e029bcc0c5441868506b9f", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/88b02528208efdc6c6e029bcc0c5441868506b9f", "committedDate": "2020-06-04T15:37:18Z", "message": "Merge branch 'develop' into feature/android_lcm\n\n# Conflicts:\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/SdlManager.java\n#\tbase/src/main/java/com/smartdevicelink/managers/BaseSdlManager.java\n#\tjavaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a6e18e90d2c4702e354f63bd6fb2d0184181d1f", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/8a6e18e90d2c4702e354f63bd6fb2d0184181d1f", "committedDate": "2020-06-04T15:47:44Z", "message": "Remove old checkLifecycleConfiguration method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64023263a5a8a22bd32f7d2511e0422309a3c5d0", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/64023263a5a8a22bd32f7d2511e0422309a3c5d0", "committedDate": "2020-06-04T20:25:07Z", "message": "Prevent sending RPC with protected CorrelationID"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "454c3e3a6682d5bcf136d6b1087482591c3ab11b", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/454c3e3a6682d5bcf136d6b1087482591c3ab11b", "committedDate": "2020-06-04T20:31:31Z", "message": "Update getProtocolVersion() to return default version if value is null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed4286b4dd410a03cf32d7ecb842ec102c8fac49", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ed4286b4dd410a03cf32d7ecb842ec102c8fac49", "committedDate": "2020-06-05T15:23:19Z", "message": "Update formatting in SdlManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3622381b0d5a99a941302bdde1ef3c4b0f353f8c", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3622381b0d5a99a941302bdde1ef3c4b0f353f8c", "committedDate": "2020-06-05T15:53:48Z", "message": "Add logic to set SdlSecurityBase.context"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f45dc766fa5c8e7bcd236e5db0bf8af966f5d5b0", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f45dc766fa5c8e7bcd236e5db0bf8af966f5d5b0", "committedDate": "2020-06-05T17:59:29Z", "message": "Remove deprecated methods usage in SdlManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "582014293e69ec06d96f7b0d9d3fd59f748deb35", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/582014293e69ec06d96f7b0d9d3fd59f748deb35", "committedDate": "2020-06-05T17:59:44Z", "message": "Fix SdlManager unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a65389af0a19e9ec54beb1080a1b7e64c8660914", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a65389af0a19e9ec54beb1080a1b7e64c8660914", "committedDate": "2020-06-05T21:11:11Z", "message": "Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a9cc73fa4a540218ac4b9442a498401243da1db", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9a9cc73fa4a540218ac4b9442a498401243da1db", "committedDate": "2020-06-08T13:59:19Z", "message": "Remove unsed vars from LifecycleManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97ecbfab51b1e61788565dc328eaa039b6f6f857", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/97ecbfab51b1e61788565dc328eaa039b6f6f857", "committedDate": "2020-06-08T18:44:01Z", "message": "add createSession method to LCM"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "committedDate": "2020-06-09T15:33:41Z", "message": "Add cycle proxy logic to LCM"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MDA2ODAz", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#pullrequestreview-429006803", "createdAt": "2020-06-11T15:08:39Z", "commit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNTowODozOVrOGihrZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNjo0MDozNFrOGilyEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NjU0OQ==", "bodyText": "There are formatting issues in this class with spaces needing to be added before { in regards to methods and if statements", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438856549", "createdAt": "2020-06-11T15:08:39Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -41,65 +41,22 @@\n import android.support.annotation.Nullable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1ODE4Mg==", "bodyText": "add space before {", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438858182", "createdAt": "2020-06-11T15:11:05Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.lifecycle;\n+\n+import android.app.Service;\n+import android.content.Context;\n+import android.support.annotation.RestrictTo;\n+import android.util.Log;\n+\n+import com.smartdevicelink.SdlConnection.SdlSession;\n+import com.smartdevicelink.SdlConnection.SdlSession2;\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.exception.SdlExceptionCause;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.rpc.enums.SdlDisconnectedReason;\n+import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n+import com.smartdevicelink.security.SdlSecurityBase;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.USBTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * The lifecycle manager creates a central point for all SDL session logic to converge. It should only be used by\n+ * the library itself. Usage outside the library is not permitted and will not be protected for in the future.\n+ *\n+ * @author Bilal Alsharifi.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY)\n+public class LifecycleManager extends BaseLifecycleManager {\n+    private static final int RESPONSE_WAIT_TIME = 2000;\n+    private ISdlServiceListener navServiceListener;\n+    private boolean navServiceStartResponseReceived = false;\n+    private boolean navServiceStartResponse = false;\n+    private boolean navServiceEndResponseReceived = false;\n+    private boolean navServiceEndResponse = false;\n+    private boolean pcmServiceEndResponseReceived = false;\n+    private boolean pcmServiceEndResponse = false;\n+    private Context context;\n+\n+    public LifecycleManager(AppConfig appConfig, BaseTransportConfig config, LifecycleListener listener) {\n+        super(appConfig, config, listener);\n+    }\n+\n+    @Override\n+    void initializeProxy() {\n+        super.initializeProxy();\n+\n+        //Handle legacy USB connections\n+        if (_transportConfig != null && TransportType.USB.equals(_transportConfig.getTransportType())) {\n+            //A USB transport config was provided\n+            USBTransportConfig usbTransportConfig = (USBTransportConfig) _transportConfig;\n+            if (usbTransportConfig.getUsbAccessory() == null) {\n+                DebugTool.logInfo(\"Legacy USB transport config was used, but received null for accessory. Attempting to connect with router service\");\n+                //The accessory was null which means it came from a router service\n+                MultiplexTransportConfig multiplexTransportConfig = new MultiplexTransportConfig(usbTransportConfig.getUSBContext(), appConfig.getAppID());\n+                multiplexTransportConfig.setRequiresHighBandwidth(true);\n+                multiplexTransportConfig.setSecurityLevel(MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n+                multiplexTransportConfig.setPrimaryTransports(Collections.singletonList(TransportType.USB));\n+                multiplexTransportConfig.setSecondaryTransports(new ArrayList<TransportType>());\n+                _transportConfig = multiplexTransportConfig;\n+            }\n+        }\n+\n+        if (_transportConfig != null && _transportConfig.getTransportType().equals(TransportType.MULTIPLEX)) {\n+            this.session = new SdlSession2(sdlConnectionListener, (MultiplexTransportConfig) _transportConfig);\n+        } else if (_transportConfig != null && _transportConfig.getTransportType().equals(TransportType.TCP)) {\n+            this.session = new SdlSession2(sdlConnectionListener, (TCPTransportConfig) _transportConfig);\n+        } else {\n+            this.session = SdlSession.createSession((byte) getProtocolVersion().getMajor(), sdlConnectionListener, _transportConfig);\n+        }\n+    }\n+\n+    private void cycleProxy(SdlDisconnectedReason disconnectedReason) {\n+        cleanProxy();\n+        initializeProxy();\n+        if(!SdlDisconnectedReason.LEGACY_BLUETOOTH_MODE_ENABLED.equals(disconnectedReason) && !SdlDisconnectedReason.PRIMARY_TRANSPORT_CYCLE_REQUEST.equals(disconnectedReason)){\n+            //We don't want to alert higher if we are just cycling for legacy bluetooth\n+            onClose(\"Sdl Proxy Cycled\", new SdlException(\"Sdl Proxy Cycled\", SdlExceptionCause.SDL_PROXY_CYCLED));\n+        }\n+        try {\n+            session.startSession();\n+        } catch (SdlException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public void setContext(Context context) {\n+        this.context = context;\n+    }\n+\n+    @Override\n+    void setSdlSecurityStaticVars() {\n+        super.setSdlSecurityStaticVars();\n+\n+        Service service = null;\n+        if (context != null && context instanceof Service) {\n+            service = (Service) context;\n+        }\n+        SdlSecurityBase.setAppService(service);\n+        SdlSecurityBase.setContext(context);\n+    }\n+\n+    @Override\n+    void onProtocolSessionStarted(SessionType sessionType) {\n+        super.onProtocolSessionStarted(sessionType);\n+        if (sessionType.eq(SessionType.NAV)) {\n+            navServiceStartResponseReceived = true;\n+            navServiceStartResponse = true;\n+        }\n+    }\n+\n+    @Override\n+    void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MTYxMA==", "bodyText": "There are several cases in this class where a space needs to be added before {", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438861610", "createdAt": "2020-06-11T15:15:57Z", "author": {"login": "JulianKast"}, "path": "base/src/main/java/com/smartdevicelink/managers/BaseSdlManager.java", "diffHunk": "@@ -31,24 +31,46 @@\n  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2Mjk3Mg==", "bodyText": "There are several cases in this class where a space needs to be added before {", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438862972", "createdAt": "2020-06-11T15:17:54Z", "author": {"login": "JulianKast"}, "path": "base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseLifecycleManager.java", "diffHunk": "@@ -32,5 +32,1490 @@\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MzkyMA==", "bodyText": "Add space before '{'", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438863920", "createdAt": "2020-06-11T15:19:14Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){\n+            if (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n+                DebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n+                transitionToState(BaseSubManager.READY);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            } else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n+                String info = \"ERROR starting sdl manager, all sub managers are in error state\";\n+                Log.e(TAG, info);\n+                transitionToState(BaseSubManager.ERROR);\n+                notifyDevListener(info);\n+            } else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n+                DebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n+                transitionToState(BaseSubManager.SETTING_UP);\n+                // No need to notify developer here!\n+            } else {\n+                Log.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n+                transitionToState(BaseSubManager.LIMITED);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            }\n+        } else {\n+            // We should never be here, but somehow one of the sub-sub managers is null\n+            String info = \"ERROR one of the sdl sub managers is null\";\n+            Log.e(TAG, info);\n+            transitionToState(BaseSubManager.ERROR);\n+            notifyDevListener(info);\n+        }\n+    }\n+\n+    private void notifyDevListener(String info) {\n+        if (managerListener != null) {\n+            if (getState() == BaseSubManager.ERROR){\n+                managerListener.onError((SdlManager)this, info, null);\n+            } else {\n+                managerListener.onStart((SdlManager) this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void retryChangeRegistration() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    void onProxyClosed(SdlDisconnectedReason reason) {\n+        Log.i(TAG,\"Proxy is closed.\");\n+        if(managerListener != null){\n+            managerListener.onDestroy(SdlManager.this);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (this.permissionManager != null) {\n+            this.permissionManager.dispose();\n+        }\n+\n+        if (this.fileManager != null) {\n+            this.fileManager.dispose();\n+        }\n+\n+        if (this.screenManager != null) {\n+            this.screenManager.dispose();\n+        }\n+\n+        if (this.lifecycleManager != null) {\n+            this.lifecycleManager.stop();\n+        }\n+\n+        if(managerListener != null){\n+            managerListener.onDestroy((SdlManager)this);\n+            managerListener = null;\n+        }\n+\n+        transitionToState(BaseSubManager.SHUTDOWN);\n+    }\n+\n+    // BUILDER\n+    public static class Builder extends BaseSdlManager.Builder {\n+        /**\n+         * Builder for the SdlManager. Parameters in the constructor are required.\n+         * @param appId the app's ID\n+         * @param appName the app's name\n+         * @param listener a SdlManagerListener object\n+         */\n+        public Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 931}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NDE3NA==", "bodyText": "Add space before '{'", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438864174", "createdAt": "2020-06-11T15:19:39Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){\n+            if (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n+                DebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n+                transitionToState(BaseSubManager.READY);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            } else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n+                String info = \"ERROR starting sdl manager, all sub managers are in error state\";\n+                Log.e(TAG, info);\n+                transitionToState(BaseSubManager.ERROR);\n+                notifyDevListener(info);\n+            } else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n+                DebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n+                transitionToState(BaseSubManager.SETTING_UP);\n+                // No need to notify developer here!\n+            } else {\n+                Log.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n+                transitionToState(BaseSubManager.LIMITED);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            }\n+        } else {\n+            // We should never be here, but somehow one of the sub-sub managers is null\n+            String info = \"ERROR one of the sdl sub managers is null\";\n+            Log.e(TAG, info);\n+            transitionToState(BaseSubManager.ERROR);\n+            notifyDevListener(info);\n+        }\n+    }\n+\n+    private void notifyDevListener(String info) {\n+        if (managerListener != null) {\n+            if (getState() == BaseSubManager.ERROR){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 876}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NDUzOA==", "bodyText": "Add space before '{'", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438864538", "createdAt": "2020-06-11T15:20:10Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){\n+            if (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n+                DebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n+                transitionToState(BaseSubManager.READY);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            } else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 849}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NDYwMg==", "bodyText": "Add space before '{'", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438864602", "createdAt": "2020-06-11T15:20:16Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){\n+            if (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 843}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NDY3MQ==", "bodyText": "Add space before '{'", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438864671", "createdAt": "2020-06-11T15:20:21Z", "author": {"login": "JulianKast"}, "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 842}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyMzc5NA==", "bodyText": "Add space before {", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438923794", "createdAt": "2020-06-11T16:40:34Z", "author": {"login": "JulianKast"}, "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/SdlManagerTests.java", "diffHunk": "@@ -371,18 +369,16 @@ public Void answer(InvocationOnMock invocation) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t};\n-\t\ttry {\n-\t\t\tif (sequentialSend){\n-\t\t\t\tdoAnswer(answer).when(sdlProxyBase).sendSequentialRequests(any(List.class), any(OnMultipleRequestListener.class));\n \n-\t\t\t} else {\n-\t\t\t\tdoAnswer(answer).when(sdlProxyBase).sendRequests(any(List.class), any(OnMultipleRequestListener.class));\n-\t\t\t}\n-\t\t} catch (SdlException e) {\n-\t\t\te.printStackTrace();\n+\t\tif (sequentialSend){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c025a72c44c53a7b9ff6fbf88aad62d0a840771", "author": {"user": {"login": "bilal-alsharifi", "name": "Bilal Alsharifi"}}, "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/4c025a72c44c53a7b9ff6fbf88aad62d0a840771", "committedDate": "2020-06-11T18:35:15Z", "message": "Update formatting"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2171, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}