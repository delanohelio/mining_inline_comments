{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MjAyMTc2", "number": 1534, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDozNToyNVrOEfqT5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMjoyMTo0MFrOEfuD2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjM0NTM1OnYy", "diffSide": "RIGHT", "path": "k-distribution/include/kframework/cparser/main.c", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDozNToyNVrOHMFEDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDozNToyNVrOHMFEDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyNzkxOQ==", "bodyText": "Half joking: How about caching the lengths, then:\n  strcpy(strcpy(strcpy(strcpy(strcpy(symbol, prefix) + len(prefix), lesser) + len(lesser), infix) + len(infix), greater) + len(greater), suffix);", "url": "https://github.com/kframework/k/pull/1534#discussion_r482427919", "createdAt": "2020-09-02T20:35:25Z", "author": {"login": "virgil-serbanuta"}, "path": "k-distribution/include/kframework/cparser/main.c", "diffHunk": "@@ -77,6 +61,20 @@ bool equalsNode(node *x0, node *x1) {\n   }\n }\n \n+char *injSymbol(char *lesser, char *greater) {\n+  char *prefix = \"inj{\";\n+  char *infix = \", \";\n+  char *suffix = \"}\";\n+  size_t len = strlen(prefix) + strlen(suffix) + strlen(lesser) + strlen(greater) + strlen(infix) + 1;\n+  char *symbol = malloc(len);\n+  strcpy(symbol, prefix);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac05bc57dea6b085bae2be1a9652c0576b234e08"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjc1ODk3OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTozOToxM1rOHMJbzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNzoxMjoxNFrOHMwGcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ5OTUzMg==", "bodyText": "I assume that \"less\" means \"included in\", i.e. here lesserSort is included in greaterSort and lesser's sort is included in greater's, right?", "url": "https://github.com/kframework/k/pull/1534#discussion_r482499532", "createdAt": "2020-09-02T21:39:13Z", "author": {"login": "virgil-serbanuta"}, "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "diffHunk": "@@ -215,6 +217,83 @@ private static void encode(Sort sort, StringBuilder sb) {\n     sb.append(\"_\");\n   }\n \n+  private static void appendOverloadCondition(StringBuilder bison, Module module, Production greater, Production lesser, List<Integer> nts) {\n+    bison.append(\"true\");\n+    for (int i = 0; i < nts.size(); i++) {\n+      boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+      if (!hasSameSort) {\n+        bison.append(\" && strncmp($\").append(nts.get(i)).append(\".nterm->symbol, \\\"inj{\\\", 4) == 0 && (false\");\n+        Sort greaterSort = lesser.nonterminals().apply(i).sort();\n+        for (Sort lesserSort : iterable(module.subsorts().elements())) {\n+          if (module.subsorts().lessThanEq(lesserSort, greaterSort)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac05bc57dea6b085bae2be1a9652c0576b234e08"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEzMzA0Mg==", "bodyText": "A <= B in this context means either A = B, or A is a subsort of B.", "url": "https://github.com/kframework/k/pull/1534#discussion_r483133042", "createdAt": "2020-09-03T17:12:14Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "diffHunk": "@@ -215,6 +217,83 @@ private static void encode(Sort sort, StringBuilder sb) {\n     sb.append(\"_\");\n   }\n \n+  private static void appendOverloadCondition(StringBuilder bison, Module module, Production greater, Production lesser, List<Integer> nts) {\n+    bison.append(\"true\");\n+    for (int i = 0; i < nts.size(); i++) {\n+      boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+      if (!hasSameSort) {\n+        bison.append(\" && strncmp($\").append(nts.get(i)).append(\".nterm->symbol, \\\"inj{\\\", 4) == 0 && (false\");\n+        Sort greaterSort = lesser.nonterminals().apply(i).sort();\n+        for (Sort lesserSort : iterable(module.subsorts().elements())) {\n+          if (module.subsorts().lessThanEq(lesserSort, greaterSort)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ5OTUzMg=="}, "originalCommit": {"oid": "ac05bc57dea6b085bae2be1a9652c0576b234e08"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjg1OTM3OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTo1OTo1MVrOHMKdKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTo1OTo1MVrOHMKdKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUxNjI2NA==", "bodyText": "Would this work if there are multiple terminals? I.e. wouldn't origChild be redeclared in the same block?", "url": "https://github.com/kframework/k/pull/1534#discussion_r482516264", "createdAt": "2020-09-02T21:59:51Z", "author": {"login": "virgil-serbanuta"}, "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "diffHunk": "@@ -215,6 +217,83 @@ private static void encode(Sort sort, StringBuilder sb) {\n     sb.append(\"_\");\n   }\n \n+  private static void appendOverloadCondition(StringBuilder bison, Module module, Production greater, Production lesser, List<Integer> nts) {\n+    bison.append(\"true\");\n+    for (int i = 0; i < nts.size(); i++) {\n+      boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+      if (!hasSameSort) {\n+        bison.append(\" && strncmp($\").append(nts.get(i)).append(\".nterm->symbol, \\\"inj{\\\", 4) == 0 && (false\");\n+        Sort greaterSort = lesser.nonterminals().apply(i).sort();\n+        for (Sort lesserSort : iterable(module.subsorts().elements())) {\n+          if (module.subsorts().lessThanEq(lesserSort, greaterSort)) {\n+            bison.append(\" || strcmp($\").append(nts.get(i)).append(\".nterm->children[0]->sort, \\\"\");\n+            encodeKore(lesserSort, bison);\n+            bison.append(\"\\\") == 0\");\n+          }\n+        }\n+        bison.append(\")\");\n+      }\n+    }\n+  }\n+\n+  private static void appendOverloadChecks(StringBuilder bison, Module module, Production greater, List<Integer> nts, boolean hasLocation) {\n+    for (Production lesser : iterable(module.overloads().elements())) {\n+      if (module.overloads().lessThan(lesser, greater)) {\n+        bison.append(\"  if (\");\n+        appendOverloadCondition(bison, module, greater, lesser, nts);\n+        bison.append(\") {\\n\" +\n+            \"    n->symbol =\\\"\");\n+        encodeKore(lesser.klabel().get(), bison);\n+        bison.append(\"\\\";\\n\" +\n+            \"    n->sort = \\\"\");\n+        encodeKore(lesser.sort(), bison);\n+        boolean hasLesserLocation = module.sortAttributesFor().get(lesser.sort().head()).getOrElse(() -> Att.empty()).contains(\"locations\");\n+        bison.append(\"\\\";\\n\" +\n+            \"    n->hasLocation = \" + (hasLesserLocation ? \"1\" : \"0\") + \";\\n\");\n+        for (int i = 0; i < nts.size(); i++) {\n+          boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+          if (hasSameSort) {\n+            bison.append(\n+                \"    n->children[\").append(i).append(\"] = $\").append(nts.get(i)).append(\".nterm;\\n\");\n+          } else {\n+            bison.append(\n+                \"    node *origChild = $\").append(nts.get(i)).append(\".nterm;\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac05bc57dea6b085bae2be1a9652c0576b234e08"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjk1OTYzOnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMjoyMTo0MFrOHMLfFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNzozMTo0NlrOHMww_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzMzE0MA==", "bodyText": "This is a repeated if( ... ) { ... } else section, which means that only the first lesser production that passes the test is processed. Why is it good enough to use only the first one?", "url": "https://github.com/kframework/k/pull/1534#discussion_r482533140", "createdAt": "2020-09-02T22:21:40Z", "author": {"login": "virgil-serbanuta"}, "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "diffHunk": "@@ -215,6 +217,83 @@ private static void encode(Sort sort, StringBuilder sb) {\n     sb.append(\"_\");\n   }\n \n+  private static void appendOverloadCondition(StringBuilder bison, Module module, Production greater, Production lesser, List<Integer> nts) {\n+    bison.append(\"true\");\n+    for (int i = 0; i < nts.size(); i++) {\n+      boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+      if (!hasSameSort) {\n+        bison.append(\" && strncmp($\").append(nts.get(i)).append(\".nterm->symbol, \\\"inj{\\\", 4) == 0 && (false\");\n+        Sort greaterSort = lesser.nonterminals().apply(i).sort();\n+        for (Sort lesserSort : iterable(module.subsorts().elements())) {\n+          if (module.subsorts().lessThanEq(lesserSort, greaterSort)) {\n+            bison.append(\" || strcmp($\").append(nts.get(i)).append(\".nterm->children[0]->sort, \\\"\");\n+            encodeKore(lesserSort, bison);\n+            bison.append(\"\\\") == 0\");\n+          }\n+        }\n+        bison.append(\")\");\n+      }\n+    }\n+  }\n+\n+  private static void appendOverloadChecks(StringBuilder bison, Module module, Production greater, List<Integer> nts, boolean hasLocation) {\n+    for (Production lesser : iterable(module.overloads().elements())) {\n+      if (module.overloads().lessThan(lesser, greater)) {\n+        bison.append(\"  if (\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac05bc57dea6b085bae2be1a9652c0576b234e08"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0MzkzNQ==", "bodyText": "This is a good catch; I meant to topologically sort the entries, but forgot. This should be fixed now; because of the topological sorting, a lesser overload will always appear before a greater overload, so we will always end up choosing an overload such that there is no lesser overload than the overload we chose that would also satisfy the constraints. As a result, any remaining ambiguities will be real ambiguities.", "url": "https://github.com/kframework/k/pull/1534#discussion_r483143935", "createdAt": "2020-09-03T17:31:46Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/KSyntax2Bison.java", "diffHunk": "@@ -215,6 +217,83 @@ private static void encode(Sort sort, StringBuilder sb) {\n     sb.append(\"_\");\n   }\n \n+  private static void appendOverloadCondition(StringBuilder bison, Module module, Production greater, Production lesser, List<Integer> nts) {\n+    bison.append(\"true\");\n+    for (int i = 0; i < nts.size(); i++) {\n+      boolean hasSameSort = lesser.nonterminals().apply(i).sort().equals(greater.nonterminals().apply(i).sort());\n+      if (!hasSameSort) {\n+        bison.append(\" && strncmp($\").append(nts.get(i)).append(\".nterm->symbol, \\\"inj{\\\", 4) == 0 && (false\");\n+        Sort greaterSort = lesser.nonterminals().apply(i).sort();\n+        for (Sort lesserSort : iterable(module.subsorts().elements())) {\n+          if (module.subsorts().lessThanEq(lesserSort, greaterSort)) {\n+            bison.append(\" || strcmp($\").append(nts.get(i)).append(\".nterm->children[0]->sort, \\\"\");\n+            encodeKore(lesserSort, bison);\n+            bison.append(\"\\\") == 0\");\n+          }\n+        }\n+        bison.append(\")\");\n+      }\n+    }\n+  }\n+\n+  private static void appendOverloadChecks(StringBuilder bison, Module module, Production greater, List<Integer> nts, boolean hasLocation) {\n+    for (Production lesser : iterable(module.overloads().elements())) {\n+      if (module.overloads().lessThan(lesser, greater)) {\n+        bison.append(\"  if (\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUzMzE0MA=="}, "originalCommit": {"oid": "ac05bc57dea6b085bae2be1a9652c0576b234e08"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3015, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}