{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NTYzNDEz", "number": 1468, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzowMjoyNFrOETWCvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzowMzo0NFrOETWEkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzE5NTQ4OnYy", "diffSide": "RIGHT", "path": "pending-documentation.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzowMjoyNFrOG5BvOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxOTowMjozM1rOG5GDyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MDQ5MA==", "bodyText": "Is it currently an error to specify both simplification and concrete/symbolic? If not, can we open an issue for that and add it to the backlog?", "url": "https://github.com/kframework/k/pull/1468#discussion_r462450490", "createdAt": "2020-07-29T17:02:24Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -1157,45 +1198,31 @@ rule X +Int (Y +Int Z) => (X +Int Z) +Int Y\n    andBool #isVariable(Y)\n ```\n \n-### `simplification` attribute (Haskell backend)\n-\n-The simplification attribute identifies axioms that are useful for simplifying\n-configurations, without being part of the main semantics. When a rule is tagged\n-as `simplification`, the Haskell backend will only apply that rule if:\n+### `concrete` and `symbolic` attributes (Haskell backend)\n \n--   the rule lhs _matches_ the subterm of interest, and\n--   the side condition has no remainder given the current top-level predicate\n-    (that is, the current top-level predicate _implies_ the side condition of\n-    the rule).\n+Sometimes you only want a rule to apply if some or all arguments are concrete\n+(not symbolic). This is done with the `concrete` attribute. Conversely, the\n+`symbolic` attribute will allow a rule to apply only when some arguments are not\n+concrete. These attributes should only be given with the `simplification`\n+attribute.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba5196eee254171737d586fbc6195ba47ec1923"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMTI4OA==", "bodyText": "Added #1470", "url": "https://github.com/kframework/k/pull/1468#discussion_r462521288", "createdAt": "2020-07-29T19:02:33Z", "author": {"login": "ttuegel"}, "path": "pending-documentation.md", "diffHunk": "@@ -1157,45 +1198,31 @@ rule X +Int (Y +Int Z) => (X +Int Z) +Int Y\n    andBool #isVariable(Y)\n ```\n \n-### `simplification` attribute (Haskell backend)\n-\n-The simplification attribute identifies axioms that are useful for simplifying\n-configurations, without being part of the main semantics. When a rule is tagged\n-as `simplification`, the Haskell backend will only apply that rule if:\n+### `concrete` and `symbolic` attributes (Haskell backend)\n \n--   the rule lhs _matches_ the subterm of interest, and\n--   the side condition has no remainder given the current top-level predicate\n-    (that is, the current top-level predicate _implies_ the side condition of\n-    the rule).\n+Sometimes you only want a rule to apply if some or all arguments are concrete\n+(not symbolic). This is done with the `concrete` attribute. Conversely, the\n+`symbolic` attribute will allow a rule to apply only when some arguments are not\n+concrete. These attributes should only be given with the `simplification`\n+attribute.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MDQ5MA=="}, "originalCommit": {"oid": "3ba5196eee254171737d586fbc6195ba47ec1923"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzE5ODU0OnYy", "diffSide": "RIGHT", "path": "pending-documentation.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzowMzoxNVrOG5BxHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxOTowMTowNVrOG5GAXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MDk3NQ==", "bodyText": "I think use a better example, which won't cause an infinite loop if you can. Just a minor annoyance on my part.", "url": "https://github.com/kframework/k/pull/1468#discussion_r462450975", "createdAt": "2020-07-29T17:03:15Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -1157,45 +1198,31 @@ rule X +Int (Y +Int Z) => (X +Int Z) +Int Y\n    andBool #isVariable(Y)\n ```\n \n-### `simplification` attribute (Haskell backend)\n-\n-The simplification attribute identifies axioms that are useful for simplifying\n-configurations, without being part of the main semantics. When a rule is tagged\n-as `simplification`, the Haskell backend will only apply that rule if:\n+### `concrete` and `symbolic` attributes (Haskell backend)\n \n--   the rule lhs _matches_ the subterm of interest, and\n--   the side condition has no remainder given the current top-level predicate\n-    (that is, the current top-level predicate _implies_ the side condition of\n-    the rule).\n+Sometimes you only want a rule to apply if some or all arguments are concrete\n+(not symbolic). This is done with the `concrete` attribute. Conversely, the\n+`symbolic` attribute will allow a rule to apply only when some arguments are not\n+concrete. These attributes should only be given with the `simplification`\n+attribute.\n \n-Note that the `simplification` attribute can be applied to _any_ rule, not just\n-function rules, and that `simplification` rules are tried _before_ rules from\n-the semantic definition.\n-\n-For example, for the following definition:\n+For example, the following will only re-associate terms when all arguments\n+are concrete:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba5196eee254171737d586fbc6195ba47ec1923"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMDQxMw==", "bodyText": "I don't see why this will cause a loop. It is the same example used for the Java backend. Anyway, I took two examples from INT-SYMBOLIC-KORE instead, as I thought that would be more productive.", "url": "https://github.com/kframework/k/pull/1468#discussion_r462520413", "createdAt": "2020-07-29T19:01:05Z", "author": {"login": "ttuegel"}, "path": "pending-documentation.md", "diffHunk": "@@ -1157,45 +1198,31 @@ rule X +Int (Y +Int Z) => (X +Int Z) +Int Y\n    andBool #isVariable(Y)\n ```\n \n-### `simplification` attribute (Haskell backend)\n-\n-The simplification attribute identifies axioms that are useful for simplifying\n-configurations, without being part of the main semantics. When a rule is tagged\n-as `simplification`, the Haskell backend will only apply that rule if:\n+### `concrete` and `symbolic` attributes (Haskell backend)\n \n--   the rule lhs _matches_ the subterm of interest, and\n--   the side condition has no remainder given the current top-level predicate\n-    (that is, the current top-level predicate _implies_ the side condition of\n-    the rule).\n+Sometimes you only want a rule to apply if some or all arguments are concrete\n+(not symbolic). This is done with the `concrete` attribute. Conversely, the\n+`symbolic` attribute will allow a rule to apply only when some arguments are not\n+concrete. These attributes should only be given with the `simplification`\n+attribute.\n \n-Note that the `simplification` attribute can be applied to _any_ rule, not just\n-function rules, and that `simplification` rules are tried _before_ rules from\n-the semantic definition.\n-\n-For example, for the following definition:\n+For example, the following will only re-associate terms when all arguments\n+are concrete:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MDk3NQ=="}, "originalCommit": {"oid": "3ba5196eee254171737d586fbc6195ba47ec1923"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzIwMDE4OnYy", "diffSide": "RIGHT", "path": "pending-documentation.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzowMzo0NFrOG5ByQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzowOToxM1rOG5B_Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MTI2NQ==", "bodyText": "I thought we supported something like concrete(X, Y), symbolic(Z) instead of having them all be separate?", "url": "https://github.com/kframework/k/pull/1468#discussion_r462451265", "createdAt": "2020-07-29T17:03:44Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -1157,45 +1198,31 @@ rule X +Int (Y +Int Z) => (X +Int Z) +Int Y\n    andBool #isVariable(Y)\n ```\n \n-### `simplification` attribute (Haskell backend)\n-\n-The simplification attribute identifies axioms that are useful for simplifying\n-configurations, without being part of the main semantics. When a rule is tagged\n-as `simplification`, the Haskell backend will only apply that rule if:\n+### `concrete` and `symbolic` attributes (Haskell backend)\n \n--   the rule lhs _matches_ the subterm of interest, and\n--   the side condition has no remainder given the current top-level predicate\n-    (that is, the current top-level predicate _implies_ the side condition of\n-    the rule).\n+Sometimes you only want a rule to apply if some or all arguments are concrete\n+(not symbolic). This is done with the `concrete` attribute. Conversely, the\n+`symbolic` attribute will allow a rule to apply only when some arguments are not\n+concrete. These attributes should only be given with the `simplification`\n+attribute.\n \n-Note that the `simplification` attribute can be applied to _any_ rule, not just\n-function rules, and that `simplification` rules are tried _before_ rules from\n-the semantic definition.\n-\n-For example, for the following definition:\n+For example, the following will only re-associate terms when all arguments\n+are concrete:\n \n ```k\n-    syntax WordStack ::= Int \":\" WordStack | \".WordStack\"\n-    syntax Int ::= sizeWordStack    ( WordStack       ) [function]\n-                 | sizeWordStackAux ( WordStack , Int ) [function]\n- // --------------------------------------------------------------\n-    rule sizeWordStack(WS) => sizeWordStackAux(WS, 0)\n-\n-    rule sizeWordStackAux(.WordStack, N) => N\n-    rule sizeWordStackAux(W : WS    , N) => sizeWordStackAux(WS, N +Int 1)\n+rule X +Int (Y +Int Z) => (X +Int Y) +Int Z [simplification, concrete]\n ```\n \n-We might add the following simplification lemma:\n+And the following rules will only re-associate terms when it will end up\n+grouping concrete sub-terms:\n \n ```k\n-    rule sizeWordStackAux(WS, N) => N +Int sizeWordStackAux(WS, 0)\n-      requires N =/=Int 0\n-      [simplification]\n-```\n+rule X +Int (Y +Int Z) => (X +Int Y) +Int Z\n+  [simplification, concrete(X), concrete(Y), symbolic(Z)]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba5196eee254171737d586fbc6195ba47ec1923"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1NDU0Ng==", "bodyText": "Yes, looking at domains.k we do support grouping them. Let's use the grouped version, to encourage better styling for people.", "url": "https://github.com/kframework/k/pull/1468#discussion_r462454546", "createdAt": "2020-07-29T17:09:13Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -1157,45 +1198,31 @@ rule X +Int (Y +Int Z) => (X +Int Z) +Int Y\n    andBool #isVariable(Y)\n ```\n \n-### `simplification` attribute (Haskell backend)\n-\n-The simplification attribute identifies axioms that are useful for simplifying\n-configurations, without being part of the main semantics. When a rule is tagged\n-as `simplification`, the Haskell backend will only apply that rule if:\n+### `concrete` and `symbolic` attributes (Haskell backend)\n \n--   the rule lhs _matches_ the subterm of interest, and\n--   the side condition has no remainder given the current top-level predicate\n-    (that is, the current top-level predicate _implies_ the side condition of\n-    the rule).\n+Sometimes you only want a rule to apply if some or all arguments are concrete\n+(not symbolic). This is done with the `concrete` attribute. Conversely, the\n+`symbolic` attribute will allow a rule to apply only when some arguments are not\n+concrete. These attributes should only be given with the `simplification`\n+attribute.\n \n-Note that the `simplification` attribute can be applied to _any_ rule, not just\n-function rules, and that `simplification` rules are tried _before_ rules from\n-the semantic definition.\n-\n-For example, for the following definition:\n+For example, the following will only re-associate terms when all arguments\n+are concrete:\n \n ```k\n-    syntax WordStack ::= Int \":\" WordStack | \".WordStack\"\n-    syntax Int ::= sizeWordStack    ( WordStack       ) [function]\n-                 | sizeWordStackAux ( WordStack , Int ) [function]\n- // --------------------------------------------------------------\n-    rule sizeWordStack(WS) => sizeWordStackAux(WS, 0)\n-\n-    rule sizeWordStackAux(.WordStack, N) => N\n-    rule sizeWordStackAux(W : WS    , N) => sizeWordStackAux(WS, N +Int 1)\n+rule X +Int (Y +Int Z) => (X +Int Y) +Int Z [simplification, concrete]\n ```\n \n-We might add the following simplification lemma:\n+And the following rules will only re-associate terms when it will end up\n+grouping concrete sub-terms:\n \n ```k\n-    rule sizeWordStackAux(WS, N) => N +Int sizeWordStackAux(WS, 0)\n-      requires N =/=Int 0\n-      [simplification]\n-```\n+rule X +Int (Y +Int Z) => (X +Int Y) +Int Z\n+  [simplification, concrete(X), concrete(Y), symbolic(Z)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MTI2NQ=="}, "originalCommit": {"oid": "3ba5196eee254171737d586fbc6195ba47ec1923"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2995, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}