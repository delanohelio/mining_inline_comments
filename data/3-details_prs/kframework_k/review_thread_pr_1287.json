{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4MDg0NzEw", "number": 1287, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozNzoyMlrOD8nzvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMDo1MTowOVrOD9V4jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODkzMzcyOnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTozNzoyMlrOGVrXpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMDowMjozMVrOGVsMLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4Mzg0NQ==", "bodyText": "Why is this for loop inside the above one? It does not seem to depend on sort, which, I guess, would mean that genSubsortAxiom below generates multiple identical axioms (assuming that the bracketProductionsFor can have more than one entry).", "url": "https://github.com/kframework/k/pull/1287#discussion_r425383845", "createdAt": "2020-05-14T19:37:22Z", "author": {"login": "virgil-serbanuta"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -198,6 +197,26 @@ public String convert(boolean heatCoolEq, StringBuilder sb) {\n         }\n         translateSymbols(attributes, functionRules, impurities, overloads, sb);\n \n+        // print syntax definition\n+        int length = sb.length();\n+        for (Tuple2<Sort, scala.collection.immutable.List<Production>> sort : iterable(module.bracketProductionsFor())) {\n+            for (Production prod : iterable(sort._2())) {\n+                translateSymbol(attributes, functionRules, impurities, overloads, prod.att().get(\"bracketLabel\", KLabel.class), prod, sb);\n+            }\n+            for (Production prod : iterable(module.sortedProductions())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb81ce3852919f4cdc64224c8ef055ee55bdd7b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5NzI5Mg==", "bodyText": "good catch. I did not notice that.", "url": "https://github.com/kframework/k/pull/1287#discussion_r425397292", "createdAt": "2020-05-14T20:02:31Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -198,6 +197,26 @@ public String convert(boolean heatCoolEq, StringBuilder sb) {\n         }\n         translateSymbols(attributes, functionRules, impurities, overloads, sb);\n \n+        // print syntax definition\n+        int length = sb.length();\n+        for (Tuple2<Sort, scala.collection.immutable.List<Production>> sort : iterable(module.bracketProductionsFor())) {\n+            for (Production prod : iterable(sort._2())) {\n+                translateSymbol(attributes, functionRules, impurities, overloads, prod.att().get(\"bracketLabel\", KLabel.class), prod, sb);\n+            }\n+            for (Production prod : iterable(module.sortedProductions())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4Mzg0NQ=="}, "originalCommit": {"oid": "7bb81ce3852919f4cdc64224c8ef055ee55bdd7b"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTAwNzE3OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTo1OTozNVrOGVsGeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoyNDowNlrOGXZ4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5NTgzMg==", "bodyText": "It would be nice if these new attributes would be documented somewhere.", "url": "https://github.com/kframework/k/pull/1287#discussion_r425395832", "createdAt": "2020-05-14T19:59:35Z", "author": {"login": "virgil-serbanuta"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -1452,17 +1404,62 @@ private Att addKoreAttributes(Production prod, SetMultimap<KLabel, Rule> functio\n         String format = att.getOptional(\"format\").orElse(Formatter.defaultFormat(prod.items().size()));\n         int nt = 1;\n         boolean hasFormat = true;\n+        int terminals = 0;\n         for (int i = 0; i < prod.items().size(); i++) {\n           if (prod.items().apply(i) instanceof NonTerminal) {\n             format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%\" + (nt++));\n           } else if (prod.items().apply(i) instanceof Terminal) {\n             format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%c\" + ((Terminal)prod.items().apply(i)).value().replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\") + \"%r\");\n+            terminals++;\n           } else {\n             hasFormat = false;\n           }\n         }\n         if (hasFormat) {\n           att = att.add(\"format\", format);\n+          if (att.contains(\"color\")) {\n+            boolean escape = false;\n+            StringBuilder colors = new StringBuilder();\n+            String conn = \"\";\n+            for (int i = 0; i < format.length(); i++) {\n+              if (escape && format.charAt(i) == 'c') {\n+                colors.append(conn).append(att.get(\"color\"));\n+                conn = \",\";\n+              }\n+              if (format.charAt(i) == '%') {\n+                escape = true;\n+              } else {\n+                escape = false;\n+              }\n+            }\n+            att = att.add(\"colors\", colors.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bb81ce3852919f4cdc64224c8ef055ee55bdd7b"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5NDQxOQ==", "bodyText": "Seconded. I see that color, colors, format are already documented in pending-documentation.md.\npriorities, left, right are not, please add these to pending-documentation.md. I also see that bracket is folded into the paremetric productions section of pending-documentation.md, maybe it should be made into it's own section though?\nI also see terminals here as an attribute and nat, but I don't think that's something we want the users setting, so maybe we shouldn't document that. If these are supposed to be user exposed, also add to pending-documentation.md. If not, then maybe we should either (i) make sure they don't exist in the attributes before adding them in, or (ii) have a check in the frontend that they do not occur.", "url": "https://github.com/kframework/k/pull/1287#discussion_r427194419", "createdAt": "2020-05-19T10:24:06Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -1452,17 +1404,62 @@ private Att addKoreAttributes(Production prod, SetMultimap<KLabel, Rule> functio\n         String format = att.getOptional(\"format\").orElse(Formatter.defaultFormat(prod.items().size()));\n         int nt = 1;\n         boolean hasFormat = true;\n+        int terminals = 0;\n         for (int i = 0; i < prod.items().size(); i++) {\n           if (prod.items().apply(i) instanceof NonTerminal) {\n             format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%\" + (nt++));\n           } else if (prod.items().apply(i) instanceof Terminal) {\n             format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%c\" + ((Terminal)prod.items().apply(i)).value().replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\") + \"%r\");\n+            terminals++;\n           } else {\n             hasFormat = false;\n           }\n         }\n         if (hasFormat) {\n           att = att.add(\"format\", format);\n+          if (att.contains(\"color\")) {\n+            boolean escape = false;\n+            StringBuilder colors = new StringBuilder();\n+            String conn = \"\";\n+            for (int i = 0; i < format.length(); i++) {\n+              if (escape && format.charAt(i) == 'c') {\n+                colors.append(conn).append(att.get(\"color\"));\n+                conn = \",\";\n+              }\n+              if (format.charAt(i) == '%') {\n+                escape = true;\n+              } else {\n+                escape = false;\n+              }\n+            }\n+            att = att.add(\"colors\", colors.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5NTgzMg=="}, "originalCommit": {"oid": "7bb81ce3852919f4cdc64224c8ef055ee55bdd7b"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NjQ3ODg4OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMDo0OTo1NlrOGWxydQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxMDoyNzowMlrOGXZ-UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzNzU4OQ==", "bodyText": "I don't see this used anywhere. It's just incremented in the below loop, but then the value doesn't seem to be used.", "url": "https://github.com/kframework/k/pull/1287#discussion_r426537589", "createdAt": "2020-05-18T10:49:56Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -1416,17 +1370,62 @@ private Att addKoreAttributes(Production prod, SetMultimap<KLabel, Rule> functio\n         String format = att.getOptional(\"format\").orElse(Formatter.defaultFormat(prod.items().size()));\n         int nt = 1;\n         boolean hasFormat = true;\n+        int terminals = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eed3187c9e1357798eae5588ea4f19f37ab70378"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5NTk4NQ==", "bodyText": "@dwightguth I still don't see any uses of this variable.", "url": "https://github.com/kframework/k/pull/1287#discussion_r427195985", "createdAt": "2020-05-19T10:27:02Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -1416,17 +1370,62 @@ private Att addKoreAttributes(Production prod, SetMultimap<KLabel, Rule> functio\n         String format = att.getOptional(\"format\").orElse(Formatter.defaultFormat(prod.items().size()));\n         int nt = 1;\n         boolean hasFormat = true;\n+        int terminals = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzNzU4OQ=="}, "originalCommit": {"oid": "eed3187c9e1357798eae5588ea4f19f37ab70378"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NjQ4MjcwOnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxMDo1MTowOVrOGWx06g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNTo1NTo0MVrOGW9gJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzODIxOA==", "bodyText": "So now instead of writing separate files with the unparsing information, we're adding attributes to the generated Kore file?\nI like the approach more, just want to make sure I understand.", "url": "https://github.com/kframework/k/pull/1287#discussion_r426538218", "createdAt": "2020-05-18T10:51:09Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -356,87 +361,34 @@ private void translateSymbols(Map<String, Boolean> attributes, SetMultimap<KLabe\n             if (impurities.contains(prod.klabel().get())) {\n                 impureFunctions.add(prod.klabel().get().name());\n             }\n-            sb.append(\"  \");\n-            if (isFunction(prod) && prod.att().contains(Att.HOOK()) && isRealHook(prod.att())) {\n-                sb.append(\"hooked-\");\n-            }\n-            sb.append(\"symbol \");\n-            convert(prod.klabel().get(), prod.params(), sb);\n-            String conn;\n-            sb.append(\"(\");\n-            conn = \"\";\n-            for (NonTerminal nt : iterable(prod.nonterminals())) {\n-                Sort sort = nt.sort();\n-                sb.append(conn);\n-                convert(sort, prod, sb);\n-                conn = \", \";\n-            }\n-            sb.append(\") : \");\n-            convert(prod.sort(), prod, sb);\n-            sb.append(\" \");\n-            Att koreAtt = addKoreAttributes(prod, functionRules, impurities, overloads);\n-            convert(attributes, koreAtt, sb, null, null);\n-            writeUnparsingDataForSymbol(prod, koreAtt);\n-            sb.append(\"\\n\");\n+            translateSymbol(attributes, functionRules, impurities, overloads, prod.klabel().get(), prod, sb);\n         }\n     }\n \n-    private void writeUnparsingDataForSymbol(Production prod, Att koreAtt) {\n-        if (koreAtt.contains(\"format\")) {\n-            formats.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), formats);\n-            formats.append('\\n');\n-            formats.append(koreAtt.get(\"format\"));\n-            formats.append('\\n');\n-        }\n-        if (koreAtt.contains(\"color\")) {\n-            colors.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), colors);\n-            colors.append('\\n');\n-            for (int i = 0; i < prod.items().size(); i++) {\n-                if (prod.items().apply(i) instanceof Terminal) {\n-                    colors.append(koreAtt.get(\"color\"));\n-                    colors.append('\\n');\n-                }\n-            }\n-            if (koreAtt.contains(\"format\")) {\n-              String format = koreAtt.get(\"format\");\n-              boolean escape = false;\n-              for (int i = 0; i < format.length(); i++) {\n-                if (escape && format.charAt(i) == 'c') {\n-                  colors.append(koreAtt.get(\"color\"));\n-                  colors.append('\\n');\n-                }\n-                if (format.charAt(i) == '%') {\n-                  escape = true;\n-                } else {\n-                  escape = false;\n-                }\n-              }\n-            }\n-            colors.append('\\n');\n-        } else if (koreAtt.contains(\"colors\")) {\n-            String[] data = koreAtt.get(\"colors\").split(\",\");\n-            colors.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), colors);\n-            colors.append('\\n');\n-            for (int i = 0; i < data.length; i++) {\n-                colors.append(data[i].trim());\n-                colors.append('\\n');\n-            }\n-            colors.append('\\n');\n-        }\n-        if (koreAtt.contains(\"assoc\")) {\n-            assocs.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), assocs);\n-            assocs.append('\\n');\n+    private void translateSymbol(Map<String, Boolean> attributes, SetMultimap<KLabel, Rule> functionRules, Set<KLabel> impurities, Set<Production> overloads, KLabel label, Production prod, StringBuilder sb) {\n+        sb.append(\"  \");\n+        if (isFunction(prod) && prod.att().contains(Att.HOOK()) && isRealHook(prod.att())) {\n+            sb.append(\"hooked-\");\n         }\n-        if (koreAtt.contains(\"comm\")) {\n-            comms.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), comms);\n-            comms.append('\\n');\n+        sb.append(\"symbol \");\n+        convert(label, prod.params(), sb);\n+        String conn;\n+        sb.append(\"(\");\n+        conn = \"\";\n+        for (NonTerminal nt : iterable(prod.nonterminals())) {\n+            Sort sort = nt.sort();\n+            sb.append(conn);\n+            convert(sort, prod, sb);\n+            conn = \", \";\n         }\n+        sb.append(\") : \");\n+        convert(prod.sort(), prod, sb);\n+        sb.append(\" \");\n+        Att koreAtt = addKoreAttributes(prod, functionRules, impurities, overloads);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eed3187c9e1357798eae5588ea4f19f37ab70378"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcyOTUxMA==", "bodyText": "I ended up needing extra information to support the bracket pass, so I decided to reevaluate the approach. The only reason I had used separate files originally was because it proved to be significantly faster. But I was able to optimize the code sufficiently that it became less of an issue, which is why I went back to my original idea, which was the kore file attributes.", "url": "https://github.com/kframework/k/pull/1287#discussion_r426729510", "createdAt": "2020-05-18T15:55:41Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -356,87 +361,34 @@ private void translateSymbols(Map<String, Boolean> attributes, SetMultimap<KLabe\n             if (impurities.contains(prod.klabel().get())) {\n                 impureFunctions.add(prod.klabel().get().name());\n             }\n-            sb.append(\"  \");\n-            if (isFunction(prod) && prod.att().contains(Att.HOOK()) && isRealHook(prod.att())) {\n-                sb.append(\"hooked-\");\n-            }\n-            sb.append(\"symbol \");\n-            convert(prod.klabel().get(), prod.params(), sb);\n-            String conn;\n-            sb.append(\"(\");\n-            conn = \"\";\n-            for (NonTerminal nt : iterable(prod.nonterminals())) {\n-                Sort sort = nt.sort();\n-                sb.append(conn);\n-                convert(sort, prod, sb);\n-                conn = \", \";\n-            }\n-            sb.append(\") : \");\n-            convert(prod.sort(), prod, sb);\n-            sb.append(\" \");\n-            Att koreAtt = addKoreAttributes(prod, functionRules, impurities, overloads);\n-            convert(attributes, koreAtt, sb, null, null);\n-            writeUnparsingDataForSymbol(prod, koreAtt);\n-            sb.append(\"\\n\");\n+            translateSymbol(attributes, functionRules, impurities, overloads, prod.klabel().get(), prod, sb);\n         }\n     }\n \n-    private void writeUnparsingDataForSymbol(Production prod, Att koreAtt) {\n-        if (koreAtt.contains(\"format\")) {\n-            formats.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), formats);\n-            formats.append('\\n');\n-            formats.append(koreAtt.get(\"format\"));\n-            formats.append('\\n');\n-        }\n-        if (koreAtt.contains(\"color\")) {\n-            colors.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), colors);\n-            colors.append('\\n');\n-            for (int i = 0; i < prod.items().size(); i++) {\n-                if (prod.items().apply(i) instanceof Terminal) {\n-                    colors.append(koreAtt.get(\"color\"));\n-                    colors.append('\\n');\n-                }\n-            }\n-            if (koreAtt.contains(\"format\")) {\n-              String format = koreAtt.get(\"format\");\n-              boolean escape = false;\n-              for (int i = 0; i < format.length(); i++) {\n-                if (escape && format.charAt(i) == 'c') {\n-                  colors.append(koreAtt.get(\"color\"));\n-                  colors.append('\\n');\n-                }\n-                if (format.charAt(i) == '%') {\n-                  escape = true;\n-                } else {\n-                  escape = false;\n-                }\n-              }\n-            }\n-            colors.append('\\n');\n-        } else if (koreAtt.contains(\"colors\")) {\n-            String[] data = koreAtt.get(\"colors\").split(\",\");\n-            colors.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), colors);\n-            colors.append('\\n');\n-            for (int i = 0; i < data.length; i++) {\n-                colors.append(data[i].trim());\n-                colors.append('\\n');\n-            }\n-            colors.append('\\n');\n-        }\n-        if (koreAtt.contains(\"assoc\")) {\n-            assocs.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), assocs);\n-            assocs.append('\\n');\n+    private void translateSymbol(Map<String, Boolean> attributes, SetMultimap<KLabel, Rule> functionRules, Set<KLabel> impurities, Set<Production> overloads, KLabel label, Production prod, StringBuilder sb) {\n+        sb.append(\"  \");\n+        if (isFunction(prod) && prod.att().contains(Att.HOOK()) && isRealHook(prod.att())) {\n+            sb.append(\"hooked-\");\n         }\n-        if (koreAtt.contains(\"comm\")) {\n-            comms.append(\"Lbl\");\n-            convert(prod.klabel().get().name(), comms);\n-            comms.append('\\n');\n+        sb.append(\"symbol \");\n+        convert(label, prod.params(), sb);\n+        String conn;\n+        sb.append(\"(\");\n+        conn = \"\";\n+        for (NonTerminal nt : iterable(prod.nonterminals())) {\n+            Sort sort = nt.sort();\n+            sb.append(conn);\n+            convert(sort, prod, sb);\n+            conn = \", \";\n         }\n+        sb.append(\") : \");\n+        convert(prod.sort(), prod, sb);\n+        sb.append(\" \");\n+        Att koreAtt = addKoreAttributes(prod, functionRules, impurities, overloads);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjUzODIxOA=="}, "originalCommit": {"oid": "eed3187c9e1357798eae5588ea4f19f37ab70378"}, "originalPosition": 204}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3031, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}