{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5NjQ1Njgy", "number": 1003, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNzoyMDowMVrODWUHog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMDozNzo1NFrODWXMmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NzI0ODk4OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/kast/KastFrontEnd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNzoyMDowMlrOFbAIRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMTo0MDoxN1rOFbGnCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1Nzk5MQ==", "bodyText": "Why is this in the temp directory?\nShouldn't this be inside the -kompiled directory?\nCould you put all the related files inside a single directory? -kompiled already has many things in it, and it would make it easier to look for debugging info when files are a bit more organized.", "url": "https://github.com/kframework/k/pull/1003#discussion_r363857991", "createdAt": "2020-01-07T17:20:02Z", "author": {"login": "radumereuta"}, "path": "kernel/src/main/java/org/kframework/kast/KastFrontEnd.java", "diffHunk": "@@ -124,13 +135,59 @@ public int run() {\n             }\n             Module parsingMod = maybeMod.get();\n \n-            K parsed = kread.prettyRead(parsingMod, sort, def, source, FileUtil.read(stringToParse));\n+            if (options.genParser) {\n+                try (ParseInModule parseInModule = RuleGrammarGenerator.getCombinedGrammar(parsingMod, true)) {\n+                    try (Scanner scanner = parseInModule.getScanner()) {\n+                        FileUtil files = this.files.get();\n+                        File scannerFile = files.resolveTemp(\"scanner.l\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d8c2a4d156e28382419cb2f425881340f5e319a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2NDE3MQ==", "bodyText": "it's in the temp directory because they're temporary files; if you want to keep them around, you can pass --debug, but otherwise there's no need for them to be kept around after the program terminates.", "url": "https://github.com/kframework/k/pull/1003#discussion_r363964171", "createdAt": "2020-01-07T21:40:17Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/kast/KastFrontEnd.java", "diffHunk": "@@ -124,13 +135,59 @@ public int run() {\n             }\n             Module parsingMod = maybeMod.get();\n \n-            K parsed = kread.prettyRead(parsingMod, sort, def, source, FileUtil.read(stringToParse));\n+            if (options.genParser) {\n+                try (ParseInModule parseInModule = RuleGrammarGenerator.getCombinedGrammar(parsingMod, true)) {\n+                    try (Scanner scanner = parseInModule.getScanner()) {\n+                        FileUtil files = this.files.get();\n+                        File scannerFile = files.resolveTemp(\"scanner.l\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1Nzk5MQ=="}, "originalCommit": {"oid": "3d8c2a4d156e28382419cb2f425881340f5e319a"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NzI1ODYxOnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/generator/RuleGrammarGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNzoyMzoxOFrOFbAONA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNzoyMzoxOFrOFbAONA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1OTUwOA==", "bodyText": "Maybe make notInjection a static String.", "url": "https://github.com/kframework/k/pull/1003#discussion_r363859508", "createdAt": "2020-01-07T17:23:18Z", "author": {"login": "radumereuta"}, "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/generator/RuleGrammarGenerator.java", "diffHunk": "@@ -392,9 +392,9 @@ public static ParseInModule getCombinedGrammar(Module mod, boolean strict, boole\n                         Seq(NonTerminal(ul.childSort), Terminal(\"\"), NonTerminal(Sort(ul.sort.name() + \"#Terminator\", ul.sort.params()))),\n                         newAtts.add(Constants.ORIGINAL_PRD, Production.class, ul.pList));\n                 // Es ::= Ne#Es\n-                prod4 = Production(Seq(), ul.sort, Seq(NonTerminal(Sort(\"Ne#\" + ul.sort.name(), ul.sort.params()))));\n+                prod4 = Production(Seq(), ul.sort, Seq(NonTerminal(Sort(\"Ne#\" + ul.sort.name(), ul.sort.params()))), Att().add(\"notInjection\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d8c2a4d156e28382419cb2f425881340f5e319a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NzI2NTY3OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/kernel/KSyntax2Bison.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNzoyNTo1MFrOFbAStg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNzoyNTo1MFrOFbAStg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2MDY2Mg==", "bodyText": "get method returns void? Maybe find a better name?", "url": "https://github.com/kframework/k/pull/1003#discussion_r363860662", "createdAt": "2020-01-07T17:25:50Z", "author": {"login": "radumereuta"}, "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/kernel/KSyntax2Bison.java", "diffHunk": "@@ -0,0 +1,297 @@\n+// Copyright (c) 2019 K Team. All Rights Reserved.\n+package org.kframework.parser.concrete2kore.kernel;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.kframework.Collections;\n+import org.kframework.TopologicalSort;\n+import org.kframework.attributes.Att;\n+import org.kframework.backend.kore.ModuleToKORE;\n+import org.kframework.definition.Associativity;\n+import org.kframework.definition.Module;\n+import org.kframework.definition.NonTerminal;\n+import org.kframework.definition.Production;\n+import org.kframework.definition.ProductionItem;\n+import org.kframework.definition.RegexTerminal;\n+import org.kframework.definition.Sentence;\n+import org.kframework.definition.SyntaxAssociativity;\n+import org.kframework.definition.Tag;\n+import org.kframework.definition.Terminal;\n+import org.kframework.definition.TerminalLike;\n+import org.kframework.kil.loader.Constants;\n+import org.kframework.kore.KLabel;\n+import org.kframework.kore.Sort;\n+import org.kframework.utils.StringUtil;\n+import org.kframework.utils.errorsystem.KEMException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+\n+import static org.kframework.Collections.*;\n+import static org.kframework.definition.Constructors.*;\n+import static org.kframework.kore.KORE.*;\n+\n+public class KSyntax2Bison {\n+\n+  private static void computeSide(int idx, Production prod, List<ProductionItem> items, Module module, scala.collection.Set<Tuple2<Tag, Tag>> assoc, Map<Set<Tag>, Integer> ordinals, Set<Tuple2<Sort, Set<Tag>>> nts, MutableInt nextOrdinal) {\n+    NonTerminal nt = (NonTerminal) items.get(idx);\n+    Tag parent = new Tag(prod.klabel().get().name());\n+    Set<Tag> prods = new HashSet<>();\n+    for (Tag child : iterable(module.priorities().relations().get(parent).getOrElse(() -> Collections.<Tag>Set()))) {\n+      prods.add(child);\n+    }\n+    for (Tuple2<Tag, Tag> entry : iterable(assoc)) {\n+      if (entry._1().equals(parent)) {\n+        prods.add(entry._2());\n+      }\n+    }\n+    if (prods.isEmpty()) {\n+      return;\n+    }\n+    int ordinal;\n+    if (ordinals.containsKey(prods)) {\n+      ordinal = ordinals.get(prods);\n+    } else {\n+      ordinal = nextOrdinal.intValue();\n+      ordinals.put(prods, nextOrdinal.intValue());\n+      nextOrdinal.increment();\n+    }\n+    items.set(idx, NonTerminal(Sort(nt.sort().name() + \"#\" + ordinal, nt.sort().params()), nt.name()));\n+    nts.add(Tuple2.apply(nt.sort(), prods));\n+  }\n+\n+  public static Module transformByPriorityAndAssociativity(Module module) {\n+    Map<Set<Tag>, Integer> ordinals = new HashMap<>();\n+    MutableInt nextOrdinal = new MutableInt(0);\n+    Set<Sentence> sentences = new HashSet<>();\n+    Set<Tuple2<Sort, Set<Tag>>> nts = new HashSet<>();\n+    for (Sentence s : iterable(module.sentences())) {\n+      if (s instanceof Production) {\n+        Production prod = (Production)s;\n+        if (prod.klabel().isDefined() && prod.params().isEmpty()) {\n+          List<ProductionItem> items = new ArrayList<>(mutable(prod.items()));\n+          if (items.get(0) instanceof NonTerminal) {\n+            computeSide(0, prod, items, module, module.rightAssoc(), ordinals, nts, nextOrdinal);\n+          }\n+          if (items.size() > 1 && items.get(items.size() - 1) instanceof NonTerminal) {\n+            computeSide(items.size()-1, prod, items, module, module.leftAssoc(), ordinals, nts, nextOrdinal);\n+          }\n+          sentences.add(Production(prod.klabel(), prod.params(), prod.sort(), immutable(items), prod.att().add(Constants.ORIGINAL_PRD, Production.class, prod)));\n+        } else {\n+          sentences.add(prod.withAtt(prod.att().add(Constants.ORIGINAL_PRD, Production.class, prod)));\n+        }\n+      } else {\n+        sentences.add(s);\n+      }\n+    }\n+    module = Module(module.name(), module.imports(), immutable(sentences), module.att());\n+    Deque<Tuple2<Sort, Set<Tag>>> worklist = new ArrayDeque<>(nts);\n+    worklist.addAll(nts);\n+    while (!worklist.isEmpty()) {\n+      Tuple2<Sort, Set<Tag>> item = worklist.poll();\n+      for (Production prod : iterable(module.productionsForSort().apply(item._1().head()))) {\n+        int ordinal = ordinals.get(item._2());\n+        Sort newNT = Sort(item._1().name() + \"#\" + ordinal, item._1().params());\n+        if (prod.isSubsort()) {\n+          worklist.offer(Tuple2.apply(prod.getSubsortSort(), item._2()));\n+          sentences.add(Production(prod.klabel(), prod.params(), newNT, Seq(NonTerminal(prod.getSubsortSort(), prod.nonterminals().apply(0).name())), prod.att()));\n+        } else if (prod.klabel().isEmpty() || !item._2().contains(new Tag(prod.klabel().get().name()))) {\n+          sentences.add(Production(prod.klabel(), prod.params(), newNT, prod.items(), prod.att()));\n+        }\n+      }\n+    }\n+    return Module(module.name(), module.imports(), immutable(sentences), module.att());\n+  }\n+\n+  public static void getParser(Module module, Scanner scanner, Sort start, File path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d8c2a4d156e28382419cb2f425881340f5e319a"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NzI3MzkyOnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/kernel/Scanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNzoyODo0MlrOFbAXxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNzoyODo0MlrOFbAXxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg2MTk1Nw==", "bodyText": "Another get that returns void.", "url": "https://github.com/kframework/k/pull/1003#discussion_r363861957", "createdAt": "2020-01-07T17:28:42Z", "author": {"login": "radumereuta"}, "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/kernel/Scanner.java", "diffHunk": "@@ -52,11 +53,44 @@ public Module getModule() {\n         return module;\n     }\n \n+    public Set<Integer> kinds() {\n+        return tokens.values().stream().map(v -> v._1()).collect(Collectors.toSet());\n+    }\n+\n     // debugging method\n-    private TerminalLike getTokenByKind(int kind) {\n+    public TerminalLike getTokenByKind(int kind) {\n         return tokens.entrySet().stream().filter(e -> e.getValue()._1() == kind).findAny().get().getKey();\n     }\n \n+    public void getStandaloneScanner(File path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d8c2a4d156e28382419cb2f425881340f5e319a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0Nzc0OTU3OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/kast/KastFrontEnd.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMDozNjoyM1rOFbFFlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMTo0MToxN1rOFbGomQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkzOTIyMA==", "bodyText": "Wow, the logic here got a lot more complicated.\nI think having kast --gen-parser doesn't make much sense. kompile --backend bison or kompile --emit-bison-parser makes more sense to me. I also agree that the generated parser should go in the kompiled directory, and should form a standalone binary/executable which the user can call directly (without having to invoke immediately via kast).\nIf you absolutely must keep it here, put all the bison generation stuff it its own method and call it under the if (options.genParser) instead of inlining it, so that it's easier to see the overall logic of this main method.\nIt would also make sense to me to add kast --use-bison-parser and krun --use-bison-parser, which would use the parser emitted during kompile.", "url": "https://github.com/kframework/k/pull/1003#discussion_r363939220", "createdAt": "2020-01-07T20:36:23Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/kast/KastFrontEnd.java", "diffHunk": "@@ -124,13 +135,59 @@ public int run() {\n             }\n             Module parsingMod = maybeMod.get();\n \n-            K parsed = kread.prettyRead(parsingMod, sort, def, source, FileUtil.read(stringToParse));\n+            if (options.genParser) {\n+                try (ParseInModule parseInModule = RuleGrammarGenerator.getCombinedGrammar(parsingMod, true)) {\n+                    try (Scanner scanner = parseInModule.getScanner()) {\n+                        FileUtil files = this.files.get();\n+                        File scannerFile = files.resolveTemp(\"scanner.l\");\n+                        File parserFile = files.resolveTemp(\"parser.y\");\n+                        scanner.getStandaloneScanner(scannerFile);\n+                        KSyntax2Bison.getParser(parseInModule.getParsingModule(), scanner, sort, parserFile);\n+                        int exit = files.getProcessBuilder()\n+                          .directory(files.resolveTemp(\".\"))\n+                          .command(\"flex\", \"-w\", scannerFile.getAbsolutePath())\n+                          .inheritIO()\n+                          .start()\n+                          .waitFor();\n+                        if (exit != 0) {\n+                            throw KEMException.internalError(\"flex returned nonzero exit code: \" + exit + \"\\n\");\n+                        }\n+                        exit = files.getProcessBuilder()\n+                          .directory(files.resolveTemp(\".\"))\n+                          .command(\"bison\", \"-d\", \"-Wno-other\", \"-Wno-conflicts-sr\", \"-Wno-conflicts-rr\", parserFile.getAbsolutePath())\n+                          .inheritIO()\n+                          .start()\n+                          .waitFor();\n+                        if (exit != 0) {\n+                            throw KEMException.internalError(\"bison returned nonzero exit code: \" + exit + \"\\n\");\n+                        }\n+                        exit = files.getProcessBuilder()\n+                          .command(\"gcc\",\n+                              files.resolveKBase(\"include/cparser/main.c\").getAbsolutePath(),\n+                              files.resolveTemp(\"lex.yy.c\").getAbsolutePath(),\n+                              files.resolveTemp(\"parser.tab.c\").getAbsolutePath(),\n+                              \"-iquote\", files.resolveTemp(\".\").getAbsolutePath(),\n+                              \"-iquote\", files.resolveKBase(\"include/cparser\").getAbsolutePath(),\n+                              \"-o\", outputFile.getAbsolutePath())\n+                          .inheritIO()\n+                          .start()\n+                          .waitFor();\n+                        if (exit != 0) {\n+                            throw KEMException.internalError(\"gcc returned nonzero exit code: \" + exit + \"\\n\");\n+                        }\n+                    } catch(IOException | InterruptedException e) {\n+                      throw KEMException.internalError(\"Failed to execute process.\", e);\n+                    }\n+                }\n+            } else {\n+              K parsed = kread.prettyRead(parsingMod, sort, def, source, FileUtil.read(stringToParse));\n+\n+              if (options.expandMacros) {\n+                  parsed = ExpandMacros.forNonSentences(unparsingMod, files.get(), def.kompileOptions, false).expand(parsed);\n+              }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac4337c1cfb3dff3f6a210c7daf102a75b708b96"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0MDY0Nw==", "bodyText": "Or, since kompile --emit-bison-parser will make a standalone executable, should be able to say krun --parser path/to/definition-kompiled/bison-parser, and no more options are needed?", "url": "https://github.com/kframework/k/pull/1003#discussion_r363940647", "createdAt": "2020-01-07T20:40:08Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/kast/KastFrontEnd.java", "diffHunk": "@@ -124,13 +135,59 @@ public int run() {\n             }\n             Module parsingMod = maybeMod.get();\n \n-            K parsed = kread.prettyRead(parsingMod, sort, def, source, FileUtil.read(stringToParse));\n+            if (options.genParser) {\n+                try (ParseInModule parseInModule = RuleGrammarGenerator.getCombinedGrammar(parsingMod, true)) {\n+                    try (Scanner scanner = parseInModule.getScanner()) {\n+                        FileUtil files = this.files.get();\n+                        File scannerFile = files.resolveTemp(\"scanner.l\");\n+                        File parserFile = files.resolveTemp(\"parser.y\");\n+                        scanner.getStandaloneScanner(scannerFile);\n+                        KSyntax2Bison.getParser(parseInModule.getParsingModule(), scanner, sort, parserFile);\n+                        int exit = files.getProcessBuilder()\n+                          .directory(files.resolveTemp(\".\"))\n+                          .command(\"flex\", \"-w\", scannerFile.getAbsolutePath())\n+                          .inheritIO()\n+                          .start()\n+                          .waitFor();\n+                        if (exit != 0) {\n+                            throw KEMException.internalError(\"flex returned nonzero exit code: \" + exit + \"\\n\");\n+                        }\n+                        exit = files.getProcessBuilder()\n+                          .directory(files.resolveTemp(\".\"))\n+                          .command(\"bison\", \"-d\", \"-Wno-other\", \"-Wno-conflicts-sr\", \"-Wno-conflicts-rr\", parserFile.getAbsolutePath())\n+                          .inheritIO()\n+                          .start()\n+                          .waitFor();\n+                        if (exit != 0) {\n+                            throw KEMException.internalError(\"bison returned nonzero exit code: \" + exit + \"\\n\");\n+                        }\n+                        exit = files.getProcessBuilder()\n+                          .command(\"gcc\",\n+                              files.resolveKBase(\"include/cparser/main.c\").getAbsolutePath(),\n+                              files.resolveTemp(\"lex.yy.c\").getAbsolutePath(),\n+                              files.resolveTemp(\"parser.tab.c\").getAbsolutePath(),\n+                              \"-iquote\", files.resolveTemp(\".\").getAbsolutePath(),\n+                              \"-iquote\", files.resolveKBase(\"include/cparser\").getAbsolutePath(),\n+                              \"-o\", outputFile.getAbsolutePath())\n+                          .inheritIO()\n+                          .start()\n+                          .waitFor();\n+                        if (exit != 0) {\n+                            throw KEMException.internalError(\"gcc returned nonzero exit code: \" + exit + \"\\n\");\n+                        }\n+                    } catch(IOException | InterruptedException e) {\n+                      throw KEMException.internalError(\"Failed to execute process.\", e);\n+                    }\n+                }\n+            } else {\n+              K parsed = kread.prettyRead(parsingMod, sort, def, source, FileUtil.read(stringToParse));\n+\n+              if (options.expandMacros) {\n+                  parsed = ExpandMacros.forNonSentences(unparsingMod, files.get(), def.kompileOptions, false).expand(parsed);\n+              }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkzOTIyMA=="}, "originalCommit": {"oid": "ac4337c1cfb3dff3f6a210c7daf102a75b708b96"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2NDU2OQ==", "bodyText": "You cannot say krun --parser because krun currently doesn't know how to deserialize and execute something that has already been translated into kore. But since the whole point of this is to /not/ invoke krun at all, I think that's fine.", "url": "https://github.com/kframework/k/pull/1003#discussion_r363964569", "createdAt": "2020-01-07T21:41:17Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/kast/KastFrontEnd.java", "diffHunk": "@@ -124,13 +135,59 @@ public int run() {\n             }\n             Module parsingMod = maybeMod.get();\n \n-            K parsed = kread.prettyRead(parsingMod, sort, def, source, FileUtil.read(stringToParse));\n+            if (options.genParser) {\n+                try (ParseInModule parseInModule = RuleGrammarGenerator.getCombinedGrammar(parsingMod, true)) {\n+                    try (Scanner scanner = parseInModule.getScanner()) {\n+                        FileUtil files = this.files.get();\n+                        File scannerFile = files.resolveTemp(\"scanner.l\");\n+                        File parserFile = files.resolveTemp(\"parser.y\");\n+                        scanner.getStandaloneScanner(scannerFile);\n+                        KSyntax2Bison.getParser(parseInModule.getParsingModule(), scanner, sort, parserFile);\n+                        int exit = files.getProcessBuilder()\n+                          .directory(files.resolveTemp(\".\"))\n+                          .command(\"flex\", \"-w\", scannerFile.getAbsolutePath())\n+                          .inheritIO()\n+                          .start()\n+                          .waitFor();\n+                        if (exit != 0) {\n+                            throw KEMException.internalError(\"flex returned nonzero exit code: \" + exit + \"\\n\");\n+                        }\n+                        exit = files.getProcessBuilder()\n+                          .directory(files.resolveTemp(\".\"))\n+                          .command(\"bison\", \"-d\", \"-Wno-other\", \"-Wno-conflicts-sr\", \"-Wno-conflicts-rr\", parserFile.getAbsolutePath())\n+                          .inheritIO()\n+                          .start()\n+                          .waitFor();\n+                        if (exit != 0) {\n+                            throw KEMException.internalError(\"bison returned nonzero exit code: \" + exit + \"\\n\");\n+                        }\n+                        exit = files.getProcessBuilder()\n+                          .command(\"gcc\",\n+                              files.resolveKBase(\"include/cparser/main.c\").getAbsolutePath(),\n+                              files.resolveTemp(\"lex.yy.c\").getAbsolutePath(),\n+                              files.resolveTemp(\"parser.tab.c\").getAbsolutePath(),\n+                              \"-iquote\", files.resolveTemp(\".\").getAbsolutePath(),\n+                              \"-iquote\", files.resolveKBase(\"include/cparser\").getAbsolutePath(),\n+                              \"-o\", outputFile.getAbsolutePath())\n+                          .inheritIO()\n+                          .start()\n+                          .waitFor();\n+                        if (exit != 0) {\n+                            throw KEMException.internalError(\"gcc returned nonzero exit code: \" + exit + \"\\n\");\n+                        }\n+                    } catch(IOException | InterruptedException e) {\n+                      throw KEMException.internalError(\"Failed to execute process.\", e);\n+                    }\n+                }\n+            } else {\n+              K parsed = kread.prettyRead(parsingMod, sort, def, source, FileUtil.read(stringToParse));\n+\n+              if (options.expandMacros) {\n+                  parsed = ExpandMacros.forNonSentences(unparsingMod, files.get(), def.kompileOptions, false).expand(parsed);\n+              }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkzOTIyMA=="}, "originalCommit": {"oid": "ac4337c1cfb3dff3f6a210c7daf102a75b708b96"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0Nzc1MzIwOnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/kernel/Scanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMDozNzo1NFrOFbFHzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QyMDozNzo1NFrOFbFHzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkzOTc4OA==", "bodyText": "Is there no way for getStandaloneScanner and getScanner to re-use chunks amongst themselves?", "url": "https://github.com/kframework/k/pull/1003#discussion_r363939788", "createdAt": "2020-01-07T20:37:54Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/kernel/Scanner.java", "diffHunk": "@@ -52,11 +53,44 @@ public Module getModule() {\n         return module;\n     }\n \n+    public Set<Integer> kinds() {\n+        return tokens.values().stream().map(v -> v._1()).collect(Collectors.toSet());\n+    }\n+\n     // debugging method\n-    private TerminalLike getTokenByKind(int kind) {\n+    public TerminalLike getTokenByKind(int kind) {\n         return tokens.entrySet().stream().filter(e -> e.getValue()._1() == kind).findAny().get().getKey();\n     }\n \n+    public void getStandaloneScanner(File path) {\n+        StringBuilder flex  = new StringBuilder();\n+        flex.append(\"%{\\n\" +\n+            \"#include \\\"node.h\\\"\\n\" +\n+            \"#include \\\"parser.tab.h\\\"\\n\" +\n+            \"%}\\n\\n\" +\n+            \"%option noyywrap\\n\" +\n+            \"%%\\n\\n\");\n+        if (this.module.allSorts().contains(Sorts.Layout())) {\n+            flex.append(this.module.layout() + \" ;\\n\");\n+        }\n+        List<TerminalLike> ordered = tokens.keySet().stream().sorted((t1, t2) -> tokens.get(t2)._2() - tokens.get(t1)._2()).collect(Collectors.toList());\n+        for (TerminalLike key : ordered) {\n+            if (key instanceof Terminal) {\n+                Terminal t = (Terminal) key;\n+                flex.append(StringUtil.enquoteCString(t.value()));\n+            } else {\n+                RegexTerminal t = (RegexTerminal) key;\n+                flex.append(t.regex());\n+            }\n+            writeStandaloneAction(flex, key);\n+        }\n+        try {\n+            FileUtils.write(path, flex);\n+        } catch (IOException e) {\n+            throw KEMException.internalError(\"Failed to write file for scanner\", e);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac4337c1cfb3dff3f6a210c7daf102a75b708b96"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3140, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}