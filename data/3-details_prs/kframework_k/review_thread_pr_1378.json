{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwMzExMzMx", "number": 1378, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMToxMzozOFrOEI-P2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1NjozNFrOEI-o6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODQzOTMxOnYy", "diffSide": "RIGHT", "path": "pending-documentation.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMToxMzozOFrOGpQtTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMjo1MToxOFrOGpSFKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxODU0MQ==", "bodyText": "Should this be indented consistently with the other code blocks?", "url": "https://github.com/kframework/k/pull/1378#discussion_r445918541", "createdAt": "2020-06-26T01:13:38Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk0MDQyMA==", "bodyText": "Different code blocks in the document are formatted differently. The most common was unindented, so I was using that. But, I'll change it to 4 spaces.", "url": "https://github.com/kframework/k/pull/1378#discussion_r445940420", "createdAt": "2020-06-26T02:48:23Z", "author": {"login": "nishantjr"}, "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxODU0MQ=="}, "originalCommit": {"oid": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk0MTAzNA==", "bodyText": "Actually, the document is overwhelmingly unindented, so I'll move the couple I forgot to left indented to that format", "url": "https://github.com/kframework/k/pull/1378#discussion_r445941034", "createdAt": "2020-06-26T02:51:18Z", "author": {"login": "nishantjr"}, "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxODU0MQ=="}, "originalCommit": {"oid": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODQ4MjUyOnYy", "diffSide": "RIGHT", "path": "pending-documentation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo0MjoxNVrOGpRHVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo0MjoxNVrOGpRHVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNTIwNQ==", "bodyText": "Clarify here that they will be thrown away by the scanner, so the parser will not even see these tokens.", "url": "https://github.com/kframework/k/pull/1378#discussion_r445925205", "createdAt": "2020-06-26T01:42:15Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```\n+\n+Similarly, the hook `STRING.string2Token` allows the inverse:\n+\n+```k\n+  syntax Bar ::= StringToBar(String) [function, functional, hook(STRING.string2token)]\n+```\n+\n+WARNING: This sort of conversion does *NOT* do any sort of parsing or validation.\n+Thus, we can create arbitary tokens of any sort:\n+\n+```\n+StringToBar(\"The sun rises in the west.\")\n+```\n+\n+Composing these two functions lets us convert from `Foo` to `Bar`\n+\n+```k\n+  syntax Bar ::= FooToBar(Foo) [function]\n+  rule FooToBar(F) => StringToBar(FooToString(F))\n+```\n+\n+### Parsing comments, and the `#Layout` sort\n+\n+Productions for the `#Layout` sort are used to describe tokens that are\n+considered \"whitespace\". For example, below, we use it to define lines begining\n+with `;` (semicolon) as comments.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODQ4MzI2OnYy", "diffSide": "RIGHT", "path": "pending-documentation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo0Mjo0OVrOGpRHuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo0Mjo0OVrOGpRHuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNTMwNw==", "bodyText": "whos syntax allows => with syntax that allows.\nAlso lowercase Names => names", "url": "https://github.com/kframework/k/pull/1378#discussion_r445925307", "createdAt": "2020-06-26T01:42:49Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```\n+\n+Similarly, the hook `STRING.string2Token` allows the inverse:\n+\n+```k\n+  syntax Bar ::= StringToBar(String) [function, functional, hook(STRING.string2token)]\n+```\n+\n+WARNING: This sort of conversion does *NOT* do any sort of parsing or validation.\n+Thus, we can create arbitary tokens of any sort:\n+\n+```\n+StringToBar(\"The sun rises in the west.\")\n+```\n+\n+Composing these two functions lets us convert from `Foo` to `Bar`\n+\n+```k\n+  syntax Bar ::= FooToBar(Foo) [function]\n+  rule FooToBar(F) => StringToBar(FooToString(F))\n+```\n+\n+### Parsing comments, and the `#Layout` sort\n+\n+Productions for the `#Layout` sort are used to describe tokens that are\n+considered \"whitespace\". For example, below, we use it to define lines begining\n+with `;` (semicolon) as comments.\n+\n+```k\n+syntax #Layout ::= r\"(;[^\\\\n\\\\r]*)\"    // Semi-colon comments\n+                 | r\"([\\\\ \\\\n\\\\r\\\\t])\" // Whitespace\n+```\n+\n+### `prec` attribute\n+\n+Consider the following naive attempt at creating a language whos syntax\n+allows two types of variables: Names that contain underbars, and names that\n+contain sharps/hashes/pound-signs:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODQ5ODg5OnYy", "diffSide": "RIGHT", "path": "pending-documentation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1Mzo0M1rOGpRRnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1Mzo0M1rOGpRRnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNzgzNw==", "bodyText": "This should not be in the documentation, but made into an issue.", "url": "https://github.com/kframework/k/pull/1378#discussion_r445927837", "createdAt": "2020-06-26T01:53:43Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -185,6 +185,99 @@ have any constructors declared.\n syntax Bytes [hook(BYTES.Bytes), token]\n ```\n \n+### Converting between `[token]` sorts\n+\n+You can convert between tokens of one sort via `String`s by defining functions\n+implemented by builtin hooks.\n+The hook `STRING.token2string` allows conversion of any token to a string:\n+\n+```k\n+syntax String ::= FooToString(Foo)  [function, functional, hook(STRING.token2string)]\n+```\n+\n+Similarly, the hook `STRING.string2Token` allows the inverse:\n+\n+```k\n+  syntax Bar ::= StringToBar(String) [function, functional, hook(STRING.string2token)]\n+```\n+\n+WARNING: This sort of conversion does *NOT* do any sort of parsing or validation.\n+Thus, we can create arbitary tokens of any sort:\n+\n+```\n+StringToBar(\"The sun rises in the west.\")\n+```\n+\n+Composing these two functions lets us convert from `Foo` to `Bar`\n+\n+```k\n+  syntax Bar ::= FooToBar(Foo) [function]\n+  rule FooToBar(F) => StringToBar(FooToString(F))\n+```\n+\n+### Parsing comments, and the `#Layout` sort\n+\n+Productions for the `#Layout` sort are used to describe tokens that are\n+considered \"whitespace\". For example, below, we use it to define lines begining\n+with `;` (semicolon) as comments.\n+\n+```k\n+syntax #Layout ::= r\"(;[^\\\\n\\\\r]*)\"    // Semi-colon comments\n+                 | r\"([\\\\ \\\\n\\\\r\\\\t])\" // Whitespace\n+```\n+\n+### `prec` attribute\n+\n+Consider the following naive attempt at creating a language whos syntax\n+allows two types of variables: Names that contain underbars, and names that\n+contain sharps/hashes/pound-signs:\n+\n+```k\n+syntax NameWithUnderbar ::= r\"[a-zA-Z][A-Za-z0-9_]*\"  [token]\n+syntax NameWithSharp    ::= r\"[a-zA-Z][A-Za-z0-9_#]*\" [token]\n+syntax Pgm ::= underbar(NameWithUnderbar)\n+             | sharp(NameWithSharp)\n+```\n+\n+Although, it seems that K has enough information to parse the programs\n+`underbar(foo)` and `sharp(foo)` with, the lexer does not take into account\n+whether a token is being parsed for the `sharp` or for the `underbar`\n+production. It chooses an arbitary sort for the token `foo` (perhaps\n+`NameWithUnderbar`). Thus, during paring it is unable to construct a valid term\n+for one of those programs (`sharp(foo)`) and produces the error message:\n+`Inner Parser: Parse error: unexpected token 'foo'.`\n+\n+Since calculating inclusions and intersections between regular expressions is\n+tricky, we must provide this information to K. We do this via the `prec(N)`\n+attribute that specifies the order in which the lexer tries tokens. Token\n+productions with higher precedence are tried first.\n+\n+We also need to make sorts with more specific tokens subsorts of ones with more\n+general tokens. We add the token attribute to this production so that all tokens\n+of a particular sort are marked with the sort it is parsed as, and not a subsort\n+thereof. e.g.\u00a0we get `underbar(#token(\"foo\", \"NameWithUnderbar\"))` instead of\n+`underbar(#token(\"foo\", \"#LowerId\"))`\n+\n+*TODO:* `#UpperId` and `#LowerId` have `prec(2)` while `KLabel` and `#KVariable`\n+have `prec(1)`. That does not leave much room for other priorities. Even if\n+`KLabel`, `#KVariable` aren't a problem, since we can't have negative\n+precedences, only `prec(0)` and `prec(1)` are available to users. Perhaps we\n+should multiply these by 100?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODUwMzQ2OnYy", "diffSide": "RIGHT", "path": "pending-documentation.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1NjozNFrOGpRUYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1NjozNFrOGpRUYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyODU0Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            syntax Set ::= collectOddFoos(FoosCell) [function]\n          \n          \n            \n            rule collectOddFoos(<foos> <foo> I </foo> REST </foos>)\n          \n          \n            \n              => SetItem(I) collectOddFoos(<foos> REST </foos>)\n          \n          \n            \n              requires I %Int 2 ==Int 1\n          \n          \n            \n            rule collectOddFoos(<foos> <foo> I </foo> REST </foos>)\n          \n          \n            \n              => collectOddFoos(<foos> REST </foos>)\n          \n          \n            \n              requires I %Int 2 ==Int 0\n          \n          \n            \n            rule collectOddFoos(<foos> .Bag </foos>) => .Set\n          \n          \n            \n                syntax Set ::= collectOddFoos(FoosCell) [function]\n          \n          \n            \n             // -----------------------------------------\n          \n          \n            \n                rule collectOddFoos(<foos> .Bag </foos>) => .Set\n          \n          \n            \n                rule collectOddFoos(<foos> <foo> I </foo> REST </foos>) => SetItem(I) collectOddFoos(<foos> REST </foos>) requires I %Int 2 ==Int 1\n          \n          \n            \n                rule collectOddFoos(<foos> <foo> I </foo> REST </foos>) => collectOddFoos(<foos> REST </foos>) requires I %Int 2 ==Int 0\n          \n      \n    \n    \n  \n\nThis is just a suggestion, but try to format this one so it's more readable/scannable. I like to try and make it obvious what the differences between the multiple rules are.", "url": "https://github.com/kframework/k/pull/1378#discussion_r445928547", "createdAt": "2020-06-26T01:56:34Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -1321,6 +1414,43 @@ Note that in the case of Set and Map, one guarantee is that K1, K2, K3, and K4\n represent /distinct/ elements. Pattern matching fails if the correct number of\n distinct elements cannot be found.\n \n+### Matching on cell fragments\n+\n+K allows matching fragments of the configuration and using them to construct\n+terms and use as function parameters.\n+\n+```k\n+configuration <t>\n+                <k> #init ~> #collectOddFoos ~> $PGM </k>\n+                <foos>\n+                  <foo multiplicity=\"*\" type=\"Set\"> 1 </foo>\n+                </foos>\n+              </t>\n+```\n+\n+The `#collectOddFoos` construct grabs the entire content of the `<foos>` cell.\n+We may also match on only a portion of its content. Note that the fragment\n+must be wrapped in a `<foo>` cell at the call site.\n+\n+```k\n+syntax KItem ::= \"#collectOddFoos\"\n+rule <k> #collectOddFoos => collectOddFoos(<foos> FOOS </foos>) ... </k>\n+     <foos> FOOS </foos>\n+```\n+\n+The `collectOddFoos` function collects the items it needs\n+\n+```k\n+syntax Set ::= collectOddFoos(FoosCell) [function]\n+rule collectOddFoos(<foos> <foo> I </foo> REST </foos>)\n+  => SetItem(I) collectOddFoos(<foos> REST </foos>)\n+  requires I %Int 2 ==Int 1\n+rule collectOddFoos(<foos> <foo> I </foo> REST </foos>)\n+  => collectOddFoos(<foos> REST </foos>)\n+  requires I %Int 2 ==Int 0\n+rule collectOddFoos(<foos> .Bag </foos>) => .Set", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed31c8428a5ea05cd61d59ebbe8aef341facaaff"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3071, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}