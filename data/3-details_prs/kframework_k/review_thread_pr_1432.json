{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwMzA1NDM4", "number": 1432, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODowNDozMVrOEQUCjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODoyNjozOVrOEQUgeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTQxMDA2OnYy", "diffSide": "RIGHT", "path": "k-distribution/src/main/scripts/bin/kx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODowNDozMVrOG0Zauw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODowNDozMVrOG0Zauw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NTU3OQ==", "bodyText": "This variable should be named a little better, because it appears it's only for the Haskell backend? Or at least, it's only for when doing search or prove?\nI would say it should be haskellCmd, instead of just cmd. If later we change LLVM backend to handle things like search or prove, then we can change the variable name.", "url": "https://github.com/kframework/k/pull/1432#discussion_r457595579", "createdAt": "2020-07-20T18:04:31Z", "author": {"login": "ehildenb"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -11,26 +11,30 @@ depth=\n params=()\n allPath=true\n dir=.\n-cmd=\n+cmd=kore-exec", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86d69b99dacfb7e1cdf7a288a19d7c65365cdcc"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTQyMzE0OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODowODoxNFrOG0Zixw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODoyNzo0NlrOG0aMWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NzYzOQ==", "bodyText": "This doesn't result in too many % being added? It looks something like %3 could get turned into %%cSOME_TERMINAL, where maybe it should be %cSOME_TERMINAL.\nAlso, why use replace for the last two instead of replaceAll? Just want you to double-check that this is correct.", "url": "https://github.com/kframework/k/pull/1432#discussion_r457597639", "createdAt": "2020-07-20T18:08:14Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -1374,7 +1374,7 @@ private Att addKoreAttributes(Production prod, SetMultimap<KLabel, Rule> functio\n           if (prod.items().apply(i) instanceof NonTerminal) {\n             format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%\" + (nt++));\n           } else if (prod.items().apply(i) instanceof Terminal) {\n-            format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%c\" + ((Terminal)prod.items().apply(i)).value().replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\") + \"%r\");\n+            format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%c\" + ((Terminal)prod.items().apply(i)).value().replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\").replace(\"%\", \"%%\") + \"%r\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86d69b99dacfb7e1cdf7a288a19d7c65365cdcc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwMzE4Ng==", "bodyText": "%c and %r are not part of the string passed to replace. We use replace because replace replaces a string everywhere with another string, whereas replaceAll replaces a regular expression with a string containing backreferences. We need the regular expressions in one case, but not the other, thus, we use replaceAll only in that one place.", "url": "https://github.com/kframework/k/pull/1432#discussion_r457603186", "createdAt": "2020-07-20T18:18:15Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -1374,7 +1374,7 @@ private Att addKoreAttributes(Production prod, SetMultimap<KLabel, Rule> functio\n           if (prod.items().apply(i) instanceof NonTerminal) {\n             format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%\" + (nt++));\n           } else if (prod.items().apply(i) instanceof Terminal) {\n-            format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%c\" + ((Terminal)prod.items().apply(i)).value().replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\") + \"%r\");\n+            format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%c\" + ((Terminal)prod.items().apply(i)).value().replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\").replace(\"%\", \"%%\") + \"%r\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NzYzOQ=="}, "originalCommit": {"oid": "e86d69b99dacfb7e1cdf7a288a19d7c65365cdcc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwODI4MA==", "bodyText": "Ah sorry, I misread.", "url": "https://github.com/kframework/k/pull/1432#discussion_r457608280", "createdAt": "2020-07-20T18:27:46Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -1374,7 +1374,7 @@ private Att addKoreAttributes(Production prod, SetMultimap<KLabel, Rule> functio\n           if (prod.items().apply(i) instanceof NonTerminal) {\n             format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%\" + (nt++));\n           } else if (prod.items().apply(i) instanceof Terminal) {\n-            format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%c\" + ((Terminal)prod.items().apply(i)).value().replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\") + \"%r\");\n+            format = format.replaceAll(\"%\" + (i+1) + \"(?![0-9])\", \"%c\" + ((Terminal)prod.items().apply(i)).value().replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\").replace(\"%\", \"%%\") + \"%r\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NzYzOQ=="}, "originalCommit": {"oid": "e86d69b99dacfb7e1cdf7a288a19d7c65365cdcc"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTQyNTg4OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/ksearchpattern/KSearchPatternFrontEnd.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODowODo1OFrOG0ZkXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODoyNTozM1rOG0aHtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5ODA0Nw==", "bodyText": "This looks like a very short kompile pipeline? Could it be framed as such? Mostly curious.", "url": "https://github.com/kframework/k/pull/1432#discussion_r457598047", "createdAt": "2020-07-20T18:08:58Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/ksearchpattern/KSearchPatternFrontEnd.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2020 K Team. All Rights Reserved.\n+package org.kframework.ksearchpattern;\n+\n+import com.google.inject.Provider;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+import com.google.inject.Module;\n+import org.kframework.attributes.Source;\n+import org.kframework.backend.kore.ModuleToKORE;\n+import org.kframework.builtin.BooleanUtils;\n+import org.kframework.compile.AddSortInjections;\n+import org.kframework.compile.ExpandMacros;\n+import org.kframework.compile.RewriteToTop;\n+import org.kframework.definition.Rule;\n+import org.kframework.kompile.CompiledDefinition;\n+import org.kframework.kompile.KompileOptions;\n+import org.kframework.kore.K;\n+import org.kframework.main.FrontEnd;\n+import org.kframework.main.GlobalOptions;\n+import org.kframework.utils.errorsystem.KExceptionManager;\n+import org.kframework.utils.file.FileUtil;\n+import org.kframework.utils.file.JarInfo;\n+import org.kframework.utils.file.KompiledDir;\n+import org.kframework.utils.inject.CommonModule;\n+import org.kframework.utils.inject.DefinitionScope;\n+import org.kframework.utils.inject.JCommanderModule;\n+import org.kframework.utils.inject.JCommanderModule.ExperimentalUsage;\n+import org.kframework.utils.inject.JCommanderModule.Usage;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Frontend for k-compiled-search-pattern tool.\n+ * <p>\n+ * k-compile-search-patterrn is used by the new krun frontend in order to\n+ * convert a search pattern written as a rule bubble into a KORE search pattern\n+ * for the Haskell backend.\n+ */\n+public class KSearchPatternFrontEnd extends FrontEnd {\n+\n+    private final KSearchPatternOptions options;\n+    private final Provider<KompileOptions> kompileOptions;\n+    private final KExceptionManager kem;\n+    private final Provider<FileUtil> files;\n+    private final GlobalOptions globalOptions;\n+    private final DefinitionScope scope;\n+    private final Provider<File> kompiledDir;\n+    private final Provider<CompiledDefinition> compiledDef;\n+\n+    @Inject\n+    public KSearchPatternFrontEnd(\n+            KSearchPatternOptions options,\n+            KExceptionManager kem,\n+            Provider<KompileOptions> kompileOptions,\n+            GlobalOptions globalOptions,\n+            @Usage String usage,\n+            @ExperimentalUsage String experimentalUsage,\n+            JarInfo jarInfo,\n+            Provider<FileUtil> files,\n+            @KompiledDir Provider<File> kompiledDir,\n+            Provider<CompiledDefinition> compiledDef,\n+            DefinitionScope scope) {\n+        super(kem, globalOptions, usage, experimentalUsage, jarInfo, files);\n+        this.options = options;\n+        this.kompileOptions = kompileOptions;\n+        this.globalOptions = globalOptions;\n+        this.kem = kem;\n+        this.files = files;\n+        this.scope = scope;\n+        this.kompiledDir = kompiledDir;\n+        this.compiledDef = compiledDef;\n+    }\n+\n+    public static List<Module> getModules() {\n+        List<Module> modules = new ArrayList<>();\n+        modules.add(new KSearchPatternModule());\n+        modules.add(new JCommanderModule());\n+        modules.add(new CommonModule());\n+        return modules;\n+    }\n+\n+    @Override\n+    protected int run() {\n+        scope.enter(kompiledDir.get());\n+        try {\n+          FileUtil files = this.files.get();\n+          CompiledDefinition compiledDef = this.compiledDef.get();\n+          KompileOptions kompileOptions = this.kompileOptions.get();\n+          Rule pattern = compiledDef.compilePatternIfAbsent(files, kem, options.pattern(), Source.apply(\"<command line>\"));\n+          K patternTerm = RewriteToTop.toLeft(pattern.body());\n+          K patternCondition = pattern.requires();\n+          org.kframework.definition.Module mod = compiledDef.executionModule();\n+          ModuleToKORE converter = new ModuleToKORE(mod, files, compiledDef.topCellInitializer, kompileOptions);\n+          StringBuilder sb = new StringBuilder();\n+          ExpandMacros macroExpander = ExpandMacros.forNonSentences(mod, files, kompileOptions, false);\n+          K withMacros = macroExpander.expand(patternTerm);\n+          K kWithInjections = new AddSortInjections(mod).addInjections(withMacros);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e86d69b99dacfb7e1cdf7a288a19d7c65365cdcc"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNDAwNA==", "bodyText": "What do you mean by \"framed as\"? Like, what change are you suggesting? It is correct that we are essentially taking a single pattern with a single optional side condition and parsing and kompiling it to kore.", "url": "https://github.com/kframework/k/pull/1432#discussion_r457604004", "createdAt": "2020-07-20T18:19:51Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/ksearchpattern/KSearchPatternFrontEnd.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2020 K Team. All Rights Reserved.\n+package org.kframework.ksearchpattern;\n+\n+import com.google.inject.Provider;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+import com.google.inject.Module;\n+import org.kframework.attributes.Source;\n+import org.kframework.backend.kore.ModuleToKORE;\n+import org.kframework.builtin.BooleanUtils;\n+import org.kframework.compile.AddSortInjections;\n+import org.kframework.compile.ExpandMacros;\n+import org.kframework.compile.RewriteToTop;\n+import org.kframework.definition.Rule;\n+import org.kframework.kompile.CompiledDefinition;\n+import org.kframework.kompile.KompileOptions;\n+import org.kframework.kore.K;\n+import org.kframework.main.FrontEnd;\n+import org.kframework.main.GlobalOptions;\n+import org.kframework.utils.errorsystem.KExceptionManager;\n+import org.kframework.utils.file.FileUtil;\n+import org.kframework.utils.file.JarInfo;\n+import org.kframework.utils.file.KompiledDir;\n+import org.kframework.utils.inject.CommonModule;\n+import org.kframework.utils.inject.DefinitionScope;\n+import org.kframework.utils.inject.JCommanderModule;\n+import org.kframework.utils.inject.JCommanderModule.ExperimentalUsage;\n+import org.kframework.utils.inject.JCommanderModule.Usage;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Frontend for k-compiled-search-pattern tool.\n+ * <p>\n+ * k-compile-search-patterrn is used by the new krun frontend in order to\n+ * convert a search pattern written as a rule bubble into a KORE search pattern\n+ * for the Haskell backend.\n+ */\n+public class KSearchPatternFrontEnd extends FrontEnd {\n+\n+    private final KSearchPatternOptions options;\n+    private final Provider<KompileOptions> kompileOptions;\n+    private final KExceptionManager kem;\n+    private final Provider<FileUtil> files;\n+    private final GlobalOptions globalOptions;\n+    private final DefinitionScope scope;\n+    private final Provider<File> kompiledDir;\n+    private final Provider<CompiledDefinition> compiledDef;\n+\n+    @Inject\n+    public KSearchPatternFrontEnd(\n+            KSearchPatternOptions options,\n+            KExceptionManager kem,\n+            Provider<KompileOptions> kompileOptions,\n+            GlobalOptions globalOptions,\n+            @Usage String usage,\n+            @ExperimentalUsage String experimentalUsage,\n+            JarInfo jarInfo,\n+            Provider<FileUtil> files,\n+            @KompiledDir Provider<File> kompiledDir,\n+            Provider<CompiledDefinition> compiledDef,\n+            DefinitionScope scope) {\n+        super(kem, globalOptions, usage, experimentalUsage, jarInfo, files);\n+        this.options = options;\n+        this.kompileOptions = kompileOptions;\n+        this.globalOptions = globalOptions;\n+        this.kem = kem;\n+        this.files = files;\n+        this.scope = scope;\n+        this.kompiledDir = kompiledDir;\n+        this.compiledDef = compiledDef;\n+    }\n+\n+    public static List<Module> getModules() {\n+        List<Module> modules = new ArrayList<>();\n+        modules.add(new KSearchPatternModule());\n+        modules.add(new JCommanderModule());\n+        modules.add(new CommonModule());\n+        return modules;\n+    }\n+\n+    @Override\n+    protected int run() {\n+        scope.enter(kompiledDir.get());\n+        try {\n+          FileUtil files = this.files.get();\n+          CompiledDefinition compiledDef = this.compiledDef.get();\n+          KompileOptions kompileOptions = this.kompileOptions.get();\n+          Rule pattern = compiledDef.compilePatternIfAbsent(files, kem, options.pattern(), Source.apply(\"<command line>\"));\n+          K patternTerm = RewriteToTop.toLeft(pattern.body());\n+          K patternCondition = pattern.requires();\n+          org.kframework.definition.Module mod = compiledDef.executionModule();\n+          ModuleToKORE converter = new ModuleToKORE(mod, files, compiledDef.topCellInitializer, kompileOptions);\n+          StringBuilder sb = new StringBuilder();\n+          ExpandMacros macroExpander = ExpandMacros.forNonSentences(mod, files, kompileOptions, false);\n+          K withMacros = macroExpander.expand(patternTerm);\n+          K kWithInjections = new AddSortInjections(mod).addInjections(withMacros);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5ODA0Nw=="}, "originalCommit": {"oid": "e86d69b99dacfb7e1cdf7a288a19d7c65365cdcc"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNzA5Mw==", "bodyText": "Not suggesting a change, just want to understand (should have made that clear). The main reason I'm thinking is because we've discussed changes to the kompile pipeline (ie framing it more declaratively using dependencies/checks interface), and if that happens the question is should this also happen here, or not?\nNothing actionable, just want to make sure it's been noted.", "url": "https://github.com/kframework/k/pull/1432#discussion_r457607093", "createdAt": "2020-07-20T18:25:33Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/ksearchpattern/KSearchPatternFrontEnd.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) 2020 K Team. All Rights Reserved.\n+package org.kframework.ksearchpattern;\n+\n+import com.google.inject.Provider;\n+import com.google.common.collect.Lists;\n+import com.google.inject.Inject;\n+import com.google.inject.Module;\n+import org.kframework.attributes.Source;\n+import org.kframework.backend.kore.ModuleToKORE;\n+import org.kframework.builtin.BooleanUtils;\n+import org.kframework.compile.AddSortInjections;\n+import org.kframework.compile.ExpandMacros;\n+import org.kframework.compile.RewriteToTop;\n+import org.kframework.definition.Rule;\n+import org.kframework.kompile.CompiledDefinition;\n+import org.kframework.kompile.KompileOptions;\n+import org.kframework.kore.K;\n+import org.kframework.main.FrontEnd;\n+import org.kframework.main.GlobalOptions;\n+import org.kframework.utils.errorsystem.KExceptionManager;\n+import org.kframework.utils.file.FileUtil;\n+import org.kframework.utils.file.JarInfo;\n+import org.kframework.utils.file.KompiledDir;\n+import org.kframework.utils.inject.CommonModule;\n+import org.kframework.utils.inject.DefinitionScope;\n+import org.kframework.utils.inject.JCommanderModule;\n+import org.kframework.utils.inject.JCommanderModule.ExperimentalUsage;\n+import org.kframework.utils.inject.JCommanderModule.Usage;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Frontend for k-compiled-search-pattern tool.\n+ * <p>\n+ * k-compile-search-patterrn is used by the new krun frontend in order to\n+ * convert a search pattern written as a rule bubble into a KORE search pattern\n+ * for the Haskell backend.\n+ */\n+public class KSearchPatternFrontEnd extends FrontEnd {\n+\n+    private final KSearchPatternOptions options;\n+    private final Provider<KompileOptions> kompileOptions;\n+    private final KExceptionManager kem;\n+    private final Provider<FileUtil> files;\n+    private final GlobalOptions globalOptions;\n+    private final DefinitionScope scope;\n+    private final Provider<File> kompiledDir;\n+    private final Provider<CompiledDefinition> compiledDef;\n+\n+    @Inject\n+    public KSearchPatternFrontEnd(\n+            KSearchPatternOptions options,\n+            KExceptionManager kem,\n+            Provider<KompileOptions> kompileOptions,\n+            GlobalOptions globalOptions,\n+            @Usage String usage,\n+            @ExperimentalUsage String experimentalUsage,\n+            JarInfo jarInfo,\n+            Provider<FileUtil> files,\n+            @KompiledDir Provider<File> kompiledDir,\n+            Provider<CompiledDefinition> compiledDef,\n+            DefinitionScope scope) {\n+        super(kem, globalOptions, usage, experimentalUsage, jarInfo, files);\n+        this.options = options;\n+        this.kompileOptions = kompileOptions;\n+        this.globalOptions = globalOptions;\n+        this.kem = kem;\n+        this.files = files;\n+        this.scope = scope;\n+        this.kompiledDir = kompiledDir;\n+        this.compiledDef = compiledDef;\n+    }\n+\n+    public static List<Module> getModules() {\n+        List<Module> modules = new ArrayList<>();\n+        modules.add(new KSearchPatternModule());\n+        modules.add(new JCommanderModule());\n+        modules.add(new CommonModule());\n+        return modules;\n+    }\n+\n+    @Override\n+    protected int run() {\n+        scope.enter(kompiledDir.get());\n+        try {\n+          FileUtil files = this.files.get();\n+          CompiledDefinition compiledDef = this.compiledDef.get();\n+          KompileOptions kompileOptions = this.kompileOptions.get();\n+          Rule pattern = compiledDef.compilePatternIfAbsent(files, kem, options.pattern(), Source.apply(\"<command line>\"));\n+          K patternTerm = RewriteToTop.toLeft(pattern.body());\n+          K patternCondition = pattern.requires();\n+          org.kframework.definition.Module mod = compiledDef.executionModule();\n+          ModuleToKORE converter = new ModuleToKORE(mod, files, compiledDef.topCellInitializer, kompileOptions);\n+          StringBuilder sb = new StringBuilder();\n+          ExpandMacros macroExpander = ExpandMacros.forNonSentences(mod, files, kompileOptions, false);\n+          K withMacros = macroExpander.expand(patternTerm);\n+          K kWithInjections = new AddSortInjections(mod).addInjections(withMacros);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5ODA0Nw=="}, "originalCommit": {"oid": "e86d69b99dacfb7e1cdf7a288a19d7c65365cdcc"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTQ4NjY1OnYy", "diffSide": "RIGHT", "path": "k-distribution/include/kframework/ktest.mak", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODoyNjozOVrOG0aJ8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxODo0Mzo1M1rOG0avhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNzY2Ng==", "bodyText": "Are we testing the old krun codepath at all at this point then?", "url": "https://github.com/kframework/k/pull/1432#discussion_r457607666", "createdAt": "2020-07-20T18:26:39Z", "author": {"login": "ehildenb"}, "path": "k-distribution/include/kframework/ktest.mak", "diffHunk": "@@ -45,6 +45,9 @@ SOURCE_EXT?=$(or $(and $(wildcard $(DEF).k), k), $(or $(and $(wildcard $(DEF).md\n ifeq ($(KOMPILE_BACKEND),llvm)\n KRUN=$(abspath $(MAKEFILE_PATH)/../../bin/kx)\n endif\n+ifeq ($(KOMPILE_BACKEND),haskell)\n+KRUN=$(abspath $(MAKEFILE_PATH)/../../bin/kx)\n+endif", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ab58130d0d29fa63f9e08dfda7ff60f63cabb20"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNzg5NA==", "bodyText": "We still are falling back to the old tools if we don't have direct generated parsers, so it should be OK.", "url": "https://github.com/kframework/k/pull/1432#discussion_r457607894", "createdAt": "2020-07-20T18:27:02Z", "author": {"login": "ehildenb"}, "path": "k-distribution/include/kframework/ktest.mak", "diffHunk": "@@ -45,6 +45,9 @@ SOURCE_EXT?=$(or $(and $(wildcard $(DEF).k), k), $(or $(and $(wildcard $(DEF).md\n ifeq ($(KOMPILE_BACKEND),llvm)\n KRUN=$(abspath $(MAKEFILE_PATH)/../../bin/kx)\n endif\n+ifeq ($(KOMPILE_BACKEND),haskell)\n+KRUN=$(abspath $(MAKEFILE_PATH)/../../bin/kx)\n+endif", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNzY2Ng=="}, "originalCommit": {"oid": "9ab58130d0d29fa63f9e08dfda7ff60f63cabb20"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYxNzI4Nw==", "bodyText": "Well, we are still testing the code path via the java backend in places...", "url": "https://github.com/kframework/k/pull/1432#discussion_r457617287", "createdAt": "2020-07-20T18:43:53Z", "author": {"login": "dwightguth"}, "path": "k-distribution/include/kframework/ktest.mak", "diffHunk": "@@ -45,6 +45,9 @@ SOURCE_EXT?=$(or $(and $(wildcard $(DEF).k), k), $(or $(and $(wildcard $(DEF).md\n ifeq ($(KOMPILE_BACKEND),llvm)\n KRUN=$(abspath $(MAKEFILE_PATH)/../../bin/kx)\n endif\n+ifeq ($(KOMPILE_BACKEND),haskell)\n+KRUN=$(abspath $(MAKEFILE_PATH)/../../bin/kx)\n+endif", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYwNzY2Ng=="}, "originalCommit": {"oid": "9ab58130d0d29fa63f9e08dfda7ff60f63cabb20"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2965, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}