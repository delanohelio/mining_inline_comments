{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyMjU4MDc2", "number": 1247, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTo1OToxMFrOD5Lkyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo1MjowMFrOD5cJWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjg1MDY2OnYy", "diffSide": "RIGHT", "path": "k-distribution/tests/regression-new/parse-c/c18-syntax.k", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMTo1OToxMFrOGQTxow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzo1ODozNVrOGQWTdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NDQwMw==", "bodyText": "The for doesn't look very nice. What happened?", "url": "https://github.com/kframework/k/pull/1247#discussion_r419754403", "createdAt": "2020-05-04T21:59:10Z", "author": {"login": "radumereuta"}, "path": "k-distribution/tests/regression-new/parse-c/c18-syntax.k", "diffHunk": "@@ -0,0 +1,340 @@\n+module C-LEXICAL-SORTS\n+  syntax Identifier\n+  syntax Constant ::= Char\n+  syntax StringLiteral\n+  syntax Char\n+endmodule\n+\n+module C-LEXICAL\n+  imports C-LEXICAL-SORTS\n+\n+  imports ID-SYNTAX\n+  imports FLOAT-SYNTAX\n+  imports STRING-SYNTAX\n+\n+  syntax Identifier ::= Id\n+  syntax Constant ::= IntConstant | Float\n+  syntax StringLiteral ::= String\n+\n+  syntax IntConstant ::= r\"(([1-9][0-9]*)|(0[0-7]*)|(0[xX][0-9a-fA-F]+))(([uU][lL]?)|([uU]((ll)|(LL)))|([lL][uU]?)|(((ll)|(LL))[uU]?))?\"\n+  syntax Char ::= r\"[LuU]?'(([^'\\\\n\\\\\\\\])|(\\\\\\\\['\\\\\\\"?\\\\\\\\abfnrtv])|(\\\\\\\\[0-7]{3})|(\\\\\\\\x[0-9a-fA-F]+)|(\\\\\\\\u[0-9a-fA-F]{4})|(\\\\\\\\U[0-9a-fA-F]{8}))+'\" [token]\n+\n+endmodule\n+\n+module C18-COMMON\n+  imports C-LEXICAL-SORTS\n+\n+  // \\section(A.2.1)\n+\n+  syntax Exp ::= Identifier\n+               | Constant\n+               | StringLiteral\n+               | \"(\" Exp \")\" [bracket]\n+               | \"_Generic\" \"(\" Exp \",\" GenericAssocs \")\"\n+               > Exp \"[\" Exp \"]\"\n+               | Exp \"(\" Exps \")\"\n+               | Exp \"(\" \")\"\n+               | Exp \".\" Identifier\n+               | Exp \"->\" Identifier\n+               | Exp \"++\"\n+               | Exp \"--\"\n+               | \"(\" TypeName \")\" \"{\" Inits \"}\"\n+               | \"(\" TypeName \")\" \"{\" Inits \",\" \"}\"\n+               > \"++\" Exp\n+               | \"--\" Exp\n+               | \"&\" Exp\n+               | \"*\" Exp\n+               | \"+\" Exp\n+               | \"-\" Exp\n+               | \"~\" Exp\n+               | \"!\" Exp\n+               | \"sizeof\" Exp\n+               | \"sizeof\" \"(\" TypeName \")\"\n+               | \"_Alignof\" \"(\" TypeName \")\"\n+               > \"(\" TypeName \")\" Exp\n+               > left:\n+                 Exp \"*\" Exp\n+               | Exp \"/\" Exp\n+               | Exp \"%\" Exp\n+               > left:\n+                 Exp \"+\" Exp\n+               | Exp \"-\" Exp\n+               > left:\n+                 Exp \"<<\" Exp\n+               | Exp \">>\" Exp\n+               > left:\n+                 Exp \"<\" Exp\n+               | Exp \">\" Exp\n+               | Exp \"<=\" Exp\n+               | Exp \">=\" Exp\n+               > left:\n+                 Exp \"==\" Exp\n+               | Exp \"==\" Exp\n+               > left:\n+                 Exp \"&\" Exp\n+               > left:\n+                 Exp \"^\" Exp\n+               > left:\n+                 Exp \"|\" Exp\n+               > left:\n+                 Exp \"&&\" Exp\n+               > left:\n+                 Exp \"||\" Exp\n+               > right:\n+                 Exp \"?\" Exp \":\" Exp\n+               > right:\n+                 Exp \"=\" Exp [assign]\n+               | Exp \"*=\" Exp [assign]\n+               | Exp \"/=\" Exp [assign]\n+               | Exp \"%=\" Exp [assign]\n+               | Exp \"+=\" Exp [assign]\n+               | Exp \"-=\" Exp [assign]\n+               | Exp \"<<=\" Exp [assign]\n+               | Exp \">>=\" Exp [assign]\n+               | Exp \"&=\" Exp [assign]\n+               | Exp \"^=\" Exp [assign]\n+               | Exp \"|=\" Exp [assign]\n+               > left:\n+                 Exp \",\" Exp [comma]\n+  syntax priorities assignExp > comma\n+  syntax priorities constantExp > assign\n+\n+  syntax GenericAssocs ::= NeList{GenericAssoc,\",\"}\n+\n+  syntax GenericAssoc ::= TypeName \":\" Exp  [assignExp]\n+                              | \"default\" \":\" Exp [assignExp]\n+\n+  syntax Exps ::= Exp [klabel(arg), assignExp]\n+                | Exps \",\" Exp [assignExp]\n+\n+  // \\section(A.2.2)\n+\n+  syntax Decl ::= DeclSpecifiers InitDecls \";\"\n+                | DeclSpecifiers \";\"\n+                | StaticAssertDecl\n+\n+  syntax DeclSpecifiers ::= NeList{DeclSpecifier,\"\"}\n+\n+  syntax DeclSpecifier ::= StorageClassSpecifier\n+                         | TypeSpecifier\n+                         | TypeQualifier\n+                         | FunctionSpecifier\n+                         | AlignmentSpecifier\n+\n+  syntax InitDecls ::= NeList{InitDecl,\",\"}\n+\n+  syntax InitDecl ::= Declarator\n+                    | Declarator \"=\" Init\n+\n+  syntax StorageClassSpecifier ::= \"typedef\"\n+                                 | \"extern\"\n+                                 | \"static\"\n+                                 | \"_Thread_local\"\n+                                 | \"auto\"\n+                                 | \"register\"\n+\n+  syntax TypeSpecifier ::= \"void\"\n+                         | \"char\"\n+                         | \"short\"\n+                         | \"int\"\n+                         | \"long\"\n+                         | \"float\"\n+                         | \"double\"\n+                         | \"signed\"\n+                         | \"unsigned\"\n+                         | \"_Bool\"\n+                         | \"_Complex\"\n+                         | AtomicTypeSpecifier\n+                         | \"struct\" Identifier \"{\" StructDecls \"}\"\n+                         | \"struct\" \"{\" StructDecls \"}\"\n+                         | \"struct\" Identifier\n+                         | \"union\" Identifier \"{\" StructDecls \"}\"\n+                         | \"union\" \"{\" StructDecls \"}\"\n+                         | \"union\" Identifier\n+                         | \"enum\" Identifier \"{\" Enumerators \"}\"\n+                         | \"enum\" \"{\" Enumerators \"}\"\n+                         | \"enum\" Identifier \"{\" Enumerators \",\" \"}\"\n+                         | \"enum\" \"{\" Enumerators \",\" \"}\"\n+                         | \"enum\" Identifier\n+                         | Identifier\n+\n+  syntax AtomicTypeSpecifier ::= \"_Atomic\" \"(\" TypeName \")\"\n+\n+  syntax StructDecls ::= NeList{StructDecl,\"\"}\n+\n+  syntax StructDecl ::= SpecifierQuals StructDeclarators \";\"\n+                      | SpecifierQuals \";\"\n+                      | StaticAssertDecl\n+\n+  syntax SpecifierQuals ::= NeList{SpecifierQual,\"\"}\n+\n+  syntax SpecifierQual ::= TypeSpecifier\n+                         | TypeQualifier\n+\n+  syntax StructDeclarators ::= NeList{StructDeclarator,\",\"}\n+\n+  syntax StructDeclarator ::= Declarator\n+                            | Declarator \":\" Exp [constantExp]\n+                            | \":\" Exp [constantExp]\n+\n+  syntax Enumerators ::= NeList{Enumerator,\",\"}\n+\n+  syntax Enumerator ::= Identifier\n+                      | Identifier \"=\" Exp [constantExp]\n+\n+  syntax TypeQualifier ::= \"const\" | \"restrict\" | \"volatile\" | \"_Atomic\"\n+  syntax FunctionSpecifier ::= \"inline\" | \"_Noreturn\"\n+  syntax AlignmentSpecifier ::= \"_Alignas\" \"(\" TypeName \")\"\n+                              | \"_Alignas\" \"(\" Exp \")\"\n+\n+  syntax Declarator ::= Pointer DirectDeclarator\n+                      | DirectDeclarator\n+\n+  syntax DirectDeclarator ::= Identifier\n+                            | \"(\" Declarator \")\" [bracket]\n+                            | DirectDeclarator \"[\" TypeQualifiers Exp \"]\"\n+                            | DirectDeclarator \"[\" TypeQualifiers \"]\"\n+                            | DirectDeclarator \"[\" Exp \"]\"\n+                            | DirectDeclarator \"[\" \"]\"\n+                            | DirectDeclarator \"[\" \"static\" TypeQualifiers Exp \"]\"\n+                            | DirectDeclarator \"[\" \"static\" Exp \"]\"\n+                            | DirectDeclarator \"[\" TypeQualifiers \"static\" Exp \"]\"\n+                            | DirectDeclarator \"[\" TypeQualifiers \"*\" \"]\"\n+                            | DirectDeclarator \"[\" \"*\" \"]\"\n+                            | DirectDeclarator \"(\" ParamTypeList \")\"\n+                            | DirectDeclarator \"(\" Identifiers \")\"\n+                            | DirectDeclarator \"(\" \")\"\n+\n+  syntax FunctionDeclarator ::= Pointer FunctionDirectDeclarator\n+                              | FunctionDirectDeclarator\n+\n+  syntax FunctionDirectDeclarator ::= \"(\" FunctionDeclarator \")\"\n+                                    | DirectDeclarator \"(\" ParamTypeList \")\"\n+                                    | DirectDeclarator \"(\" Identifiers \")\"\n+                                    | DirectDeclarator \"(\" \")\"\n+\n+  syntax Pointer ::= \"*\"\n+                   | \"*\" TypeQualifiers\n+                   | \"*\" Pointer\n+                   | \"*\" TypeQualifiers Pointer\n+\n+  syntax TypeQualifiers ::= NeList{TypeQualifier,\"\"}\n+\n+  syntax ParamTypeList ::= Params\n+                         | Params \",\" \"...\"\n+\n+  syntax Params ::= NeList{ParamDecl,\",\"}\n+\n+  syntax ParamDecl ::= DeclSpecifiers Declarator\n+                     | DeclSpecifiers\n+                     | DeclSpecifiers AbstractDeclarator\n+\n+  syntax Identifiers ::= NeList{Identifier,\",\"}\n+\n+  syntax TypeName ::= SpecifierQuals\n+                    | SpecifierQuals AbstractDeclarator\n+\n+  syntax AbstractDeclarator ::= Pointer\n+                              | DirectAbstractDeclarator\n+                              | Pointer DirectAbstractDeclarator\n+\n+  syntax DirectAbstractDeclarator ::= \"(\" AbstractDeclarator \")\" [bracket]\n+                                    | \"[\" \"]\"\n+                                    | \"[\" TypeQualifiers \"]\"\n+                                    | \"[\" TypeQualifiers Exp \"]\"\n+                                    | DirectAbstractDeclarator \"[\" Exp \"]\"\n+                                    | \"[\" \"static\" Exp \"]\"\n+                                    | \"[\" \"static\" TypeQualifiers Exp \"]\"\n+                                    | DirectAbstractDeclarator \"[\" \"static\" Exp \"]\"\n+                                    | DirectAbstractDeclarator \"[\" \"static\" TypeQualifiers Exp \"]\"\n+                                    | DirectAbstractDeclarator \"[\" TypeQualifiers \"static\" Exp \"]\"\n+                                    | \"[\" TypeQualifiers \"static\" Exp \"]\"\n+                                    | \"[\" \"*\" \"]\"\n+                                    | DirectAbstractDeclarator \"[\" \"*\" \"]\"\n+                                    | \"(\" \")\"\n+                                    | \"(\" ParamTypeList \")\"\n+                                    | DirectAbstractDeclarator \"(\" \")\"\n+                                    | DirectAbstractDeclarator \"(\" ParamTypeList \")\"\n+\n+  syntax Init ::= Exp [klabel(initExp), assignExp]\n+                | \"{\" Inits \"}\"\n+                | \"{\" Inits \",\" \"}\"\n+\n+  syntax Inits ::= NeList{InitDesignation,\",\"}\n+\n+  syntax InitDesignation ::= Init | Designators \"=\" Init\n+\n+  syntax Designators ::= NeList{Designator,\"\"}\n+\n+  syntax Designator ::= \"[\" Exp \"]\"\n+                      | \".\" Identifier\n+\n+  syntax StaticAssertDecl ::= \"_Static_assert\" \"(\" Exp \",\" StringLiteral \")\" \";\"\n+\n+  // \\section(A.2.3)\n+\n+  syntax Stmt ::= Identifier \":\" Stmt\n+                | \"case\" Exp \":\" Stmt\n+                | \"default\" \":\" Stmt\n+                | CompoundStmt\n+                | \";\"\n+                | Exp \";\"\n+                | \"if\" \"(\" Exp \")\" Stmt\n+                | \"if\" \"(\" Exp \")\" Stmt \"else\" Stmt [avoid]\n+                | \"switch\" \"(\" Exp \")\" Stmt\n+                | \"while\" \"(\" Exp \")\" Stmt\n+                | \"do\" Stmt \"while\" \"(\" Exp \")\" \";\"\n+                | \"for\" \"(\"     \";\"     \";\"     \")\" Stmt\n+                | \"for\" \"(\"     \";\" Exp \";\"     \")\" Stmt\n+                | \"for\" \"(\"     \";\" Exp \";\" Exp \")\" Stmt\n+                | \"for\" \"(\"     \";\"     \";\" Exp \")\" Stmt\n+                | \"for\" \"(\" Exp \";\"     \";\"     \")\" Stmt\n+                | \"for\" \"(\" Exp \";\" Exp \";\"     \")\" Stmt\n+                | \"for\" \"(\" Exp \";\" Exp \";\" Exp \")\" Stmt\n+                | \"for\" \"(\" Exp \";\"     \";\" Exp \")\" Stmt\n+                | \"for\" \"(\" Decl     \";\"     \")\" Stmt\n+                | \"for\" \"(\" Decl Exp \";\"     \")\" Stmt\n+                | \"for\" \"(\" Decl Exp \";\" Exp \")\" Stmt\n+                | \"for\" \"(\" Decl     \";\" Exp \")\" Stmt", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36d45351accd7b0beb77f57c0823a09a550f1a9e"}, "originalPosition": 298}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5NTgzMQ==", "bodyText": "Combinatory explosion. The reference grammar has three optional norterminals, so we generate 2^3=8 productions. The alternative would be to introduce a new nonterminal that has an empty production, but bison dislikes this immensely and you end up with a parser that splits a lot more often.", "url": "https://github.com/kframework/k/pull/1247#discussion_r419795831", "createdAt": "2020-05-04T23:58:35Z", "author": {"login": "dwightguth"}, "path": "k-distribution/tests/regression-new/parse-c/c18-syntax.k", "diffHunk": "@@ -0,0 +1,340 @@\n+module C-LEXICAL-SORTS\n+  syntax Identifier\n+  syntax Constant ::= Char\n+  syntax StringLiteral\n+  syntax Char\n+endmodule\n+\n+module C-LEXICAL\n+  imports C-LEXICAL-SORTS\n+\n+  imports ID-SYNTAX\n+  imports FLOAT-SYNTAX\n+  imports STRING-SYNTAX\n+\n+  syntax Identifier ::= Id\n+  syntax Constant ::= IntConstant | Float\n+  syntax StringLiteral ::= String\n+\n+  syntax IntConstant ::= r\"(([1-9][0-9]*)|(0[0-7]*)|(0[xX][0-9a-fA-F]+))(([uU][lL]?)|([uU]((ll)|(LL)))|([lL][uU]?)|(((ll)|(LL))[uU]?))?\"\n+  syntax Char ::= r\"[LuU]?'(([^'\\\\n\\\\\\\\])|(\\\\\\\\['\\\\\\\"?\\\\\\\\abfnrtv])|(\\\\\\\\[0-7]{3})|(\\\\\\\\x[0-9a-fA-F]+)|(\\\\\\\\u[0-9a-fA-F]{4})|(\\\\\\\\U[0-9a-fA-F]{8}))+'\" [token]\n+\n+endmodule\n+\n+module C18-COMMON\n+  imports C-LEXICAL-SORTS\n+\n+  // \\section(A.2.1)\n+\n+  syntax Exp ::= Identifier\n+               | Constant\n+               | StringLiteral\n+               | \"(\" Exp \")\" [bracket]\n+               | \"_Generic\" \"(\" Exp \",\" GenericAssocs \")\"\n+               > Exp \"[\" Exp \"]\"\n+               | Exp \"(\" Exps \")\"\n+               | Exp \"(\" \")\"\n+               | Exp \".\" Identifier\n+               | Exp \"->\" Identifier\n+               | Exp \"++\"\n+               | Exp \"--\"\n+               | \"(\" TypeName \")\" \"{\" Inits \"}\"\n+               | \"(\" TypeName \")\" \"{\" Inits \",\" \"}\"\n+               > \"++\" Exp\n+               | \"--\" Exp\n+               | \"&\" Exp\n+               | \"*\" Exp\n+               | \"+\" Exp\n+               | \"-\" Exp\n+               | \"~\" Exp\n+               | \"!\" Exp\n+               | \"sizeof\" Exp\n+               | \"sizeof\" \"(\" TypeName \")\"\n+               | \"_Alignof\" \"(\" TypeName \")\"\n+               > \"(\" TypeName \")\" Exp\n+               > left:\n+                 Exp \"*\" Exp\n+               | Exp \"/\" Exp\n+               | Exp \"%\" Exp\n+               > left:\n+                 Exp \"+\" Exp\n+               | Exp \"-\" Exp\n+               > left:\n+                 Exp \"<<\" Exp\n+               | Exp \">>\" Exp\n+               > left:\n+                 Exp \"<\" Exp\n+               | Exp \">\" Exp\n+               | Exp \"<=\" Exp\n+               | Exp \">=\" Exp\n+               > left:\n+                 Exp \"==\" Exp\n+               | Exp \"==\" Exp\n+               > left:\n+                 Exp \"&\" Exp\n+               > left:\n+                 Exp \"^\" Exp\n+               > left:\n+                 Exp \"|\" Exp\n+               > left:\n+                 Exp \"&&\" Exp\n+               > left:\n+                 Exp \"||\" Exp\n+               > right:\n+                 Exp \"?\" Exp \":\" Exp\n+               > right:\n+                 Exp \"=\" Exp [assign]\n+               | Exp \"*=\" Exp [assign]\n+               | Exp \"/=\" Exp [assign]\n+               | Exp \"%=\" Exp [assign]\n+               | Exp \"+=\" Exp [assign]\n+               | Exp \"-=\" Exp [assign]\n+               | Exp \"<<=\" Exp [assign]\n+               | Exp \">>=\" Exp [assign]\n+               | Exp \"&=\" Exp [assign]\n+               | Exp \"^=\" Exp [assign]\n+               | Exp \"|=\" Exp [assign]\n+               > left:\n+                 Exp \",\" Exp [comma]\n+  syntax priorities assignExp > comma\n+  syntax priorities constantExp > assign\n+\n+  syntax GenericAssocs ::= NeList{GenericAssoc,\",\"}\n+\n+  syntax GenericAssoc ::= TypeName \":\" Exp  [assignExp]\n+                              | \"default\" \":\" Exp [assignExp]\n+\n+  syntax Exps ::= Exp [klabel(arg), assignExp]\n+                | Exps \",\" Exp [assignExp]\n+\n+  // \\section(A.2.2)\n+\n+  syntax Decl ::= DeclSpecifiers InitDecls \";\"\n+                | DeclSpecifiers \";\"\n+                | StaticAssertDecl\n+\n+  syntax DeclSpecifiers ::= NeList{DeclSpecifier,\"\"}\n+\n+  syntax DeclSpecifier ::= StorageClassSpecifier\n+                         | TypeSpecifier\n+                         | TypeQualifier\n+                         | FunctionSpecifier\n+                         | AlignmentSpecifier\n+\n+  syntax InitDecls ::= NeList{InitDecl,\",\"}\n+\n+  syntax InitDecl ::= Declarator\n+                    | Declarator \"=\" Init\n+\n+  syntax StorageClassSpecifier ::= \"typedef\"\n+                                 | \"extern\"\n+                                 | \"static\"\n+                                 | \"_Thread_local\"\n+                                 | \"auto\"\n+                                 | \"register\"\n+\n+  syntax TypeSpecifier ::= \"void\"\n+                         | \"char\"\n+                         | \"short\"\n+                         | \"int\"\n+                         | \"long\"\n+                         | \"float\"\n+                         | \"double\"\n+                         | \"signed\"\n+                         | \"unsigned\"\n+                         | \"_Bool\"\n+                         | \"_Complex\"\n+                         | AtomicTypeSpecifier\n+                         | \"struct\" Identifier \"{\" StructDecls \"}\"\n+                         | \"struct\" \"{\" StructDecls \"}\"\n+                         | \"struct\" Identifier\n+                         | \"union\" Identifier \"{\" StructDecls \"}\"\n+                         | \"union\" \"{\" StructDecls \"}\"\n+                         | \"union\" Identifier\n+                         | \"enum\" Identifier \"{\" Enumerators \"}\"\n+                         | \"enum\" \"{\" Enumerators \"}\"\n+                         | \"enum\" Identifier \"{\" Enumerators \",\" \"}\"\n+                         | \"enum\" \"{\" Enumerators \",\" \"}\"\n+                         | \"enum\" Identifier\n+                         | Identifier\n+\n+  syntax AtomicTypeSpecifier ::= \"_Atomic\" \"(\" TypeName \")\"\n+\n+  syntax StructDecls ::= NeList{StructDecl,\"\"}\n+\n+  syntax StructDecl ::= SpecifierQuals StructDeclarators \";\"\n+                      | SpecifierQuals \";\"\n+                      | StaticAssertDecl\n+\n+  syntax SpecifierQuals ::= NeList{SpecifierQual,\"\"}\n+\n+  syntax SpecifierQual ::= TypeSpecifier\n+                         | TypeQualifier\n+\n+  syntax StructDeclarators ::= NeList{StructDeclarator,\",\"}\n+\n+  syntax StructDeclarator ::= Declarator\n+                            | Declarator \":\" Exp [constantExp]\n+                            | \":\" Exp [constantExp]\n+\n+  syntax Enumerators ::= NeList{Enumerator,\",\"}\n+\n+  syntax Enumerator ::= Identifier\n+                      | Identifier \"=\" Exp [constantExp]\n+\n+  syntax TypeQualifier ::= \"const\" | \"restrict\" | \"volatile\" | \"_Atomic\"\n+  syntax FunctionSpecifier ::= \"inline\" | \"_Noreturn\"\n+  syntax AlignmentSpecifier ::= \"_Alignas\" \"(\" TypeName \")\"\n+                              | \"_Alignas\" \"(\" Exp \")\"\n+\n+  syntax Declarator ::= Pointer DirectDeclarator\n+                      | DirectDeclarator\n+\n+  syntax DirectDeclarator ::= Identifier\n+                            | \"(\" Declarator \")\" [bracket]\n+                            | DirectDeclarator \"[\" TypeQualifiers Exp \"]\"\n+                            | DirectDeclarator \"[\" TypeQualifiers \"]\"\n+                            | DirectDeclarator \"[\" Exp \"]\"\n+                            | DirectDeclarator \"[\" \"]\"\n+                            | DirectDeclarator \"[\" \"static\" TypeQualifiers Exp \"]\"\n+                            | DirectDeclarator \"[\" \"static\" Exp \"]\"\n+                            | DirectDeclarator \"[\" TypeQualifiers \"static\" Exp \"]\"\n+                            | DirectDeclarator \"[\" TypeQualifiers \"*\" \"]\"\n+                            | DirectDeclarator \"[\" \"*\" \"]\"\n+                            | DirectDeclarator \"(\" ParamTypeList \")\"\n+                            | DirectDeclarator \"(\" Identifiers \")\"\n+                            | DirectDeclarator \"(\" \")\"\n+\n+  syntax FunctionDeclarator ::= Pointer FunctionDirectDeclarator\n+                              | FunctionDirectDeclarator\n+\n+  syntax FunctionDirectDeclarator ::= \"(\" FunctionDeclarator \")\"\n+                                    | DirectDeclarator \"(\" ParamTypeList \")\"\n+                                    | DirectDeclarator \"(\" Identifiers \")\"\n+                                    | DirectDeclarator \"(\" \")\"\n+\n+  syntax Pointer ::= \"*\"\n+                   | \"*\" TypeQualifiers\n+                   | \"*\" Pointer\n+                   | \"*\" TypeQualifiers Pointer\n+\n+  syntax TypeQualifiers ::= NeList{TypeQualifier,\"\"}\n+\n+  syntax ParamTypeList ::= Params\n+                         | Params \",\" \"...\"\n+\n+  syntax Params ::= NeList{ParamDecl,\",\"}\n+\n+  syntax ParamDecl ::= DeclSpecifiers Declarator\n+                     | DeclSpecifiers\n+                     | DeclSpecifiers AbstractDeclarator\n+\n+  syntax Identifiers ::= NeList{Identifier,\",\"}\n+\n+  syntax TypeName ::= SpecifierQuals\n+                    | SpecifierQuals AbstractDeclarator\n+\n+  syntax AbstractDeclarator ::= Pointer\n+                              | DirectAbstractDeclarator\n+                              | Pointer DirectAbstractDeclarator\n+\n+  syntax DirectAbstractDeclarator ::= \"(\" AbstractDeclarator \")\" [bracket]\n+                                    | \"[\" \"]\"\n+                                    | \"[\" TypeQualifiers \"]\"\n+                                    | \"[\" TypeQualifiers Exp \"]\"\n+                                    | DirectAbstractDeclarator \"[\" Exp \"]\"\n+                                    | \"[\" \"static\" Exp \"]\"\n+                                    | \"[\" \"static\" TypeQualifiers Exp \"]\"\n+                                    | DirectAbstractDeclarator \"[\" \"static\" Exp \"]\"\n+                                    | DirectAbstractDeclarator \"[\" \"static\" TypeQualifiers Exp \"]\"\n+                                    | DirectAbstractDeclarator \"[\" TypeQualifiers \"static\" Exp \"]\"\n+                                    | \"[\" TypeQualifiers \"static\" Exp \"]\"\n+                                    | \"[\" \"*\" \"]\"\n+                                    | DirectAbstractDeclarator \"[\" \"*\" \"]\"\n+                                    | \"(\" \")\"\n+                                    | \"(\" ParamTypeList \")\"\n+                                    | DirectAbstractDeclarator \"(\" \")\"\n+                                    | DirectAbstractDeclarator \"(\" ParamTypeList \")\"\n+\n+  syntax Init ::= Exp [klabel(initExp), assignExp]\n+                | \"{\" Inits \"}\"\n+                | \"{\" Inits \",\" \"}\"\n+\n+  syntax Inits ::= NeList{InitDesignation,\",\"}\n+\n+  syntax InitDesignation ::= Init | Designators \"=\" Init\n+\n+  syntax Designators ::= NeList{Designator,\"\"}\n+\n+  syntax Designator ::= \"[\" Exp \"]\"\n+                      | \".\" Identifier\n+\n+  syntax StaticAssertDecl ::= \"_Static_assert\" \"(\" Exp \",\" StringLiteral \")\" \";\"\n+\n+  // \\section(A.2.3)\n+\n+  syntax Stmt ::= Identifier \":\" Stmt\n+                | \"case\" Exp \":\" Stmt\n+                | \"default\" \":\" Stmt\n+                | CompoundStmt\n+                | \";\"\n+                | Exp \";\"\n+                | \"if\" \"(\" Exp \")\" Stmt\n+                | \"if\" \"(\" Exp \")\" Stmt \"else\" Stmt [avoid]\n+                | \"switch\" \"(\" Exp \")\" Stmt\n+                | \"while\" \"(\" Exp \")\" Stmt\n+                | \"do\" Stmt \"while\" \"(\" Exp \")\" \";\"\n+                | \"for\" \"(\"     \";\"     \";\"     \")\" Stmt\n+                | \"for\" \"(\"     \";\" Exp \";\"     \")\" Stmt\n+                | \"for\" \"(\"     \";\" Exp \";\" Exp \")\" Stmt\n+                | \"for\" \"(\"     \";\"     \";\" Exp \")\" Stmt\n+                | \"for\" \"(\" Exp \";\"     \";\"     \")\" Stmt\n+                | \"for\" \"(\" Exp \";\" Exp \";\"     \")\" Stmt\n+                | \"for\" \"(\" Exp \";\" Exp \";\" Exp \")\" Stmt\n+                | \"for\" \"(\" Exp \";\"     \";\" Exp \")\" Stmt\n+                | \"for\" \"(\" Decl     \";\"     \")\" Stmt\n+                | \"for\" \"(\" Decl Exp \";\"     \")\" Stmt\n+                | \"for\" \"(\" Decl Exp \";\" Exp \")\" Stmt\n+                | \"for\" \"(\" Decl     \";\" Exp \")\" Stmt", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NDQwMw=="}, "originalCommit": {"oid": "36d45351accd7b0beb77f57c0823a09a550f1a9e"}, "originalPosition": 298}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjg1OTc0OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/Scanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMjowMjoyOFrOGQT3GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMjowMjoyOFrOGQT3GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1NTgwMQ==", "bodyText": "Why the extra space? :)", "url": "https://github.com/kframework/k/pull/1247#discussion_r419755801", "createdAt": "2020-05-04T22:02:28Z", "author": {"login": "radumereuta"}, "path": "kernel/src/main/java/org/kframework/parser/inner/kernel/Scanner.java", "diffHunk": "@@ -201,8 +207,8 @@ private void writeAction(StringBuilder flex, TerminalLike key) {\n     private void writeStandaloneAction(StringBuilder flex, TerminalLike key) {\n         flex.append(\" {\\n\" +\n             \"  int kind = \").append(tokens.get(key)._1()+1).append(\";\\n\" +\n-            \"  *((char **)&yylval) = malloc(strlen(yytext) + 1);\\n\" +\n-            \"  strcpy(*((char **)&yylval), yytext);\\n\" +\n+            \"  *((char **)yylval  ) = malloc(strlen(yytext) + 1);\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36d45351accd7b0beb77f57c0823a09a550f1a9e"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTU2MjMzOnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/kompile/KompileOptions.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo1MToxOFrOGQtM8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo1MToxOFrOGQtM8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE3MDk5NA==", "bodyText": "We should emit a parser for each $ variable that shows up in the configuration, not just $PGM.", "url": "https://github.com/kframework/k/pull/1247#discussion_r420170994", "createdAt": "2020-05-05T14:51:18Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/kompile/KompileOptions.java", "diffHunk": "@@ -135,6 +137,9 @@ public boolean isKore() {\n         @Parameter(names=\"--gen-bison-parser\", description=\"Emit bison parser for the PGM configuration variable within the syntax module of your definition into the kompiled definition.\")\n         public boolean genBisonParser;\n \n+        @Parameter(names=\"--gen-glr-bison-parser\", description=\"Emit GLR bison parser for the PGM configuration variable within the syntax module of your definition into the kompiled definition.\")\n+        public boolean genGlrBisonParser;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "162c21f2532abfa9dd3d4f6ca9e8a2b20088cebf"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTU2NTY4OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/kore/convertors/KILtoKORE.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo1MjowMFrOGQtPJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo1MjowMFrOGQtPJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE3MTU1OA==", "bodyText": "Should this be left instead?", "url": "https://github.com/kframework/k/pull/1247#discussion_r420171558", "createdAt": "2020-05-05T14:52:00Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/kore/convertors/KILtoKORE.java", "diffHunk": "@@ -300,9 +303,15 @@ public void applyUserList(Set<org.kframework.definition.Sentence> res,\n         org.kframework.definition.Production prod1, prod3;\n \n         // Es ::= E \",\" Es\n-        prod1 = Production(KLabel(p.getKLabel(kore), immutable(p.getParams())), sort,\n-                Seq(NonTerminal(elementSort), Terminal(userList.getSeparator()), NonTerminal(sort)),\n-                attrs.add(\"right\"));\n+        if (bisonLists) {\n+          prod1 = Production(KLabel(p.getKLabel(kore), immutable(p.getParams())), sort,\n+                  Seq(NonTerminal(sort), Terminal(userList.getSeparator()), NonTerminal(elementSort)),\n+                  attrs.add(\"right\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "162c21f2532abfa9dd3d4f6ca9e8a2b20088cebf"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3078, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}