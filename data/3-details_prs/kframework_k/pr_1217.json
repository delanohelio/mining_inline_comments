{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MzQxNjA0", "number": 1217, "title": "performance improvements to prover frontend", "bodyText": "", "createdAt": "2020-04-17T21:09:44Z", "url": "https://github.com/kframework/k/pull/1217", "merged": true, "mergeCommit": {"oid": "815016e417de500b7513655ca9c34c1633244271"}, "closed": true, "closedAt": "2020-04-22T00:52:02Z", "author": {"login": "dwightguth"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYn5SSAH2gAyNDA1MzQxNjA0OmQzMDM2NmFmZGFkZjA0NjY0OWU5ZmI2MTBmZGU1OThjNjM5NDQ2OTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcaglvhAFqTM5OTMzMTAzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d30366afdadf046649e9fb610fde598c63944696", "author": {"user": {"login": "dwightguth", "name": "Dwight Guth"}}, "url": "https://github.com/kframework/k/commit/d30366afdadf046649e9fb610fde598c63944696", "committedDate": "2020-04-17T21:09:08Z", "message": "performance improvements to prover frontend"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df19d71599a739d692b13976a9680595149153b3", "author": {"user": {"login": "dwightguth", "name": "Dwight Guth"}}, "url": "https://github.com/kframework/k/commit/df19d71599a739d692b13976a9680595149153b3", "committedDate": "2020-04-20T16:16:04Z", "message": "parse configs in sequence after all"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f003f9ac90f858ef749fb25d3d999b9ae6f21343", "author": {"user": {"login": "dwightguth", "name": "Dwight Guth"}}, "url": "https://github.com/kframework/k/commit/f003f9ac90f858ef749fb25d3d999b9ae6f21343", "committedDate": "2020-04-21T13:45:19Z", "message": "update tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5c650b92a88b0c9dbe99130fcc624500d75f140", "author": {"user": {"login": "dwightguth", "name": "Dwight Guth"}}, "url": "https://github.com/kframework/k/commit/b5c650b92a88b0c9dbe99130fcc624500d75f140", "committedDate": "2020-04-21T13:45:33Z", "message": "add another error message"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NTEwMzMz", "url": "https://github.com/kframework/k/pull/1217#pullrequestreview-397510333", "createdAt": "2020-04-21T17:15:50Z", "commit": {"oid": "b5c650b92a88b0c9dbe99130fcc624500d75f140"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxNTo1MFrOGJPUSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxNTo1MFrOGJPUSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MTMyMQ==", "bodyText": "I don't think I fully understand this, so want to make sure I do.\nWe're grabbing the entryPoint and main modules, as well as any modules they transitively import. We're also grabbing any entryModule (which I guess would be something like the proving module?), but not the transitive imports of the entryModules? And we're specifically only grabbing entryModules which have bubbles which need parsing.\nI guess my questions are:\n\nWhy not get transitive imports of entryModules()?\nWhy not apply the filter for only modules with bubbles across all the modules, not just the entryModules()?", "url": "https://github.com/kframework/k/pull/1217#discussion_r412341321", "createdAt": "2020-04-21T17:15:50Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/kompile/DefinitionParsing.java", "diffHunk": "@@ -111,23 +113,36 @@ public DefinitionParsing(\n                 kore,\n                 options.preprocess);\n \n+        if (!def.getModule(mainModule).isDefined()) {\n+          throw KEMException.criticalError(\"Module \" + mainModule + \" does not exist.\");\n+        }\n+        if (!def.getModule(entryPointModule).isDefined()) {\n+          throw KEMException.criticalError(\"Module \" + entryPointModule + \" does not exist.\");\n+        }\n+        Stream<Module> modules = Stream.of(def.getModule(mainModule).get());\n+        modules = Stream.concat(modules, stream(def.getModule(mainModule).get().importedModules()));\n+        modules = Stream.concat(modules, Stream.of(def.getModule(entryPointModule).get()));\n+        modules = Stream.concat(modules, stream(def.getModule(entryPointModule).get().importedModules()));\n+        modules = Stream.concat(modules,\n+                stream(def.entryModules()).filter(m -> !stream(m.sentences()).anyMatch(s -> s instanceof Bubble)));\n+        def = Definition(def.mainModule(), modules.collect(Collections.toSet()), def.att());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c650b92a88b0c9dbe99130fcc624500d75f140"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NTI3NzU1", "url": "https://github.com/kframework/k/pull/1217#pullrequestreview-397527755", "createdAt": "2020-04-21T17:37:20Z", "commit": {"oid": "b5c650b92a88b0c9dbe99130fcc624500d75f140"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2038003f67ad5427b74feb24d065b815d2481fe", "author": {"user": {"login": "rv-jenkins", "name": null}}, "url": "https://github.com/kframework/k/commit/f2038003f67ad5427b74feb24d065b815d2481fe", "committedDate": "2020-04-21T23:51:50Z", "message": "Merge branch 'master' into kprove"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MzMxMDM3", "url": "https://github.com/kframework/k/pull/1217#pullrequestreview-399331037", "createdAt": "2020-04-23T17:41:18Z", "commit": {"oid": "f2038003f67ad5427b74feb24d065b815d2481fe"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzo0MToxOFrOGK0Rnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzo0NTowMVrOGK0bSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NTQyMw==", "bodyText": "I recommend a comment explaining the above logic. Lack of comments in such places is a reason why code is hard to maintain.\nI don't see any advantage to build a Stream then to convert it to Set. You should create a Set from start. Code will look simpler. If you want the preserve the iterating order then use LinkedHashSet.", "url": "https://github.com/kframework/k/pull/1217#discussion_r413995423", "createdAt": "2020-04-23T17:41:18Z", "author": {"login": "denis-bogdanas"}, "path": "kernel/src/main/java/org/kframework/kompile/DefinitionParsing.java", "diffHunk": "@@ -111,23 +113,36 @@ public DefinitionParsing(\n                 kore,\n                 options.preprocess);\n \n+        if (!def.getModule(mainModule).isDefined()) {\n+          throw KEMException.criticalError(\"Module \" + mainModule + \" does not exist.\");\n+        }\n+        if (!def.getModule(entryPointModule).isDefined()) {\n+          throw KEMException.criticalError(\"Module \" + entryPointModule + \" does not exist.\");\n+        }\n+        Stream<Module> modules = Stream.of(def.getModule(mainModule).get());\n+        modules = Stream.concat(modules, stream(def.getModule(mainModule).get().importedModules()));\n+        modules = Stream.concat(modules, Stream.of(def.getModule(entryPointModule).get()));\n+        modules = Stream.concat(modules, stream(def.getModule(entryPointModule).get().importedModules()));\n+        modules = Stream.concat(modules,\n+                stream(def.entryModules()).filter(m -> !stream(m.sentences()).anyMatch(s -> s instanceof Bubble)));\n+        def = Definition(def.mainModule(), modules.collect(Collections.toSet()), def.att());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MTMyMQ=="}, "originalCommit": {"oid": "b5c650b92a88b0c9dbe99130fcc624500d75f140"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5Nzg5OA==", "bodyText": "Please add comments where you see fit.", "url": "https://github.com/kframework/k/pull/1217#discussion_r413997898", "createdAt": "2020-04-23T17:45:01Z", "author": {"login": "denis-bogdanas"}, "path": "kernel/src/main/java/org/kframework/kompile/DefinitionParsing.java", "diffHunk": "@@ -247,15 +260,90 @@ protected Definition resolveConfigBubbles(Definition definition, Module defaultC\n         return errors;\n     }\n \n-    public Definition resolveNonConfigBubbles(Definition defWithConfig, RuleGrammarGenerator gen) {\n-        Module ruleParserModule = gen.getRuleGrammar(defWithConfig.mainModule());\n+    public Definition resolveNonConfigBubbles(Definition defWithConfig, Module mainModule, RuleGrammarGenerator gen) {\n+        Module ruleParserModule = gen.getRuleGrammar(mainModule);\n         ParseCache cache = loadCache(ruleParserModule);\n         try (ParseInModule parser = RuleGrammarGenerator.getCombinedGrammar(cache.getModule(), isStrict, profileRules, files)) {\n+            parser.getScanner();\n             Map<String, Module> parsed = defWithConfig.parMap(m -> this.resolveNonConfigBubbles(m, parser.getScanner(), gen));\n             return DefinitionTransformer.from(m -> Module(m.name(), m.imports(), parsed.get(m.name()).localSentences(), m.att()), \"parsing rules\").apply(defWithConfig);\n         }\n     }\n \n+    private Definition resolveConfigBubbles(Definition def, RuleGrammarGenerator gen) {\n+      return DefinitionTransformer.from(m -> resolveConfigBubbles(def, m, gen), \"parsing configs\").apply(def);\n+    }\n+\n+    private Module resolveConfigBubbles(Definition def, Module inputModule, RuleGrammarGenerator gen) {\n+        if (stream(inputModule.localSentences())\n+                .filter(s -> s instanceof Bubble)\n+                .map(b -> (Bubble) b)\n+                .filter(b -> b.sentenceType().equals(\"config\")).count() == 0)\n+            return inputModule;\n+\n+\n+        Set<Sentence> importedConfigurationSortsSubsortedToCell = stream(inputModule.productions())\n+                .filter(p -> p.att().contains(\"cell\"))\n+                .map(p -> Production(Seq(), Sorts.Cell(), Seq(NonTerminal(p.sort())))).collect(Collections.toSet());\n+\n+        Module module = Module(inputModule.name(), (Set<Module>) inputModule.imports(),\n+                (Set<Sentence>) inputModule.localSentences().$bar(importedConfigurationSortsSubsortedToCell),\n+                inputModule.att());\n+\n+        Set<Sentence> configDeclProductions;\n+        ParseCache cache = loadCache(gen.getConfigGrammar(module));\n+        try (ParseInModule parser = RuleGrammarGenerator.getCombinedGrammar(cache.getModule(), isStrict, profileRules, files)) {\n+             parser.getScanner();\n+             configDeclProductions = stream(module.localSentences())\n+                    .parallel()\n+                    .filter(s -> s instanceof Bubble)\n+                    .map(b -> (Bubble) b)\n+                    .filter(b -> b.sentenceType().equals(\"config\"))\n+                    .flatMap(b -> performParse(cache.getCache(), parser, parser.getScanner(), b))\n+                    .map(contents -> {\n+                        KApply configContents = (KApply) contents;\n+                        List<K> items = configContents.klist().items();\n+                        switch (configContents.klabel().name()) {\n+                        case \"#ruleNoConditions\":\n+                            return Configuration(items.get(0), BooleanUtils.TRUE, configContents.att());\n+                        case \"#ruleEnsures\":\n+                            return Configuration(items.get(0), items.get(1), configContents.att());\n+                        default:\n+                            throw KEMException.compilerError(\"Illegal configuration with requires clause detected.\", configContents);\n+                        }\n+                    })\n+                    .flatMap(\n+                            configDecl -> stream(GenerateSentencesFromConfigDecl.gen(configDecl.body(), configDecl.ensures(), configDecl.att(), parser.getExtensionModule(), kore)))\n+                    .collect(Collections.toSet());\n+        }\n+\n+        Set<Sentence> configDeclSyntax = stream(configDeclProductions).filter(Sentence::isSyntax).collect(Collections.toSet());\n+        Set<Sentence> configDeclRules = stream(configDeclProductions).filter(Sentence::isNonSyntax).collect(Collections.toSet());\n+\n+        if (module.name().endsWith(Import.IMPORTS_SYNTAX_SUFFIX)) {\n+            Module mapModule;\n+            if (def.getModule(\"MAP$SYNTAX\").isDefined()) {\n+                mapModule = def.getModule(\"MAP$SYNTAX\").get();\n+            } else {\n+                throw KEMException.compilerError(\"Module Map must be visible at the configuration declaration, in module \" + module.name());\n+            }\n+            return Module(module.name(), (Set<Module>) module.imports().$bar(Set(mapModule)),\n+                    (Set<Sentence>) module.localSentences().$bar(configDeclSyntax),\n+                    module.att());\n+        } else {\n+            Module mapModule;\n+            if (def.getModule(\"MAP\").isDefined()) {\n+                mapModule = def.getModule(\"MAP\").get();\n+            } else {\n+                throw KEMException.compilerError(\"Module Map must be visible at the configuration declaration, in module \" + module.name());\n+            }\n+            return Module(module.name(), (Set<Module>) module.imports().$bar(Set(mapModule)),\n+                    (Set<Sentence>) module.localSentences().$bar(configDeclRules),\n+                    module.att());\n+        }\n+\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2038003f67ad5427b74feb24d065b815d2481fe"}, "originalPosition": 179}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2456, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}