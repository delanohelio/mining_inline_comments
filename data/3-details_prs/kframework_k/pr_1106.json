{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2NjYwNDUz", "number": 1106, "title": "Kapp2termcons", "bodyText": "This is supposed to be a fix for #985\nI've added a new filter at parsing time that transforms instances of KApp into the equivalent TermCons\nThis way the type inferencer can apply correctly\nI also found a pretty-printing issue in TreeNodesToKORE.scala and simplified the code a bit.", "createdAt": "2020-02-18T14:50:41Z", "url": "https://github.com/kframework/k/pull/1106", "merged": true, "mergeCommit": {"oid": "afa40c8e873af1a198d553c489c0a7c5e8946297"}, "closed": true, "closedAt": "2020-02-26T19:22:03Z", "author": {"login": "radumereuta"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcEAyEWAH2gAyMzc2NjYwNDUzOjZiMjAyNTFiZDBkY2I0ZDFlZjkyNDgyOTRlODcxY2RjNzZkMTljODA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcILd7HgFqTM2NTE1ODkzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6b20251bd0dcb4d1ef9248294e871cdc76d19c80", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/6b20251bd0dcb4d1ef9248294e871cdc76d19c80", "committedDate": "2020-02-13T20:16:28Z", "message": "Fix TermCons.toString for bracket productions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a31897d2374bdea264c3aa2076bd0db2f7f1df6", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/3a31897d2374bdea264c3aa2076bd0db2f7f1df6", "committedDate": "2020-02-15T21:23:05Z", "message": "Adding KApp to TermCons filter\n\nNeeds tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40ab08b6ab3d93bd5b8233748428931adc9ea84f", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/40ab08b6ab3d93bd5b8233748428931adc9ea84f", "committedDate": "2020-02-18T14:43:44Z", "message": "Work on transformer\n\nand adding unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2c025d45bcd2a9c9863cb0165468d429158dffc", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/e2c025d45bcd2a9c9863cb0165468d429158dffc", "committedDate": "2020-02-18T14:50:50Z", "message": "Merge branch 'master' into kapp2termcons"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6a5262cdb512b68a38fbb72f5e140221ee84795", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/f6a5262cdb512b68a38fbb72f5e140221ee84795", "committedDate": "2020-02-18T20:25:41Z", "message": "Fix a failing test."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzM0NzQ1", "url": "https://github.com/kframework/k/pull/1106#pullrequestreview-360734745", "createdAt": "2020-02-18T22:56:39Z", "commit": {"oid": "f6a5262cdb512b68a38fbb72f5e140221ee84795"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjo1NjozOVrOFrVhFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjo1NjozOVrOFrVhFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4NTYyMQ==", "bodyText": "Not sure about adding a warning here.", "url": "https://github.com/kframework/k/pull/1106#discussion_r380985621", "createdAt": "2020-02-18T22:56:39Z", "author": {"login": "radumereuta"}, "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) 2015-2019 K Team. All Rights Reserved.\n+package org.kframework.parser.concrete2kore.disambiguation;\n+\n+import com.google.common.collect.Sets;\n+import org.kframework.builtin.Sorts;\n+import org.kframework.definition.Module;\n+import org.kframework.definition.Production;\n+import org.kframework.parser.Ambiguity;\n+import org.kframework.parser.Constant;\n+import org.kframework.parser.SetsTransformerWithErrors;\n+import org.kframework.parser.Term;\n+import org.kframework.parser.TermCons;\n+import org.kframework.utils.StringUtil;\n+import org.kframework.utils.errorsystem.KEMException;\n+import org.pcollections.ConsPStack;\n+import org.pcollections.PStack;\n+import scala.collection.immutable.Set$;\n+import scala.util.Either;\n+import scala.util.Left;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.kframework.Collections.*;\n+import static org.kframework.kore.KORE.*;\n+\n+\n+/**\n+ * Transform the KApps found in a term into the corresponding TermCons so type checking and\n+ * variable type inference takes place correctly. Must be applied between type inference and\n+ * priority filter.\n+ */\n+public class KAppToTermConsVisitor extends SetsTransformerWithErrors<KEMException> {\n+\n+    private final Module mod;\n+    public KAppToTermConsVisitor(Module mod) {\n+        super();\n+        this.mod = mod;\n+    }\n+\n+    @Override\n+    public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n+        assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n+            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))\n+                // TODO: maybe return a hidden warning?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6a5262cdb512b68a38fbb72f5e140221ee84795"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMzY1NjIw", "url": "https://github.com/kframework/k/pull/1106#pullrequestreview-361365620", "createdAt": "2020-02-19T19:16:26Z", "commit": {"oid": "f6a5262cdb512b68a38fbb72f5e140221ee84795"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOToxNjoyNlrOFr0NdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxOToyMjoxMlrOFr0ZqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4ODUwMQ==", "bodyText": "Let's use TermCons.get everywhere so we don't get confused by the reversed indices", "url": "https://github.com/kframework/k/pull/1106#discussion_r381488501", "createdAt": "2020-02-19T19:16:26Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) 2015-2019 K Team. All Rights Reserved.\n+package org.kframework.parser.concrete2kore.disambiguation;\n+\n+import com.google.common.collect.Sets;\n+import org.kframework.builtin.Sorts;\n+import org.kframework.definition.Module;\n+import org.kframework.definition.Production;\n+import org.kframework.parser.Ambiguity;\n+import org.kframework.parser.Constant;\n+import org.kframework.parser.SetsTransformerWithErrors;\n+import org.kframework.parser.Term;\n+import org.kframework.parser.TermCons;\n+import org.kframework.utils.StringUtil;\n+import org.kframework.utils.errorsystem.KEMException;\n+import org.pcollections.ConsPStack;\n+import org.pcollections.PStack;\n+import scala.collection.immutable.Set$;\n+import scala.util.Either;\n+import scala.util.Left;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.kframework.Collections.*;\n+import static org.kframework.kore.KORE.*;\n+\n+\n+/**\n+ * Transform the KApps found in a term into the corresponding TermCons so type checking and\n+ * variable type inference takes place correctly. Must be applied between type inference and\n+ * priority filter.\n+ */\n+public class KAppToTermConsVisitor extends SetsTransformerWithErrors<KEMException> {\n+\n+    private final Module mod;\n+    public KAppToTermConsVisitor(Module mod) {\n+        super();\n+        this.mod = mod;\n+    }\n+\n+    @Override\n+    public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n+        assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n+            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6a5262cdb512b68a38fbb72f5e140221ee84795"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MDAxMA==", "bodyText": "The logic in this block doesn't look sound to me. You are basically dropping some of the parses in the forest", "url": "https://github.com/kframework/k/pull/1106#discussion_r381490010", "createdAt": "2020-02-19T19:19:10Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) 2015-2019 K Team. All Rights Reserved.\n+package org.kframework.parser.concrete2kore.disambiguation;\n+\n+import com.google.common.collect.Sets;\n+import org.kframework.builtin.Sorts;\n+import org.kframework.definition.Module;\n+import org.kframework.definition.Production;\n+import org.kframework.parser.Ambiguity;\n+import org.kframework.parser.Constant;\n+import org.kframework.parser.SetsTransformerWithErrors;\n+import org.kframework.parser.Term;\n+import org.kframework.parser.TermCons;\n+import org.kframework.utils.StringUtil;\n+import org.kframework.utils.errorsystem.KEMException;\n+import org.pcollections.ConsPStack;\n+import org.pcollections.PStack;\n+import scala.collection.immutable.Set$;\n+import scala.util.Either;\n+import scala.util.Left;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.kframework.Collections.*;\n+import static org.kframework.kore.KORE.*;\n+\n+\n+/**\n+ * Transform the KApps found in a term into the corresponding TermCons so type checking and\n+ * variable type inference takes place correctly. Must be applied between type inference and\n+ * priority filter.\n+ */\n+public class KAppToTermConsVisitor extends SetsTransformerWithErrors<KEMException> {\n+\n+    private final Module mod;\n+    public KAppToTermConsVisitor(Module mod) {\n+        super();\n+        this.mod = mod;\n+    }\n+\n+    @Override\n+    public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n+        assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n+            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))\n+                // TODO: maybe return a hidden warning?\n+                return super.apply(tc); // don't do anything if the label is not a token KLabel (in case of variable or casted variable)\n+            Constant kl = (Constant) tc.items().get(1);\n+            PStack<Term> items = flattenKList(tc.items().get(0));\n+            String klvalue = kl.value();\n+            try { klvalue = StringUtil.unescapeKoreKLabel(kl.value()); } catch (IllegalArgumentException e) { /* ignore */ } // if possible, unescape\n+            Set<Production> prods = mutable(mod.productionsFor().get(KLabel(klvalue))\n+                    .getOrElse(Set$.MODULE$::emptyInstance)\n+                    .filter(x -> ((Production) x).arity() == items.size()).toSet());\n+            if (prods.size() == 0) {\n+                String msg = \"Could not find any production with arity \" + items.size() + \" for label \" + kl.value();\n+                return Left.apply(Sets.newHashSet(KEMException.innerParserError(msg, kl)));\n+            } else if (prods.size() == 1)\n+                return super.apply(TermCons.apply(items, prods.iterator().next(), tc.location(), tc.source()));\n+            else {\n+                // instantiate all labels found and let the type checker filter them out\n+                Set<Term> tcs = new HashSet<>();\n+                for (Production prd : prods)\n+                    tcs.add(TermCons.apply(items, prd, tc.location(), tc.source()));\n+                return super.apply(Ambiguity.apply(tcs, tc.location(), tc.source()));\n+            }\n+        }\n+        return super.apply(tc);\n+    }\n+\n+    /**  Recurse under #KList and flatten all the terms */\n+    private static PStack<Term> flattenKList(Term t) {\n+        if (t instanceof Ambiguity) {\n+            Ambiguity amb = (Ambiguity) t;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6a5262cdb512b68a38fbb72f5e140221ee84795"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MDg5OQ==", "bodyText": "This needs to be converted to an arraylist still because otherwise reverse will take quadratic time.", "url": "https://github.com/kframework/k/pull/1106#discussion_r381490899", "createdAt": "2020-02-19T19:20:57Z", "author": {"login": "dwightguth"}, "path": "kore/src/main/scala/org/kframework/parser/TreeNodesToKORE.scala", "diffHunk": "@@ -29,21 +29,23 @@ class TreeNodesToKORE(parseSort: java.util.function.Function[String, Sort], stri\n     if (strict) KApply(lbl, KList(KToken(\"_\", Sorts.KVariable)), Att.add(classOf[Production], Production(lbl, Seq(), sort, Seq(NonTerminal(sort, None))))) else KToken(\"_\", Sorts.KVariable)\n   }\n \n-  def termConsToKApply(t: TermCons, items: PStack[Term], p: Production): KApply = {\n-    if (p.att.contains(\"recordPrd\", classOf[Production])) {\n-      val realProd = p.att.get(\"recordPrd\", classOf[Production])\n-      val map = new util.ArrayList(items).asScala.reverse.zipWithIndex.map { case (item, idx) => (p.nonterminal(idx).name.get, apply(item))} toMap\n+  def termConsToKApply(t: TermCons): K = {\n+    if (t.production.att.contains(\"recordPrd\", classOf[Production])) {\n+      val realProd = t.production.att.get(\"recordPrd\", classOf[Production])\n+      val map = t.items.asScala.reverse.zipWithIndex.map { case (item, idx) => (t.production.nonterminal(idx).name.get, apply(item))} toMap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6a5262cdb512b68a38fbb72f5e140221ee84795"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MTYyNQ==", "bodyText": "Same here", "url": "https://github.com/kframework/k/pull/1106#discussion_r381491625", "createdAt": "2020-02-19T19:22:12Z", "author": {"login": "dwightguth"}, "path": "kore/src/main/scala/org/kframework/parser/TreeNodesToKORE.scala", "diffHunk": "@@ -29,21 +29,23 @@ class TreeNodesToKORE(parseSort: java.util.function.Function[String, Sort], stri\n     if (strict) KApply(lbl, KList(KToken(\"_\", Sorts.KVariable)), Att.add(classOf[Production], Production(lbl, Seq(), sort, Seq(NonTerminal(sort, None))))) else KToken(\"_\", Sorts.KVariable)\n   }\n \n-  def termConsToKApply(t: TermCons, items: PStack[Term], p: Production): KApply = {\n-    if (p.att.contains(\"recordPrd\", classOf[Production])) {\n-      val realProd = p.att.get(\"recordPrd\", classOf[Production])\n-      val map = new util.ArrayList(items).asScala.reverse.zipWithIndex.map { case (item, idx) => (p.nonterminal(idx).name.get, apply(item))} toMap\n+  def termConsToKApply(t: TermCons): K = {\n+    if (t.production.att.contains(\"recordPrd\", classOf[Production])) {\n+      val realProd = t.production.att.get(\"recordPrd\", classOf[Production])\n+      val map = t.items.asScala.reverse.zipWithIndex.map { case (item, idx) => (t.production.nonterminal(idx).name.get, apply(item))} toMap\n       val realItems = realProd.nonterminals.map {\n         case NonTerminal(sort, None) => anonVar(sort)\n         case NonTerminal(sort, Some(x)) => map.getOrElse(x, anonVar(sort))\n       }\n-      KApply(p.klabel.get.head, KList(realItems.asJava), locationToAtt(t.location, t.source).add(classOf[Production], realProd))\n+      KApply(t.production.klabel.get.head, KList(realItems.asJava), locationToAtt(t.location, t.source).add(classOf[Production], realProd))\n     } else {\n-      val realProd = if (p.att.contains(\"originalPrd\", classOf[Production])) p.att.get(\"originalPrd\", classOf[Production]) else p\n-      if (p.klabel.isEmpty)\n-        throw KEMException.internalError(\"Missing klabel in production: \" + p, t)\n-      val klabel = if (p.klabel.get.name == \"#OuterCast\") KLabel(\"project:\" ++ p.sort.toString) else p.klabel.get\n-      KApply(klabel.head, KList(new util.ArrayList(items).asScala.reverse map apply asJava), locationToAtt(t.location, t.source).add(classOf[Production], realProd))\n+      val realProd = if (t.production.att.contains(\"originalPrd\", classOf[Production])) t.production.att.get(\"originalPrd\", classOf[Production]) else t.production\n+      if (t.production.att.contains(\"bracket\"))\n+        return apply(t.items.get(0))\n+      if (t.production.klabel.isEmpty)\n+        throw KEMException.internalError(\"Missing klabel in production: \" + t.production, t)\n+      val klabel = if (t.production.klabel.get.name == \"#OuterCast\") KLabel(\"project:\" ++ t.production.sort.toString) else t.production.klabel.get\n+      KApply(klabel.head, KList(t.items.asScala.reverse map apply asJava), locationToAtt(t.location, t.source).add(classOf[Production], realProd))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6a5262cdb512b68a38fbb72f5e140221ee84795"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "100366d025f23e31bddc9fb8b687b263981f8f4c", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/100366d025f23e31bddc9fb8b687b263981f8f4c", "committedDate": "2020-02-20T13:45:20Z", "message": "Fix PR issues."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8008917be7f876a13386a583092dd0c48be90b1c", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/8008917be7f876a13386a583092dd0c48be90b1c", "committedDate": "2020-02-20T13:45:37Z", "message": "Merge branch 'master' into kapp2termcons"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7572658bb8fd57dfea5a6d36c796003bebcb17c8", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/7572658bb8fd57dfea5a6d36c796003bebcb17c8", "committedDate": "2020-02-23T21:13:03Z", "message": "Accept multiple possible parses under KApp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab3add6197841f21cd2447a77f7f3c076808767d", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/ab3add6197841f21cd2447a77f7f3c076808767d", "committedDate": "2020-02-23T21:13:49Z", "message": "Merge branch 'master' into kapp2termcons"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MTIxMTQ5", "url": "https://github.com/kframework/k/pull/1106#pullrequestreview-364121149", "createdAt": "2020-02-25T13:01:19Z", "commit": {"oid": "ab3add6197841f21cd2447a77f7f3c076808767d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzowMToxOVrOFuFKuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzowMzoyOVrOFuFO9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MzQ4MQ==", "bodyText": "Pretty sure this is reversed from the order you want.", "url": "https://github.com/kframework/k/pull/1106#discussion_r383863481", "createdAt": "2020-02-25T13:01:19Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -43,57 +51,68 @@ public KAppToTermConsVisitor(Module mod) {\n     @Override\n     public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n         assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n-        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n-            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))\n-                // TODO: maybe return a hidden warning?\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.KAPP)) {\n+            if (!(tc.get(0) instanceof Constant) || !((Constant) tc.get(0)).production().sort().equals(Sorts.KLabel()))\n+                // TODO: remove check once the java and ocaml backends are no longer supported.\n                 return super.apply(tc); // don't do anything if the label is not a token KLabel (in case of variable or casted variable)\n-            Constant kl = (Constant) tc.items().get(1);\n-            PStack<Term> items = flattenKList(tc.items().get(0));\n+            Constant kl = (Constant) tc.get(0);\n             String klvalue = kl.value();\n             try { klvalue = StringUtil.unescapeKoreKLabel(kl.value()); } catch (IllegalArgumentException e) { /* ignore */ } // if possible, unescape\n             Set<Production> prods = mutable(mod.productionsFor().get(KLabel(klvalue))\n-                    .getOrElse(Set$.MODULE$::emptyInstance)\n-                    .filter(x -> ((Production) x).arity() == items.size()).toSet());\n-            if (prods.size() == 0) {\n-                String msg = \"Could not find any production with arity \" + items.size() + \" for label \" + kl.value();\n+                    .getOrElse(Set$.MODULE$::emptyInstance).toSet());\n+            Set<Term> sol = new HashSet<>();\n+            Term t = new PushTopAmbiguityUp2().apply(tc.get(1));\n+            Stream<Term> uppedAmb = t instanceof Ambiguity ? ((Ambiguity) t).items().stream() : Lists.newArrayList(t).stream();\n+            Map<Integer, List<PStack<Term>>> flattKLists = uppedAmb\n+                    .map(KAppToTermConsVisitor::flattenKList)\n+                    .collect(Collectors.groupingBy(PStack::size));\n+            for (Production prd : prods)\n+                for (PStack<Term> terms : flattKLists.getOrDefault(prd.arity(), Lists.newArrayList()))\n+                    sol.add(TermCons.apply(terms, prd, tc.location(), tc.source()));\n+\n+            if (sol.size() == 0) {\n+                String msg = \"Could not find any suitable production for label \" + kl.value();\n                 return Left.apply(Sets.newHashSet(KEMException.innerParserError(msg, kl)));\n-            } else if (prods.size() == 1)\n-                return super.apply(TermCons.apply(items, prods.iterator().next(), tc.location(), tc.source()));\n-            else {\n-                // instantiate all labels found and let the type checker filter them out\n-                Set<Term> tcs = new HashSet<>();\n-                for (Production prd : prods)\n-                    tcs.add(TermCons.apply(items, prd, tc.location(), tc.source()));\n-                return super.apply(Ambiguity.apply(tcs, tc.location(), tc.source()));\n-            }\n+            } else if (sol.size() == 1) {\n+                return super.apply(sol.iterator().next());\n+            } else\n+                return super.apply(Ambiguity.apply(sol, tc.location(), tc.source()));\n         }\n         return super.apply(tc);\n     }\n \n     /**  Recurse under #KList and flatten all the terms */\n     private static PStack<Term> flattenKList(Term t) {\n         if (t instanceof Ambiguity) {\n-            Ambiguity amb = (Ambiguity) t;\n-            // prefer KList if they exist, otherwise return t\n-            List<PStack<Term>> klists = amb.items().stream()\n-                    .filter(x -> x instanceof TermCons\n-                            && ((TermCons) x).production().klabel().isDefined()\n-                            && ((TermCons) x).production().klabel().get().name().equals(\"#KList\"))\n-                    .map(KAppToTermConsVisitor::flattenKList)\n-                    .sorted((o1, o2) -> o2.size() - o1.size()).collect(Collectors.toList());\n-\n-            // expecting the first ambiguity branch to have the highest amount of elements\n-            assert klists.size() <= 1 || klists.get(0).size() != klists.get(1).size():\n-                    KAppToTermConsVisitor.class + \":\" + \" unexpected ambiguity pattern found under KApp \" + amb;\n-            if (klists.size() != 0)\n-                return klists.get(0);\n+            assert false : KAppToTermConsVisitor.class + \" expected all ambiguities to already be pushed to the top:\\n\" +\n+                    \"   Source: \" + ((Ambiguity) t).items().iterator().next().source().orElse(null) + \"\\n\" +\n+                    \"   Location: \" + ((Ambiguity) t).items().iterator().next().location().orElse(null);\n         } else if (t instanceof TermCons) {\n             TermCons tc = (TermCons) t;\n-            if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KList\"))\n-                return flattenKList(tc.items().get(1)).plusAll(flattenKList(tc.items().get(0)));\n-            else if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#EmptyKList\"))\n+            if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.KLIST))\n+                return flattenKList(tc.get(0)).plusAll(flattenKList(tc.get(1)));\n+            else if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.EMPTYKLIST))\n                 return ConsPStack.empty();\n         }\n         return ConsPStack.singleton(t);\n     }\n+\n+    // push ambiguities top so we can get easy access to KList\n+    private static class PushTopAmbiguityUp2 extends SafeTransformer {\n+        @Override\n+        public Term apply(TermCons tc) {\n+            if (tc.production().klabel().isDefined() && tc.production().klabel().get().head().equals(KLabels.KLIST)) {\n+                Term v0 = super.apply(tc.get(0));\n+                Term v1 = super.apply(tc.get(1));\n+                Set<Term> t0 = v0 instanceof Ambiguity ? ((Ambiguity) v0).items() : Sets.newHashSet(v0);\n+                Set<Term> t1 = v1 instanceof Ambiguity ? ((Ambiguity) v1).items() : Sets.newHashSet(v1);\n+                Set<Term> rez = Sets.newHashSet();\n+                for (Term t00 : t0)\n+                    for (Term t11 : t1)\n+                        rez.add(TermCons.apply(ConsPStack.singleton(t00).plus(t11), tc.production(), tc.location(), tc.source()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab3add6197841f21cd2447a77f7f3c076808767d"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NDU2Nw==", "bodyText": "Pretty sure this is reversed too", "url": "https://github.com/kframework/k/pull/1106#discussion_r383864567", "createdAt": "2020-02-25T13:03:29Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -43,57 +51,68 @@ public KAppToTermConsVisitor(Module mod) {\n     @Override\n     public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n         assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n-        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n-            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))\n-                // TODO: maybe return a hidden warning?\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.KAPP)) {\n+            if (!(tc.get(0) instanceof Constant) || !((Constant) tc.get(0)).production().sort().equals(Sorts.KLabel()))\n+                // TODO: remove check once the java and ocaml backends are no longer supported.\n                 return super.apply(tc); // don't do anything if the label is not a token KLabel (in case of variable or casted variable)\n-            Constant kl = (Constant) tc.items().get(1);\n-            PStack<Term> items = flattenKList(tc.items().get(0));\n+            Constant kl = (Constant) tc.get(0);\n             String klvalue = kl.value();\n             try { klvalue = StringUtil.unescapeKoreKLabel(kl.value()); } catch (IllegalArgumentException e) { /* ignore */ } // if possible, unescape\n             Set<Production> prods = mutable(mod.productionsFor().get(KLabel(klvalue))\n-                    .getOrElse(Set$.MODULE$::emptyInstance)\n-                    .filter(x -> ((Production) x).arity() == items.size()).toSet());\n-            if (prods.size() == 0) {\n-                String msg = \"Could not find any production with arity \" + items.size() + \" for label \" + kl.value();\n+                    .getOrElse(Set$.MODULE$::emptyInstance).toSet());\n+            Set<Term> sol = new HashSet<>();\n+            Term t = new PushTopAmbiguityUp2().apply(tc.get(1));\n+            Stream<Term> uppedAmb = t instanceof Ambiguity ? ((Ambiguity) t).items().stream() : Lists.newArrayList(t).stream();\n+            Map<Integer, List<PStack<Term>>> flattKLists = uppedAmb\n+                    .map(KAppToTermConsVisitor::flattenKList)\n+                    .collect(Collectors.groupingBy(PStack::size));\n+            for (Production prd : prods)\n+                for (PStack<Term> terms : flattKLists.getOrDefault(prd.arity(), Lists.newArrayList()))\n+                    sol.add(TermCons.apply(terms, prd, tc.location(), tc.source()));\n+\n+            if (sol.size() == 0) {\n+                String msg = \"Could not find any suitable production for label \" + kl.value();\n                 return Left.apply(Sets.newHashSet(KEMException.innerParserError(msg, kl)));\n-            } else if (prods.size() == 1)\n-                return super.apply(TermCons.apply(items, prods.iterator().next(), tc.location(), tc.source()));\n-            else {\n-                // instantiate all labels found and let the type checker filter them out\n-                Set<Term> tcs = new HashSet<>();\n-                for (Production prd : prods)\n-                    tcs.add(TermCons.apply(items, prd, tc.location(), tc.source()));\n-                return super.apply(Ambiguity.apply(tcs, tc.location(), tc.source()));\n-            }\n+            } else if (sol.size() == 1) {\n+                return super.apply(sol.iterator().next());\n+            } else\n+                return super.apply(Ambiguity.apply(sol, tc.location(), tc.source()));\n         }\n         return super.apply(tc);\n     }\n \n     /**  Recurse under #KList and flatten all the terms */\n     private static PStack<Term> flattenKList(Term t) {\n         if (t instanceof Ambiguity) {\n-            Ambiguity amb = (Ambiguity) t;\n-            // prefer KList if they exist, otherwise return t\n-            List<PStack<Term>> klists = amb.items().stream()\n-                    .filter(x -> x instanceof TermCons\n-                            && ((TermCons) x).production().klabel().isDefined()\n-                            && ((TermCons) x).production().klabel().get().name().equals(\"#KList\"))\n-                    .map(KAppToTermConsVisitor::flattenKList)\n-                    .sorted((o1, o2) -> o2.size() - o1.size()).collect(Collectors.toList());\n-\n-            // expecting the first ambiguity branch to have the highest amount of elements\n-            assert klists.size() <= 1 || klists.get(0).size() != klists.get(1).size():\n-                    KAppToTermConsVisitor.class + \":\" + \" unexpected ambiguity pattern found under KApp \" + amb;\n-            if (klists.size() != 0)\n-                return klists.get(0);\n+            assert false : KAppToTermConsVisitor.class + \" expected all ambiguities to already be pushed to the top:\\n\" +\n+                    \"   Source: \" + ((Ambiguity) t).items().iterator().next().source().orElse(null) + \"\\n\" +\n+                    \"   Location: \" + ((Ambiguity) t).items().iterator().next().location().orElse(null);\n         } else if (t instanceof TermCons) {\n             TermCons tc = (TermCons) t;\n-            if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KList\"))\n-                return flattenKList(tc.items().get(1)).plusAll(flattenKList(tc.items().get(0)));\n-            else if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#EmptyKList\"))\n+            if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.KLIST))\n+                return flattenKList(tc.get(0)).plusAll(flattenKList(tc.get(1)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab3add6197841f21cd2447a77f7f3c076808767d"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzYxNzQy", "url": "https://github.com/kframework/k/pull/1106#pullrequestreview-364361742", "createdAt": "2020-02-25T18:50:16Z", "commit": {"oid": "ab3add6197841f21cd2447a77f7f3c076808767d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MDoxNlrOFuQ8wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MDoxNlrOFuQ8wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1NjUxMg==", "bodyText": "Test 1", "url": "https://github.com/kframework/k/pull/1106#discussion_r384056512", "createdAt": "2020-02-25T18:50:16Z", "author": {"login": "radumereuta"}, "path": "kernel/src/test/java/org/kframework/parser/concrete2kore/RuleGrammarTest.java", "diffHunk": "@@ -472,4 +474,35 @@ public void testLayout() {\n         parseProgram(\"0 (; some text ;) + 3\", customLayout, \"Int\", 0, false);\n         parseProgram(\"0 + 3 // some text\"   , customLayout, \"Int\", 0, true);\n     }\n+\n+    // test KAppToTermConsVisitor for issue #985\n+    @Test\n+    public void test25() {\n+        String def = \"\" +\n+                \"module TEST\\n\" +\n+                \"  syntax E ::= \\\"a\\\"         [klabel(elma), symbol]\\n\" +\n+                \"  syntax Lst ::= E \\\",\\\" Lst [klabel(constr), symbol]\\n\" +\n+                \"  syntax Lst2 ::= E \\\",\\\" Lst2 [klabel(constr), symbol]\\n\" +\n+                \"                | Lst \\n\" +\n+                \"endmodule\";\n+        parseRule(\"constr(I, L) => L\", def, 0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab3add6197841f21cd2447a77f7f3c076808767d"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MzYxODQx", "url": "https://github.com/kframework/k/pull/1106#pullrequestreview-364361841", "createdAt": "2020-02-25T18:50:26Z", "commit": {"oid": "ab3add6197841f21cd2447a77f7f3c076808767d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MDoyNlrOFuQ9Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxODo1MDoyNlrOFuQ9Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1NjU5OQ==", "bodyText": "Test 2", "url": "https://github.com/kframework/k/pull/1106#discussion_r384056599", "createdAt": "2020-02-25T18:50:26Z", "author": {"login": "radumereuta"}, "path": "kernel/src/test/java/org/kframework/parser/concrete2kore/RuleGrammarTest.java", "diffHunk": "@@ -472,4 +474,35 @@ public void testLayout() {\n         parseProgram(\"0 (; some text ;) + 3\", customLayout, \"Int\", 0, false);\n         parseProgram(\"0 + 3 // some text\"   , customLayout, \"Int\", 0, true);\n     }\n+\n+    // test KAppToTermConsVisitor for issue #985\n+    @Test\n+    public void test25() {\n+        String def = \"\" +\n+                \"module TEST\\n\" +\n+                \"  syntax E ::= \\\"a\\\"         [klabel(elma), symbol]\\n\" +\n+                \"  syntax Lst ::= E \\\",\\\" Lst [klabel(constr), symbol]\\n\" +\n+                \"  syntax Lst2 ::= E \\\",\\\" Lst2 [klabel(constr), symbol]\\n\" +\n+                \"                | Lst \\n\" +\n+                \"endmodule\";\n+        parseRule(\"constr(I, L) => L\", def, 0,\n+                KApply(KLabel(\"#ruleNoConditions\"),KApply(KLabel(\"#KRewrite\"),\n+                        KApply(KLabel(\"constr\"),\n+                                KApply(KLabel(\"#SemanticCastToE\"), KToken(\"I\",Sort(\"#KVariable\"))),\n+                                KApply(KLabel(\"#SemanticCastToLst2\"), KToken(\"L\",Sort(\"#KVariable\")))),\n+                        KApply(KLabel(\"#SemanticCastToLst2\"), KToken(\"L\",Sort(\"#KVariable\")))\n+                )));\n+        parseRule(\"`constr`(I, (a, L)) => L\", def, 0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab3add6197841f21cd2447a77f7f3c076808767d"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "002bddc157fa6c926f1e52f8959d665256a18176", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/002bddc157fa6c926f1e52f8959d665256a18176", "committedDate": "2020-02-25T20:13:06Z", "message": "Fix reverse order and extend test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f94a92bd8a0d7fbae8acddb1b2363376408fb388", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/f94a92bd8a0d7fbae8acddb1b2363376408fb388", "committedDate": "2020-02-25T20:13:23Z", "message": "Merge branch 'master' into kapp2termcons"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ca19af785796ebf8700679a8db12e876d5e100e", "author": {"user": {"login": "radumereuta", "name": "Radu Mereuta"}}, "url": "https://github.com/kframework/k/commit/4ca19af785796ebf8700679a8db12e876d5e100e", "committedDate": "2020-02-25T20:59:26Z", "message": "Merge branch 'master' into kapp2termcons"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTU4OTMz", "url": "https://github.com/kframework/k/pull/1106#pullrequestreview-365158933", "createdAt": "2020-02-26T18:59:07Z", "commit": {"oid": "4ca19af785796ebf8700679a8db12e876d5e100e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2511, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}