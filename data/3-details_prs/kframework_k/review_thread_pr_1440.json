{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxMzU5Mzkz", "number": 1440, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDowNToxMlrOEPqSJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDowNzo1M1rOEPqVLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODU2ODcxOnYy", "diffSide": "RIGHT", "path": "k-distribution/include/kframework/builtin/ffi.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDowNToxMlrOGzfspw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDowNTozNFrOGzftRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0OTg5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```k\n          \n          \n            \n                             | \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]\n          \n          \n            \n            ```\n          \n          \n            \n            ```k\n          \n          \n            \n              syntax Bytes ::= \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]", "url": "https://github.com/kframework/k/pull/1440#discussion_r456649895", "createdAt": "2020-07-17T20:05:12Z", "author": {"login": "ehildenb"}, "path": "k-distribution/include/kframework/builtin/ffi.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+permalink: ffi.html\n+copyright: Copyright (c) 2019-2020 K Team. All Rights Reserved.\n+---\n+\n+K Foreign Function Interface\n+============================\n+\n+The K Foreign Function Interface (FFI) module provides a way to call native\n+functions directly from a K semantics using the C ABI. It also provides\n+utilities for allocating and deallocating byte buffers with static addresses\n+that are suitable for being passed to native code.\n+\n+It is built off of the underlying libffi library\n+(https://sourceware.org/libffi/) and is subject to some of the same\n+limitations as that library. Bear in mind, because this library exposes\n+a number of unsafe C APIs directly, misuse of the library is likely to lead\n+to memory corruption in your interpreter and can cause segmentation faults or\n+corrupted term representations that lead to undefined behavior at runtime.\n+\n+```k\n+require \"domains.k\"\n+\n+module FFI-SYNTAX\n+  imports LIST\n+```\n+\n+The FFIType sort is used to declare the native C ABI types of operands passed\n+to the `#ffiCall` function. These types roughly correspond to the types \n+declared in `ffi.h` by libffi.\n+\n+```k\n+  syntax FFIType ::= \"#void\" [klabel(#void), symbol]\n+                  | \"#uint8\" [klabel(#uint8), symbol]\n+                  | \"#sint8\" [klabel(#sint8), symbol]\n+                  | \"#uint16\" [klabel(#uint16), symbol]\n+                  | \"#sint16\" [klabel(#sint16), symbol]\n+                  | \"#uint32\" [klabel(#uint32), symbol]\n+                  | \"#sint32\" [klabel(#sint32), symbol]\n+                  | \"#uint64\" [klabel(#uint64), symbol]\n+                  | \"#sint64\" [klabel(#sint64), symbol]\n+                  | \"#float\" [klabel(#float), symbol]\n+                  | \"#double\" [klabel(#double), symbol]\n+                  | \"#uchar\" [klabel(#uchar), symbol]\n+                  | \"#schar\" [klabel(#schar), symbol]\n+                  | \"#ushort\" [klabel(#ushort), symbol]\n+                  | \"#sshort\" [klabel(#sshort), symbol]\n+                  | \"#uint\" [klabel(#uint), symbol]\n+                  | \"#sint\" [klabel(#sint), symbol]\n+                  | \"#ulong\" [klabel(#ulong), symbol]\n+                  | \"#slong\" [klabel(#slong), symbol]\n+                  | \"#longdouble\" [klabel(#longdouble), symbol]\n+                  | \"#struct\" \"(\" List \")\" [klabel(#struct), symbol]\n+endmodule\n+\n+module FFI\n+  imports FFI-SYNTAX\n+  imports BYTES\n+  imports STRING\n+\n+```\n+\n+FFI Calls\n+---------\n+\n+The `#ffiCall` functions are designed to call a native C ABI function and \n+return a native result. They come in three variants:\n+\n+### Non-variadic\n+\n+In the first variant, `#ffiCall(Address, Args, ArgTypes, ReturnType)` takes\n+an integer address of a function (which can be obtained from\n+`#functionAddress`), a `List` of `Bytes` containing the arguments of the\n+function, a `List` of `FFIType`s containing the types of the parameters of the\n+function, and an `FFIType` containing the return type of the function, and \n+returns the return value of the function as a `Bytes`.\n+\n+```k\n+  syntax Bytes ::= \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call)]\n+```\n+\n+### Variadic\n+\n+In the second variant,\n+`#ffiCall(Address, Args, FixedTypes, VariadicTypes, ReturnType` takes an\n+integer address of a function, a `List` of `Bytes` containing the arguments\n+of the call, a `List` of `FFIType`s containing the types of the fixed\n+parameters of the function, a `List` of `FFIType`s containing the types of the\n+variadic parameters of the function, and an `FFIType` containing the return\n+type of the function, and returns the return value of the function as a\n+`Bytes`.\n+\n+```k\n+                 | \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MDA1Mw==", "bodyText": "Otherwise it's confusing and you're not able to copy-paste this code block around to other locatiions.", "url": "https://github.com/kframework/k/pull/1440#discussion_r456650053", "createdAt": "2020-07-17T20:05:34Z", "author": {"login": "ehildenb"}, "path": "k-distribution/include/kframework/builtin/ffi.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+permalink: ffi.html\n+copyright: Copyright (c) 2019-2020 K Team. All Rights Reserved.\n+---\n+\n+K Foreign Function Interface\n+============================\n+\n+The K Foreign Function Interface (FFI) module provides a way to call native\n+functions directly from a K semantics using the C ABI. It also provides\n+utilities for allocating and deallocating byte buffers with static addresses\n+that are suitable for being passed to native code.\n+\n+It is built off of the underlying libffi library\n+(https://sourceware.org/libffi/) and is subject to some of the same\n+limitations as that library. Bear in mind, because this library exposes\n+a number of unsafe C APIs directly, misuse of the library is likely to lead\n+to memory corruption in your interpreter and can cause segmentation faults or\n+corrupted term representations that lead to undefined behavior at runtime.\n+\n+```k\n+require \"domains.k\"\n+\n+module FFI-SYNTAX\n+  imports LIST\n+```\n+\n+The FFIType sort is used to declare the native C ABI types of operands passed\n+to the `#ffiCall` function. These types roughly correspond to the types \n+declared in `ffi.h` by libffi.\n+\n+```k\n+  syntax FFIType ::= \"#void\" [klabel(#void), symbol]\n+                  | \"#uint8\" [klabel(#uint8), symbol]\n+                  | \"#sint8\" [klabel(#sint8), symbol]\n+                  | \"#uint16\" [klabel(#uint16), symbol]\n+                  | \"#sint16\" [klabel(#sint16), symbol]\n+                  | \"#uint32\" [klabel(#uint32), symbol]\n+                  | \"#sint32\" [klabel(#sint32), symbol]\n+                  | \"#uint64\" [klabel(#uint64), symbol]\n+                  | \"#sint64\" [klabel(#sint64), symbol]\n+                  | \"#float\" [klabel(#float), symbol]\n+                  | \"#double\" [klabel(#double), symbol]\n+                  | \"#uchar\" [klabel(#uchar), symbol]\n+                  | \"#schar\" [klabel(#schar), symbol]\n+                  | \"#ushort\" [klabel(#ushort), symbol]\n+                  | \"#sshort\" [klabel(#sshort), symbol]\n+                  | \"#uint\" [klabel(#uint), symbol]\n+                  | \"#sint\" [klabel(#sint), symbol]\n+                  | \"#ulong\" [klabel(#ulong), symbol]\n+                  | \"#slong\" [klabel(#slong), symbol]\n+                  | \"#longdouble\" [klabel(#longdouble), symbol]\n+                  | \"#struct\" \"(\" List \")\" [klabel(#struct), symbol]\n+endmodule\n+\n+module FFI\n+  imports FFI-SYNTAX\n+  imports BYTES\n+  imports STRING\n+\n+```\n+\n+FFI Calls\n+---------\n+\n+The `#ffiCall` functions are designed to call a native C ABI function and \n+return a native result. They come in three variants:\n+\n+### Non-variadic\n+\n+In the first variant, `#ffiCall(Address, Args, ArgTypes, ReturnType)` takes\n+an integer address of a function (which can be obtained from\n+`#functionAddress`), a `List` of `Bytes` containing the arguments of the\n+function, a `List` of `FFIType`s containing the types of the parameters of the\n+function, and an `FFIType` containing the return type of the function, and \n+returns the return value of the function as a `Bytes`.\n+\n+```k\n+  syntax Bytes ::= \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call)]\n+```\n+\n+### Variadic\n+\n+In the second variant,\n+`#ffiCall(Address, Args, FixedTypes, VariadicTypes, ReturnType` takes an\n+integer address of a function, a `List` of `Bytes` containing the arguments\n+of the call, a `List` of `FFIType`s containing the types of the fixed\n+parameters of the function, a `List` of `FFIType`s containing the types of the\n+variadic parameters of the function, and an `FFIType` containing the return\n+type of the function, and returns the return value of the function as a\n+`Bytes`.\n+\n+```k\n+                 | \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0OTg5NQ=="}, "originalCommit": {"oid": "2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODU3MDQzOnYy", "diffSide": "RIGHT", "path": "k-distribution/include/kframework/builtin/ffi.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDowNTo1MFrOGzftsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDowNjozMlrOGzfu8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MDE2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                             | \"#ffiCall\" \"(\" Bool \",\" Int \",\" List \",\" List \",\" Int \",\" FFIType \")\" [function]\n          \n          \n            \n              syntax Bytes ::= \"#ffiCall\" \"(\" Bool \",\" Int \",\" List \",\" List \",\" Int \",\" FFIType \")\" [function]", "url": "https://github.com/kframework/k/pull/1440#discussion_r456650160", "createdAt": "2020-07-17T20:05:50Z", "author": {"login": "ehildenb"}, "path": "k-distribution/include/kframework/builtin/ffi.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+permalink: ffi.html\n+copyright: Copyright (c) 2019-2020 K Team. All Rights Reserved.\n+---\n+\n+K Foreign Function Interface\n+============================\n+\n+The K Foreign Function Interface (FFI) module provides a way to call native\n+functions directly from a K semantics using the C ABI. It also provides\n+utilities for allocating and deallocating byte buffers with static addresses\n+that are suitable for being passed to native code.\n+\n+It is built off of the underlying libffi library\n+(https://sourceware.org/libffi/) and is subject to some of the same\n+limitations as that library. Bear in mind, because this library exposes\n+a number of unsafe C APIs directly, misuse of the library is likely to lead\n+to memory corruption in your interpreter and can cause segmentation faults or\n+corrupted term representations that lead to undefined behavior at runtime.\n+\n+```k\n+require \"domains.k\"\n+\n+module FFI-SYNTAX\n+  imports LIST\n+```\n+\n+The FFIType sort is used to declare the native C ABI types of operands passed\n+to the `#ffiCall` function. These types roughly correspond to the types \n+declared in `ffi.h` by libffi.\n+\n+```k\n+  syntax FFIType ::= \"#void\" [klabel(#void), symbol]\n+                  | \"#uint8\" [klabel(#uint8), symbol]\n+                  | \"#sint8\" [klabel(#sint8), symbol]\n+                  | \"#uint16\" [klabel(#uint16), symbol]\n+                  | \"#sint16\" [klabel(#sint16), symbol]\n+                  | \"#uint32\" [klabel(#uint32), symbol]\n+                  | \"#sint32\" [klabel(#sint32), symbol]\n+                  | \"#uint64\" [klabel(#uint64), symbol]\n+                  | \"#sint64\" [klabel(#sint64), symbol]\n+                  | \"#float\" [klabel(#float), symbol]\n+                  | \"#double\" [klabel(#double), symbol]\n+                  | \"#uchar\" [klabel(#uchar), symbol]\n+                  | \"#schar\" [klabel(#schar), symbol]\n+                  | \"#ushort\" [klabel(#ushort), symbol]\n+                  | \"#sshort\" [klabel(#sshort), symbol]\n+                  | \"#uint\" [klabel(#uint), symbol]\n+                  | \"#sint\" [klabel(#sint), symbol]\n+                  | \"#ulong\" [klabel(#ulong), symbol]\n+                  | \"#slong\" [klabel(#slong), symbol]\n+                  | \"#longdouble\" [klabel(#longdouble), symbol]\n+                  | \"#struct\" \"(\" List \")\" [klabel(#struct), symbol]\n+endmodule\n+\n+module FFI\n+  imports FFI-SYNTAX\n+  imports BYTES\n+  imports STRING\n+\n+```\n+\n+FFI Calls\n+---------\n+\n+The `#ffiCall` functions are designed to call a native C ABI function and \n+return a native result. They come in three variants:\n+\n+### Non-variadic\n+\n+In the first variant, `#ffiCall(Address, Args, ArgTypes, ReturnType)` takes\n+an integer address of a function (which can be obtained from\n+`#functionAddress`), a `List` of `Bytes` containing the arguments of the\n+function, a `List` of `FFIType`s containing the types of the parameters of the\n+function, and an `FFIType` containing the return type of the function, and \n+returns the return value of the function as a `Bytes`.\n+\n+```k\n+  syntax Bytes ::= \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call)]\n+```\n+\n+### Variadic\n+\n+In the second variant,\n+`#ffiCall(Address, Args, FixedTypes, VariadicTypes, ReturnType` takes an\n+integer address of a function, a `List` of `Bytes` containing the arguments\n+of the call, a `List` of `FFIType`s containing the types of the fixed\n+parameters of the function, a `List` of `FFIType`s containing the types of the\n+variadic parameters of the function, and an `FFIType` containing the return\n+type of the function, and returns the return value of the function as a\n+`Bytes`.\n+\n+```k\n+                 | \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]\n+```\n+\n+### Generic\n+\n+In the third variant,\n+`#ffiCall(IsVariadic, Address, Args, ArgTypes, NFixed, ReturnType` takes\n+a boolean indicating whether the function is variadic or not, an integer\n+address of a function, a `List` of `Bytes` containing the arguments of the\n+call, a `List` of `FFIType`s containing the parameter typess of the call\n+followed by the types of the variadic arguments of the call, if any, an `Int`\n+containing how many of the arguments of the call are fixed or not, and an\n+`FFIType` containing the return type of the function, and returns the return\n+value of the function as a `Bytes`.\n+\n+```k\n+                 | \"#ffiCall\" \"(\" Bool \",\" Int \",\" List \",\" List \",\" Int \",\" FFIType \")\" [function]\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MDQ4MA==", "bodyText": "Another option would be to just declare all three together, with the documentation above all together.", "url": "https://github.com/kframework/k/pull/1440#discussion_r456650480", "createdAt": "2020-07-17T20:06:32Z", "author": {"login": "ehildenb"}, "path": "k-distribution/include/kframework/builtin/ffi.md", "diffHunk": "@@ -0,0 +1,177 @@\n+---\n+permalink: ffi.html\n+copyright: Copyright (c) 2019-2020 K Team. All Rights Reserved.\n+---\n+\n+K Foreign Function Interface\n+============================\n+\n+The K Foreign Function Interface (FFI) module provides a way to call native\n+functions directly from a K semantics using the C ABI. It also provides\n+utilities for allocating and deallocating byte buffers with static addresses\n+that are suitable for being passed to native code.\n+\n+It is built off of the underlying libffi library\n+(https://sourceware.org/libffi/) and is subject to some of the same\n+limitations as that library. Bear in mind, because this library exposes\n+a number of unsafe C APIs directly, misuse of the library is likely to lead\n+to memory corruption in your interpreter and can cause segmentation faults or\n+corrupted term representations that lead to undefined behavior at runtime.\n+\n+```k\n+require \"domains.k\"\n+\n+module FFI-SYNTAX\n+  imports LIST\n+```\n+\n+The FFIType sort is used to declare the native C ABI types of operands passed\n+to the `#ffiCall` function. These types roughly correspond to the types \n+declared in `ffi.h` by libffi.\n+\n+```k\n+  syntax FFIType ::= \"#void\" [klabel(#void), symbol]\n+                  | \"#uint8\" [klabel(#uint8), symbol]\n+                  | \"#sint8\" [klabel(#sint8), symbol]\n+                  | \"#uint16\" [klabel(#uint16), symbol]\n+                  | \"#sint16\" [klabel(#sint16), symbol]\n+                  | \"#uint32\" [klabel(#uint32), symbol]\n+                  | \"#sint32\" [klabel(#sint32), symbol]\n+                  | \"#uint64\" [klabel(#uint64), symbol]\n+                  | \"#sint64\" [klabel(#sint64), symbol]\n+                  | \"#float\" [klabel(#float), symbol]\n+                  | \"#double\" [klabel(#double), symbol]\n+                  | \"#uchar\" [klabel(#uchar), symbol]\n+                  | \"#schar\" [klabel(#schar), symbol]\n+                  | \"#ushort\" [klabel(#ushort), symbol]\n+                  | \"#sshort\" [klabel(#sshort), symbol]\n+                  | \"#uint\" [klabel(#uint), symbol]\n+                  | \"#sint\" [klabel(#sint), symbol]\n+                  | \"#ulong\" [klabel(#ulong), symbol]\n+                  | \"#slong\" [klabel(#slong), symbol]\n+                  | \"#longdouble\" [klabel(#longdouble), symbol]\n+                  | \"#struct\" \"(\" List \")\" [klabel(#struct), symbol]\n+endmodule\n+\n+module FFI\n+  imports FFI-SYNTAX\n+  imports BYTES\n+  imports STRING\n+\n+```\n+\n+FFI Calls\n+---------\n+\n+The `#ffiCall` functions are designed to call a native C ABI function and \n+return a native result. They come in three variants:\n+\n+### Non-variadic\n+\n+In the first variant, `#ffiCall(Address, Args, ArgTypes, ReturnType)` takes\n+an integer address of a function (which can be obtained from\n+`#functionAddress`), a `List` of `Bytes` containing the arguments of the\n+function, a `List` of `FFIType`s containing the types of the parameters of the\n+function, and an `FFIType` containing the return type of the function, and \n+returns the return value of the function as a `Bytes`.\n+\n+```k\n+  syntax Bytes ::= \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call)]\n+```\n+\n+### Variadic\n+\n+In the second variant,\n+`#ffiCall(Address, Args, FixedTypes, VariadicTypes, ReturnType` takes an\n+integer address of a function, a `List` of `Bytes` containing the arguments\n+of the call, a `List` of `FFIType`s containing the types of the fixed\n+parameters of the function, a `List` of `FFIType`s containing the types of the\n+variadic parameters of the function, and an `FFIType` containing the return\n+type of the function, and returns the return value of the function as a\n+`Bytes`.\n+\n+```k\n+                 | \"#ffiCall\" \"(\" Int \",\" List \",\" List \",\" List \",\" FFIType \")\" [function, hook(FFI.call_variadic)]\n+```\n+\n+### Generic\n+\n+In the third variant,\n+`#ffiCall(IsVariadic, Address, Args, ArgTypes, NFixed, ReturnType` takes\n+a boolean indicating whether the function is variadic or not, an integer\n+address of a function, a `List` of `Bytes` containing the arguments of the\n+call, a `List` of `FFIType`s containing the parameter typess of the call\n+followed by the types of the variadic arguments of the call, if any, an `Int`\n+containing how many of the arguments of the call are fixed or not, and an\n+`FFIType` containing the return type of the function, and returns the return\n+value of the function as a `Bytes`.\n+\n+```k\n+                 | \"#ffiCall\" \"(\" Bool \",\" Int \",\" List \",\" List \",\" Int \",\" FFIType \")\" [function]\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MDE2MA=="}, "originalCommit": {"oid": "2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODU3NjQ2OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/parser/ParserUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDowNzo1M1rOGzfxNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDowNzo1M1rOGzfxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1MTA2MA==", "bodyText": "This looks like a typo in the name of this variable allLookupDirectoris => allLookupDirectories\nWhat is this change? The 0 => 1.", "url": "https://github.com/kframework/k/pull/1440#discussion_r456651060", "createdAt": "2020-07-17T20:07:53Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/parser/ParserUtils.java", "diffHunk": "@@ -155,8 +155,15 @@ else if (di instanceof Require) {\n \n                 String definitionFileName = ((Require) di).getValue();\n \n+                if (definitionFileName.equals(\"ffi.k\")) {\n+                    kem.registerCompilerWarning(ExceptionType.FUTURE_ERROR,\n+                        \"Requiring a K file in the K builtin directory via \" +\n+                        \"a deprecated filename. Please replace \\\"\" + definitionFileName +\n+                        \"\\\" with \\\"\" + definitionFileName.substring(0, definitionFileName.length() - 2) + \".md\\\".\", di);\n+                }\n+\n                 ArrayList<File> allLookupDirectoris = new ArrayList<>(lookupDirectories);\n-                allLookupDirectoris.add(0, currentDirectory);\n+                allLookupDirectoris.add(1, currentDirectory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2cd6dc6d9da9ca8cddda547d6d7590e8bc31d7c0"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2973, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}