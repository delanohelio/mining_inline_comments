{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3MjI2OTEw", "number": 1413, "title": "map-symbolic-tests: update assignment specs to have an explicit RHS", "bodyText": "This is the first step toward running the map-symbolic-tests for both java and haskell backends.\nThe existing tests rely on the kprove failure output (even for passed tests), which the two backends do not agree on.  So, it is better to make the test specs to have an explicit RHS, so that the *.out file of passed tests could be simply #True.  For failed tests, the *.out file will still have the failure output.  This way, we can easily identify which tests are expected to pass or fail.  This also allows us later to reorg this test directory to run the haskell backend as well, and have different *.out files for different failed tests.\nThe explicit RHS of all assignment specs is manually written carefully, and I confirmed that the haskell backend passes all but two (assignment-{7,11}-spec), where the two are failed because the haskell backend failed to infer Z =/=K X from both Z in_keys(MAP) and notBool X in_keys(MAP).   The java backend, unfortunately, failed more tests because of its unsound behaviors and certain unification bugs, but I don't think we need to take care of them now, because we will eventually switch to the haskell backend.\nThe diff is quite big, but all the spec files (and *out files) are auto-generated by test-gen.sh, so the only meaningful file to review is: https://github.com/kframework/k/compare/map-symbolic-tests?expand=1#diff-25df3c38373f6337ee94dc799e6f7f42\nBut still the diff is big, and I'd like to have a separate PR for each test group (inkeys, lookup, and remove).  But please let me know if you want to see the changes of all the four test groups in a single PR.", "createdAt": "2020-07-10T05:07:43Z", "url": "https://github.com/kframework/k/pull/1413", "merged": true, "mergeCommit": {"oid": "71181e3719b72a71188e76de8689780ee4143fcd"}, "closed": true, "closedAt": "2020-07-10T20:50:54Z", "author": {"login": "daejunpark"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABczcD6TAH2gAyNDQ3MjI2OTEwOjIxYTZjMDVmNWFiZGM3YTViMTFiYjI2NTcwNzU5NDNkMTRiNjFlYmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczog5IgFqTQ0NjY0MDgxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "21a6c05f5abdc7a5b11bb2657075943d14b61ebb", "author": {"user": {"login": "daejunpark", "name": "Daejun Park"}}, "url": "https://github.com/kframework/k/commit/21a6c05f5abdc7a5b11bb2657075943d14b61ebb", "committedDate": "2020-07-10T04:37:50Z", "message": "align the commented out rule"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca73a1701a0f98d929b11d1492abf671d4ae6720", "author": {"user": {"login": "daejunpark", "name": "Daejun Park"}}, "url": "https://github.com/kframework/k/commit/ca73a1701a0f98d929b11d1492abf671d4ae6720", "committedDate": "2020-07-10T04:37:50Z", "message": "assignment: add explicit RHS of spec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d38381c8013dd644f62030dadcda0afec1c33fd", "author": {"user": {"login": "daejunpark", "name": "Daejun Park"}}, "url": "https://github.com/kframework/k/commit/7d38381c8013dd644f62030dadcda0afec1c33fd", "committedDate": "2020-07-10T04:37:50Z", "message": "gen-test assignment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTI2MTYx", "url": "https://github.com/kframework/k/pull/1413#pullrequestreview-446126161", "createdAt": "2020-07-10T05:14:53Z", "commit": {"oid": "7d38381c8013dd644f62030dadcda0afec1c33fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNToxNDo1NFrOGvqGPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNToxNDo1NFrOGvqGPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyNTk4Mg==", "bodyText": "I'd like to have the RHS of this spec to be #False, but the java backend couldn't parse it.  .Map should be not bad, because it is unlikely to be proved accidentally.", "url": "https://github.com/kframework/k/pull/1413#discussion_r452625982", "createdAt": "2020-07-10T05:14:54Z", "author": {"login": "daejunpark"}, "path": "k-distribution/tests/regression-new/map-symbolic-tests/assignment", "diffHunk": "@@ -1,31 +1,31 @@\n-rule <k> assignment ( .Map [ x <- 3 ] ) => . </k>\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k>\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Y in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool notBool Y in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool notBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool notBool Y in_keys(MAP) andBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z  ==K Y andBool Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool Z  ==K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X andBool Y in_keys(MAP) andBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X andBool notBool Y in_keys(MAP) andBool notBool Z in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X andBool X in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X andBool notBool X in_keys(MAP)\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Y ==K X andBool Z =/=K Y andBool Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z  ==K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z =/=K X\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z  ==K Y\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z =/=K Y\n-rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => . </k> requires Z =/=K Y andBool Z =/=K X\n-rule <k> assignment ( (X:MyId |-> 3 1 |-> 4) [ 0 <- 5 ] ) => . </k> requires X =/=K 1\n-rule <k> assignment ( (X:MyId |-> 4) [ X <- 3 ] ) => . </k>\n-rule <k> assignment ( (X:MyId |-> 3 y |-> 4) [ x <- 5 ] ) => . </k> requires X =/=K y\n-rule <k> assignment ( (       X:MyId   |-> BAL_TO:Int       Y:MyId   |-> BAL_FROM:Int MAP:Map ) [       Y   <- BAL_FROM -Int 30 ] ) => . </k> requires       X   =/=K       Y\n-rule <k> assignment ( ( foo ( X:MyId ) |-> BAL_TO:Int foo ( Y:MyId ) |-> BAL_FROM:Int MAP:Map ) [ foo ( Y ) <- BAL_FROM -Int 30 ] ) => . </k> requires       X   =/=K       Y\n-rule <k> assignment ( ( foo ( X:MyId ) |-> BAL_TO:Int foo ( Y:MyId ) |-> BAL_FROM:Int MAP:Map ) [ foo ( Y ) <- BAL_FROM -Int 30 ] ) => . </k> requires foo ( X ) =/=K foo ( Y )\n+rule <k> assignment ( .Map [ x <- 3 ] ) => assignmentResult ( x |-> 3 )  </k>\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP  X |-> 1 ) [ Y <- 2 ] [ Z <- 3 ] )   </k>\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP [ Y <- 2 ]  X |-> 1 ) [ Z <- 3 ] )   </k> requires Y =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP [ Y <- 2 ]  X |-> 1 ) [ Z <- 3 ] )   </k> requires Y =/=K X andBool Y in_keys(MAP)\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP [ Y <- 2 ]  X |-> 1 ) [ Z <- 3 ] )   </k> requires Y =/=K X andBool notBool Y in_keys(MAP) // oracle: ( MAP Y |-> 2 X |-> 1 ) [ Z <- 3 ]\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP  X |-> 2 ) [ Z <- 3 ]            )   </k> requires Y ==K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Z <- 3 ]  X |-> 2              )   </k> requires Y ==K X andBool Z in_keys(MAP) // implies Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP  X |-> 2 ) [ Z <- 3 ]            )   </k> requires Y ==K X andBool notBool Z in_keys(MAP)\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult ( ( MAP [ Y <- 2 ]  X |-> 1 ) [ Z <- 3 ] )   </k> requires Y =/=K X andBool Z =/=K Y\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K Y andBool notBool Y in_keys(MAP) andBool Z in_keys(MAP) // implies Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 3 ]  X |-> 1              )   </k> requires Y =/=K X andBool Z  ==K Y andBool Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ]  X |-> 3              )   </k> requires Y =/=K X andBool Z =/=K Y andBool Z  ==K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X andBool Y in_keys(MAP) andBool Z in_keys(MAP)\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP [ Y <- 2 ] [ Z <- 3 ]  X |-> 1   )   </k> requires Y =/=K X andBool Z =/=K Y andBool Z =/=K X andBool notBool Y in_keys(MAP) andBool notBool Z in_keys(MAP)\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (   MAP  X |-> 3                         )   </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X\n+rule <k> assignment ( (MAP:Map X:MyId |-> 1) [ Y:MyId <- 2 ] [ Z:MyId <- 3 ] ) => assignmentResult (  .Map                                  )   </k> requires Y ==K X andBool Z  ==K Y andBool Z  ==K X andBool X in_keys(MAP) // unsatisfiable pre-condition", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d38381c8013dd644f62030dadcda0afec1c33fd"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTI5MDQx", "url": "https://github.com/kframework/k/pull/1413#pullrequestreview-446129041", "createdAt": "2020-07-10T05:25:20Z", "commit": {"oid": "7d38381c8013dd644f62030dadcda0afec1c33fd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNToyNToyMFrOGvqQNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNToyNToyMFrOGvqQNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyODUzMw==", "bodyText": "Note that I also found that this rule could lead to an infinite loop, even if we have the additional condition of K2 in_keys(MAP).  A counter example: M [ K1 <- _ ] [ K2 <- _ ] where M is a variable, and we have both K1 in_keys(M) and K2 in_keys(M).\n(It is possible to make it finite by having a custom in_keys rules, but its performance overhead could be problematic for a large map. So, such rules are better to be put in project-specific lemmas.)", "url": "https://github.com/kframework/k/pull/1413#discussion_r452628533", "createdAt": "2020-07-10T05:25:20Z", "author": {"login": "daejunpark"}, "path": "k-distribution/include/kframework/builtin/domains.k", "diffHunk": "@@ -190,9 +190,7 @@ module MAP-JAVA-SYMBOLIC [kast, symbolic]\n   rule ((K1 |-> V1) MAP) [ K2 <- V2 ] => (K1 |-> V1) (MAP [ K2 <- V2 ]) requires K1 =/=K K2\n \n   rule (MAP:Map [ K1 <- V1 ]) [ K2 <- V2 ] => MAP              [ K1 <- V2 ] requires K1  ==K K2\n-\n-  // potential infinite loop\n-  // rule (MAP:Map [ K1 <- V1 ]) [ K2 <- V2 ] => MAP [ K2 <- V2 ] [ K1 <- V1 ] requires K1 =/=K K2\n+//rule (MAP:Map [ K1 <- V1 ]) [ K2 <- V2 ] => MAP [ K2 <- V2 ] [ K1 <- V1 ] requires K1 =/=K K2 // potential infinite loop even if `K2 in_keys(MAP)`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d38381c8013dd644f62030dadcda0afec1c33fd"}, "originalPosition": 7}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4aec0366fb2ff20ae78040b37f279c9f1dff0fc", "author": {"user": {"login": "daejunpark", "name": "Daejun Park"}}, "url": "https://github.com/kframework/k/commit/e4aec0366fb2ff20ae78040b37f279c9f1dff0fc", "committedDate": "2020-07-10T06:14:45Z", "message": "update assignment-30-spec.k.out"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MjY2MDU5", "url": "https://github.com/kframework/k/pull/1413#pullrequestreview-446266059", "createdAt": "2020-07-10T09:40:35Z", "commit": {"oid": "e4aec0366fb2ff20ae78040b37f279c9f1dff0fc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NTM1NzQ4", "url": "https://github.com/kframework/k/pull/1413#pullrequestreview-446535748", "createdAt": "2020-07-10T16:27:01Z", "commit": {"oid": "e4aec0366fb2ff20ae78040b37f279c9f1dff0fc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "167adf8fbbba6079a21f7ee145d35854f35df79d", "author": {"user": {"login": "daejunpark", "name": "Daejun Park"}}, "url": "https://github.com/kframework/k/commit/167adf8fbbba6079a21f7ee145d35854f35df79d", "committedDate": "2020-07-10T19:03:52Z", "message": "Merge branch 'master' into map-symbolic-tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjQwODE5", "url": "https://github.com/kframework/k/pull/1413#pullrequestreview-446640819", "createdAt": "2020-07-10T19:08:21Z", "commit": {"oid": "167adf8fbbba6079a21f7ee145d35854f35df79d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2290, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}