{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMTkwNDU5", "number": 1476, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNjoxMDo0N1rOEUHONg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNjoxMDo0N1rOEUHONg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTI1MzAyOnYy", "diffSide": "RIGHT", "path": "k-distribution/include/kframework/builtin/domains.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNjoxMDo0N1rOG6OD_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNjoyMDo1NlrOG6OXxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDk4OA==", "bodyText": "What's going on here? Are we removing support for some class of floating point parses?", "url": "https://github.com/kframework/k/pull/1476#discussion_r463700988", "createdAt": "2020-07-31T16:10:47Z", "author": {"login": "ehildenb"}, "path": "k-distribution/include/kframework/builtin/domains.md", "diffHunk": "@@ -533,10 +1082,43 @@ module INT\n   syntax Int ::= randInt(Int) [function, hook(INT.rand)]\n   syntax K ::= srandInt(Int) [function, hook(INT.srand)]\n endmodule\n-\n+```\n+\n+IEEE 754 Floating-point Numbers\n+-------------------------------\n+\n+Provided here is the syntax of an implementation of arbitrary-precision\n+floating-point arithmetic in K based on a generalization of the IEEE 754\n+standard. This type is hooked to an implementation of floats provided by the \n+backend.\n+\n+The syntax of ordinary floating-point values in K consists of an optional sign\n+(+ or -) followed by an optional integer part, followed by a decimal point,\n+followed by an optional fractional part. Either the integer part or the \n+fractional part must be specified. The mantissa is followed by an optional\n+exponent part, which consists of an `e` or `E`, an optional sign (+ or -), \n+and an integer. The expoennt is followed by an optional suffix, which can be\n+either `f`, `F`, `d`, `D`, or `pNxM` where `N` and `M` are positive integers.\n+`p` and `x` can be either upper or lowercase.\n+\n+The value of a floating-point literal is computed as follows: First the\n+mantissa is read as a rational number. Then it is multiplied by 10 to the\n+power of the exponent, which is interpreted as an integer, and defaults to\n+zero if it is not present. Finally, it is rounded to the nearest possible\n+value in a floating-point type represented like an IEEE754 floating-point type,\n+with the number of bits of precision and exponent specified by the suffix.\n+A suffix of `f` or `f` represents the IEEE `binary32` format. A suffix of `d`\n+or `D`, or no suffix, represents the IEEE `binary64` format. A suffix of\n+`pNxM` (either upper or lowercase) specifies exactly `N` bits of precision and\n+`M` bits of exponent. The number of bits of precision is assumed to include\n+any optional `1` that precedes the IEEE 754 mantissa. In other words, `p24x8`\n+is equal to the IEEE `binary32` format, and `p53x11` is equal to the IEEE\n+`binary64` format.\n+\n+```k\n module FLOAT-SYNTAX\n   syntax Float [hook(FLOAT.Float)]\n-  syntax Float ::= r\"([\\\\+-]?[0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([eE][\\\\+-]?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]d+))?([fFdD]|([pP][0-9]+[xX][0-9]+))?\" [token, prec(1)]\n+  syntax Float ::= r\"([\\\\+-]?[0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([eE][\\\\+-]?[0-9]+)?([fFdD]|([pP][0-9]+[xX][0-9]+))?\" [token, prec(1)]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4e827c8b342462a38eb6964b1c2596de677f85f"}, "originalPosition": 1019}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNjA1NA==", "bodyText": "Removed here is the case when the exponent has a decimal point, which I'm quite certain was never actually working and should never have been part of this syntax.", "url": "https://github.com/kframework/k/pull/1476#discussion_r463706054", "createdAt": "2020-07-31T16:20:56Z", "author": {"login": "dwightguth"}, "path": "k-distribution/include/kframework/builtin/domains.md", "diffHunk": "@@ -533,10 +1082,43 @@ module INT\n   syntax Int ::= randInt(Int) [function, hook(INT.rand)]\n   syntax K ::= srandInt(Int) [function, hook(INT.srand)]\n endmodule\n-\n+```\n+\n+IEEE 754 Floating-point Numbers\n+-------------------------------\n+\n+Provided here is the syntax of an implementation of arbitrary-precision\n+floating-point arithmetic in K based on a generalization of the IEEE 754\n+standard. This type is hooked to an implementation of floats provided by the \n+backend.\n+\n+The syntax of ordinary floating-point values in K consists of an optional sign\n+(+ or -) followed by an optional integer part, followed by a decimal point,\n+followed by an optional fractional part. Either the integer part or the \n+fractional part must be specified. The mantissa is followed by an optional\n+exponent part, which consists of an `e` or `E`, an optional sign (+ or -), \n+and an integer. The expoennt is followed by an optional suffix, which can be\n+either `f`, `F`, `d`, `D`, or `pNxM` where `N` and `M` are positive integers.\n+`p` and `x` can be either upper or lowercase.\n+\n+The value of a floating-point literal is computed as follows: First the\n+mantissa is read as a rational number. Then it is multiplied by 10 to the\n+power of the exponent, which is interpreted as an integer, and defaults to\n+zero if it is not present. Finally, it is rounded to the nearest possible\n+value in a floating-point type represented like an IEEE754 floating-point type,\n+with the number of bits of precision and exponent specified by the suffix.\n+A suffix of `f` or `f` represents the IEEE `binary32` format. A suffix of `d`\n+or `D`, or no suffix, represents the IEEE `binary64` format. A suffix of\n+`pNxM` (either upper or lowercase) specifies exactly `N` bits of precision and\n+`M` bits of exponent. The number of bits of precision is assumed to include\n+any optional `1` that precedes the IEEE 754 mantissa. In other words, `p24x8`\n+is equal to the IEEE `binary32` format, and `p53x11` is equal to the IEEE\n+`binary64` format.\n+\n+```k\n module FLOAT-SYNTAX\n   syntax Float [hook(FLOAT.Float)]\n-  syntax Float ::= r\"([\\\\+-]?[0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([eE][\\\\+-]?([0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]d+))?([fFdD]|([pP][0-9]+[xX][0-9]+))?\" [token, prec(1)]\n+  syntax Float ::= r\"([\\\\+-]?[0-9]+(\\\\.[0-9]*)?|\\\\.[0-9]+)([eE][\\\\+-]?[0-9]+)?([fFdD]|([pP][0-9]+[xX][0-9]+))?\" [token, prec(1)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDk4OA=="}, "originalCommit": {"oid": "b4e827c8b342462a38eb6964b1c2596de677f85f"}, "originalPosition": 1019}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2998, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}