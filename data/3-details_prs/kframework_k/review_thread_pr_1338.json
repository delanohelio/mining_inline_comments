{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzODEzNTQ1", "number": 1338, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDoyOTozM1rOEHuAPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjowMzozMVrOEI01JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTI5MjEyOnYy", "diffSide": "RIGHT", "path": "k-distribution/src/main/scripts/bin/kx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDoyOTozM1rOGnP3iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDoyOTozM1rOGnP3iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwNzYyNA==", "bodyText": "I think we should set -eo pipefail at least, so any commands added in pipes also fail the script if they fail (instead of just the last command in the pipe).\nWe probably also should do set -euo pipefail, so that we fail on unitialized variables (and so changes to variables here must provide defaults), but that may be trickier.", "url": "https://github.com/kframework/k/pull/1338#discussion_r443807624", "createdAt": "2020-06-22T20:29:33Z", "author": {"login": "ehildenb"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,438 @@\n+#!/bin/bash\n+set -e", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3e08dc7fc35ae0b7253019d566d527375e6cd1"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTI5ODY5OnYy", "diffSide": "RIGHT", "path": "k-distribution/src/main/scripts/bin/kx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDozMTozNFrOGnP7mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDozMTozNFrOGnP7mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwODY2NQ==", "bodyText": "Just a styling argument, any single-line if CONDITION; then COMMAND; fi can be rewritten as ! CONDITION || COMMAND. Up to you.", "url": "https://github.com/kframework/k/pull/1338#discussion_r443808665", "createdAt": "2020-06-22T20:31:34Z", "author": {"login": "ehildenb"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,438 @@\n+#!/bin/bash\n+set -e\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      -save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if $search; then\n+  io=false\n+fi\n+\n+if [[ \"${#ARGV[@]}\" -gt 1 ]]; then\n+  error 'Cannot pass more than one configuration variable as a positional argument.'\n+fi", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d3e08dc7fc35ae0b7253019d566d527375e6cd1"}, "originalPosition": 331}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NjY4NzEyOnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/kompile/KompileFrontEnd.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNToxMzozOFrOGo_ZeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNToyOTo0NlrOGpAHBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzNDkzNw==", "bodyText": "This information isn't already saved somewhere else?", "url": "https://github.com/kframework/k/pull/1338#discussion_r445634937", "createdAt": "2020-06-25T15:13:38Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/kompile/KompileFrontEnd.java", "diffHunk": "@@ -68,6 +68,7 @@ public int run() {\n         Kompile kompile = new Kompile(options, files.get(), kem, sw, !options.profileRules);\n         Backend backend = koreBackend.get();\n         CompiledDefinition def = kompile.run(options.outerParsing.mainDefinitionFile(files.get()), options.mainModule(files.get()), options.syntaxModule(files.get()), backend.steps(), backend.excludedModuleTags());\n+        files.get().saveToKompiled(\"mainModule.txt\", def.executionModule().name());\n         sw.printIntermediate(\"Kompile to kore\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "090bf614f2dbe44df9a8ff5e194778c01fc670ad"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY0NjU5Nw==", "bodyText": "It is not saved anywhere in any place that is convenient for a shell script to parse. Mostly the java code gets this information from the deserialized K definition, which we are not making use of in the new script.", "url": "https://github.com/kframework/k/pull/1338#discussion_r445646597", "createdAt": "2020-06-25T15:29:46Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/kompile/KompileFrontEnd.java", "diffHunk": "@@ -68,6 +68,7 @@ public int run() {\n         Kompile kompile = new Kompile(options, files.get(), kem, sw, !options.profileRules);\n         Backend backend = koreBackend.get();\n         CompiledDefinition def = kompile.run(options.outerParsing.mainDefinitionFile(files.get()), options.mainModule(files.get()), options.syntaxModule(files.get()), backend.steps(), backend.excludedModuleTags());\n+        files.get().saveToKompiled(\"mainModule.txt\", def.executionModule().name());\n         sw.printIntermediate(\"Kompile to kore\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzNDkzNw=="}, "originalCommit": {"oid": "090bf614f2dbe44df9a8ff5e194778c01fc670ad"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Njc3NDI2OnYy", "diffSide": "RIGHT", "path": "k-distribution/src/main/scripts/bin/kx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTozMzo0NVrOGpARfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTozMzo0NVrOGpARfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY0OTI3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  -save-temps          Do not delete temporary files when $KX terminates.\n          \n          \n            \n                  --save-temps         Do not delete temporary files when $KX terminates.", "url": "https://github.com/kframework/k/pull/1338#discussion_r445649276", "createdAt": "2020-06-25T15:33:45Z", "author": {"login": "ehildenb"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "090bf614f2dbe44df9a8ff5e194778c01fc670ad"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Njc4NTY3OnYy", "diffSide": "RIGHT", "path": "k-distribution/src/main/scripts/bin/kx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTozNjozMFrOGpAYmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTozNjozMFrOGpAYmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MTA5OA==", "bodyText": "I don't see the definition of error anywhere...", "url": "https://github.com/kframework/k/pull/1338#discussion_r445651098", "createdAt": "2020-06-25T15:36:30Z", "author": {"login": "ehildenb"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "090bf614f2dbe44df9a8ff5e194778c01fc670ad"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Njc5MjM1OnYy", "diffSide": "RIGHT", "path": "k-distribution/src/main/scripts/bin/kx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTozODoxOVrOGpAc_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTozODoxOVrOGpAc_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MjIyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  -save-temps)\n          \n          \n            \n                  trap - INT TERM EXIT\n          \n          \n            \n                  flags=\"$flags -save-temps\"\n          \n          \n            \n                  ;;\n          \n          \n            \n                  --save-temps)\n          \n          \n            \n                  trap - INT TERM EXIT\n          \n          \n            \n                  flags=\"$flags -save-temps\"\n          \n          \n            \n                  ;;\n          \n      \n    \n    \n  \n\nWhy do we have just a single dash here?", "url": "https://github.com/kframework/k/pull/1338#discussion_r445652222", "createdAt": "2020-06-25T15:38:19Z", "author": {"login": "ehildenb"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      -save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "090bf614f2dbe44df9a8ff5e194778c01fc670ad"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Njc5NDYwOnYy", "diffSide": "RIGHT", "path": "k-distribution/src/main/scripts/bin/kx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTozODo1NVrOGpAeaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTo0MDozOVrOGpAi-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MjU4Nw==", "bodyText": "It looks like flags is only intended to be for the llvm backend, maybe it should be named llvm_flags instead?", "url": "https://github.com/kframework/k/pull/1338#discussion_r445652587", "createdAt": "2020-06-25T15:38:55Z", "author": {"login": "ehildenb"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      -save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if $search; then\n+  io=false\n+fi\n+\n+if [[ \"${#ARGV[@]}\" -gt 1 ]]; then\n+  error 'Cannot pass more than one configuration variable as a positional argument.'\n+fi\n+\n+kompiledDir=\n+hasKompiledDir=false\n+for file in \"$dir\"/*-kompiled; do\n+  kompiledDir=$file\n+  if $hasKompiledDir; then\n+    error 'Multiple compiled definitions found in the current working directory: ' \"$dir\"/*-kompiled\n+  fi\n+  hasKompiledDir=true\n+done\n+\n+if ! $hasKompiledDir; then\n+  error 'Could not find a compiled definition. Use --directory to specify one.'\n+fi\n+\n+hasArgv=false\n+if [[ \"${#ARGV[@]}\" -gt 0 ]]; then\n+  config_var_PGM=\"${ARGV[0]}\"\n+  hasArgv=true\n+  params+=(\"PGM\")\n+fi\n+\n+mainModuleName=$(cat \"$kompiledDir\"/mainModule.txt)\n+\n+if [ \"$outputFile\" = \"-\" ]; then\n+  outputFile=/dev/stdout\n+fi\n+\n+if $term; then\n+  if [ -z \"${parser_PGM+unset}\" ]; then\n+    execute kast -m \"$mainModuleName\" \"$config_var_PGM\" -o kore > \"$input_file\"\n+  else\n+    execute $parser_PGM \"$config_var_PGM\" > \"$input_file\"\n+  fi\n+else\n+  for name in \"${params[@]}\"; do\n+    parser_name=\"parser_$name\"\n+    config_name=\"config_var_$name\"\n+    tempFile=\"$(mktemp tmp.in.\"$name\".XXXXXXXXXX)\"\n+    tempFiles+=(\"$tempFile\")\n+    sortName=`cat \"$kompiledDir\"/sort_\"$name\".txt`\n+    if [ -z \"${!parser_name+unset}\" ]; then\n+      if [ -f \"$kompiledDir/parser_$name\" ]; then\n+        parser=\"$kompiledDir/parser_$name\"\n+      elif [ \"$name\" = \"PGM\" ]; then\n+        if $hasArgv; then\n+          parser=\"kast -o kore\"\n+\telse\n+          parser=\"kast -m $mainModuleName -o kore\"\n+\tfi\n+      else\n+        parser=\"kast -m $mainModuleName -o kore\"\n+      fi\n+    else\n+      parser=\"${!parser_name}\"\n+    fi\n+    execute $parser \"${!config_name}\" > \"$tempFile\"\n+    configVars=\"$configVars -c $name $tempFile $sortName korefile\"\n+  done\n+  if [ \"$(cat \"$kompiledDir\"/sort_IO.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      ioText=on\n+    else\n+      ioText=off\n+    fi\n+    configVars=\"$configVars -c IO \\dv{SortString{}}(\\\"$ioText\\\") String kore\"\n+  fi\n+  if [ \"$(cat \"$kompiledDir\"/sort_STDIN.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      stdinText=\n+    else\n+      unescaped=$(</dev/stdin)\n+      stdinText=$(awk 'BEGIN {for(n=0;n<256;n++)ord[sprintf(\"%c\",n)]=n} {text = text $0 ORS} END {split(text, chars, \"\"); for (i=1; i<=length(text); i++) { if (chars[i] == \"\\\"\") { printf(\"%s\", \"\\\\\\\"\") } else if (chars[i] == \"\\\\\") { printf(\"%s\", \"\\\\\\\\\") } else if (chars[i] == \"\\n\") { printf(\"%s\", \"\\\\n\") } else if (chars[i] == \"\\t\") { printf(\"%s\", \"\\\\t\") } else if (chars[i] == \"\\r\") { printf(\"%s\", \"\\\\r\") } else if (chars[i] == \"\\f\") { printf(\"%s\", \"\\\\f\") } else if (ord[chars[i]] >= 32 && ord[chars[i]] < 127) { printf(\"%s\", chars[i]) } else { printf(\"\\\\x%02x\", ord[chars[i]]) } } }' <<< \"$unescaped\")\n+    fi\n+    stdinFile=\"$(mktemp tmp.stdin.XXXXXXXXXX)\"\n+    tempFiles+=(\"$stdinFile\")\n+    printf '\\dv{SortString{}}(\\\"%s\\\")\\n' \"$stdinText\" > \"$stdinFile\"\n+    configVars=\"$configVars -c STDIN $stdinFile String korefile\"\n+  fi\n+  execute llvm-krun $configVars -d \"$kompiledDir\" $flags --dry-run -o \"$input_file\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "090bf614f2dbe44df9a8ff5e194778c01fc670ad"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1Mzc1NA==", "bodyText": "Well, this code is going to be used by the haskell backend code path as well to construct the initial configuration, so I'm not sure that makes sense.", "url": "https://github.com/kframework/k/pull/1338#discussion_r445653754", "createdAt": "2020-06-25T15:40:39Z", "author": {"login": "dwightguth"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      -save-temps          Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      -save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if $search; then\n+  io=false\n+fi\n+\n+if [[ \"${#ARGV[@]}\" -gt 1 ]]; then\n+  error 'Cannot pass more than one configuration variable as a positional argument.'\n+fi\n+\n+kompiledDir=\n+hasKompiledDir=false\n+for file in \"$dir\"/*-kompiled; do\n+  kompiledDir=$file\n+  if $hasKompiledDir; then\n+    error 'Multiple compiled definitions found in the current working directory: ' \"$dir\"/*-kompiled\n+  fi\n+  hasKompiledDir=true\n+done\n+\n+if ! $hasKompiledDir; then\n+  error 'Could not find a compiled definition. Use --directory to specify one.'\n+fi\n+\n+hasArgv=false\n+if [[ \"${#ARGV[@]}\" -gt 0 ]]; then\n+  config_var_PGM=\"${ARGV[0]}\"\n+  hasArgv=true\n+  params+=(\"PGM\")\n+fi\n+\n+mainModuleName=$(cat \"$kompiledDir\"/mainModule.txt)\n+\n+if [ \"$outputFile\" = \"-\" ]; then\n+  outputFile=/dev/stdout\n+fi\n+\n+if $term; then\n+  if [ -z \"${parser_PGM+unset}\" ]; then\n+    execute kast -m \"$mainModuleName\" \"$config_var_PGM\" -o kore > \"$input_file\"\n+  else\n+    execute $parser_PGM \"$config_var_PGM\" > \"$input_file\"\n+  fi\n+else\n+  for name in \"${params[@]}\"; do\n+    parser_name=\"parser_$name\"\n+    config_name=\"config_var_$name\"\n+    tempFile=\"$(mktemp tmp.in.\"$name\".XXXXXXXXXX)\"\n+    tempFiles+=(\"$tempFile\")\n+    sortName=`cat \"$kompiledDir\"/sort_\"$name\".txt`\n+    if [ -z \"${!parser_name+unset}\" ]; then\n+      if [ -f \"$kompiledDir/parser_$name\" ]; then\n+        parser=\"$kompiledDir/parser_$name\"\n+      elif [ \"$name\" = \"PGM\" ]; then\n+        if $hasArgv; then\n+          parser=\"kast -o kore\"\n+\telse\n+          parser=\"kast -m $mainModuleName -o kore\"\n+\tfi\n+      else\n+        parser=\"kast -m $mainModuleName -o kore\"\n+      fi\n+    else\n+      parser=\"${!parser_name}\"\n+    fi\n+    execute $parser \"${!config_name}\" > \"$tempFile\"\n+    configVars=\"$configVars -c $name $tempFile $sortName korefile\"\n+  done\n+  if [ \"$(cat \"$kompiledDir\"/sort_IO.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      ioText=on\n+    else\n+      ioText=off\n+    fi\n+    configVars=\"$configVars -c IO \\dv{SortString{}}(\\\"$ioText\\\") String kore\"\n+  fi\n+  if [ \"$(cat \"$kompiledDir\"/sort_STDIN.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      stdinText=\n+    else\n+      unescaped=$(</dev/stdin)\n+      stdinText=$(awk 'BEGIN {for(n=0;n<256;n++)ord[sprintf(\"%c\",n)]=n} {text = text $0 ORS} END {split(text, chars, \"\"); for (i=1; i<=length(text); i++) { if (chars[i] == \"\\\"\") { printf(\"%s\", \"\\\\\\\"\") } else if (chars[i] == \"\\\\\") { printf(\"%s\", \"\\\\\\\\\") } else if (chars[i] == \"\\n\") { printf(\"%s\", \"\\\\n\") } else if (chars[i] == \"\\t\") { printf(\"%s\", \"\\\\t\") } else if (chars[i] == \"\\r\") { printf(\"%s\", \"\\\\r\") } else if (chars[i] == \"\\f\") { printf(\"%s\", \"\\\\f\") } else if (ord[chars[i]] >= 32 && ord[chars[i]] < 127) { printf(\"%s\", chars[i]) } else { printf(\"\\\\x%02x\", ord[chars[i]]) } } }' <<< \"$unescaped\")\n+    fi\n+    stdinFile=\"$(mktemp tmp.stdin.XXXXXXXXXX)\"\n+    tempFiles+=(\"$stdinFile\")\n+    printf '\\dv{SortString{}}(\\\"%s\\\")\\n' \"$stdinText\" > \"$stdinFile\"\n+    configVars=\"$configVars -c STDIN $stdinFile String korefile\"\n+  fi\n+  execute llvm-krun $configVars -d \"$kompiledDir\" $flags --dry-run -o \"$input_file\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MjU4Nw=="}, "originalCommit": {"oid": "090bf614f2dbe44df9a8ff5e194778c01fc670ad"}, "originalPosition": 415}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Njc5OTc3OnYy", "diffSide": "RIGHT", "path": "k-distribution/src/main/scripts/bin/kx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTo0MDoxMFrOGpAhxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTo0MDoxMFrOGpAhxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1MzQ0Ng==", "bodyText": "This should be more like:\nif $search && $io; then\n    error \"Cannot specify both --search* and --io on\"\nfi", "url": "https://github.com/kframework/k/pull/1338#discussion_r445653446", "createdAt": "2020-06-25T15:40:10Z", "author": {"login": "ehildenb"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,442 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+color=false\n+if [ -t 1 ]; then\n+  color=true\n+fi\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+io=true\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      --save-temps         Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      -save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if $search; then\n+  io=false\n+fi\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88b72a7be3d66878bc3c1f2717a5155f15129f2a"}, "originalPosition": 332}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3Njg5NjM2OnYy", "diffSide": "RIGHT", "path": "k-distribution/src/main/scripts/bin/kx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjowMzozMVrOGpBfUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxODowMToyMFrOGpF05g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2OTIwMQ==", "bodyText": "Where is this coming from? Is this a heuristic or definitely correct?", "url": "https://github.com/kframework/k/pull/1338#discussion_r445669201", "createdAt": "2020-06-25T16:03:31Z", "author": {"login": "ehildenb"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,456 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+result=1\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+error () {\n+  printf \"%s\" \"[Error] Critical: \"\n+  echo \"$@\"\n+  exit $result\n+}\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      --save-temps         Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      --save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if [ -z \"${io+unset}\" ]; then\n+  if $search; then\n+    io=false\n+  else\n+    io=true\n+  fi\n+fi\n+\n+if [ -z \"${color+unset}\" ]; then\n+  if [[ \"$outputFile\" == \"-\" && -t 1 ]]; then\n+    color=true\n+  else\n+    color=false\n+  fi\n+fi\n+\n+if [[ \"${#ARGV[@]}\" -gt 1 ]]; then\n+  error 'Cannot pass more than one configuration variable as a positional argument.'\n+fi\n+\n+kompiledDir=\n+hasKompiledDir=false\n+for file in \"$dir\"/*-kompiled; do\n+  kompiledDir=$file\n+  if $hasKompiledDir; then\n+    error 'Multiple compiled definitions found in the current working directory: ' \"$dir\"/*-kompiled\n+  fi\n+  hasKompiledDir=true\n+done\n+\n+if ! $hasKompiledDir; then\n+  error 'Could not find a compiled definition. Use --directory to specify one.'\n+fi\n+\n+hasArgv=false\n+if [[ \"${#ARGV[@]}\" -gt 0 ]]; then\n+  config_var_PGM=\"${ARGV[0]}\"\n+  hasArgv=true\n+  params+=(\"PGM\")\n+fi\n+\n+mainModuleName=$(cat \"$kompiledDir\"/mainModule.txt)\n+\n+if [ \"$outputFile\" = \"-\" ]; then\n+  outputFile=/dev/stdout\n+fi\n+\n+if $term; then\n+  if [ -z \"${parser_PGM+unset}\" ]; then\n+    execute kast -m \"$mainModuleName\" \"$config_var_PGM\" -o kore > \"$input_file\"\n+  else\n+    execute $parser_PGM \"$config_var_PGM\" > \"$input_file\"\n+  fi\n+else\n+  for name in \"${params[@]}\"; do\n+    parser_name=\"parser_$name\"\n+    config_name=\"config_var_$name\"\n+    tempFile=\"$(mktemp tmp.in.\"$name\".XXXXXXXXXX)\"\n+    tempFiles+=(\"$tempFile\")\n+    sortName=`cat \"$kompiledDir\"/sort_\"$name\".txt`\n+    if [ -z \"${!parser_name+unset}\" ]; then\n+      if [ -f \"$kompiledDir/parser_$name\" ]; then\n+        parser=\"$kompiledDir/parser_$name\"\n+      elif [ \"$name\" = \"PGM\" ]; then\n+        if $hasArgv; then\n+          parser=\"kast -o kore\"\n+\telse\n+          parser=\"kast -m $mainModuleName -o kore\"\n+\tfi\n+      else\n+        parser=\"kast -m $mainModuleName -o kore\"\n+      fi\n+    else\n+      parser=\"${!parser_name}\"\n+    fi\n+    execute $parser \"${!config_name}\" > \"$tempFile\"\n+    configVars=\"$configVars -c $name $tempFile $sortName korefile\"\n+  done\n+  if [ \"$(cat \"$kompiledDir\"/sort_IO.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      ioText=on\n+    else\n+      ioText=off\n+    fi\n+    configVars=\"$configVars -c IO \\dv{SortString{}}(\\\"$ioText\\\") String kore\"\n+  fi\n+  if [ \"$(cat \"$kompiledDir\"/sort_STDIN.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      stdinText=\n+    else\n+      unescaped=$(</dev/stdin)\n+      stdinText=$(awk 'BEGIN {for(n=0;n<256;n++)ord[sprintf(\"%c\",n)]=n} {text = text $0 ORS} END {split(text, chars, \"\"); for (i=1; i<=length(text); i++) { if (chars[i] == \"\\\"\") { printf(\"%s\", \"\\\\\\\"\") } else if (chars[i] == \"\\\\\") { printf(\"%s\", \"\\\\\\\\\") } else if (chars[i] == \"\\n\") { printf(\"%s\", \"\\\\n\") } else if (chars[i] == \"\\t\") { printf(\"%s\", \"\\\\t\") } else if (chars[i] == \"\\r\") { printf(\"%s\", \"\\\\r\") } else if (chars[i] == \"\\f\") { printf(\"%s\", \"\\\\f\") } else if (ord[chars[i]] >= 32 && ord[chars[i]] < 127) { printf(\"%s\", chars[i]) } else { printf(\"\\\\x%02x\", ord[chars[i]]) } } }' <<< \"$unescaped\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5ffe62e0d608fecbc26fc6857c67683e75f8d05"}, "originalPosition": 422}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0MDI2Mg==", "bodyText": "This is the awk script to escape an ascii string into a K string literal.", "url": "https://github.com/kframework/k/pull/1338#discussion_r445740262", "createdAt": "2020-06-25T18:01:20Z", "author": {"login": "dwightguth"}, "path": "k-distribution/src/main/scripts/bin/kx", "diffHunk": "@@ -0,0 +1,456 @@\n+#!/bin/bash\n+set -e\n+set -o pipefail\n+set -u\n+\n+export PATH=\"$(dirname \"$0\"):$PATH\"\n+\n+ARGV=()\n+bound=\n+depth=\n+params=()\n+allPath=true\n+dir=.\n+cmd=\n+cmdprefix=\n+filterSubst=true\n+outputFile=-\n+pattern=\n+search=false\n+searchType=!\n+term=false\n+verbose=false\n+literal=false\n+outputMode=pretty\n+flags=\n+configVars=\n+result=1\n+\n+tempFiles=()\n+trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT\n+\n+input_file=\"$(mktemp tmp.in.XXXXXXXXXX)\"\n+kore_output=\"$(mktemp tmp.out.XXXXXXXXXX)\"\n+tempFiles+=(\"$input_file\")\n+tempFiles+=(\"$kore_output\")\n+\n+execute () {\n+  (\n+  if $verbose; then\n+    set -x\n+  fi\n+  \"$@\"\n+  )\n+}\n+\n+KX=$(basename \"$0\")\n+\n+error () {\n+  printf \"%s\" \"[Error] Critical: \"\n+  echo \"$@\"\n+  exit $result\n+}\n+\n+print_usage () {\n+cat <<HERE\n+Usage: $KX [PROGRAM] [-cNAME=VALUE] [-d DIR]\n+Execute a program using a K semantics that was built with kompile.\n+\n+Mandatory arguments to long options are mandatory for short options too.\n+\n+$KX expects 0 or 1 positional arguments. If a positional argument is present,\n+it must be a file and the contents of that file is parsed using the parser\n+specified with --parser and used as the value of \\$PGM (unless --term is\n+present; see below).\n+\n+Currently only the LLVM backend is supported. This will change in the near\n+future.\n+\n+      --bound N            Return at most N solutions  with --search\n+      --depth N            Execute at most N rewrite steps\n+      --color [on|off]     Enable/disable ANSI color codes. Overrides default,\n+                           which is determined based on whether stdout is a\n+                           terminal.\n+  -pNAME=VALUE             Use VALUE as a command to parse \\$NAME. For example,\n+                           if NAME=PGM and VALUE=cat, and the user also passes\n+                           \\`-cPGM=foo\\`, a temporary file containing the word\n+                           \"foo\" is created and cat is called on it to provide\n+                           the value of \\$PGM as a KORE term.\n+  \n+  -cNAME=VALUE             Use VALUE as the value for \\$NAME. By default,\n+                           \\`kast -m MAINMODULE -o kore\\` is used as the\n+                           parser. This can be overridden with -p.\n+      --debugger           Launch the backend in a debugging console.\n+                           Currently only supported on LLVM backend.\n+  -d, --directory DIR      Look for a kompiled directory ending in \"-kompiled\"\n+                           under the directory DIR.\n+      --dry-run            Do not execute backend, but instead print the\n+                           command that would be executed to stdout.\n+      --haskell-backend-command CMD  use CMD instead of kore-exec to invoke\n+                                     Haskell backend\n+  -h, --help               Display this help and exit\n+      --io [on|off]        Enable/disable reading/writing to actual\n+                           stdin/stdout via cells with \"stream\" attribute.\n+                           Defaults to enabled when performing concrete\n+                           execution, and disabled when --search is passed.\n+      --no-substitution-filtering  Don't filter conjuncts with anonymous\n+                                   variables from substitution output\n+  -o, --output MODE        Select output mode to use when unparsing. Valid\n+                           values are pretty, program, kast, binary, json,\n+                           latex, kore, and none.\n+      --output-file FILE   Print final configuration to FILE\n+      --parser VALUE       Use VALUE as parser to parse \\$PGM. For example,\n+                           if the user says \"$KX --parser cat foo.kore\", then\n+                           \\`cat foo.kore\\` is invoked and the result on stdout\n+                           is used as the value of \\$PGM as a KORE term.\n+      --pattern PAT        Use PAT as the search pattern with --search. Can\n+                           also be used without --search to match the output\n+                           configuration against a pattern and print the\n+                           substitution. Only supported on Haskell backend.\n+      --save-temps         Do not delete temporary files when $KX terminates.\n+      --search             Search for all possible output states after\n+                           rewriting. Only supported on Haskell backend.\n+      --search-all         Like --search, but also return interim states\n+      --search-final       Synonym for --search\n+      --search-one-or-more-steps  Like --search-all, but do not include the\n+                                  initial state in the result\n+      --search-one-step    Search for all possible states that are the\n+                           immediate successor of the input.\n+      --statistics         Print number of steps executed. Currently only\n+                           supported on LLVM backend.\n+      --term               Use the value that would otherwise be considered the\n+                           value for \\$PGM as the entire input configuration.\n+                           i.e., skip composing configuration from\n+                           configuration variables.\n+  -v, --verbose            Print significant commands executed by $KX.\n+      --version            Print version of K\n+      --                   Interpret all arguments following as positional\n+                           arguments.\n+HERE\n+}\n+\n+while [[ $# -gt 0 ]]\n+do\n+  arg=\"$1\"\n+  if $literal; then\n+    ARGV+=(\"$1\")\n+  else\n+    case \"$arg\" in\n+      --bound)\n+      bound=\"$2\"\n+      shift\n+      ;;\n+  \n+      --depth)\n+      depth=\"$2\"\n+      shift\n+      ;;\n+  \n+      --color)\n+      case \"$2\" in\n+        on)\n+        color=true\n+        ;;\n+  \n+        off)\n+        color=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --color. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      -p*=*)\n+      keyval=${1#-p}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"parser_$key\"\n+      printf -v \"$var_name\" %s \"$val\"\n+      ;;\n+  \n+      -c*=*)\n+      keyval=${1#-c}\n+      key=${keyval%%=*}\n+      val=${keyval#*=}\n+      var_name=\"config_var_$key\"\n+      params+=(\"$key\")\n+      tempFile=\"$(mktemp tmp.\"$key\".pretty.XXXXXXXXXX)\"\n+      tempFiles+=(\"$tempFile\")\n+      printf %s \"$val\" > \"$tempFile\"\n+      printf -v \"$var_name\" %s \"$tempFile\"\n+      ;;\n+  \n+      -d|--directory)\n+      dir=\"$2\"\n+      shift\n+      ;;\n+  \n+      --dry-run)\n+      cmdprefix=\"echo \"\n+      tempFiles=(${tempFiles[@]/$input_file})\n+      outputMode=none\n+      ;;\n+  \n+      --haskell-backend-command)\n+      cmd=\"$2\"\n+      shift\n+      ;;\n+  \n+      -h|--help)\n+      print_usage\n+      exit 0\n+      ;;\n+  \n+      --io)\n+      case \"$2\" in\n+        on)\n+        io=true\n+        ;;\n+  \n+        off)\n+        io=false\n+        ;;\n+  \n+        *)\n+        error 'Invalid value for --io. Should be \"on\" or \"off\".'\n+        ;;\n+      esac\n+      shift\n+      ;;\n+  \n+      --no-substitution-filtering)\n+      filterSubst=false\n+      ;;\n+  \n+      -o|--output)\n+      case \"$2\" in\n+        pretty) ;;\n+        program) ;;\n+        kast) ;;\n+        binary) ;;\n+        json) ;;\n+        latex) ;;\n+        kore) ;;\n+        none) ;;\n+        *)\n+          error 'Invalid value for --output. Should be one of \"pretty\", \"program\", \"kast\", \"binary\", \"json\", \"latex\", \"kore\", or \"none\".'\n+  \t;;\n+      esac\n+      outputMode=\"$2\"\n+      shift\n+      ;;\n+  \n+      --output-file)\n+      outputFile=\"$2\"\n+      shift\n+      ;;\n+  \n+      --parser)\n+      var_name=\"parser_PGM\"\n+      printf -v \"$var_name\" %s \"$2\"\n+      shift\n+      ;;\n+  \n+      --pattern)\n+      pattern=\"$2\"\n+      shift\n+      ;;\n+  \n+      --search)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-all)\n+      search=true\n+      searchType='*'\n+      ;;\n+  \n+      --search-final)\n+      search=true\n+      searchType='!'\n+      ;;\n+  \n+      --search-one-or-more-steps)\n+      search=true\n+      searchType='+'\n+      ;;\n+  \n+      --search-one-step)\n+      search=true\n+      searchType='1'\n+      ;;\n+  \n+      --term)\n+      term=true\n+      ;;    \n+  \n+      -v|--verbose)\n+      verbose=true\n+      flags=\"$flags -v\"\n+      ;;\n+  \n+      --save-temps)\n+      trap - INT TERM EXIT\n+      flags=\"$flags -save-temps\"\n+      ;;\n+  \n+      --version)\n+      kompile --version\n+      exit 0\n+      ;;\n+  \n+      --debugger)\n+      cmdprefix=\"gdb --args \"\n+      ;;\n+  \n+      --statistics)\n+      flags=\"$flags --statistics\"\n+      ;;\n+  \n+      --)\n+      literal=true\n+      ;;\n+  \n+      -*)\n+      print_usage\n+      exit 1\n+      ;;\n+  \n+      *)\n+      ARGV+=(\"$1\")\n+      ;;\n+    esac\n+  fi\n+  shift\n+done\n+\n+if [ -z \"${io+unset}\" ]; then\n+  if $search; then\n+    io=false\n+  else\n+    io=true\n+  fi\n+fi\n+\n+if [ -z \"${color+unset}\" ]; then\n+  if [[ \"$outputFile\" == \"-\" && -t 1 ]]; then\n+    color=true\n+  else\n+    color=false\n+  fi\n+fi\n+\n+if [[ \"${#ARGV[@]}\" -gt 1 ]]; then\n+  error 'Cannot pass more than one configuration variable as a positional argument.'\n+fi\n+\n+kompiledDir=\n+hasKompiledDir=false\n+for file in \"$dir\"/*-kompiled; do\n+  kompiledDir=$file\n+  if $hasKompiledDir; then\n+    error 'Multiple compiled definitions found in the current working directory: ' \"$dir\"/*-kompiled\n+  fi\n+  hasKompiledDir=true\n+done\n+\n+if ! $hasKompiledDir; then\n+  error 'Could not find a compiled definition. Use --directory to specify one.'\n+fi\n+\n+hasArgv=false\n+if [[ \"${#ARGV[@]}\" -gt 0 ]]; then\n+  config_var_PGM=\"${ARGV[0]}\"\n+  hasArgv=true\n+  params+=(\"PGM\")\n+fi\n+\n+mainModuleName=$(cat \"$kompiledDir\"/mainModule.txt)\n+\n+if [ \"$outputFile\" = \"-\" ]; then\n+  outputFile=/dev/stdout\n+fi\n+\n+if $term; then\n+  if [ -z \"${parser_PGM+unset}\" ]; then\n+    execute kast -m \"$mainModuleName\" \"$config_var_PGM\" -o kore > \"$input_file\"\n+  else\n+    execute $parser_PGM \"$config_var_PGM\" > \"$input_file\"\n+  fi\n+else\n+  for name in \"${params[@]}\"; do\n+    parser_name=\"parser_$name\"\n+    config_name=\"config_var_$name\"\n+    tempFile=\"$(mktemp tmp.in.\"$name\".XXXXXXXXXX)\"\n+    tempFiles+=(\"$tempFile\")\n+    sortName=`cat \"$kompiledDir\"/sort_\"$name\".txt`\n+    if [ -z \"${!parser_name+unset}\" ]; then\n+      if [ -f \"$kompiledDir/parser_$name\" ]; then\n+        parser=\"$kompiledDir/parser_$name\"\n+      elif [ \"$name\" = \"PGM\" ]; then\n+        if $hasArgv; then\n+          parser=\"kast -o kore\"\n+\telse\n+          parser=\"kast -m $mainModuleName -o kore\"\n+\tfi\n+      else\n+        parser=\"kast -m $mainModuleName -o kore\"\n+      fi\n+    else\n+      parser=\"${!parser_name}\"\n+    fi\n+    execute $parser \"${!config_name}\" > \"$tempFile\"\n+    configVars=\"$configVars -c $name $tempFile $sortName korefile\"\n+  done\n+  if [ \"$(cat \"$kompiledDir\"/sort_IO.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      ioText=on\n+    else\n+      ioText=off\n+    fi\n+    configVars=\"$configVars -c IO \\dv{SortString{}}(\\\"$ioText\\\") String kore\"\n+  fi\n+  if [ \"$(cat \"$kompiledDir\"/sort_STDIN.txt 2>/dev/null)\" = \"String\" ]; then\n+    if $io; then\n+      stdinText=\n+    else\n+      unescaped=$(</dev/stdin)\n+      stdinText=$(awk 'BEGIN {for(n=0;n<256;n++)ord[sprintf(\"%c\",n)]=n} {text = text $0 ORS} END {split(text, chars, \"\"); for (i=1; i<=length(text); i++) { if (chars[i] == \"\\\"\") { printf(\"%s\", \"\\\\\\\"\") } else if (chars[i] == \"\\\\\") { printf(\"%s\", \"\\\\\\\\\") } else if (chars[i] == \"\\n\") { printf(\"%s\", \"\\\\n\") } else if (chars[i] == \"\\t\") { printf(\"%s\", \"\\\\t\") } else if (chars[i] == \"\\r\") { printf(\"%s\", \"\\\\r\") } else if (chars[i] == \"\\f\") { printf(\"%s\", \"\\\\f\") } else if (ord[chars[i]] >= 32 && ord[chars[i]] < 127) { printf(\"%s\", chars[i]) } else { printf(\"\\\\x%02x\", ord[chars[i]]) } } }' <<< \"$unescaped\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2OTIwMQ=="}, "originalCommit": {"oid": "f5ffe62e0d608fecbc26fc6857c67683e75f8d05"}, "originalPosition": 422}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3056, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}