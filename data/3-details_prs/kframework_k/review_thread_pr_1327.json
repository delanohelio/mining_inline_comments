{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMDAzMjI3", "number": 1327, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzo1MDo1NFrOEEGA3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzo1ODo0MVrOEEsomQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzI4Mjg0OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/compile/ResolveStrict.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzo1MDo1NFrOGhgNxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzo0MDowNVrOGh_qIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4NDAwNQ==", "bodyText": "Do we have a wrapper for 1-dimensional attribute arrays? I know it would just be attribute.split(\";\") still, but maybe it would be good to call that function if it exists for semantic readability.", "url": "https://github.com/kframework/k/pull/1327#discussion_r437784005", "createdAt": "2020-06-09T23:50:54Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/compile/ResolveStrict.java", "diffHunk": "@@ -193,6 +159,55 @@ public K apply(KVariable var) {\n                 sentences.add(ctx);\n             }\n         }\n+    }\n+\n+    public Set<Sentence> resolve(Production production, boolean sequential) {\n+        long arity = production.nonterminals().size();\n+        List<Integer> strictnessPositions = new ArrayList<>();\n+        List<Integer> allPositions = new ArrayList<>();\n+        Set<ContextAlias> aliases = new HashSet<>();\n+        String attribute;\n+        Set<Sentence> sentences = new HashSet<>();\n+        if (sequential) {\n+            attribute = production.att().get(Att.SEQSTRICT());\n+        } else {\n+            attribute = production.att().get(Att.STRICT());\n+        }\n+        if (attribute.isEmpty()) {\n+            for (int i = 1; i <= arity; i++) {\n+                strictnessPositions.add(i);\n+            }\n+            aliases.add(DEFAULT_ALIAS);\n+            resolve(sequential, sentences, arity, strictnessPositions, allPositions, aliases, production);\n+            allPositions.addAll(strictnessPositions);\n+        } else {\n+            String[] components = attribute.split(\";\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5OTE3MA==", "bodyText": "We cannot call that function because this is actually a 2d attribute array. Calliing the 2d function could theoretically work, but it would require substantially refactoring this method, so I'd rather just leave the code like this.", "url": "https://github.com/kframework/k/pull/1327#discussion_r438299170", "createdAt": "2020-06-10T17:40:05Z", "author": {"login": "dwightguth"}, "path": "kernel/src/main/java/org/kframework/compile/ResolveStrict.java", "diffHunk": "@@ -193,6 +159,55 @@ public K apply(KVariable var) {\n                 sentences.add(ctx);\n             }\n         }\n+    }\n+\n+    public Set<Sentence> resolve(Production production, boolean sequential) {\n+        long arity = production.nonterminals().size();\n+        List<Integer> strictnessPositions = new ArrayList<>();\n+        List<Integer> allPositions = new ArrayList<>();\n+        Set<ContextAlias> aliases = new HashSet<>();\n+        String attribute;\n+        Set<Sentence> sentences = new HashSet<>();\n+        if (sequential) {\n+            attribute = production.att().get(Att.SEQSTRICT());\n+        } else {\n+            attribute = production.att().get(Att.STRICT());\n+        }\n+        if (attribute.isEmpty()) {\n+            for (int i = 1; i <= arity; i++) {\n+                strictnessPositions.add(i);\n+            }\n+            aliases.add(DEFAULT_ALIAS);\n+            resolve(sequential, sentences, arity, strictnessPositions, allPositions, aliases, production);\n+            allPositions.addAll(strictnessPositions);\n+        } else {\n+            String[] components = attribute.split(\";\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4NDAwNQ=="}, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzI4Nzk2OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/kompile/DefinitionParsing.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzo1MzoyNVrOGhgQrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzo1MzoyNVrOGhgQrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4NDc0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else\n          \n          \n            \n                            kem.addAllKException(parse.getWarnings().stream().map(e -> e.getKException()).collect(Collectors.toList()));\n          \n          \n            \n                        } else {\n          \n          \n            \n                            kem.addAllKException(parse.getWarnings().stream().map(e -> e.getKException()).collect(Collectors.toList()));\n          \n          \n            \n                        }", "url": "https://github.com/kframework/k/pull/1327#discussion_r437784749", "createdAt": "2020-06-09T23:53:25Z", "author": {"login": "ehildenb"}, "path": "kernel/src/main/java/org/kframework/kompile/DefinitionParsing.java", "diffHunk": "@@ -487,21 +489,17 @@ private boolean equalsSyntax(Module _this, Module that) {\n         Tuple2<Either<java.util.Set<KEMException>, K>, java.util.Set<KEMException>> result;\n         if (cache.containsKey(b.contents())) {\n             ParsedSentence parse = cache.get(b.contents());\n-            Optional<Source> cacheSource = parse.getParse().source();\n-            //Cache might contain content from an identical file but another source path.\n-            //The content will have wrong Source attribute and must be invalidated.\n-            if (cacheSource.isPresent() && cacheSource.get().equals(source)) {\n-                cachedBubbles.getAndIncrement();\n-                if (kem.options.warnings2errors) {\n-                    for (KEMException err : parse.getWarnings().stream().map(e -> (KEMException) e).collect(Collectors.toList())) {\n-                        if (kem.options.warnings.includesExceptionType(err.exception.getType())) {\n-                            errors.add(KEMException.asError(err));\n-                        }\n+            cachedBubbles.getAndIncrement();\n+            if (kem.options.warnings2errors) {\n+                for (KEMException err : parse.getWarnings().stream().map(e -> (KEMException) e).collect(Collectors.toList())) {\n+                    if (kem.options.warnings.includesExceptionType(err.exception.getType())) {\n+                        errors.add(KEMException.asError(err));\n                     }\n-                } else\n-                    kem.addAllKException(parse.getWarnings().stream().map(e -> e.getKException()).collect(Collectors.toList()));\n-                return Stream.of(parse.getParse());\n-            }\n+                }\n+            } else\n+                kem.addAllKException(parse.getWarnings().stream().map(e -> e.getKException()).collect(Collectors.toList()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyODk4NDY4OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/compile/ResolveStrict.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTozNzo1OVrOGhw2rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTozNzo1OVrOGhw2rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1NjYyMA==", "bodyText": "This error message doesn't really reflect the code, let alone the user input.\nSee my other comment.", "url": "https://github.com/kframework/k/pull/1327#discussion_r438056620", "createdAt": "2020-06-10T11:37:59Z", "author": {"login": "radumereuta"}, "path": "kernel/src/main/java/org/kframework/compile/ResolveStrict.java", "diffHunk": "@@ -193,6 +159,55 @@ public K apply(KVariable var) {\n                 sentences.add(ctx);\n             }\n         }\n+    }\n+\n+    public Set<Sentence> resolve(Production production, boolean sequential) {\n+        long arity = production.nonterminals().size();\n+        List<Integer> strictnessPositions = new ArrayList<>();\n+        List<Integer> allPositions = new ArrayList<>();\n+        Set<ContextAlias> aliases = new HashSet<>();\n+        String attribute;\n+        Set<Sentence> sentences = new HashSet<>();\n+        if (sequential) {\n+            attribute = production.att().get(Att.SEQSTRICT());\n+        } else {\n+            attribute = production.att().get(Att.STRICT());\n+        }\n+        if (attribute.isEmpty()) {\n+            for (int i = 1; i <= arity; i++) {\n+                strictnessPositions.add(i);\n+            }\n+            aliases.add(DEFAULT_ALIAS);\n+            resolve(sequential, sentences, arity, strictnessPositions, allPositions, aliases, production);\n+            allPositions.addAll(strictnessPositions);\n+        } else {\n+            String[] components = attribute.split(\";\");\n+            if (components.length == 1) {\n+                if (Character.isDigit(components[0].trim().charAt(0))) {\n+                    aliases.add(DEFAULT_ALIAS);\n+                    setPositions(components[0].trim(), strictnessPositions, arity, production);\n+                } else {\n+                    for (int i = 1; i <= arity; i++) {\n+                        strictnessPositions.add(i);\n+                    }\n+                    setAliases(components[0].trim(), aliases, production);\n+                }\n+                resolve(sequential, sentences, arity, strictnessPositions, allPositions, aliases, production);\n+                allPositions.addAll(strictnessPositions);\n+            } else if (components.length % 2 == 0) {\n+                for (int i = 0; i < components.length; i+=2) {\n+                    setAliases(components[i].trim(), aliases, production);\n+                    setPositions(components[i+1].trim(), strictnessPositions, arity, production);\n+                    resolve(sequential, sentences, arity, strictnessPositions, allPositions, aliases, production);\n+                    aliases.clear();\n+                    allPositions.addAll(strictnessPositions);\n+                    strictnessPositions.clear();\n+                }\n+            } else {\n+                throw KEMException.compilerError(\"Invalid strict attribute containing multiple semicolons.\", production);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyOTAwNDYwOnYy", "diffSide": "RIGHT", "path": "pending-documentation.md", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMTo0NDo1OVrOGhxDWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzo1NjozNlrOGiemJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTg2NQ==", "bodyText": "syntax Exp ::= foo(Exp, Exp) [strict(1(left); 2(right)]\n\nWouldn't this be more intuitive? In this case, you might need to add a new parsing entry in Outer.jj, but it shouldn't be that hard.", "url": "https://github.com/kframework/k/pull/1327#discussion_r438059865", "createdAt": "2020-06-10T11:44:59Z", "author": {"login": "radumereuta"}, "path": "pending-documentation.md", "diffHunk": "@@ -459,6 +459,20 @@ each argument of the production, whereas `strict(c; 1)` will instantiate it\n only for the first argument. The special variable `HERE` is used to tell the\n compiler where you want to place the production that is to be heated or cooled.\n \n+You can also specify multiple context aliases for different parts of a production,\n+for example:\n+\n+```k\n+syntax Exp ::= foo(Exp, Exp) [strict(left; 1; right; 2)]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5ODY1MQ==", "bodyText": "Seconded, I was wondering why we aren't using the 2D array for this actually, left, 1; right, 2 (since that is functionality we already support)", "url": "https://github.com/kframework/k/pull/1327#discussion_r438298651", "createdAt": "2020-06-10T17:39:06Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -459,6 +459,20 @@ each argument of the production, whereas `strict(c; 1)` will instantiate it\n only for the first argument. The special variable `HERE` is used to tell the\n compiler where you want to place the production that is to be heated or cooled.\n \n+You can also specify multiple context aliases for different parts of a production,\n+for example:\n+\n+```k\n+syntax Exp ::= foo(Exp, Exp) [strict(left; 1; right; 2)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTg2NQ=="}, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNTA3Mw==", "bodyText": "@ehildenb it's because strict(left; 1, 2, 3) is the existing syntax for a single alias label. Commas separate strictness positions, semicolons separate labels from positions and delimit multiple labels. We could have done what you describe previously, but it would probably not be backwards compatible at this point.", "url": "https://github.com/kframework/k/pull/1327#discussion_r438305073", "createdAt": "2020-06-10T17:50:08Z", "author": {"login": "dwightguth"}, "path": "pending-documentation.md", "diffHunk": "@@ -459,6 +459,20 @@ each argument of the production, whereas `strict(c; 1)` will instantiate it\n only for the first argument. The special variable `HERE` is used to tell the\n compiler where you want to place the production that is to be heated or cooled.\n \n+You can also specify multiple context aliases for different parts of a production,\n+for example:\n+\n+```k\n+syntax Exp ::= foo(Exp, Exp) [strict(left; 1; right; 2)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTg2NQ=="}, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwNTQ2OA==", "bodyText": "As for the other syntax, it is inconsistent with how we specify attributes elsewhere and would probably require a grammar to parse, which I would prefer to avoid when we can use a regular language instead.", "url": "https://github.com/kframework/k/pull/1327#discussion_r438305468", "createdAt": "2020-06-10T17:50:48Z", "author": {"login": "dwightguth"}, "path": "pending-documentation.md", "diffHunk": "@@ -459,6 +459,20 @@ each argument of the production, whereas `strict(c; 1)` will instantiate it\n only for the first argument. The special variable `HERE` is used to tell the\n compiler where you want to place the production that is to be heated or cooled.\n \n+You can also specify multiple context aliases for different parts of a production,\n+for example:\n+\n+```k\n+syntax Exp ::= foo(Exp, Exp) [strict(left; 1; right; 2)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTg2NQ=="}, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM0MzQzOA==", "bodyText": "In what way they are inconsistent? I may misunderstand what you are trying to do.\nIf by creating a parser you get better results, I think it's worth it. The JJTree part of JavaCC makes it quite easy.", "url": "https://github.com/kframework/k/pull/1327#discussion_r438343438", "createdAt": "2020-06-10T18:58:42Z", "author": {"login": "radumereuta"}, "path": "pending-documentation.md", "diffHunk": "@@ -459,6 +459,20 @@ each argument of the production, whereas `strict(c; 1)` will instantiate it\n only for the first argument. The special variable `HERE` is used to tell the\n compiler where you want to place the production that is to be heated or cooled.\n \n+You can also specify multiple context aliases for different parts of a production,\n+for example:\n+\n+```k\n+syntax Exp ::= foo(Exp, Exp) [strict(left; 1; right; 2)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTg2NQ=="}, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwNjA1Mg==", "bodyText": "I agree with @dwightguth that it's inconsistent, in other places where we need lists or 2D lists of data we always use _;_ and _;_,_,_;_. If we want improved ways of specifying structured data in attributes, that can be another PR.", "url": "https://github.com/kframework/k/pull/1327#discussion_r438806052", "createdAt": "2020-06-11T13:56:36Z", "author": {"login": "ehildenb"}, "path": "pending-documentation.md", "diffHunk": "@@ -459,6 +459,20 @@ each argument of the production, whereas `strict(c; 1)` will instantiate it\n only for the first argument. The special variable `HERE` is used to tell the\n compiler where you want to place the production that is to be heated or cooled.\n \n+You can also specify multiple context aliases for different parts of a production,\n+for example:\n+\n+```k\n+syntax Exp ::= foo(Exp, Exp) [strict(left; 1; right; 2)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTg2NQ=="}, "originalCommit": {"oid": "bd3c7ca39dcca44e0cc4b35ab8998b1c2ee61b4f"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMzYxMDQ5OnYy", "diffSide": "RIGHT", "path": "k-distribution/tests/regression-new/context-alias-2/test.k", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzo1ODo0MVrOGiet8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzo1ODo0MVrOGiet8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgwODA0OA==", "bodyText": "Please write some more tests:\n\nOne which uses 3 context aliases (eg left, right, and center)\nOne which uses the same alias for multiple argument positions: (eg left; 1, 3; right; 2)", "url": "https://github.com/kframework/k/pull/1327#discussion_r438808048", "createdAt": "2020-06-11T13:58:41Z", "author": {"login": "ehildenb"}, "path": "k-distribution/tests/regression-new/context-alias-2/test.k", "diffHunk": "@@ -0,0 +1,24 @@\n+module TEST\n+  imports INT\n+  imports ID\n+  imports MAP\n+\n+  syntax Exp ::= foo(Exp, Exp) [seqstrict(left; 1; right; 2)]\n+               | Id \"=\" Int\n+               | Id\n+               | Int\n+               | l(Exp) [symbol] | r(Exp) [symbol]\n+  syntax KResult ::= Int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70e44497487f7f30ebb0d03bf0dd738ec9606e46"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3052, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}