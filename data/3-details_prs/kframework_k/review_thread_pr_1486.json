{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMDEwMTYy", "number": 1486, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozODowM1rOEV4f4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo0MjowNlrOEV4nQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgxMjE5OnYy", "diffSide": "RIGHT", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozODowM1rOG85F5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjoxODoyNVrOG86uOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzE0Mg==", "bodyText": "This information can go in the markdown YAML header above (where the copyright is). Your choice, but that makes it more scrape-able.", "url": "https://github.com/kframework/k/pull/1486#discussion_r466503142", "createdAt": "2020-08-06T15:38:03Z", "author": {"login": "ehildenb"}, "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUyOTg1MA==", "bodyText": "I like the idea. Do you have a specific format in mind? Because I can't seem to find a configuration that I like. Apparently I can't put two values for the same tag.", "url": "https://github.com/kframework/k/pull/1486#discussion_r466529850", "createdAt": "2020-08-06T16:18:25Z", "author": {"login": "radumereuta"}, "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzE0Mg=="}, "originalCommit": {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgxMzUyOnYy", "diffSide": "RIGHT", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozODoyM1rOG85GyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozODoyM1rOG85GyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzM2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            ### Abstract\n          \n          \n            \n            This is the **K** semantic definition of the untyped SIMPLE language.\n          \n          \n            \n            ### Abstract\n          \n          \n            \n            \n          \n          \n            \n            This is the **K** semantic definition of the untyped SIMPLE language.\n          \n      \n    \n    \n  \n\nBlank lines after headers are more readable.", "url": "https://github.com/kframework/k/pull/1486#discussion_r466503369", "createdAt": "2020-08-06T15:38:23Z", "author": {"login": "ehildenb"}, "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgxNTgwOnYy", "diffSide": "RIGHT", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozODo1MlrOG85IOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozODo1MlrOG85IOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzczOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Syntax\n          \n          \n            \n            We start by defining the SIMPLE syntax.  The language constructs discussed\n          \n          \n            \n            ### Syntax\n          \n          \n            \n            \n          \n          \n            \n            We start by defining the SIMPLE syntax.  The language constructs discussed", "url": "https://github.com/kframework/k/pull/1486#discussion_r466503738", "createdAt": "2020-08-06T15:38:52Z", "author": {"login": "ehildenb"}, "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.\n-\\item Functions and function values.  Functions can have zero or\n-more parameters and can return abruptly using a \\texttt{return} statement.\n+\n+* Functions and function values.  Functions can have zero or\n+more parameters and can return abruptly using a `return` statement.\n SIMPLE follows a call-by-value parameter passing style, with static scoping.\n Function names evaluate to function abstractions, which hereby become ordinary\n values in the language, same like the array references.\n-\\item Blocks with locals.  SIMPLE variables can be declared\n+\n+* Blocks with locals.  SIMPLE variables can be declared\n anywhere, their scope being from the place where they are declared\n until the end of the most nested enclosing block.\n-\\item Input/Output.  The expression \\texttt{read()} evaluates to the\n-next value in the input buffer, and the statement \\texttt{write(e)}\n-evaluates \\texttt{e} and outputs its value to the output buffer.  The\n+\n+* Input/Output.  The expression `read()` evaluates to the\n+next value in the input buffer, and the statement `write(e)`\n+evaluates `e` and outputs its value to the output buffer.  The\n input and output buffers are lists of values.\n-\\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n+\n+* Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n an exception can be caught and bound).\n-\\item Concurrency via dynamic thread creation/termination and\n+\n+* Concurrency via dynamic thread creation/termination and\n synchronization.  One can spawn a thread to execute any statement.\n The spawned thread shares with its parent its environment at creation time.\n Threads can be synchronized via a join command which blocks the current thread\n until the joined thread completes, via re-entrant locks which can be acquired\n and released, as well as through rendezvous commands.\n-\\end{itemize}\n+\n+\n Like in many other languages, some of SIMPLE's constructs can be\n desugared into a smaller set of basic constructs.  We do that at the end\n of the syntax module, and then we only give semantics to the core constructs.\n \n-\\paragraph{Note:}{\n-This definition is commented slightly more than others, because it is\n+__Note__: This definition is commented slightly more than others, because it is\n intended to be one of the first non-trivial definitions that the new\n-user of \\K sees.  We recommend the beginner user to first check the\n-language definitions discussed in the \\K tutorial.} */\n+user of **K** sees.  We recommend the beginner user to first check the\n+language definitions discussed in the **K** tutorial.\n \n+```k\n module SIMPLE-UNTYPED-SYNTAX\n   imports DOMAINS-SYNTAX\n+```\n \n-/*@ \\section{Syntax}\n+### Syntax\n We start by defining the SIMPLE syntax.  The language constructs discussed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgxNjUxOnYy", "diffSide": "RIGHT", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozOTowM1rOG85IuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozOTowM1rOG85IuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMzg2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Identifiers\n          \n          \n            \n            Recall from the **K** tutorial that identifiers are builtin and come under the\n          \n          \n            \n            ### Identifiers\n          \n          \n            \n            \n          \n          \n            \n            Recall from the **K** tutorial that identifiers are builtin and come under the", "url": "https://github.com/kframework/k/pull/1486#discussion_r466503865", "createdAt": "2020-08-06T15:39:03Z", "author": {"login": "ehildenb"}, "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.\n-\\item Functions and function values.  Functions can have zero or\n-more parameters and can return abruptly using a \\texttt{return} statement.\n+\n+* Functions and function values.  Functions can have zero or\n+more parameters and can return abruptly using a `return` statement.\n SIMPLE follows a call-by-value parameter passing style, with static scoping.\n Function names evaluate to function abstractions, which hereby become ordinary\n values in the language, same like the array references.\n-\\item Blocks with locals.  SIMPLE variables can be declared\n+\n+* Blocks with locals.  SIMPLE variables can be declared\n anywhere, their scope being from the place where they are declared\n until the end of the most nested enclosing block.\n-\\item Input/Output.  The expression \\texttt{read()} evaluates to the\n-next value in the input buffer, and the statement \\texttt{write(e)}\n-evaluates \\texttt{e} and outputs its value to the output buffer.  The\n+\n+* Input/Output.  The expression `read()` evaluates to the\n+next value in the input buffer, and the statement `write(e)`\n+evaluates `e` and outputs its value to the output buffer.  The\n input and output buffers are lists of values.\n-\\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n+\n+* Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n an exception can be caught and bound).\n-\\item Concurrency via dynamic thread creation/termination and\n+\n+* Concurrency via dynamic thread creation/termination and\n synchronization.  One can spawn a thread to execute any statement.\n The spawned thread shares with its parent its environment at creation time.\n Threads can be synchronized via a join command which blocks the current thread\n until the joined thread completes, via re-entrant locks which can be acquired\n and released, as well as through rendezvous commands.\n-\\end{itemize}\n+\n+\n Like in many other languages, some of SIMPLE's constructs can be\n desugared into a smaller set of basic constructs.  We do that at the end\n of the syntax module, and then we only give semantics to the core constructs.\n \n-\\paragraph{Note:}{\n-This definition is commented slightly more than others, because it is\n+__Note__: This definition is commented slightly more than others, because it is\n intended to be one of the first non-trivial definitions that the new\n-user of \\K sees.  We recommend the beginner user to first check the\n-language definitions discussed in the \\K tutorial.} */\n+user of **K** sees.  We recommend the beginner user to first check the\n+language definitions discussed in the **K** tutorial.\n \n+```k\n module SIMPLE-UNTYPED-SYNTAX\n   imports DOMAINS-SYNTAX\n+```\n \n-/*@ \\section{Syntax}\n+### Syntax\n We start by defining the SIMPLE syntax.  The language constructs discussed\n-above have the expected syntax and evaluation strategies.  Recall that in \\K\n+above have the expected syntax and evaluation strategies.  Recall that in **K**\n we annotate the syntax with appropriate strictness attributes, thus giving\n-each language construct the desired evaluation strategy. */\n+each language construct the desired evaluation strategy.\n \n-/*@ \\subsection{Identifiers}\n-Recall from the \\K tutorial that identifiers are builtin and come under the\n-syntactic category \\textit{Id}.  The special identifier for the function\n-``main'' belongs to all programs, and plays a special role in the semantics,\n+### Identifiers\n+Recall from the **K** tutorial that identifiers are builtin and come under the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgxODA3OnYy", "diffSide": "RIGHT", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozOToyMVrOG85Jpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozOToyMVrOG85Jpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNDEwMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Declarations\n          \n          \n            \n            There are two types of declarations: for variables (including arrays) and\n          \n          \n            \n            ### Declarations\n          \n          \n            \n            \n          \n          \n            \n            There are two types of declarations: for variables (including arrays) and\n          \n      \n    \n    \n  \n\nI'm going to stop marking this, but please fix them all.", "url": "https://github.com/kframework/k/pull/1486#discussion_r466504103", "createdAt": "2020-08-06T15:39:21Z", "author": {"login": "ehildenb"}, "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.\n-\\item Functions and function values.  Functions can have zero or\n-more parameters and can return abruptly using a \\texttt{return} statement.\n+\n+* Functions and function values.  Functions can have zero or\n+more parameters and can return abruptly using a `return` statement.\n SIMPLE follows a call-by-value parameter passing style, with static scoping.\n Function names evaluate to function abstractions, which hereby become ordinary\n values in the language, same like the array references.\n-\\item Blocks with locals.  SIMPLE variables can be declared\n+\n+* Blocks with locals.  SIMPLE variables can be declared\n anywhere, their scope being from the place where they are declared\n until the end of the most nested enclosing block.\n-\\item Input/Output.  The expression \\texttt{read()} evaluates to the\n-next value in the input buffer, and the statement \\texttt{write(e)}\n-evaluates \\texttt{e} and outputs its value to the output buffer.  The\n+\n+* Input/Output.  The expression `read()` evaluates to the\n+next value in the input buffer, and the statement `write(e)`\n+evaluates `e` and outputs its value to the output buffer.  The\n input and output buffers are lists of values.\n-\\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n+\n+* Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n an exception can be caught and bound).\n-\\item Concurrency via dynamic thread creation/termination and\n+\n+* Concurrency via dynamic thread creation/termination and\n synchronization.  One can spawn a thread to execute any statement.\n The spawned thread shares with its parent its environment at creation time.\n Threads can be synchronized via a join command which blocks the current thread\n until the joined thread completes, via re-entrant locks which can be acquired\n and released, as well as through rendezvous commands.\n-\\end{itemize}\n+\n+\n Like in many other languages, some of SIMPLE's constructs can be\n desugared into a smaller set of basic constructs.  We do that at the end\n of the syntax module, and then we only give semantics to the core constructs.\n \n-\\paragraph{Note:}{\n-This definition is commented slightly more than others, because it is\n+__Note__: This definition is commented slightly more than others, because it is\n intended to be one of the first non-trivial definitions that the new\n-user of \\K sees.  We recommend the beginner user to first check the\n-language definitions discussed in the \\K tutorial.} */\n+user of **K** sees.  We recommend the beginner user to first check the\n+language definitions discussed in the **K** tutorial.\n \n+```k\n module SIMPLE-UNTYPED-SYNTAX\n   imports DOMAINS-SYNTAX\n+```\n \n-/*@ \\section{Syntax}\n+### Syntax\n We start by defining the SIMPLE syntax.  The language constructs discussed\n-above have the expected syntax and evaluation strategies.  Recall that in \\K\n+above have the expected syntax and evaluation strategies.  Recall that in **K**\n we annotate the syntax with appropriate strictness attributes, thus giving\n-each language construct the desired evaluation strategy. */\n+each language construct the desired evaluation strategy.\n \n-/*@ \\subsection{Identifiers}\n-Recall from the \\K tutorial that identifiers are builtin and come under the\n-syntactic category \\textit{Id}.  The special identifier for the function\n-``main'' belongs to all programs, and plays a special role in the semantics,\n+### Identifiers\n+Recall from the **K** tutorial that identifiers are builtin and come under the\n+syntactic category `Id`.  The special identifier for the function\n+`main` belongs to all programs, and plays a special role in the semantics,\n so we declare it explicitly.  This would not be necessary if the identifiers\n were all included automatically in semantic definitions, but that is not\n-possible because of parsing reasons (e.g., \\K variables used to match\n+possible because of parsing reasons (e.g., **K** variables used to match\n concrete identifiers would then be ambiguously parsed as identifiers).  They\n are only included in the parser generated to parse programs (and used by the\n-\\texttt{kast} tool).  Consequently, we have to explicitly declare all the\n+`kast` tool).  Consequently, we have to explicitly declare all the\n concrete identifiers that play a special role in the semantics, like\n-\\texttt{main} below. */\n+`main` below.\n \n+```k\n   syntax Id ::= \"main\" [token]\n+```\n \n-/*@ \\subsection{Declarations}\n+### Declarations\n There are two types of declarations: for variables (including arrays) and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgxOTkxOnYy", "diffSide": "RIGHT", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozOTo0MlrOG85Kvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozOTo0MlrOG85Kvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNDM4Mg==", "bodyText": "Blank lines after codeblocks too please\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```\n          \n          \n            \n            ### Expressions\n          \n          \n            \n            ```\n          \n          \n            \n            \n          \n          \n            \n            ### Expressions", "url": "https://github.com/kframework/k/pull/1486#discussion_r466504382", "createdAt": "2020-08-06T15:39:42Z", "author": {"login": "ehildenb"}, "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.\n-\\item Functions and function values.  Functions can have zero or\n-more parameters and can return abruptly using a \\texttt{return} statement.\n+\n+* Functions and function values.  Functions can have zero or\n+more parameters and can return abruptly using a `return` statement.\n SIMPLE follows a call-by-value parameter passing style, with static scoping.\n Function names evaluate to function abstractions, which hereby become ordinary\n values in the language, same like the array references.\n-\\item Blocks with locals.  SIMPLE variables can be declared\n+\n+* Blocks with locals.  SIMPLE variables can be declared\n anywhere, their scope being from the place where they are declared\n until the end of the most nested enclosing block.\n-\\item Input/Output.  The expression \\texttt{read()} evaluates to the\n-next value in the input buffer, and the statement \\texttt{write(e)}\n-evaluates \\texttt{e} and outputs its value to the output buffer.  The\n+\n+* Input/Output.  The expression `read()` evaluates to the\n+next value in the input buffer, and the statement `write(e)`\n+evaluates `e` and outputs its value to the output buffer.  The\n input and output buffers are lists of values.\n-\\item Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n+\n+* Exceptions.  SIMPLE has parametric exceptions (the value thrown as\n an exception can be caught and bound).\n-\\item Concurrency via dynamic thread creation/termination and\n+\n+* Concurrency via dynamic thread creation/termination and\n synchronization.  One can spawn a thread to execute any statement.\n The spawned thread shares with its parent its environment at creation time.\n Threads can be synchronized via a join command which blocks the current thread\n until the joined thread completes, via re-entrant locks which can be acquired\n and released, as well as through rendezvous commands.\n-\\end{itemize}\n+\n+\n Like in many other languages, some of SIMPLE's constructs can be\n desugared into a smaller set of basic constructs.  We do that at the end\n of the syntax module, and then we only give semantics to the core constructs.\n \n-\\paragraph{Note:}{\n-This definition is commented slightly more than others, because it is\n+__Note__: This definition is commented slightly more than others, because it is\n intended to be one of the first non-trivial definitions that the new\n-user of \\K sees.  We recommend the beginner user to first check the\n-language definitions discussed in the \\K tutorial.} */\n+user of **K** sees.  We recommend the beginner user to first check the\n+language definitions discussed in the **K** tutorial.\n \n+```k\n module SIMPLE-UNTYPED-SYNTAX\n   imports DOMAINS-SYNTAX\n+```\n \n-/*@ \\section{Syntax}\n+### Syntax\n We start by defining the SIMPLE syntax.  The language constructs discussed\n-above have the expected syntax and evaluation strategies.  Recall that in \\K\n+above have the expected syntax and evaluation strategies.  Recall that in **K**\n we annotate the syntax with appropriate strictness attributes, thus giving\n-each language construct the desired evaluation strategy. */\n+each language construct the desired evaluation strategy.\n \n-/*@ \\subsection{Identifiers}\n-Recall from the \\K tutorial that identifiers are builtin and come under the\n-syntactic category \\textit{Id}.  The special identifier for the function\n-``main'' belongs to all programs, and plays a special role in the semantics,\n+### Identifiers\n+Recall from the **K** tutorial that identifiers are builtin and come under the\n+syntactic category `Id`.  The special identifier for the function\n+`main` belongs to all programs, and plays a special role in the semantics,\n so we declare it explicitly.  This would not be necessary if the identifiers\n were all included automatically in semantic definitions, but that is not\n-possible because of parsing reasons (e.g., \\K variables used to match\n+possible because of parsing reasons (e.g., **K** variables used to match\n concrete identifiers would then be ambiguously parsed as identifiers).  They\n are only included in the parser generated to parse programs (and used by the\n-\\texttt{kast} tool).  Consequently, we have to explicitly declare all the\n+`kast` tool).  Consequently, we have to explicitly declare all the\n concrete identifiers that play a special role in the semantics, like\n-\\texttt{main} below. */\n+`main` below.\n \n+```k\n   syntax Id ::= \"main\" [token]\n+```\n \n-/*@ \\subsection{Declarations}\n+### Declarations\n There are two types of declarations: for variables (including arrays) and\n for functions.  We are going to allow declarations of the form\n-``\\texttt{var x=10, a[10,10], y=23;}'', which is why we allow the \\texttt{var}\n+`var x=10, a[10,10], y=23;`, which is why we allow the `var`\n keyword to take a list of expressions.  The non-terminals used in the two\n-productions below are defined shortly. */\n+productions below are defined shortly.\n \n+```k\n   syntax Decl ::= \"var\" Exps \";\"\n                 | \"function\" Id \"(\" Ids \")\" Block\n-\n-/*@ \\subsection{Expressions}\n-The expression constructs below are standard.  Increment (\\texttt{++}) takes\n+```\n+### Expressions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgzMTA3OnYy", "diffSide": "RIGHT", "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo0MjowNlrOG85RiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo0MjoyM1rOG85SOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNjEyMQ==", "bodyText": "I prefer bullet lists to be indented more like this (for readability/scanability):\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Multidimensional arrays and array references.  An array evaluates\n          \n          \n            \n            to an array reference, which is a special value holding a location (where\n          \n          \n            \n            the elements of the array start) together with the size of the array;\n          \n          \n            \n            the elements of the array can be array references themselves (particularly\n          \n          \n            \n            when the array is multi-dimensional).  Array references are ordinary values,\n          \n          \n            \n            so they can be assigned to variables and passed/received by functions.\n          \n          \n            \n            * Multidimensional arrays and array references.  An array evaluates\n          \n          \n            \n              to an array reference, which is a special value holding a location (where\n          \n          \n            \n              the elements of the array start) together with the size of the array;\n          \n          \n            \n              the elements of the array can be array references themselves (particularly\n          \n          \n            \n              when the array is multi-dimensional).  Array references are ordinary values,\n          \n          \n            \n              so they can be assigned to variables and passed/received by functions.", "url": "https://github.com/kframework/k/pull/1486#discussion_r466506121", "createdAt": "2020-08-06T15:42:06Z", "author": {"login": "ehildenb"}, "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNjI5Nw==", "bodyText": "I would also prefer four spaces instead of 2, but up to you.", "url": "https://github.com/kframework/k/pull/1486#discussion_r466506297", "createdAt": "2020-08-06T15:42:23Z", "author": {"login": "ehildenb"}, "path": "k-distribution/tutorial/2_languages/1_simple/1_untyped/simple-untyped.md", "diffHunk": "@@ -1,114 +1,129 @@\n-// Copyright (c) 2014-2019 K Team. All Rights Reserved.\n+---\n+copyright: Copyright (c) 2014-2020 K Team. All Rights Reserved.\n+---\n \n-/*!\n-\\title{SIMPLE --- Untyped}\n-\\author{Grigore Ro\\c{s}u and Traian Florin \\c{S}erb\\u{a}nu\\c{t}\\u{a}\n-        (\\texttt{\\{grosu,tserban2\\}@illinois.edu})}\n-\\organization{University of Illinois at Urbana-Champaign}\n-*/\n+SIMPLE \u2014 Untyped\n+================\n \n-/*@ \\section{Abstract}\n-This is the \\K semantic definition of the untyped SIMPLE language.\n+Author: Grigore Ro\u0219u (grosu@illinois.edu)  \n+Organization: University of Illinois at Urbana-Champaign\n+\n+Author: Traian Florin \u0218erb\u0103nu\u021b\u0103 (traian.serbanuta@unibuc.ro)  \n+Organization: University of Bucharest\n+\n+\n+### Abstract\n+This is the **K** semantic definition of the untyped SIMPLE language.\n SIMPLE is intended to be a pedagogical and research language that captures\n the essence of the imperative programming paradigm, extended with several\n features often encountered in imperative programming languages.\n A program consists of a set of global variable declarations and\n function definitions.  Like in C, function definitions cannot be\n-nested and each program must have one function called \\texttt{main},\n+nested and each program must have one function called `main`,\n which is invoked when the program is executed.  To make it more\n-interesting and to highlight some of \\K's strengths, SIMPLE includes\n+interesting and to highlight some of **K**'s strengths, SIMPLE includes\n the following features in addition to the conventional imperative\n expression and statement constructs:\n-\\begin{itemize}\n-\\item Multidimensional arrays and array references.  An array evaluates\n+\n+* Multidimensional arrays and array references.  An array evaluates\n to an array reference, which is a special value holding a location (where\n the elements of the array start) together with the size of the array;\n the elements of the array can be array references themselves (particularly\n when the array is multi-dimensional).  Array references are ordinary values,\n so they can be assigned to variables and passed/received by functions.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNjEyMQ=="}, "originalCommit": {"oid": "2992ff851da565dedcd5bbf4fea46de749b0e576"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3010, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}