{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMDY0NTg2", "number": 1202, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDoyMDoyOFrODwjXJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODoyMzo0NlrODw0u7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMjM3NjA1OnYy", "diffSide": "RIGHT", "path": "k-distribution/include/builtin/domains.k", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMDoyMDoyOFrOGDoArA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjoyNjozOVrOGD5Jcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NDQ0NA==", "bodyText": "Why are we retaining these rules for the Haskell backend?", "url": "https://github.com/kframework/k/pull/1202#discussion_r406454444", "createdAt": "2020-04-09T20:20:28Z", "author": {"login": "ttuegel"}, "path": "k-distribution/include/builtin/domains.k", "diffHunk": "@@ -177,11 +178,20 @@ module MAP-SYMBOLIC [symbolic]\n   // potential infinite loop\n   // rule (MAP:Map [ K1 <- V1 ]) [ K2 <- V2 ] => MAP [ K2 <- V2 ] [ K1 <- V1 ] requires K1 =/=K K2\n \n-  rule K1 in_keys(M K2 |-> _) => true          requires K1  ==K K2 orBool K1 in_keys(M)\n-  rule K1 in_keys(M K2 |-> _) => K1 in_keys(M) requires K1 =/=K K2\n+  rule K in_keys(M K |-> _) => true\n+  rule K in_keys(_) => false [owise]\n+\n+  rule K1 in_keys(M K2 |-> _) => true          requires K1  ==K K2 orBool K1 in_keys(M) [simplification]\n+  rule K1 in_keys(M K2 |-> _) => K1 in_keys(M) requires K1 =/=K K2 [simplification]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMTIyNw==", "bodyText": "Well, I figured that since the Java engine still needs to work, we must keep these around.\nOne way to exclude them from the Haskell backend all-together would be to put them into a module which has attributes symbolic and kast, which would make it acceptable to the Java backend but excluded from the Haskell backend.  I'll try and do that.", "url": "https://github.com/kframework/k/pull/1202#discussion_r406721227", "createdAt": "2020-04-10T11:41:12Z", "author": {"login": "traiansf"}, "path": "k-distribution/include/builtin/domains.k", "diffHunk": "@@ -177,11 +178,20 @@ module MAP-SYMBOLIC [symbolic]\n   // potential infinite loop\n   // rule (MAP:Map [ K1 <- V1 ]) [ K2 <- V2 ] => MAP [ K2 <- V2 ] [ K1 <- V1 ] requires K1 =/=K K2\n \n-  rule K1 in_keys(M K2 |-> _) => true          requires K1  ==K K2 orBool K1 in_keys(M)\n-  rule K1 in_keys(M K2 |-> _) => K1 in_keys(M) requires K1 =/=K K2\n+  rule K in_keys(M K |-> _) => true\n+  rule K in_keys(_) => false [owise]\n+\n+  rule K1 in_keys(M K2 |-> _) => true          requires K1  ==K K2 orBool K1 in_keys(M) [simplification]\n+  rule K1 in_keys(M K2 |-> _) => K1 in_keys(M) requires K1 =/=K K2 [simplification]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NDQ0NA=="}, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNTIxOQ==", "bodyText": "I've completely separated the existing symbolic part from the Haskell part. We can decide later whether we want to share some of the rules or not.", "url": "https://github.com/kframework/k/pull/1202#discussion_r406735219", "createdAt": "2020-04-10T12:26:39Z", "author": {"login": "traiansf"}, "path": "k-distribution/include/builtin/domains.k", "diffHunk": "@@ -177,11 +178,20 @@ module MAP-SYMBOLIC [symbolic]\n   // potential infinite loop\n   // rule (MAP:Map [ K1 <- V1 ]) [ K2 <- V2 ] => MAP [ K2 <- V2 ] [ K1 <- V1 ] requires K1 =/=K K2\n \n-  rule K1 in_keys(M K2 |-> _) => true          requires K1  ==K K2 orBool K1 in_keys(M)\n-  rule K1 in_keys(M K2 |-> _) => K1 in_keys(M) requires K1 =/=K K2\n+  rule K in_keys(M K |-> _) => true\n+  rule K in_keys(_) => false [owise]\n+\n+  rule K1 in_keys(M K2 |-> _) => true          requires K1  ==K K2 orBool K1 in_keys(M) [simplification]\n+  rule K1 in_keys(M K2 |-> _) => K1 in_keys(M) requires K1 =/=K K2 [simplification]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ1NDQ0NA=="}, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzAxNTI2OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMDo1MTo0MFrOGDt87A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwODowNDo0NlrOGEfxmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTc4OA==", "bodyText": "What's going on with the pairs of set and element variables?", "url": "https://github.com/kframework/k/pull/1202#discussion_r406551788", "createdAt": "2020-04-10T00:51:40Z", "author": {"login": "ttuegel"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMTQ0Nw==", "bodyText": "the element variables are used for the in_keys rules. The set variables are used for the ceil rules.", "url": "https://github.com/kframework/k/pull/1202#discussion_r406721447", "createdAt": "2020-04-10T11:41:59Z", "author": {"login": "traiansf"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTc4OA=="}, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg5NjgyMQ==", "bodyText": "I find it difficult to follow how the rules are constructed because the construction of the rules is interleaved in this way, but it's not difficult enough that I'm going to hold up this pull request.", "url": "https://github.com/kframework/k/pull/1202#discussion_r406896821", "createdAt": "2020-04-10T18:58:49Z", "author": {"login": "ttuegel"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTc4OA=="}, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM2ODA4OQ==", "bodyText": "I've refactored the code and added comments with the rules. hope it is clearer now.", "url": "https://github.com/kframework/k/pull/1202#discussion_r407368089", "createdAt": "2020-04-13T08:04:46Z", "author": {"login": "traiansf"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTc4OA=="}, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzAxNTkyOnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMDo1MjowN1rOGDt9SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwMDo1MjowN1rOGDt9SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTg4MQ==", "bodyText": "Should the #Ceil and #And constants be defined somewhere?", "url": "https://github.com/kframework/k/pull/1202#discussion_r406551881", "createdAt": "2020-04-10T00:52:07Z", "author": {"login": "ttuegel"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));\n+        Sort sortParam = Sort(AddSortInjections.SORTPARAM_NAME, Sort(\"Q\"));\n+        KLabel ceilMapLabel = KLabel(\"#Ceil\", mapSort, sortParam);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNDA4MjQ5OnYy", "diffSide": "RIGHT", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDo1NTozNlrOGD3hdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMTo0NToyNlrOGD4XWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODU5Nw==", "bodyText": "What is the anywhere for?", "url": "https://github.com/kframework/k/pull/1202#discussion_r406708597", "createdAt": "2020-04-10T10:55:36Z", "author": {"login": "ttuegel"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));\n+        Sort sortParam = Sort(AddSortInjections.SORTPARAM_NAME, Sort(\"Q\"));\n+        KLabel ceilMapLabel = KLabel(\"#Ceil\", mapSort, sortParam);\n+        KLabel andLabel = KLabel(\"#And\", sortParam);\n+        K setArgsCeil = KApply(ceilMapLabel, restMapSet);\n+        for (int i = 0; i< nonterminals.length(); i++) {\n+            Sort sort = nonterminals.apply(i).sort();\n+            args.add(KVariable(\"K\" + i, Att.empty().add(Sort.class, sort)));\n+            KVariable setVar = KVariable(\"@K\" + i, Att.empty().add(Sort.class, sort));\n+            setArgs.add(setVar);\n+            KLabel ceilVarLabel = KLabel(\"#Ceil\", sort, sortParam);\n+            setArgsCeil = KApply(andLabel, setArgsCeil, KApply(ceilVarLabel, setVar));\n+        }\n+        Seq<K> argsSeq = JavaConverters.iterableAsScalaIterable(args).toSeq();\n+        Seq<K> setArgsSeq = JavaConverters.iterableAsScalaIterable(setArgs).toSeq();\n+        Rule inKeysRule1 = Rule(\n+                KRewrite(\n+                        KApply(prod.klabel().get(),\n+                                args.get(0),\n+                                KApply(concatProd.klabel().get(),\n+                                        KApply(elementProd.klabel().get(),\n+                                                argsSeq,\n+                                                Att.empty()\n+                                        ),\n+                                        restMap\n+                                )\n+                        ),\n+                        BooleanUtils.TRUE\n+                ),\n+                BooleanUtils.TRUE,\n+                BooleanUtils.TRUE\n+        );\n+        rules.add(inKeysRule1);\n+        Rule inKeysRule2 = Rule(\n+                KRewrite(\n+                        KApply(prod.klabel().get(),\n+                                args.get(0),\n+                                restMap\n+                        ),\n+                        BooleanUtils.FALSE\n+                ),\n+                BooleanUtils.TRUE,\n+                BooleanUtils.TRUE,\n+                Att.empty().add(\"owise\")\n+        );\n+        rules.add(inKeysRule2);\n+        KLabel equalsLabel = KLabel(\"#Equals\", Sorts.Bool(), sortParam);\n+        Rule ceilMapRule =\n+                Rule(\n+                        KRewrite(\n+                                KApply(ceilMapLabel,\n+                                        KApply(concatProd.klabel().get(),\n+                                                KApply(elementProd.klabel().get(),\n+                                                        setArgsSeq,\n+                                                        Att.empty()\n+                                                ),\n+                                                restMapSet\n+                                        )\n+                                )\n+                                ,\n+                                KApply(andLabel,\n+                                        KApply(equalsLabel,\n+                                                KApply(prod.klabel().get(),\n+                                                        setArgs.get(0),\n+                                                        restMapSet\n+                                                ),\n+                                                BooleanUtils.FALSE\n+                                        ),\n+                                        setArgsCeil\n+                                )\n+                        )\n+                        , BooleanUtils.TRUE\n+                        , BooleanUtils.TRUE\n+                        , Att.empty().add(\"anywhere\").add(\"simplification\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMjM5Mw==", "bodyText": "That's awkward, but since #Ceil is not a function, we usually need to annotate #Ceil rules with anywhere to prevent them from being completed with <k> and stuff. Maybe here I didn't need to add them, as we're late in the compilation process, but I added them for consistency.", "url": "https://github.com/kframework/k/pull/1202#discussion_r406722393", "createdAt": "2020-04-10T11:45:26Z", "author": {"login": "traiansf"}, "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));\n+        Sort sortParam = Sort(AddSortInjections.SORTPARAM_NAME, Sort(\"Q\"));\n+        KLabel ceilMapLabel = KLabel(\"#Ceil\", mapSort, sortParam);\n+        KLabel andLabel = KLabel(\"#And\", sortParam);\n+        K setArgsCeil = KApply(ceilMapLabel, restMapSet);\n+        for (int i = 0; i< nonterminals.length(); i++) {\n+            Sort sort = nonterminals.apply(i).sort();\n+            args.add(KVariable(\"K\" + i, Att.empty().add(Sort.class, sort)));\n+            KVariable setVar = KVariable(\"@K\" + i, Att.empty().add(Sort.class, sort));\n+            setArgs.add(setVar);\n+            KLabel ceilVarLabel = KLabel(\"#Ceil\", sort, sortParam);\n+            setArgsCeil = KApply(andLabel, setArgsCeil, KApply(ceilVarLabel, setVar));\n+        }\n+        Seq<K> argsSeq = JavaConverters.iterableAsScalaIterable(args).toSeq();\n+        Seq<K> setArgsSeq = JavaConverters.iterableAsScalaIterable(setArgs).toSeq();\n+        Rule inKeysRule1 = Rule(\n+                KRewrite(\n+                        KApply(prod.klabel().get(),\n+                                args.get(0),\n+                                KApply(concatProd.klabel().get(),\n+                                        KApply(elementProd.klabel().get(),\n+                                                argsSeq,\n+                                                Att.empty()\n+                                        ),\n+                                        restMap\n+                                )\n+                        ),\n+                        BooleanUtils.TRUE\n+                ),\n+                BooleanUtils.TRUE,\n+                BooleanUtils.TRUE\n+        );\n+        rules.add(inKeysRule1);\n+        Rule inKeysRule2 = Rule(\n+                KRewrite(\n+                        KApply(prod.klabel().get(),\n+                                args.get(0),\n+                                restMap\n+                        ),\n+                        BooleanUtils.FALSE\n+                ),\n+                BooleanUtils.TRUE,\n+                BooleanUtils.TRUE,\n+                Att.empty().add(\"owise\")\n+        );\n+        rules.add(inKeysRule2);\n+        KLabel equalsLabel = KLabel(\"#Equals\", Sorts.Bool(), sortParam);\n+        Rule ceilMapRule =\n+                Rule(\n+                        KRewrite(\n+                                KApply(ceilMapLabel,\n+                                        KApply(concatProd.klabel().get(),\n+                                                KApply(elementProd.klabel().get(),\n+                                                        setArgsSeq,\n+                                                        Att.empty()\n+                                                ),\n+                                                restMapSet\n+                                        )\n+                                )\n+                                ,\n+                                KApply(andLabel,\n+                                        KApply(equalsLabel,\n+                                                KApply(prod.klabel().get(),\n+                                                        setArgs.get(0),\n+                                                        restMapSet\n+                                                ),\n+                                                BooleanUtils.FALSE\n+                                        ),\n+                                        setArgsCeil\n+                                )\n+                        )\n+                        , BooleanUtils.TRUE\n+                        , BooleanUtils.TRUE\n+                        , Att.empty().add(\"anywhere\").add(\"simplification\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODU5Nw=="}, "originalCommit": {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNTIyMjIyOnYy", "diffSide": "RIGHT", "path": "k-distribution/include/builtin/domains.k", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxODoyMzo0NlrOGECJpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNzo0Mjo1MlrOGEfWzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4MjcyNA==", "bodyText": "Why isn't _[_ <- _] simply functional?", "url": "https://github.com/kframework/k/pull/1202#discussion_r406882724", "createdAt": "2020-04-10T18:23:46Z", "author": {"login": "ttuegel"}, "path": "k-distribution/include/builtin/domains.k", "diffHunk": "@@ -158,7 +158,32 @@ module MAP\n   syntax KItem ::= choice(Map)                      [function, hook(MAP.choice), klabel(Map:choice)]\n endmodule\n \n-module MAP-SYMBOLIC [symbolic]\n+module MAP-KORE-SYMBOLIC [kore,symbolic]\n+  imports MAP\n+\n+  rule K:KItem in_keys(M:Map K |-> _) => true\n+  rule K:KItem in_keys(_:Map) => false [owise]\n+\n+  rule\n+    #Ceil(@M:Map (@K:KItem |-> @V:KItem))\n+  =>\n+    {(@K in_keys(@M)) #Equals false} #And #Ceil(@M) #And #Ceil(@K) #And #Ceil(@V)\n+  [anywhere, simplification]\n+\n+   rule\n+     #Ceil(@M:Map [@K:KItem])\n+   =>\n+     {(@K in_keys(@M)) #Equals true} #And #Ceil(@M) #And #Ceil(@K)\n+   [anywhere, simplification]\n+\n+  rule", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9100cce53332687287b87d33fbe809040dac45e8"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM2MTIzMA==", "bodyText": "You're right. _[_ <- _] is already functional. the rule is not necessary.", "url": "https://github.com/kframework/k/pull/1202#discussion_r407361230", "createdAt": "2020-04-13T07:42:52Z", "author": {"login": "traiansf"}, "path": "k-distribution/include/builtin/domains.k", "diffHunk": "@@ -158,7 +158,32 @@ module MAP\n   syntax KItem ::= choice(Map)                      [function, hook(MAP.choice), klabel(Map:choice)]\n endmodule\n \n-module MAP-SYMBOLIC [symbolic]\n+module MAP-KORE-SYMBOLIC [kore,symbolic]\n+  imports MAP\n+\n+  rule K:KItem in_keys(M:Map K |-> _) => true\n+  rule K:KItem in_keys(_:Map) => false [owise]\n+\n+  rule\n+    #Ceil(@M:Map (@K:KItem |-> @V:KItem))\n+  =>\n+    {(@K in_keys(@M)) #Equals false} #And #Ceil(@M) #And #Ceil(@K) #And #Ceil(@V)\n+  [anywhere, simplification]\n+\n+   rule\n+     #Ceil(@M:Map [@K:KItem])\n+   =>\n+     {(@K in_keys(@M)) #Equals true} #And #Ceil(@M) #And #Ceil(@K)\n+   [anywhere, simplification]\n+\n+  rule", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4MjcyNA=="}, "originalCommit": {"oid": "9100cce53332687287b87d33fbe809040dac45e8"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3107, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}