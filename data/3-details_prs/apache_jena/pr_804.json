{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2MjU0MzUy", "number": 804, "title": "JENA-1974: G, a library of functions for working with Graph.", "bodyText": "\"G\" is a set of functions for working with Graph at the detail triple level.\nIt packages up the checking needed around, for example, \"getOne\" when the code is expecting exactly one match, not zero, not several. It is taken from original use in jena-shacl but is itself generally useful when working in Java walking data in graphs.\nThere are some operations that are RDFS aware - these would be applicable for when RDFS reasoning is not enabled (in SHACL, certain parts of RDFS are required like transitive subclass but not full RDFS reasoning).", "createdAt": "2020-10-01T13:20:10Z", "url": "https://github.com/apache/jena/pull/804", "merged": true, "mergeCommit": {"oid": "65d571cfdf5ce3257fea29aa6996b31ecb43da3a"}, "closed": true, "closedAt": "2020-10-05T20:14:20Z", "author": {"login": "afs"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOR-MzAFqTUwMDM4NjE1MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdPh4D6ABqjM4Mzk4NzY3NDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMzg2MTUx", "url": "https://github.com/apache/jena/pull/804#pullrequestreview-500386151", "createdAt": "2020-10-01T14:08:30Z", "commit": {"oid": "2e29a2e34a35bf63f1c574596abfdc658db3f529"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDowODozMFrOHbMK-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDowODozMFrOHbMK-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA==", "bodyText": "Could be more efficient without counting all triples, e.g.\ntry (ExtendedIterator<Triple> it = g.find(s, p, null) {\n  if (!it.hasNext()) {\n     return false;\n  }\n  it.next();\n  return !it.hasNext();\n}", "url": "https://github.com/apache/jena/pull/804#discussion_r498273018", "createdAt": "2020-10-01T14:08:30Z", "author": {"login": "strangepleasures"}, "path": "jena-arq/src/main/java/org/apache/jena/riot/other/G.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.riot.other;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import org.apache.jena.atlas.iterator.Iter;\n+import org.apache.jena.graph.Graph;\n+import org.apache.jena.graph.GraphUtil;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.riot.out.NodeFmtLib;\n+//import org.apache.jena.shacl.lib.GN;\n+//import org.apache.jena.shacl.lib.RDFDataException;\n+//import org.apache.jena.shacl.lib.Transitive;\n+//import org.apache.jena.shacl.sys.C;\n+import org.apache.jena.sparql.core.Quad;\n+import org.apache.jena.sparql.graph.NodeConst;\n+import org.apache.jena.sparql.util.graph.GNode;\n+import org.apache.jena.sparql.util.graph.GraphList;\n+import org.apache.jena.util.iterator.ExtendedIterator;\n+\n+/** A library of functions for working with {@link Graph}. */\n+public class G {\n+    private G() {}\n+    private static Node rdfType = NodeConst.nodeRDFType;\n+\n+    /** Return the subject of a triple, or null if the triple is null. */\n+    public static Node subject(Triple triple) {\n+        return triple == null ? null : triple.getSubject();\n+    }\n+\n+    /** Return the predicate of a triple, or null if the triple is null. */\n+    public static Node predicate(Triple triple) {\n+        return triple == null ? null : triple.getPredicate();\n+    }\n+\n+    /** Return the object of a triple, or null if the triple is null. */\n+    public static Node object(Triple triple) {\n+        return triple == null ? null : triple.getObject();\n+    }\n+\n+    // ---- Node filter tests.\n+    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n+    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n+    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n+    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n+\n+    /** Convert null to Node.ANY */\n+    public static Node nullAsAny(Node x) { return nullAsDft(x, Node.ANY) ; }\n+\n+    /** Convert null to some default Node */\n+    public static Node nullAsDft(Node x, Node dft) { return x==null ? dft : x ; }\n+\n+    /** Does the graph match the s/p/o pattern? */ \n+    public static boolean contains(Graph g, Node s, Node p, Node o) {\n+        return g.contains(s, p, o);\n+    }\n+    \n+    /** Does the graph use the node anywhere as a subject, predicate or object? */\n+    public static boolean containsNode(Graph graph, Node node) {\n+        return GraphUtil.containsNode(graph, node);\n+//        return\n+//            contains(graph, node, Node.ANY, Node.ANY) ||\n+//            contains(graph, Node.ANY, Node.ANY, node) ||\n+//            contains(graph, Node.ANY, node, Node.ANY) ;\n+    }\n+    \n+    /** Test whether the node has the type or is rdfs:subclassOf. */\n+    public static boolean isOfType(Graph graph, Node x, Node type) {\n+        Objects.requireNonNull(x, \"Subject\");\n+        Objects.requireNonNull(type, \"Type\");\n+        List<Node> allClasses = listSubClasses(graph, type);\n+        for ( Node c : allClasses ) {\n+            if ( hasType(graph, x, c) )\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /** Does the node x have the given type (non-RDFS - no rdfs:subclassOf considered)? */ \n+    public static boolean hasType(Graph graph, Node x, Node type) {\n+        Objects.requireNonNull(x, \"Subject\");\n+        Objects.requireNonNull(type, \"Type\");\n+        return contains(graph, x, NodeConst.nodeRDFType, type);\n+    }\n+\n+    //---- get/list/iter\n+\n+    /** Does node {@code s} have property {@code p} in graph {@code g}? */\n+    public static boolean hasProperty(Graph g, Node s, Node p) {\n+        return g.contains(s, p, null);\n+    }\n+\n+    /** Contains exactly one. */\n+    public static boolean containsOne(Graph g, Node s, Node p, Node o) {\n+        return g.contains(s, p, o) && Iter.count(g.find(s,p,null)) == 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e29a2e34a35bf63f1c574596abfdc658db3f529"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMzg5NzMw", "url": "https://github.com/apache/jena/pull/804#pullrequestreview-500389730", "createdAt": "2020-10-01T14:11:55Z", "commit": {"oid": "2e29a2e34a35bf63f1c574596abfdc658db3f529"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoxMTo1NlrOHbMVBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDoxMTo1NlrOHbMVBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3NTU5MA==", "bodyText": "How about isNodeTriple?", "url": "https://github.com/apache/jena/pull/804#discussion_r498275590", "createdAt": "2020-10-01T14:11:56Z", "author": {"login": "strangepleasures"}, "path": "jena-arq/src/main/java/org/apache/jena/riot/other/G.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.riot.other;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import org.apache.jena.atlas.iterator.Iter;\n+import org.apache.jena.graph.Graph;\n+import org.apache.jena.graph.GraphUtil;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.riot.out.NodeFmtLib;\n+//import org.apache.jena.shacl.lib.GN;\n+//import org.apache.jena.shacl.lib.RDFDataException;\n+//import org.apache.jena.shacl.lib.Transitive;\n+//import org.apache.jena.shacl.sys.C;\n+import org.apache.jena.sparql.core.Quad;\n+import org.apache.jena.sparql.graph.NodeConst;\n+import org.apache.jena.sparql.util.graph.GNode;\n+import org.apache.jena.sparql.util.graph.GraphList;\n+import org.apache.jena.util.iterator.ExtendedIterator;\n+\n+/** A library of functions for working with {@link Graph}. */\n+public class G {\n+    private G() {}\n+    private static Node rdfType = NodeConst.nodeRDFType;\n+\n+    /** Return the subject of a triple, or null if the triple is null. */\n+    public static Node subject(Triple triple) {\n+        return triple == null ? null : triple.getSubject();\n+    }\n+\n+    /** Return the predicate of a triple, or null if the triple is null. */\n+    public static Node predicate(Triple triple) {\n+        return triple == null ? null : triple.getPredicate();\n+    }\n+\n+    /** Return the object of a triple, or null if the triple is null. */\n+    public static Node object(Triple triple) {\n+        return triple == null ? null : triple.getObject();\n+    }\n+\n+    // ---- Node filter tests.\n+    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n+    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n+    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n+    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2e29a2e34a35bf63f1c574596abfdc658db3f529"}, "originalPosition": 65}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2e29a2e34a35bf63f1c574596abfdc658db3f529", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/2e29a2e34a35bf63f1c574596abfdc658db3f529", "committedDate": "2020-10-01T13:16:02Z", "message": "Function library for working with graphs"}, "afterCommit": {"oid": "5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "committedDate": "2020-10-01T14:50:06Z", "message": "Function library for working with graphs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b13c4c797f870cca9005821e0eca4c05e9ec5e1f", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/b13c4c797f870cca9005821e0eca4c05e9ec5e1f", "committedDate": "2020-10-04T14:20:52Z", "message": "Spelling correction."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e02e499317dd05626d2ef15eb9dd7675a59c4a1", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/7e02e499317dd05626d2ef15eb9dd7675a59c4a1", "committedDate": "2020-10-04T14:20:52Z", "message": "Correct whitespace in compact syntax output of [...]"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "committedDate": "2020-10-01T14:50:06Z", "message": "Function library for working with graphs"}, "afterCommit": {"oid": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "committedDate": "2020-10-04T19:08:45Z", "message": "Mark iterator to stream as immutable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNjg3Mzgx", "url": "https://github.com/apache/jena/pull/804#pullrequestreview-501687381", "createdAt": "2020-10-05T02:04:08Z", "commit": {"oid": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwMjowNDowOFrOHcL5Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwNjowMzo0NFrOHcOkng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMxNzA5NA==", "bodyText": "s/tripel/triple", "url": "https://github.com/apache/jena/pull/804#discussion_r499317094", "createdAt": "2020-10-05T02:04:08Z", "author": {"login": "kinow"}, "path": "jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java", "diffHunk": "@@ -91,6 +94,27 @@ public static Constraint parseSparqlConstraint(Graph shapesGraph, Node shape, No\n             throw new ShaclParseException(\"SPARQL parse error: \"+ex.getMessage()+\"\\n\"+qs);\n         }\n     }\n+    \n+    /**\n+     * Test for zero or one occurrences of a tripel pattern that is expected to be   ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMxNzEyOA==", "bodyText": "s/then/than", "url": "https://github.com/apache/jena/pull/804#discussion_r499317128", "createdAt": "2020-10-05T02:04:22Z", "author": {"login": "kinow"}, "path": "jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java", "diffHunk": "@@ -91,6 +94,27 @@ public static Constraint parseSparqlConstraint(Graph shapesGraph, Node shape, No\n             throw new ShaclParseException(\"SPARQL parse error: \"+ex.getMessage()+\"\\n\"+qs);\n         }\n     }\n+    \n+    /**\n+     * Test for zero or one occurrences of a tripel pattern that is expected to be   \n+     * Returns false for zero, true for one. \n+     * Throws an exception on two or more.\n+     */\n+    private static boolean absentOrOne(Graph g, Node s, Node p, Node o) {\n+        ExtendedIterator<Triple> iter = G.find(g, s, p, null);\n+        try {\n+            if ( ! iter.hasNext() )\n+                return false;\n+            iter.next();\n+            if ( ! iter.hasNext() )\n+                return true;\n+            long x = Iter.count(G.find(g, s, p, null));\n+            throw new ShaclParseException(\"More then one (\" + x + \") of \" + String.format(\"(%s %s %s)\", s, p, o));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MDkyNg==", "bodyText": "Do we have to close iter?", "url": "https://github.com/apache/jena/pull/804#discussion_r499360926", "createdAt": "2020-10-05T06:03:44Z", "author": {"login": "kinow"}, "path": "jena-arq/src/main/java/org/apache/jena/riot/other/G.java", "diffHunk": "@@ -0,0 +1,669 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.riot.other;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import org.apache.jena.atlas.iterator.Iter;\n+import org.apache.jena.graph.*;\n+import org.apache.jena.riot.out.NodeFmtLib;\n+import org.apache.jena.sparql.core.Quad;\n+import org.apache.jena.sparql.graph.NodeConst;\n+import org.apache.jena.sparql.util.graph.GNode;\n+import org.apache.jena.sparql.util.graph.GraphList;\n+import org.apache.jena.util.iterator.ExtendedIterator;\n+\n+/** A library of functions for working with {@link Graph}. */\n+public class G {\n+    private G() {}\n+\n+    private static Node rdfType = NodeConst.nodeRDFType;\n+\n+    /** Return the subject of a triple, or null if the triple is null. */\n+    public static Node subject(Triple triple) {\n+        return triple == null ? null : triple.getSubject();\n+    }\n+\n+    /** Return the predicate of a triple, or null if the triple is null. */\n+    public static Node predicate(Triple triple) {\n+        return triple == null ? null : triple.getPredicate();\n+    }\n+\n+    /** Return the object of a triple, or null if the triple is null. */\n+    public static Node object(Triple triple) {\n+        return triple == null ? null : triple.getObject();\n+    }\n+\n+    // ---- Node filter tests.\n+    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n+    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n+    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n+    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n+    public static boolean isNodeTriple(Node n)  { return n != null && n.isNodeTriple(); }\n+    public static boolean isNodeGraph(Node n)   { return n != null && n.isNodeGraph(); }\n+\n+    /** Convert null to Node.ANY */\n+    public static Node nullAsAny(Node x) { return nullAsDft(x, Node.ANY) ; }\n+\n+    /** Convert null to some default Node */\n+    public static Node nullAsDft(Node x, Node dft) { return x==null ? dft : x ; }\n+\n+    /** Does the graph match the s/p/o pattern? */\n+    public static boolean contains(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return graph.contains(subject, predicate, object);\n+    }\n+\n+    /** Does the graph use the node anywhere as a subject, predicate or object? */\n+    public static boolean containsNode(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        return GraphUtil.containsNode(graph, node);\n+//        return\n+//            contains(graph, node, Node.ANY, Node.ANY) ||\n+//            contains(graph, Node.ANY, Node.ANY, node) ||\n+//            contains(graph, Node.ANY, node, Node.ANY) ;\n+    }\n+\n+    /** Test whether the node has the type or is rdfs:subclassOf. */\n+    public static boolean isOfType(Graph graph, Node node, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> allClasses = listSubClasses(graph, type);\n+        for ( Node c : allClasses ) {\n+            if ( hasType(graph, node, c) )\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /** Does the node x have the given type (non-RDFS - no rdfs:subclassOf considered)? */\n+    public static boolean hasType(Graph graph, Node node, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        Objects.requireNonNull(type, \"type\");\n+        return contains(graph, node, NodeConst.nodeRDFType, type);\n+    }\n+\n+    //---- get/list/iter\n+\n+    /** Does node {@code s} have property {@code p} in graph {@code g}? */\n+    public static boolean hasProperty(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return graph.contains(subject, predicate, null);\n+    }\n+\n+    /** Contains exactly one. */\n+    public static boolean containsOne(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(subject, predicate, object);\n+        try {\n+            if ( ! iter.hasNext() )\n+                return false;\n+            iter.next();\n+            return !iter.hasNext();\n+        } finally { iter.close(); }\n+    }\n+\n+    /**\n+     * Get object, given subject and predicate. Returns one (non-deterministically) or null.\n+     * See also {@link #getOneSP} and {@link #getZeroOrOneSP}.\n+     */\n+    public static Node getSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(first(find(graph, subject, predicate, Node.ANY)));\n+    }\n+\n+    // --- Graph walking.\n+\n+    /**\n+     * Get object for subject-predicate. Must be exactly one object; exception\n+     * {@linkplain RDFDataException} thrown when none or more than one.\n+     */\n+    public static Node getOneSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(findUnique(graph, subject, predicate, Node.ANY));\n+    }\n+\n+    /**\n+     * Get object for subject-predicate. Return null for none, object for one, and\n+     * exception {@linkplain RDFDataException} if more than one.\n+     */\n+    public static Node getZeroOrOneSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(findZeroOne(graph, subject, predicate, Node.ANY));\n+    }\n+\n+    /**\n+     *  Get the subject, given predicate and object. Returns one (non-deterministically) or null.\n+     *  See also {@link #getOnePO} and {@link #getZeroOrOnePO}.\n+     */\n+    public static Node getPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(first(find(graph, Node.ANY, predicate, object)));\n+    }\n+\n+    /**\n+     * Get the subject for predicate-object. Must be exactly one subject; exception\n+     * {@linkplain RDFDataException} thrown when none or more than one.\n+     */\n+    public static Node getOnePO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return subject(findUnique(graph, Node.ANY, predicate, object));\n+    }\n+\n+    /**\n+     * Get the subject for predicate-object. Return null for none, subject for one, throw\n+     * exception {@linkplain RDFDataException} if more than one.\n+     */\n+    public static Node getZeroOrOnePO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return subject(findZeroOne(graph, Node.ANY, predicate, object));\n+    }\n+\n+    /**\n+     * Get triple if there is exactly one to match the s/p/o, else throw\n+     * {@linkplain RDFDataException}.\n+     */\n+    public static Triple getOne(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return findUnique(graph, subject, predicate, object);\n+    }\n+\n+    /**\n+     * Get triple if there is exactly one to match the s/p/o; return null if none;\n+     * throw {@linkplain RDFDataException} if more than one.\n+     */\n+    public static Triple getZeroOrOne(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return findZeroOne(graph, subject, predicate, object);\n+    }\n+\n+    // ---- Multiple matches.\n+\n+    /**\n+     * {@link ExtendedIterator} of objects where the triple matches for subject and\n+     * predicate (which can be wildcards). The {@link ExtendedIterator} must be fully\n+     * used or explicitly closed. It is preferable use {@link #listSP} which handles\n+     * this condition.\n+     */\n+    public static ExtendedIterator<Node> iterSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, subject, predicate, null).mapWith(Triple::getObject);\n+    }\n+\n+    /**\n+     * List of objects matching the subject-predicate (which can be wildcards).\n+     */\n+    public static List<Node> listSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return iterSP(graph, subject, predicate).toList();\n+    }\n+\n+    /** Count matches of subject-predicate (which can be wildcards). */\n+    public static long countSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return Iter.count(iterSP(graph, subject, predicate));\n+    }\n+\n+    /**\n+     * {@link ExtendedIterator} of subjects where the triple matches for predicate\n+     * and object (which can be wildcards). The {@link ExtendedIterator} must be\n+     * fully used or explicitly closed. It is preferable use {@link #listSP} which\n+     * handles this condition.\n+     */\n+    public static ExtendedIterator<Node> iterPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, null, predicate, object).mapWith(Triple::getSubject);\n+    }\n+\n+    /**\n+     * List of subjects matching the predicate-object (which can be wildcards).\n+     */\n+    public static List<Node> listPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return iterPO(graph, predicate, object).toList();\n+    }\n+\n+    /** Count matches of predicate-object (which can be wildcards). */\n+    public static long countPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return Iter.count(iterPO(graph, predicate, object));\n+    }\n+\n+    // DISTINCT means these are space using.\n+\n+    /** List the subjects in a graph (no duplicates) */\n+    public static Iterator<Node> listSubjects(Graph graph) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n+        return Iter.iter(iter).map(Triple::getSubject).distinct();\n+    }\n+\n+    /** List the predicates in a graph (no duplicates) */\n+    public static Iterator<Node> listPredicates(Graph graph) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n+        return Iter.iter(iter).map(Triple::getPredicate).distinct();\n+    }\n+\n+    /** List the objects in a graph (no duplicates) */\n+    public static Iterator<Node> listObjects(Graph graph) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n+        return Iter.iter(iter).map(Triple::getObject).distinct();\n+    }\n+\n+    // ---- rdf:type, not RDFS\n+\n+    /**\n+     * List the subjects with exactly {@code type}.\n+     * See {@link #listNodesOfTypeRDFS(Graph, Node)}, which does include sub-classes.\n+     */\n+    public static List<Node> nodesOfTypeAsList(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        return find(graph, null, rdfType, type).mapWith(Triple::getSubject).toList();\n+    }\n+\n+    /**\n+     * List the types of a node/subject.\n+     * See {@link #listTypesOfNodeRDFS(Graph, Node)} , which does include super-classes.\n+     */\n+    public static List<Node> typesOfNodeAsList(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        return find(graph, node, rdfType, null).mapWith(Triple::getObject).toList();\n+    }\n+\n+    /**\n+     * Set of nodes with exactly {@code type}.\n+     * See {@link #allNodesOfTypeRDFS(Graph, Node)}, which does include sub-classes.\n+     */\n+    public static Set<Node> nodesOfTypeAsSet(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        return find(graph, null, rdfType, type).mapWith(Triple::getSubject).toSet();\n+    }\n+\n+    /**\n+     * Set of exact types of a node See {@link #allTypesOfNodeRDFS(Graph, Node)},\n+     * which does include super-classes.\n+     */\n+    public static Set<Node> typesOfNodeAsSet(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        return find(graph, node, rdfType, null).mapWith(Triple::getObject).toSet();\n+    }\n+\n+    // ---- RDF list.\n+\n+    /** Return a java list for an RDF list of data. */\n+    public static List<Node> rdfList(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        GNode gNode = GNode.create(graph, node);\n+        return GraphList.members(gNode);\n+    }\n+\n+    // Sub-class / super-class\n+\n+    /**\n+     * List the subclasses of a type, including itself.\n+     * This is <tt>?x rdfs:subClassOf* type</tt>.\n+     * The list does not contain duplicates.\n+     */\n+    public static List<Node> listSubClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> acc = new ArrayList<>();\n+        // Subclasses are follow rdfs:subClassOf in reverse - object to subject.\n+        // Transitive.transitive is \"visit once\".\n+        Transitive.transitiveInc(graph, false, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    /**\n+     * List the super-classes of a type, including itself.\n+     * This is <tt>type rdfs:subClassOf* ?x</tt>.\n+     * The list does not contain duplicates.\n+     */\n+    public static List<Node> listSuperClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> acc = new ArrayList<>();\n+        // Super classes are \"follow rdfs:subclassOf\" - subject to object.\n+        // Transitive.transitive is \"visit once\".\n+        Transitive.transitiveInc(graph, true, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    /**\n+     * Set of the subclasses of a type, including itself.\n+     * This is <tt>?x rdfs:subClassOf* type</tt>.\n+     */\n+    public static Set<Node> subClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        Set<Node> acc = new HashSet<>();\n+        // Subclasses are follow rdfs:subclassOf in reverse - object to subject.\n+        Transitive.transitiveInc(graph, false, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    /**\n+     * Set of the subclasses of a type, including itself.\n+     * This is <tt>?x rdfs:subClassOf* type</tt>.\n+     */\n+    public static Set<Node> superClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        Set<Node> acc = new HashSet<>();\n+        Transitive.transitiveInc(graph, true, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    // ---- RDFS\n+\n+    /**\n+     * List the types of a node, following rdfs:subClassOf for super classes.\n+     */\n+    public static List<Node> listTypesOfNodeRDFS(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        List<Node> types = typesOfNodeAsList(graph, node);\n+        List<Node> types2 = new ArrayList<>();\n+        types.forEach(t->{\n+            List<Node> subClasses = listSuperClasses(graph, t);\n+            types2.addAll(subClasses);\n+        });\n+        return types2;\n+    }\n+\n+    /**\n+     * List all the nodes of type, including node of sub-classes.\n+     */\n+    public static List<Node> listNodesOfTypeRDFS(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> types = listSubClasses(graph, type);\n+        List<Node> nodes = new ArrayList<>();\n+        accNodesOfTypes(nodes, graph, types);\n+        return nodes;\n+    }\n+\n+    /**\n+     * List all the types of a node, including super-classes.\n+     */\n+    public static Set<Node> allTypesOfNodeRDFS(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        Set<Node> types = typesOfNodeAsSet(graph, node);\n+        Set<Node> types2 = new HashSet<>();\n+        types.forEach(t->{\n+            List<Node> subClasses = listSuperClasses(graph, t);\n+            types2.addAll(subClasses);\n+        });\n+        return types2;\n+    }\n+\n+    /** List all the node of type, including considering rdfs:subClassOf */\n+    public static Set<Node> allNodesOfTypeRDFS(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        Set<Node> types = subClasses(graph, type);\n+        Set<Node> nodes = new HashSet<>();\n+        accNodesOfTypes(nodes, graph, types);\n+        return nodes;\n+    }\n+\n+    /** For each type, find nodes of that type and accumulate */\n+    private static void accNodesOfTypes(Collection<Node> acc, Graph graph, Collection<Node> types) {\n+        types.forEach(t->\n+            find(graph, null, rdfType, t).mapWith(Triple::getSubject).forEach(acc::add)\n+            );\n+    }\n+\n+    /** Return a set of all objects for subject-predicate */\n+    public static Set<Node> allSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, subject, predicate, null).mapWith(Triple::getObject).toSet();\n+    }\n+\n+    /** Return a set of all subjects for predicate-object */\n+    public static Set<Node> allPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, null, predicate, object).mapWith(Triple::getSubject).toSet();\n+    }\n+\n+    // --- Graph walking.\n+\n+    /** Count the number of in-arc to an object */\n+    public static long objectConnectiveness(Graph graph, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(object, \"object\");\n+        return Iter.count(find(graph, null, null, object));\n+    }\n+\n+    /** Test whether an object has exactly one in-arc. */\n+    public static boolean oneConnected(Graph graph, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(object, \"object\");\n+        ExtendedIterator<Triple> iter = find(graph, null, null, object);\n+        if ( ! iter.hasNext() )\n+            // Zero.\n+            return false;\n+        iter.next();\n+        if ( iter.hasNext() )\n+            // more than one\n+            return false;\n+        return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb"}, "originalPosition": 478}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b552757b224a43926b9ffeb5e86efca206c57ecc", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/b552757b224a43926b9ffeb5e86efca206c57ecc", "committedDate": "2020-10-05T11:12:43Z", "message": "Mark iterator to stream as immutable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ce67087fc0decde38d3c79b6b85dde259c788ea", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/2ce67087fc0decde38d3c79b6b85dde259c788ea", "committedDate": "2020-10-05T11:13:47Z", "message": "JENA-1974: Function library for working with graphs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "committedDate": "2020-10-04T19:08:45Z", "message": "Mark iterator to stream as immutable"}, "afterCommit": {"oid": "2ce67087fc0decde38d3c79b6b85dde259c788ea", "author": {"user": {"login": "afs", "name": "Andy Seaborne"}}, "url": "https://github.com/apache/jena/commit/2ce67087fc0decde38d3c79b6b85dde259c788ea", "committedDate": "2020-10-05T11:13:47Z", "message": "JENA-1974: Function library for working with graphs"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2956, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}