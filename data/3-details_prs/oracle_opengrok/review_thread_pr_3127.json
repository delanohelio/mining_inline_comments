{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NjMwMzQx", "number": 3127, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjozMDoxMlrOD1HW_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1NDo0MlrOD1H8DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDIxNjk0OnYy", "diffSide": "RIGHT", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjozMDoxMlrOGKYtyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo1ODozMlrOGQLpwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0Mzg4Mw==", "bodyText": "I'd swap the parameter order cause at it seems more natural to me like this\nsyncWriteConfiguration(groups, (c, g) -> {\n      populateGroups(g, new TreeSet<>(getProjects().values()));\n      c.setGroups(g);\n});\n\nas its \"value -> consume\" that value, rather then \"consumer of a value -> value\"", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413543883", "createdAt": "2020-04-23T06:30:12Z", "author": {"login": "ktulinger"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5OTQzMw==", "bodyText": "That would mean a line like the following:\nsyncWriteConfiguration(flag, Configuration::setListDirsFirst);\nwhich seems to invert the important part.", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413999433", "createdAt": "2020-04-23T17:47:08Z", "author": {"login": "idodeclare"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0Mzg4Mw=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAwNTYzMg==", "bodyText": "I'll rename the vague arguments and transpose it as you suggest", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r414005632", "createdAt": "2020-04-23T17:56:12Z", "author": {"login": "idodeclare"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0Mzg4Mw=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMTMxNA==", "bodyText": "thank you", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r419621314", "createdAt": "2020-05-04T17:58:32Z", "author": {"login": "tulinkry"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0Mzg4Mw=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDIyODQ5OnYy", "diffSide": "RIGHT", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/CloseableReentrantReadWriteLock.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjozMzo1MlrOGKY0TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzo0NDowN1rOGK0ZIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0NTU0OA==", "bodyText": "why this.writeLock().unlock() is not enough?", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413545548", "createdAt": "2020-04-23T06:33:52Z", "author": {"login": "ktulinger"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/CloseableReentrantReadWriteLock.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * This work is licensed under the Creative Commons Attribution-ShareAlike 4.0\n+ * International License. To view a copy of this license, visit\n+ * https://creativecommons.org/licenses/by-sa/4.0/ or send a letter to\n+ * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n+ *\n+ * Copyright (c) 2017, https://stackoverflow.com/users/7583219/skoskav\n+ * Copyright (c) 2011, https://stackoverflow.com/questions/6965731/are-locks-autocloseable\n+ * Portions Copyright (c) 2019-2020, Chris Fraire <cfraire@me.com>.\n+ *\n+ * Used under CC 4 with modifications noted as follows as required by license:\n+ * 2019-09-10 -- cfraire@me.com, derived to use for ReentrantReadWriteLock.\n+ * 2020-04-21 -- cfraire@me.com, updated for proper handling re Serializable.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Represents a subclass of {@link ReentrantReadWriteLock} that can return\n+ * {@link ResourceLock} instances.\n+ */\n+public final class CloseableReentrantReadWriteLock extends ReentrantReadWriteLock {\n+\n+    private static final long serialVersionUID = 95L;\n+\n+    private transient ResourceLock readUnlocker = newReadUnlocker();\n+\n+    private transient ResourceLock writeUnlocker = newWriteUnlocker();\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #readLock()} has\n+     * been acquired\n+     */\n+    public ResourceLock readLockAsResource() {\n+        /*\n+         * A subclass of ReentrantReadWriteLock is forced to be serializable, so\n+         * we would have to handle where serialization can short-circuit field\n+         * initialization above and leave the instance's fields null.\n+         * Consequently, the fields cannot be final. They are encapsulating\n+         * fixed logic, so we can optimize and choose not to even bother\n+         * serializing by declaring transient and handling below.\n+         */\n+        ResourceLock unlocker = readUnlocker;\n+        if (unlocker == null) {\n+            unlocker = newReadUnlocker();\n+            // No synchronization necessary since overwrite is of no matter.\n+            readUnlocker = unlocker;\n+        }\n+        readLock().lock();\n+        return unlocker;\n+    }\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #writeLock()} ()}\n+     * has been acquired\n+     */\n+    public ResourceLock writeLockAsResource() {\n+        /*\n+         * A subclass of ReentrantReadWriteLock is forced to be serializable, so\n+         * we would have to handle where serialization can short-circuit field\n+         * initialization above and leave the instance's fields null.\n+         * Consequently, the fields cannot be final. They are encapsulating\n+         * fixed logic, so we can optimize and choose not to even bother\n+         * serializing by declaring transient and handling below.\n+         */\n+        ResourceLock unlocker = writeUnlocker;\n+        if (unlocker == null) {\n+            unlocker = newWriteUnlocker();\n+            // No synchronization necessary since overwrite is of no matter.\n+            writeUnlocker = unlocker;\n+        }\n+        writeLock().lock();\n+        return unlocker;\n+    }\n+\n+    private ResourceLock newReadUnlocker() {\n+        return () -> CloseableReentrantReadWriteLock.this.readLock().unlock();\n+    }\n+\n+    private ResourceLock newWriteUnlocker() {\n+        return () -> CloseableReentrantReadWriteLock.this.writeLock().unlock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NzM0NQ==", "bodyText": "Oh that was from the imported implementation. Yes it seems superfluous", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413997345", "createdAt": "2020-04-23T17:44:07Z", "author": {"login": "idodeclare"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/CloseableReentrantReadWriteLock.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * This work is licensed under the Creative Commons Attribution-ShareAlike 4.0\n+ * International License. To view a copy of this license, visit\n+ * https://creativecommons.org/licenses/by-sa/4.0/ or send a letter to\n+ * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n+ *\n+ * Copyright (c) 2017, https://stackoverflow.com/users/7583219/skoskav\n+ * Copyright (c) 2011, https://stackoverflow.com/questions/6965731/are-locks-autocloseable\n+ * Portions Copyright (c) 2019-2020, Chris Fraire <cfraire@me.com>.\n+ *\n+ * Used under CC 4 with modifications noted as follows as required by license:\n+ * 2019-09-10 -- cfraire@me.com, derived to use for ReentrantReadWriteLock.\n+ * 2020-04-21 -- cfraire@me.com, updated for proper handling re Serializable.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Represents a subclass of {@link ReentrantReadWriteLock} that can return\n+ * {@link ResourceLock} instances.\n+ */\n+public final class CloseableReentrantReadWriteLock extends ReentrantReadWriteLock {\n+\n+    private static final long serialVersionUID = 95L;\n+\n+    private transient ResourceLock readUnlocker = newReadUnlocker();\n+\n+    private transient ResourceLock writeUnlocker = newWriteUnlocker();\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #readLock()} has\n+     * been acquired\n+     */\n+    public ResourceLock readLockAsResource() {\n+        /*\n+         * A subclass of ReentrantReadWriteLock is forced to be serializable, so\n+         * we would have to handle where serialization can short-circuit field\n+         * initialization above and leave the instance's fields null.\n+         * Consequently, the fields cannot be final. They are encapsulating\n+         * fixed logic, so we can optimize and choose not to even bother\n+         * serializing by declaring transient and handling below.\n+         */\n+        ResourceLock unlocker = readUnlocker;\n+        if (unlocker == null) {\n+            unlocker = newReadUnlocker();\n+            // No synchronization necessary since overwrite is of no matter.\n+            readUnlocker = unlocker;\n+        }\n+        readLock().lock();\n+        return unlocker;\n+    }\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #writeLock()} ()}\n+     * has been acquired\n+     */\n+    public ResourceLock writeLockAsResource() {\n+        /*\n+         * A subclass of ReentrantReadWriteLock is forced to be serializable, so\n+         * we would have to handle where serialization can short-circuit field\n+         * initialization above and leave the instance's fields null.\n+         * Consequently, the fields cannot be final. They are encapsulating\n+         * fixed logic, so we can optimize and choose not to even bother\n+         * serializing by declaring transient and handling below.\n+         */\n+        ResourceLock unlocker = writeUnlocker;\n+        if (unlocker == null) {\n+            unlocker = newWriteUnlocker();\n+            // No synchronization necessary since overwrite is of no matter.\n+            writeUnlocker = unlocker;\n+        }\n+        writeLock().lock();\n+        return unlocker;\n+    }\n+\n+    private ResourceLock newReadUnlocker() {\n+        return () -> CloseableReentrantReadWriteLock.this.readLock().unlock();\n+    }\n+\n+    private ResourceLock newWriteUnlocker() {\n+        return () -> CloseableReentrantReadWriteLock.this.writeLock().unlock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0NTU0OA=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDI3OTQwOnYy", "diffSide": "RIGHT", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo0ODoxOVrOGKZQ9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxODozMjowNFrOGK2WTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1Mjg4Nw==", "bodyText": "why do you assert this when you're explicitely checking this in write|readLockAsResource?", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413552887", "createdAt": "2020-04-23T06:48:19Z", "author": {"login": "ktulinger"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {\n+        try (ResourceLock resourceLock = configLock.writeLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5Njc1Mg==", "bodyText": "That's to silent an annoying Java warning of the auto-closeable not being referenced in the block which was a blocker in IDEA when it runs tests with warnings-as-errors", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413996752", "createdAt": "2020-04-23T17:43:11Z", "author": {"login": "idodeclare"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {\n+        try (ResourceLock resourceLock = configLock.writeLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1Mjg4Nw=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAyMDMwNQ==", "bodyText": "what about @SuppressWarnings(\"unused\") ?", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r414020305", "createdAt": "2020-04-23T18:18:26Z", "author": {"login": "ktulinger"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {\n+        try (ResourceLock resourceLock = configLock.writeLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1Mjg4Nw=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAyOTM4OQ==", "bodyText": "No it\u2019s a very focused warning for auto-closeable", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r414029389", "createdAt": "2020-04-23T18:32:04Z", "author": {"login": "idodeclare"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {\n+        try (ResourceLock resourceLock = configLock.writeLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1Mjg4Nw=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1346}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDI4MzkzOnYy", "diffSide": "RIGHT", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/CloseableReentrantReadWriteLock.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo0OTowM1rOGKZT1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzo0NzozMlrOGK0iKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1MzYyMA==", "bodyText": "there are some extra brackets", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413553620", "createdAt": "2020-04-23T06:49:03Z", "author": {"login": "ktulinger"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/CloseableReentrantReadWriteLock.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * This work is licensed under the Creative Commons Attribution-ShareAlike 4.0\n+ * International License. To view a copy of this license, visit\n+ * https://creativecommons.org/licenses/by-sa/4.0/ or send a letter to\n+ * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n+ *\n+ * Copyright (c) 2017, https://stackoverflow.com/users/7583219/skoskav\n+ * Copyright (c) 2011, https://stackoverflow.com/questions/6965731/are-locks-autocloseable\n+ * Portions Copyright (c) 2019-2020, Chris Fraire <cfraire@me.com>.\n+ *\n+ * Used under CC 4 with modifications noted as follows as required by license:\n+ * 2019-09-10 -- cfraire@me.com, derived to use for ReentrantReadWriteLock.\n+ * 2020-04-21 -- cfraire@me.com, updated for proper handling re Serializable.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Represents a subclass of {@link ReentrantReadWriteLock} that can return\n+ * {@link ResourceLock} instances.\n+ */\n+public final class CloseableReentrantReadWriteLock extends ReentrantReadWriteLock {\n+\n+    private static final long serialVersionUID = 95L;\n+\n+    private transient ResourceLock readUnlocker = newReadUnlocker();\n+\n+    private transient ResourceLock writeUnlocker = newWriteUnlocker();\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #readLock()} has\n+     * been acquired\n+     */\n+    public ResourceLock readLockAsResource() {\n+        /*\n+         * A subclass of ReentrantReadWriteLock is forced to be serializable, so\n+         * we would have to handle where serialization can short-circuit field\n+         * initialization above and leave the instance's fields null.\n+         * Consequently, the fields cannot be final. They are encapsulating\n+         * fixed logic, so we can optimize and choose not to even bother\n+         * serializing by declaring transient and handling below.\n+         */\n+        ResourceLock unlocker = readUnlocker;\n+        if (unlocker == null) {\n+            unlocker = newReadUnlocker();\n+            // No synchronization necessary since overwrite is of no matter.\n+            readUnlocker = unlocker;\n+        }\n+        readLock().lock();\n+        return unlocker;\n+    }\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #writeLock()} ()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5OTY1Ng==", "bodyText": "Got it", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413999656", "createdAt": "2020-04-23T17:47:32Z", "author": {"login": "idodeclare"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/CloseableReentrantReadWriteLock.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * This work is licensed under the Creative Commons Attribution-ShareAlike 4.0\n+ * International License. To view a copy of this license, visit\n+ * https://creativecommons.org/licenses/by-sa/4.0/ or send a letter to\n+ * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n+ *\n+ * Copyright (c) 2017, https://stackoverflow.com/users/7583219/skoskav\n+ * Copyright (c) 2011, https://stackoverflow.com/questions/6965731/are-locks-autocloseable\n+ * Portions Copyright (c) 2019-2020, Chris Fraire <cfraire@me.com>.\n+ *\n+ * Used under CC 4 with modifications noted as follows as required by license:\n+ * 2019-09-10 -- cfraire@me.com, derived to use for ReentrantReadWriteLock.\n+ * 2020-04-21 -- cfraire@me.com, updated for proper handling re Serializable.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Represents a subclass of {@link ReentrantReadWriteLock} that can return\n+ * {@link ResourceLock} instances.\n+ */\n+public final class CloseableReentrantReadWriteLock extends ReentrantReadWriteLock {\n+\n+    private static final long serialVersionUID = 95L;\n+\n+    private transient ResourceLock readUnlocker = newReadUnlocker();\n+\n+    private transient ResourceLock writeUnlocker = newWriteUnlocker();\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #readLock()} has\n+     * been acquired\n+     */\n+    public ResourceLock readLockAsResource() {\n+        /*\n+         * A subclass of ReentrantReadWriteLock is forced to be serializable, so\n+         * we would have to handle where serialization can short-circuit field\n+         * initialization above and leave the instance's fields null.\n+         * Consequently, the fields cannot be final. They are encapsulating\n+         * fixed logic, so we can optimize and choose not to even bother\n+         * serializing by declaring transient and handling below.\n+         */\n+        ResourceLock unlocker = readUnlocker;\n+        if (unlocker == null) {\n+            unlocker = newReadUnlocker();\n+            // No synchronization necessary since overwrite is of no matter.\n+            readUnlocker = unlocker;\n+        }\n+        readLock().lock();\n+        return unlocker;\n+    }\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #writeLock()} ()}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1MzYyMA=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDMwOTgzOnYy", "diffSide": "RIGHT", "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/controller/ConfigurationController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1NDowOVrOGKZjlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzo0OTowNVrOGK0mHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1NzY1NQ==", "bodyText": "the exception here is only translated to throw new WebApplicationException(e, Response.Status.BAD_REQUEST)\ncan you thro that one here and remove the try block in the caller?", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413557655", "createdAt": "2020-04-23T06:54:09Z", "author": {"login": "ktulinger"}, "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/controller/ConfigurationController.java", "diffHunk": "@@ -91,4 +94,37 @@ public void reloadAuthorization() {\n         env.getAuthorizationFramework().reload();\n     }\n \n+    private Object getConfigurationValueException(String fieldName) throws IOException {\n+        final IOException[] capture = new IOException[1];\n+        final int EXCEPTION_INDEX = 0;\n+        Object result = env.syncReadConfiguration(configuration -> {\n+            try {\n+                return ClassUtil.getFieldValue(configuration, fieldName);\n+            } catch (IOException ex) {\n+                capture[EXCEPTION_INDEX] = ex;\n+                return null;\n+            }\n+        });\n+        if (capture[EXCEPTION_INDEX] != null) {\n+            throw capture[EXCEPTION_INDEX];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAwMDY3MQ==", "bodyText": "Yes", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r414000671", "createdAt": "2020-04-23T17:49:05Z", "author": {"login": "idodeclare"}, "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/controller/ConfigurationController.java", "diffHunk": "@@ -91,4 +94,37 @@ public void reloadAuthorization() {\n         env.getAuthorizationFramework().reload();\n     }\n \n+    private Object getConfigurationValueException(String fieldName) throws IOException {\n+        final IOException[] capture = new IOException[1];\n+        final int EXCEPTION_INDEX = 0;\n+        Object result = env.syncReadConfiguration(configuration -> {\n+            try {\n+                return ClassUtil.getFieldValue(configuration, fieldName);\n+            } catch (IOException ex) {\n+                capture[EXCEPTION_INDEX] = ex;\n+                return null;\n+            }\n+        });\n+        if (capture[EXCEPTION_INDEX] != null) {\n+            throw capture[EXCEPTION_INDEX];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1NzY1NQ=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDMxMTgxOnYy", "diffSide": "RIGHT", "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/controller/ConfigurationController.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1NDo0MlrOGKZkqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNzo1MDozOFrOGK0qOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1NzkzMA==", "bodyText": "extra line?", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413557930", "createdAt": "2020-04-23T06:54:42Z", "author": {"login": "ktulinger"}, "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/controller/ConfigurationController.java", "diffHunk": "@@ -91,4 +94,37 @@ public void reloadAuthorization() {\n         env.getAuthorizationFramework().reload();\n     }\n \n+    private Object getConfigurationValueException(String fieldName) throws IOException {\n+        final IOException[] capture = new IOException[1];\n+        final int EXCEPTION_INDEX = 0;\n+        Object result = env.syncReadConfiguration(configuration -> {\n+            try {\n+                return ClassUtil.getFieldValue(configuration, fieldName);\n+            } catch (IOException ex) {\n+                capture[EXCEPTION_INDEX] = ex;\n+                return null;\n+            }\n+        });\n+        if (capture[EXCEPTION_INDEX] != null) {\n+            throw capture[EXCEPTION_INDEX];\n+        }\n+        return result;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAwMDU2Mw==", "bodyText": "I don't understand", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r414000563", "createdAt": "2020-04-23T17:48:55Z", "author": {"login": "idodeclare"}, "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/controller/ConfigurationController.java", "diffHunk": "@@ -91,4 +94,37 @@ public void reloadAuthorization() {\n         env.getAuthorizationFramework().reload();\n     }\n \n+    private Object getConfigurationValueException(String fieldName) throws IOException {\n+        final IOException[] capture = new IOException[1];\n+        final int EXCEPTION_INDEX = 0;\n+        Object result = env.syncReadConfiguration(configuration -> {\n+            try {\n+                return ClassUtil.getFieldValue(configuration, fieldName);\n+            } catch (IOException ex) {\n+                capture[EXCEPTION_INDEX] = ex;\n+                return null;\n+            }\n+        });\n+        if (capture[EXCEPTION_INDEX] != null) {\n+            throw capture[EXCEPTION_INDEX];\n+        }\n+        return result;\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1NzkzMA=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAwMTcyMA==", "bodyText": "I don't know :-D I somehow saw two lines. Nevermind.", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r414001720", "createdAt": "2020-04-23T17:50:38Z", "author": {"login": "ktulinger"}, "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/controller/ConfigurationController.java", "diffHunk": "@@ -91,4 +94,37 @@ public void reloadAuthorization() {\n         env.getAuthorizationFramework().reload();\n     }\n \n+    private Object getConfigurationValueException(String fieldName) throws IOException {\n+        final IOException[] capture = new IOException[1];\n+        final int EXCEPTION_INDEX = 0;\n+        Object result = env.syncReadConfiguration(configuration -> {\n+            try {\n+                return ClassUtil.getFieldValue(configuration, fieldName);\n+            } catch (IOException ex) {\n+                capture[EXCEPTION_INDEX] = ex;\n+                return null;\n+            }\n+        });\n+        if (capture[EXCEPTION_INDEX] != null) {\n+            throw capture[EXCEPTION_INDEX];\n+        }\n+        return result;\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1NzkzMA=="}, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 223, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}