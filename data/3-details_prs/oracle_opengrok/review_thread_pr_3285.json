{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1MTI4MjQ2", "number": 3285, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozNjowNlrOEwLthw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwOTozMzozM1rOExIS0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4OTU4OTgzOnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/test/python/test_mirror.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozNjowNlrOHllXuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNzoyOToxNVrOHmUK6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MTY0MQ==", "bodyText": "do the tests assume that Git is installed on the system ?", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r509171641", "createdAt": "2020-10-21T10:36:06Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +398,183 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [\n+    (None, 'default-command'),\n+    ('/usr/bin/git', '/usr/bin/git'),\n+    ({}, 'default-command'),\n+    ({'incoming': '/bin/false'}, 'default-command'),\n+    ([], 'default-command'),\n+    ({'command': '/usr/local/bin/git'}, '/usr/local/bin/git'),\n+    (\n+            {'command': '/usr/local/bin/git', 'incoming': '/bin/false'},\n+            '/usr/local/bin/git'\n+    )\n+])\n+def test_mirroring_custom_repository_command(config, expected_command):\n+    assert expected_command == Repository._repository_command(\n+        config,\n+        lambda: 'default-command'\n+    )\n+\n+\n+@pytest.mark.parametrize(\n+    ('touch_binary'), [\n+        pytest.param('/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/touch'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/touch'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_invoke_command(touch_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': [touch_binary, 'incoming.txt']\n+        }, None, None, None)\n+        assert repository.incoming() is False\n+        assert 'incoming.txt' in os.listdir(repository_root)\n+\n+\n+@pytest.mark.parametrize(\n+    ('echo_binary'), [\n+        pytest.param('/bin/echo',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/echo'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/echo',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/echo'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_changes(echo_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "507eed5bd1667638081e310fc2f446b77b7abfbe"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODQwOA==", "bodyText": "No no, the git command is never executed, most of the tests uses custom commands (like echo or true/false) and the rest uses mocking for the original call.", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r509938408", "createdAt": "2020-10-22T07:29:15Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +398,183 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [\n+    (None, 'default-command'),\n+    ('/usr/bin/git', '/usr/bin/git'),\n+    ({}, 'default-command'),\n+    ({'incoming': '/bin/false'}, 'default-command'),\n+    ([], 'default-command'),\n+    ({'command': '/usr/local/bin/git'}, '/usr/local/bin/git'),\n+    (\n+            {'command': '/usr/local/bin/git', 'incoming': '/bin/false'},\n+            '/usr/local/bin/git'\n+    )\n+])\n+def test_mirroring_custom_repository_command(config, expected_command):\n+    assert expected_command == Repository._repository_command(\n+        config,\n+        lambda: 'default-command'\n+    )\n+\n+\n+@pytest.mark.parametrize(\n+    ('touch_binary'), [\n+        pytest.param('/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/touch'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/touch'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_invoke_command(touch_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': [touch_binary, 'incoming.txt']\n+        }, None, None, None)\n+        assert repository.incoming() is False\n+        assert 'incoming.txt' in os.listdir(repository_root)\n+\n+\n+@pytest.mark.parametrize(\n+    ('echo_binary'), [\n+        pytest.param('/bin/echo',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/echo'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/echo',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/echo'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_changes(echo_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MTY0MQ=="}, "originalCommit": {"oid": "507eed5bd1667638081e310fc2f446b77b7abfbe"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4OTU5NjgyOnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/test/python/test_mirror.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozODowNVrOHllb9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoxMjo0MlrOHmyGcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MjcyNg==", "bodyText": "make 'sync.txt' a variable ?", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r509172726", "createdAt": "2020-10-21T10:38:05Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +398,183 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [\n+    (None, 'default-command'),\n+    ('/usr/bin/git', '/usr/bin/git'),\n+    ({}, 'default-command'),\n+    ({'incoming': '/bin/false'}, 'default-command'),\n+    ([], 'default-command'),\n+    ({'command': '/usr/local/bin/git'}, '/usr/local/bin/git'),\n+    (\n+            {'command': '/usr/local/bin/git', 'incoming': '/bin/false'},\n+            '/usr/local/bin/git'\n+    )\n+])\n+def test_mirroring_custom_repository_command(config, expected_command):\n+    assert expected_command == Repository._repository_command(\n+        config,\n+        lambda: 'default-command'\n+    )\n+\n+\n+@pytest.mark.parametrize(\n+    ('touch_binary'), [\n+        pytest.param('/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/touch'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/touch'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_invoke_command(touch_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': [touch_binary, 'incoming.txt']\n+        }, None, None, None)\n+        assert repository.incoming() is False\n+        assert 'incoming.txt' in os.listdir(repository_root)\n+\n+\n+@pytest.mark.parametrize(\n+    ('echo_binary'), [\n+        pytest.param('/bin/echo',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/echo'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/echo',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/echo'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_changes(echo_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': [echo_binary, 'new incoming changes!']\n+        }, None, None, None)\n+        assert repository.incoming() is True\n+\n+\n+@pytest.mark.parametrize(\n+    ('true_binary'), [\n+        pytest.param('/bin/true',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/true'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/true',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/true'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_no_changes(true_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': true_binary\n+        }, None, None, None)\n+        assert repository.incoming() is False\n+\n+\n+@pytest.mark.parametrize(\n+    ('false_binary'), [\n+        pytest.param('/bin/false',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/false'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/false',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/false'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_error(false_binary):\n+    with pytest.raises(RepositoryException):\n+        with tempfile.TemporaryDirectory() as repository_root:\n+            repository = GitRepository(mock(), repository_root, 'test-1', {\n+                'incoming': false_binary\n+            }, None, None, None)\n+            repository.incoming()\n+\n+\n+def test_mirroring_incoming_invoke_original_command():\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1',\n+                                   None, None, None, None)\n+        with when(repository).incoming_check().thenReturn(0):\n+            repository.incoming()\n+            verify(repository).incoming_check()\n+\n+\n+@pytest.mark.parametrize(\n+    ('touch_binary'), [\n+        pytest.param('/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/touch'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/touch'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_sync_invoke_command(touch_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'sync': [touch_binary, 'sync.txt']\n+        }, None, None, None)\n+        assert repository.sync() == 0\n+        assert 'sync.txt' in os.listdir(repository_root)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "507eed5bd1667638081e310fc2f446b77b7abfbe"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyODc4Ng==", "bodyText": "done", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510428786", "createdAt": "2020-10-22T20:12:42Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +398,183 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [\n+    (None, 'default-command'),\n+    ('/usr/bin/git', '/usr/bin/git'),\n+    ({}, 'default-command'),\n+    ({'incoming': '/bin/false'}, 'default-command'),\n+    ([], 'default-command'),\n+    ({'command': '/usr/local/bin/git'}, '/usr/local/bin/git'),\n+    (\n+            {'command': '/usr/local/bin/git', 'incoming': '/bin/false'},\n+            '/usr/local/bin/git'\n+    )\n+])\n+def test_mirroring_custom_repository_command(config, expected_command):\n+    assert expected_command == Repository._repository_command(\n+        config,\n+        lambda: 'default-command'\n+    )\n+\n+\n+@pytest.mark.parametrize(\n+    ('touch_binary'), [\n+        pytest.param('/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/touch'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/touch'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_invoke_command(touch_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': [touch_binary, 'incoming.txt']\n+        }, None, None, None)\n+        assert repository.incoming() is False\n+        assert 'incoming.txt' in os.listdir(repository_root)\n+\n+\n+@pytest.mark.parametrize(\n+    ('echo_binary'), [\n+        pytest.param('/bin/echo',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/echo'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/echo',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/echo'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_changes(echo_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': [echo_binary, 'new incoming changes!']\n+        }, None, None, None)\n+        assert repository.incoming() is True\n+\n+\n+@pytest.mark.parametrize(\n+    ('true_binary'), [\n+        pytest.param('/bin/true',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/true'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/true',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/true'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_no_changes(true_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': true_binary\n+        }, None, None, None)\n+        assert repository.incoming() is False\n+\n+\n+@pytest.mark.parametrize(\n+    ('false_binary'), [\n+        pytest.param('/bin/false',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/false'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/false',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/false'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_error(false_binary):\n+    with pytest.raises(RepositoryException):\n+        with tempfile.TemporaryDirectory() as repository_root:\n+            repository = GitRepository(mock(), repository_root, 'test-1', {\n+                'incoming': false_binary\n+            }, None, None, None)\n+            repository.incoming()\n+\n+\n+def test_mirroring_incoming_invoke_original_command():\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1',\n+                                   None, None, None, None)\n+        with when(repository).incoming_check().thenReturn(0):\n+            repository.incoming()\n+            verify(repository).incoming_check()\n+\n+\n+@pytest.mark.parametrize(\n+    ('touch_binary'), [\n+        pytest.param('/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/touch'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/touch'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_sync_invoke_command(touch_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'sync': [touch_binary, 'sync.txt']\n+        }, None, None, None)\n+        assert repository.sync() == 0\n+        assert 'sync.txt' in os.listdir(repository_root)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MjcyNg=="}, "originalCommit": {"oid": "507eed5bd1667638081e310fc2f446b77b7abfbe"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4OTU5ODgyOnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/test/python/test_mirror.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDozODo0M1rOHlldMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoxMjozN1rOHmyGPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MzA0MA==", "bodyText": "make 'incoming.txt' a variable ?", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r509173040", "createdAt": "2020-10-21T10:38:43Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +398,183 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [\n+    (None, 'default-command'),\n+    ('/usr/bin/git', '/usr/bin/git'),\n+    ({}, 'default-command'),\n+    ({'incoming': '/bin/false'}, 'default-command'),\n+    ([], 'default-command'),\n+    ({'command': '/usr/local/bin/git'}, '/usr/local/bin/git'),\n+    (\n+            {'command': '/usr/local/bin/git', 'incoming': '/bin/false'},\n+            '/usr/local/bin/git'\n+    )\n+])\n+def test_mirroring_custom_repository_command(config, expected_command):\n+    assert expected_command == Repository._repository_command(\n+        config,\n+        lambda: 'default-command'\n+    )\n+\n+\n+@pytest.mark.parametrize(\n+    ('touch_binary'), [\n+        pytest.param('/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/touch'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/touch'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_invoke_command(touch_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': [touch_binary, 'incoming.txt']\n+        }, None, None, None)\n+        assert repository.incoming() is False\n+        assert 'incoming.txt' in os.listdir(repository_root)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "507eed5bd1667638081e310fc2f446b77b7abfbe"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyODczNQ==", "bodyText": "done", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510428735", "createdAt": "2020-10-22T20:12:37Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +398,183 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [\n+    (None, 'default-command'),\n+    ('/usr/bin/git', '/usr/bin/git'),\n+    ({}, 'default-command'),\n+    ({'incoming': '/bin/false'}, 'default-command'),\n+    ([], 'default-command'),\n+    ({'command': '/usr/local/bin/git'}, '/usr/local/bin/git'),\n+    (\n+            {'command': '/usr/local/bin/git', 'incoming': '/bin/false'},\n+            '/usr/local/bin/git'\n+    )\n+])\n+def test_mirroring_custom_repository_command(config, expected_command):\n+    assert expected_command == Repository._repository_command(\n+        config,\n+        lambda: 'default-command'\n+    )\n+\n+\n+@pytest.mark.parametrize(\n+    ('touch_binary'), [\n+        pytest.param('/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/bin/touch'),\n+                         reason=\"requires /bin binaries\")),\n+        pytest.param('/usr/bin/touch',\n+                     marks=pytest.mark.skipif(\n+                         not os.path.exists('/usr/bin/touch'),\n+                         reason=\"requires /usr/bin binaries\")),\n+    ]\n+)\n+def test_mirroring_custom_incoming_invoke_command(touch_binary):\n+    with tempfile.TemporaryDirectory() as repository_root:\n+        repository = GitRepository(mock(), repository_root, 'test-1', {\n+            'incoming': [touch_binary, 'incoming.txt']\n+        }, None, None, None)\n+        assert repository.incoming() is False\n+        assert 'incoming.txt' in os.listdir(repository_root)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MzA0MA=="}, "originalCommit": {"oid": "507eed5bd1667638081e310fc2f446b77b7abfbe"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4OTYxNjUyOnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMDo0Mzo0MFrOHlln3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMDoxMjozMFrOHmyGBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3NTc3NQ==", "bodyText": "refactor to a function and use that in incoming() as well ?", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r509175775", "createdAt": "2020-10-21T10:43:40Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -59,6 +61,11 @@ def getCommand(self, cmd, **kwargs):\n \n     def sync(self):\n         # Eventually, there might be per-repository hooks added here.\n+        if isinstance(self.configured_commands, dict) and \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "507eed5bd1667638081e310fc2f446b77b7abfbe"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyODY3OA==", "bodyText": "done", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510428678", "createdAt": "2020-10-22T20:12:30Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -59,6 +61,11 @@ def getCommand(self, cmd, **kwargs):\n \n     def sync(self):\n         # Eventually, there might be per-repository hooks added here.\n+        if isinstance(self.configured_commands, dict) and \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3NTc3NQ=="}, "originalCommit": {"oid": "507eed5bd1667638081e310fc2f446b77b7abfbe"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTIzNzYxOnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwODoyMDoyMVrOHnDn9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwODoyMTo0N1rOHnDrJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDcxNTg5Mg==", "bodyText": "this one don't change", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510715892", "createdAt": "2020-10-23T08:20:21Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -18,10 +18,12 @@\n #\n \n #\n-# Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa06f86f2907d9deb44743ae9e83194f70061fbc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDcxNjcwOQ==", "bodyText": "changed", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510716709", "createdAt": "2020-10-23T08:21:47Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -18,10 +18,12 @@\n #\n \n #\n-# Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDcxNTg5Mg=="}, "originalCommit": {"oid": "aa06f86f2907d9deb44743ae9e83194f70061fbc"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTM4ODc1OnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwODo1OTo0N1rOHnFEnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwODo1OTo0N1rOHnFEnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDczOTYxMw==", "bodyText": "the 'sync' string could be a variable", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510739613", "createdAt": "2020-10-23T08:59:47Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -59,6 +62,10 @@ def getCommand(self, cmd, **kwargs):\n \n     def sync(self):\n         # Eventually, there might be per-repository hooks added here.\n+        if self.is_command_overridden(self.configured_commands, 'sync'):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTM4OTI3OnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwODo1OTo1M1rOHnFE5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwODo1OTo1M1rOHnFE5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDczOTY4Ng==", "bodyText": "ditto", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510739686", "createdAt": "2020-10-23T08:59:53Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -75,6 +82,105 @@ def incoming(self):\n         \"\"\"\n         Check if there are any incoming changes.\n \n+        Return True if so, False otherwise.\n+        \"\"\"\n+        if self.is_command_overridden(self.configured_commands, 'incoming'):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTM5NTU2OnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwOTowMTozM1rOHnFIgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMDoyNjowMVrOHnsWUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc0MDYwOQ==", "bodyText": "is this something that could be reused in the individual repository implementations ? same for _run_custom_incoming_command().", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510740609", "createdAt": "2020-10-23T09:01:33Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -75,6 +82,105 @@ def incoming(self):\n         \"\"\"\n         Check if there are any incoming changes.\n \n+        Return True if so, False otherwise.\n+        \"\"\"\n+        if self.is_command_overridden(self.configured_commands, 'incoming'):\n+            return self._run_custom_incoming_command(\n+                self.listify(self.configured_commands['incoming'])\n+            )\n+        return self.incoming_check()\n+\n+    def incoming_check(self):\n+        \"\"\"\n+        Check if there are any incoming changes.\n+\n         Return True if so, False otherwise.\n         \"\"\"\n         return True\n+\n+    def _run_custom_sync_command(self, command):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM4Mjc4Nw==", "bodyText": "I think it's possible, didn't do it for mercurial as it contains more complicated logic.", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r511382787", "createdAt": "2020-10-24T10:25:14Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -75,6 +82,105 @@ def incoming(self):\n         \"\"\"\n         Check if there are any incoming changes.\n \n+        Return True if so, False otherwise.\n+        \"\"\"\n+        if self.is_command_overridden(self.configured_commands, 'incoming'):\n+            return self._run_custom_incoming_command(\n+                self.listify(self.configured_commands['incoming'])\n+            )\n+        return self.incoming_check()\n+\n+    def incoming_check(self):\n+        \"\"\"\n+        Check if there are any incoming changes.\n+\n         Return True if so, False otherwise.\n         \"\"\"\n         return True\n+\n+    def _run_custom_sync_command(self, command):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc0MDYwOQ=="}, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM4MzEyMg==", "bodyText": "I split it to a commit per repository type, could you review it again if that is ok? I don't have enough resources to test all of the repository types.", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r511383122", "createdAt": "2020-10-24T10:26:01Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -75,6 +82,105 @@ def incoming(self):\n         \"\"\"\n         Check if there are any incoming changes.\n \n+        Return True if so, False otherwise.\n+        \"\"\"\n+        if self.is_command_overridden(self.configured_commands, 'incoming'):\n+            return self._run_custom_incoming_command(\n+                self.listify(self.configured_commands['incoming'])\n+            )\n+        return self.incoming_check()\n+\n+    def incoming_check(self):\n+        \"\"\"\n+        Check if there are any incoming changes.\n+\n         Return True if so, False otherwise.\n         \"\"\"\n         return True\n+\n+    def _run_custom_sync_command(self, command):", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc0MDYwOQ=="}, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTQwMDI0OnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwOTowMzowMVrOHnFLaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNDozMjoyMVrOHnQc1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc0MTM1NQ==", "bodyText": "log the actual command", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510741355", "createdAt": "2020-10-23T09:03:01Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -75,6 +82,105 @@ def incoming(self):\n         \"\"\"\n         Check if there are any incoming changes.\n \n+        Return True if so, False otherwise.\n+        \"\"\"\n+        if self.is_command_overridden(self.configured_commands, 'incoming'):\n+            return self._run_custom_incoming_command(\n+                self.listify(self.configured_commands['incoming'])\n+            )\n+        return self.incoming_check()\n+\n+    def incoming_check(self):\n+        \"\"\"\n+        Check if there are any incoming changes.\n+\n         Return True if so, False otherwise.\n         \"\"\"\n         return True\n+\n+    def _run_custom_sync_command(self, command):\n+        \"\"\"\n+        Execute the custom sync command.\n+\n+        :param command: the command\n+        :return: 0 on success execution, 1 otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        log_handler = self.logger.info if status == 0 else self.logger.warning\n+        log_handler(\"output of '{}':\".format(command))\n+        log_handler(output)\n+        return status\n+\n+    def _run_custom_incoming_command(self, command):\n+        \"\"\"\n+        Execute the custom incoming command.\n+\n+        :param command: the command\n+        :return: true when there are changes, false otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        if status != 0:\n+            self.logger.error(\"output of '{}':\".format(command))\n+            self.logger.error(output)\n+            raise RepositoryException(\n+                'failed to check for incoming in repository {}'.format(self)\n+            )\n+        return len(output.strip()) > 0\n+\n+    def _run_command(self, command):\n+        \"\"\"\n+        Execute the command.\n+\n+        :param command: the command\n+        :return: tuple of (status, output)\n+                    - status: 0 on success execution, non-zero otherwise\n+                    - output: command output as string\n+        \"\"\"\n+        cmd = self.getCommand(command, work_dir=self.path,\n+                              env_vars=self.env, logger=self.logger)\n+        cmd.execute()\n+        if cmd.getretcode() != 0 or cmd.getstate() != Command.FINISHED:\n+            cmd.log_error(\"failed to perform command\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc0MTg1Mg==", "bodyText": "and the retcode + state", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510741852", "createdAt": "2020-10-23T09:03:58Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -75,6 +82,105 @@ def incoming(self):\n         \"\"\"\n         Check if there are any incoming changes.\n \n+        Return True if so, False otherwise.\n+        \"\"\"\n+        if self.is_command_overridden(self.configured_commands, 'incoming'):\n+            return self._run_custom_incoming_command(\n+                self.listify(self.configured_commands['incoming'])\n+            )\n+        return self.incoming_check()\n+\n+    def incoming_check(self):\n+        \"\"\"\n+        Check if there are any incoming changes.\n+\n         Return True if so, False otherwise.\n         \"\"\"\n         return True\n+\n+    def _run_custom_sync_command(self, command):\n+        \"\"\"\n+        Execute the custom sync command.\n+\n+        :param command: the command\n+        :return: 0 on success execution, 1 otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        log_handler = self.logger.info if status == 0 else self.logger.warning\n+        log_handler(\"output of '{}':\".format(command))\n+        log_handler(output)\n+        return status\n+\n+    def _run_custom_incoming_command(self, command):\n+        \"\"\"\n+        Execute the custom incoming command.\n+\n+        :param command: the command\n+        :return: true when there are changes, false otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        if status != 0:\n+            self.logger.error(\"output of '{}':\".format(command))\n+            self.logger.error(output)\n+            raise RepositoryException(\n+                'failed to check for incoming in repository {}'.format(self)\n+            )\n+        return len(output.strip()) > 0\n+\n+    def _run_command(self, command):\n+        \"\"\"\n+        Execute the command.\n+\n+        :param command: the command\n+        :return: tuple of (status, output)\n+                    - status: 0 on success execution, non-zero otherwise\n+                    - output: command output as string\n+        \"\"\"\n+        cmd = self.getCommand(command, work_dir=self.path,\n+                              env_vars=self.env, logger=self.logger)\n+        cmd.execute()\n+        if cmd.getretcode() != 0 or cmd.getstate() != Command.FINISHED:\n+            cmd.log_error(\"failed to perform command\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc0MTM1NQ=="}, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkyNjAzNw==", "bodyText": "that's part of the method\n    def log_error(self, msg):\n        if self.state is Command.FINISHED:\n            self.logger.error(\"{}: command {} in directory {} exited with {}\".\n                              format(msg, self.cmd, self.work_dir,\n                                     self.getretcode()))\n        else:\n            self.logger.error(\"{}: command {} in directory {} ended with \"\n                              \"invalid state {}\".\n                              format(msg, self.cmd, self.work_dir, self.state))", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510926037", "createdAt": "2020-10-23T14:32:21Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -75,6 +82,105 @@ def incoming(self):\n         \"\"\"\n         Check if there are any incoming changes.\n \n+        Return True if so, False otherwise.\n+        \"\"\"\n+        if self.is_command_overridden(self.configured_commands, 'incoming'):\n+            return self._run_custom_incoming_command(\n+                self.listify(self.configured_commands['incoming'])\n+            )\n+        return self.incoming_check()\n+\n+    def incoming_check(self):\n+        \"\"\"\n+        Check if there are any incoming changes.\n+\n         Return True if so, False otherwise.\n         \"\"\"\n         return True\n+\n+    def _run_custom_sync_command(self, command):\n+        \"\"\"\n+        Execute the custom sync command.\n+\n+        :param command: the command\n+        :return: 0 on success execution, 1 otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        log_handler = self.logger.info if status == 0 else self.logger.warning\n+        log_handler(\"output of '{}':\".format(command))\n+        log_handler(output)\n+        return status\n+\n+    def _run_custom_incoming_command(self, command):\n+        \"\"\"\n+        Execute the custom incoming command.\n+\n+        :param command: the command\n+        :return: true when there are changes, false otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        if status != 0:\n+            self.logger.error(\"output of '{}':\".format(command))\n+            self.logger.error(output)\n+            raise RepositoryException(\n+                'failed to check for incoming in repository {}'.format(self)\n+            )\n+        return len(output.strip()) > 0\n+\n+    def _run_command(self, command):\n+        \"\"\"\n+        Execute the command.\n+\n+        :param command: the command\n+        :return: tuple of (status, output)\n+                    - status: 0 on success execution, non-zero otherwise\n+                    - output: command output as string\n+        \"\"\"\n+        cmd = self.getCommand(command, work_dir=self.path,\n+                              env_vars=self.env, logger=self.logger)\n+        cmd.execute()\n+        if cmd.getretcode() != 0 or cmd.getstate() != Command.FINISHED:\n+            cmd.log_error(\"failed to perform command\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc0MTM1NQ=="}, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTQ2NjYzOnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/test/python/test_mirror.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwOToyMDo1N1rOHnF0aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOTo1ODoxMFrOHnruYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1MTg0OQ==", "bodyText": "expected first, actual second ?", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510751849", "createdAt": "2020-10-23T09:20:57Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +400,185 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3Mjg5Ng==", "bodyText": "done", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r511372896", "createdAt": "2020-10-24T09:58:10Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +400,185 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1MTg0OQ=="}, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTUwMTUzOnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/test/python/test_mirror.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwOToyOTo0M1rOHnGJ2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOTo1OTo1NlrOHnrw_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1NzMzOA==", "bodyText": "make 'default-command' a variable ?", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510757338", "createdAt": "2020-10-23T09:29:43Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +400,185 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [\n+    (None, 'default-command'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3MzU2NA==", "bodyText": "done", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r511373564", "createdAt": "2020-10-24T09:59:56Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/test/python/test_mirror.py", "diffHunk": "@@ -376,3 +400,185 @@ def mock_get_repo_type(*args):\n             repos = get_repos_for_project(project_name, None, source_root,\n                                           ignored_repos=['.'])\n             assert len(repos) == 0\n+\n+\n+@pytest.mark.parametrize(['config', 'expected_command'], [\n+    (None, 'default-command'),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1NzMzOA=="}, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTUxNTcxOnYy", "diffSide": "RIGHT", "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwOTozMzozM1rOHnGSmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwOTo1NDoxNlrOHnro9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1OTU3Ng==", "bodyText": "this should probably say that it looks up the 'command' key", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r510759576", "createdAt": "2020-10-23T09:33:33Z", "author": {"login": "vladak"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -75,6 +82,105 @@ def incoming(self):\n         \"\"\"\n         Check if there are any incoming changes.\n \n+        Return True if so, False otherwise.\n+        \"\"\"\n+        if self.is_command_overridden(self.configured_commands, 'incoming'):\n+            return self._run_custom_incoming_command(\n+                self.listify(self.configured_commands['incoming'])\n+            )\n+        return self.incoming_check()\n+\n+    def incoming_check(self):\n+        \"\"\"\n+        Check if there are any incoming changes.\n+\n         Return True if so, False otherwise.\n         \"\"\"\n         return True\n+\n+    def _run_custom_sync_command(self, command):\n+        \"\"\"\n+        Execute the custom sync command.\n+\n+        :param command: the command\n+        :return: 0 on success execution, 1 otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        log_handler = self.logger.info if status == 0 else self.logger.warning\n+        log_handler(\"output of '{}':\".format(command))\n+        log_handler(output)\n+        return status\n+\n+    def _run_custom_incoming_command(self, command):\n+        \"\"\"\n+        Execute the custom incoming command.\n+\n+        :param command: the command\n+        :return: true when there are changes, false otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        if status != 0:\n+            self.logger.error(\"output of '{}':\".format(command))\n+            self.logger.error(output)\n+            raise RepositoryException(\n+                'failed to check for incoming in repository {}'.format(self)\n+            )\n+        return len(output.strip()) > 0\n+\n+    def _run_command(self, command):\n+        \"\"\"\n+        Execute the command.\n+\n+        :param command: the command\n+        :return: tuple of (status, output)\n+                    - status: 0 on success execution, non-zero otherwise\n+                    - output: command output as string\n+        \"\"\"\n+        cmd = self.getCommand(command, work_dir=self.path,\n+                              env_vars=self.env, logger=self.logger)\n+        cmd.execute()\n+        if cmd.getretcode() != 0 or cmd.getstate() != Command.FINISHED:\n+            cmd.log_error(\"failed to perform command\")\n+            status = cmd.getretcode()\n+            if status == 0 and cmd.getstate() != Command.FINISHED:\n+                status = 1\n+            return status, '\\n'.join(filter(None, [\n+                cmd.getoutputstr(),\n+                cmd.geterroutputstr()\n+            ]))\n+        return 0, cmd.getoutputstr()\n+\n+    @staticmethod\n+    def _repository_command(configured_commands, default=lambda: None):\n+        \"\"\"\n+        Get the repository command, or use default supplier.\n+\n+        :param configured_commands: commands section from configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3MTUwOQ==", "bodyText": "When I add that, I should perhaps mention that it only does the lookup when the configured_commands is a dictionary and that all together....is exactly what is in the code. So I'm not a big fan adding that comment.", "url": "https://github.com/oracle/opengrok/pull/3285#discussion_r511371509", "createdAt": "2020-10-24T09:54:16Z", "author": {"login": "tulinkry"}, "path": "opengrok-tools/src/main/python/opengrok_tools/scm/repository.py", "diffHunk": "@@ -75,6 +82,105 @@ def incoming(self):\n         \"\"\"\n         Check if there are any incoming changes.\n \n+        Return True if so, False otherwise.\n+        \"\"\"\n+        if self.is_command_overridden(self.configured_commands, 'incoming'):\n+            return self._run_custom_incoming_command(\n+                self.listify(self.configured_commands['incoming'])\n+            )\n+        return self.incoming_check()\n+\n+    def incoming_check(self):\n+        \"\"\"\n+        Check if there are any incoming changes.\n+\n         Return True if so, False otherwise.\n         \"\"\"\n         return True\n+\n+    def _run_custom_sync_command(self, command):\n+        \"\"\"\n+        Execute the custom sync command.\n+\n+        :param command: the command\n+        :return: 0 on success execution, 1 otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        log_handler = self.logger.info if status == 0 else self.logger.warning\n+        log_handler(\"output of '{}':\".format(command))\n+        log_handler(output)\n+        return status\n+\n+    def _run_custom_incoming_command(self, command):\n+        \"\"\"\n+        Execute the custom incoming command.\n+\n+        :param command: the command\n+        :return: true when there are changes, false otherwise\n+        \"\"\"\n+        status, output = self._run_command(command)\n+        if status != 0:\n+            self.logger.error(\"output of '{}':\".format(command))\n+            self.logger.error(output)\n+            raise RepositoryException(\n+                'failed to check for incoming in repository {}'.format(self)\n+            )\n+        return len(output.strip()) > 0\n+\n+    def _run_command(self, command):\n+        \"\"\"\n+        Execute the command.\n+\n+        :param command: the command\n+        :return: tuple of (status, output)\n+                    - status: 0 on success execution, non-zero otherwise\n+                    - output: command output as string\n+        \"\"\"\n+        cmd = self.getCommand(command, work_dir=self.path,\n+                              env_vars=self.env, logger=self.logger)\n+        cmd.execute()\n+        if cmd.getretcode() != 0 or cmd.getstate() != Command.FINISHED:\n+            cmd.log_error(\"failed to perform command\")\n+            status = cmd.getretcode()\n+            if status == 0 and cmd.getstate() != Command.FINISHED:\n+                status = 1\n+            return status, '\\n'.join(filter(None, [\n+                cmd.getoutputstr(),\n+                cmd.geterroutputstr()\n+            ]))\n+        return 0, cmd.getoutputstr()\n+\n+    @staticmethod\n+    def _repository_command(configured_commands, default=lambda: None):\n+        \"\"\"\n+        Get the repository command, or use default supplier.\n+\n+        :param configured_commands: commands section from configuration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1OTU3Ng=="}, "originalCommit": {"oid": "739a0f8cfc53ac79257a1a37bcdda10d05df3725"}, "originalPosition": 115}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4991, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}