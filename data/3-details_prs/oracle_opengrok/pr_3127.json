{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NjMwMzQx", "number": 3127, "title": "Minimize reflection into Configuration", "bodyText": "Hello,\nPlease consider for integration this patch to minimize reflection into Configuration and shift that logic to ConfigurationController where it's more difficult to avoid given the REST-exposure of all configuration through a single web method.\nRuntimeEnvironment can use functional interfaces to achieve the equivalent of the former reflection without having to identify methods by String; thereby we get compile-time checks.\nI also imported an auto-disposable wrapper around Lock so that try-with-resources can be used instead of try-finally.\nThank you.", "createdAt": "2020-04-23T01:34:52Z", "url": "https://github.com/oracle/opengrok/pull/3127", "merged": true, "mergeCommit": {"oid": "31c97f264c286ebed7ff0223344d29a12c644616"}, "closed": true, "closedAt": "2020-05-27T06:00:41Z", "author": {"login": "idodeclare"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaXRXjAFqTM5ODc5MzU5Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcekRqUgFqTQwNjM5NDI3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NzkzNTkz", "url": "https://github.com/oracle/opengrok/pull/3127#pullrequestreview-398793593", "createdAt": "2020-04-23T06:30:12Z", "commit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjozMDoxMlrOGKYtyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjo1NDo0MlrOGKZkqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0Mzg4Mw==", "bodyText": "I'd swap the parameter order cause at it seems more natural to me like this\nsyncWriteConfiguration(groups, (c, g) -> {\n      populateGroups(g, new TreeSet<>(getProjects().values()));\n      c.setGroups(g);\n});\n\nas its \"value -> consume\" that value, rather then \"consumer of a value -> value\"", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413543883", "createdAt": "2020-04-23T06:30:12Z", "author": {"login": "ktulinger"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0NTU0OA==", "bodyText": "why this.writeLock().unlock() is not enough?", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413545548", "createdAt": "2020-04-23T06:33:52Z", "author": {"login": "ktulinger"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/CloseableReentrantReadWriteLock.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * This work is licensed under the Creative Commons Attribution-ShareAlike 4.0\n+ * International License. To view a copy of this license, visit\n+ * https://creativecommons.org/licenses/by-sa/4.0/ or send a letter to\n+ * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n+ *\n+ * Copyright (c) 2017, https://stackoverflow.com/users/7583219/skoskav\n+ * Copyright (c) 2011, https://stackoverflow.com/questions/6965731/are-locks-autocloseable\n+ * Portions Copyright (c) 2019-2020, Chris Fraire <cfraire@me.com>.\n+ *\n+ * Used under CC 4 with modifications noted as follows as required by license:\n+ * 2019-09-10 -- cfraire@me.com, derived to use for ReentrantReadWriteLock.\n+ * 2020-04-21 -- cfraire@me.com, updated for proper handling re Serializable.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Represents a subclass of {@link ReentrantReadWriteLock} that can return\n+ * {@link ResourceLock} instances.\n+ */\n+public final class CloseableReentrantReadWriteLock extends ReentrantReadWriteLock {\n+\n+    private static final long serialVersionUID = 95L;\n+\n+    private transient ResourceLock readUnlocker = newReadUnlocker();\n+\n+    private transient ResourceLock writeUnlocker = newWriteUnlocker();\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #readLock()} has\n+     * been acquired\n+     */\n+    public ResourceLock readLockAsResource() {\n+        /*\n+         * A subclass of ReentrantReadWriteLock is forced to be serializable, so\n+         * we would have to handle where serialization can short-circuit field\n+         * initialization above and leave the instance's fields null.\n+         * Consequently, the fields cannot be final. They are encapsulating\n+         * fixed logic, so we can optimize and choose not to even bother\n+         * serializing by declaring transient and handling below.\n+         */\n+        ResourceLock unlocker = readUnlocker;\n+        if (unlocker == null) {\n+            unlocker = newReadUnlocker();\n+            // No synchronization necessary since overwrite is of no matter.\n+            readUnlocker = unlocker;\n+        }\n+        readLock().lock();\n+        return unlocker;\n+    }\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #writeLock()} ()}\n+     * has been acquired\n+     */\n+    public ResourceLock writeLockAsResource() {\n+        /*\n+         * A subclass of ReentrantReadWriteLock is forced to be serializable, so\n+         * we would have to handle where serialization can short-circuit field\n+         * initialization above and leave the instance's fields null.\n+         * Consequently, the fields cannot be final. They are encapsulating\n+         * fixed logic, so we can optimize and choose not to even bother\n+         * serializing by declaring transient and handling below.\n+         */\n+        ResourceLock unlocker = writeUnlocker;\n+        if (unlocker == null) {\n+            unlocker = newWriteUnlocker();\n+            // No synchronization necessary since overwrite is of no matter.\n+            writeUnlocker = unlocker;\n+        }\n+        writeLock().lock();\n+        return unlocker;\n+    }\n+\n+    private ResourceLock newReadUnlocker() {\n+        return () -> CloseableReentrantReadWriteLock.this.readLock().unlock();\n+    }\n+\n+    private ResourceLock newWriteUnlocker() {\n+        return () -> CloseableReentrantReadWriteLock.this.writeLock().unlock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1Mjg4Nw==", "bodyText": "why do you assert this when you're explicitely checking this in write|readLockAsResource?", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413552887", "createdAt": "2020-04-23T06:48:19Z", "author": {"login": "ktulinger"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/configuration/RuntimeEnvironment.java", "diffHunk": "@@ -1996,14 +1843,45 @@ public File getDtagsEftar() {\n     }\n \n     public SuggesterConfig getSuggesterConfig() {\n-        return (SuggesterConfig) getConfigurationValue(\"suggesterConfig\");\n+        return syncReadConfiguration(Configuration::getSuggesterConfig);\n     }\n \n     public void setSuggesterConfig(SuggesterConfig config) {\n-        setConfigurationValue(\"suggesterConfig\", config);\n+        syncWriteConfiguration(Configuration::setSuggesterConfig, config);\n+    }\n+\n+    /**\n+     * Applies the specified function to the runtime configuration, after having\n+     * obtained the configuration read-lock (and releasing afterward).\n+     * @param function a defined function\n+     * @param <R> the type of the result of the function\n+     * @return the function result\n+     */\n+    public <R> R syncReadConfiguration(Function<Configuration, R> function) {\n+        try (ResourceLock resourceLock = configLock.readLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;\n+            return function.apply(configuration);\n+        }\n+    }\n+\n+    /**\n+     * Performs the specified operation which is provided the runtime\n+     * configuration and the specified argument, after first having obtained the\n+     * configuration write-lock (and releasing afterward).\n+     * @param consumer a defined consumer\n+     * @param v the input argument\n+     * @param <V> the type of the input to the operation\n+     */\n+    public <V> void syncWriteConfiguration(ConfigurationValueConsumer<V> consumer, V v) {\n+        try (ResourceLock resourceLock = configLock.writeLockAsResource()) {\n+            //noinspection ConstantConditions to silence unreference auto-closeable\n+            assert resourceLock != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 1346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1MzYyMA==", "bodyText": "there are some extra brackets", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413553620", "createdAt": "2020-04-23T06:49:03Z", "author": {"login": "ktulinger"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/util/CloseableReentrantReadWriteLock.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * This work is licensed under the Creative Commons Attribution-ShareAlike 4.0\n+ * International License. To view a copy of this license, visit\n+ * https://creativecommons.org/licenses/by-sa/4.0/ or send a letter to\n+ * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n+ *\n+ * Copyright (c) 2017, https://stackoverflow.com/users/7583219/skoskav\n+ * Copyright (c) 2011, https://stackoverflow.com/questions/6965731/are-locks-autocloseable\n+ * Portions Copyright (c) 2019-2020, Chris Fraire <cfraire@me.com>.\n+ *\n+ * Used under CC 4 with modifications noted as follows as required by license:\n+ * 2019-09-10 -- cfraire@me.com, derived to use for ReentrantReadWriteLock.\n+ * 2020-04-21 -- cfraire@me.com, updated for proper handling re Serializable.\n+ */\n+\n+package org.opengrok.indexer.util;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Represents a subclass of {@link ReentrantReadWriteLock} that can return\n+ * {@link ResourceLock} instances.\n+ */\n+public final class CloseableReentrantReadWriteLock extends ReentrantReadWriteLock {\n+\n+    private static final long serialVersionUID = 95L;\n+\n+    private transient ResourceLock readUnlocker = newReadUnlocker();\n+\n+    private transient ResourceLock writeUnlocker = newWriteUnlocker();\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #readLock()} has\n+     * been acquired\n+     */\n+    public ResourceLock readLockAsResource() {\n+        /*\n+         * A subclass of ReentrantReadWriteLock is forced to be serializable, so\n+         * we would have to handle where serialization can short-circuit field\n+         * initialization above and leave the instance's fields null.\n+         * Consequently, the fields cannot be final. They are encapsulating\n+         * fixed logic, so we can optimize and choose not to even bother\n+         * serializing by declaring transient and handling below.\n+         */\n+        ResourceLock unlocker = readUnlocker;\n+        if (unlocker == null) {\n+            unlocker = newReadUnlocker();\n+            // No synchronization necessary since overwrite is of no matter.\n+            readUnlocker = unlocker;\n+        }\n+        readLock().lock();\n+        return unlocker;\n+    }\n+\n+    /**\n+     * @return a defined {@link ResourceLock} once the {@link #writeLock()} ()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1NzY1NQ==", "bodyText": "the exception here is only translated to throw new WebApplicationException(e, Response.Status.BAD_REQUEST)\ncan you thro that one here and remove the try block in the caller?", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413557655", "createdAt": "2020-04-23T06:54:09Z", "author": {"login": "ktulinger"}, "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/controller/ConfigurationController.java", "diffHunk": "@@ -91,4 +94,37 @@ public void reloadAuthorization() {\n         env.getAuthorizationFramework().reload();\n     }\n \n+    private Object getConfigurationValueException(String fieldName) throws IOException {\n+        final IOException[] capture = new IOException[1];\n+        final int EXCEPTION_INDEX = 0;\n+        Object result = env.syncReadConfiguration(configuration -> {\n+            try {\n+                return ClassUtil.getFieldValue(configuration, fieldName);\n+            } catch (IOException ex) {\n+                capture[EXCEPTION_INDEX] = ex;\n+                return null;\n+            }\n+        });\n+        if (capture[EXCEPTION_INDEX] != null) {\n+            throw capture[EXCEPTION_INDEX];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU1NzkzMA==", "bodyText": "extra line?", "url": "https://github.com/oracle/opengrok/pull/3127#discussion_r413557930", "createdAt": "2020-04-23T06:54:42Z", "author": {"login": "ktulinger"}, "path": "opengrok-web/src/main/java/org/opengrok/web/api/v1/controller/ConfigurationController.java", "diffHunk": "@@ -91,4 +94,37 @@ public void reloadAuthorization() {\n         env.getAuthorizationFramework().reload();\n     }\n \n+    private Object getConfigurationValueException(String fieldName) throws IOException {\n+        final IOException[] capture = new IOException[1];\n+        final int EXCEPTION_INDEX = 0;\n+        Object result = env.syncReadConfiguration(configuration -> {\n+            try {\n+                return ClassUtil.getFieldValue(configuration, fieldName);\n+            } catch (IOException ex) {\n+                capture[EXCEPTION_INDEX] = ex;\n+                return null;\n+            }\n+        });\n+        if (capture[EXCEPTION_INDEX] != null) {\n+            throw capture[EXCEPTION_INDEX];\n+        }\n+        return result;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd623fb108a34b2c49017c772ea9a93776367a56"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MjE3NDQ1", "url": "https://github.com/oracle/opengrok/pull/3127#pullrequestreview-405217445", "createdAt": "2020-05-04T17:58:04Z", "commit": {"oid": "4e2b0c1caf0f5d2f77da66a044d08e18fdf2138d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4151dbf5c28985f406f4f07f1c40626ac31346b4", "author": {"user": {"login": "idodeclare", "name": "C Fraire"}}, "url": "https://github.com/oracle/opengrok/commit/4151dbf5c28985f406f4f07f1c40626ac31346b4", "committedDate": "2020-05-05T17:27:39Z", "message": "Minimize reflection into Configuration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "754ebdfb143928d28147e93dc63439b87a11f921", "author": {"user": {"login": "idodeclare", "name": "C Fraire"}}, "url": "https://github.com/oracle/opengrok/commit/754ebdfb143928d28147e93dc63439b87a11f921", "committedDate": "2020-05-05T17:27:39Z", "message": "Address review feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e2b0c1caf0f5d2f77da66a044d08e18fdf2138d", "author": {"user": {"login": "idodeclare", "name": "C Fraire"}}, "url": "https://github.com/oracle/opengrok/commit/4e2b0c1caf0f5d2f77da66a044d08e18fdf2138d", "committedDate": "2020-04-23T18:13:45Z", "message": "Address review feedback"}, "afterCommit": {"oid": "754ebdfb143928d28147e93dc63439b87a11f921", "author": {"user": {"login": "idodeclare", "name": "C Fraire"}}, "url": "https://github.com/oracle/opengrok/commit/754ebdfb143928d28147e93dc63439b87a11f921", "committedDate": "2020-05-05T17:27:39Z", "message": "Address review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Mzk0Mjcx", "url": "https://github.com/oracle/opengrok/pull/3127#pullrequestreview-406394271", "createdAt": "2020-05-06T08:19:41Z", "commit": {"oid": "754ebdfb143928d28147e93dc63439b87a11f921"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 335, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}