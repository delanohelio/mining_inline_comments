{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1MTcxOTE3", "number": 3063, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTowMTo0NlrOEOuiaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTowOToyMlrOEOuvEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODc3OTkyOnYy", "diffSide": "RIGHT", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/analysis/TextAnalyzer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTowMTo0NlrOGyCdIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxNToyMjo0N1rOGzo2lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyMjIxMQ==", "bodyText": "why is this suddenly needed ? What Reader suffers from the 0 return problem specifically ?", "url": "https://github.com/oracle/opengrok/pull/3063#discussion_r455122211", "createdAt": "2020-07-15T15:01:46Z", "author": {"login": "vladak"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/analysis/TextAnalyzer.java", "diffHunk": "@@ -91,10 +91,13 @@ public Xrefer writeXref(WriteXrefArgs args) throws IOException {\n      */\n     protected abstract Xrefer newXref(Reader reader);\n \n+    /**\n+     * Gets a BOM-stripped {@link Reader} (default UTF-8 charset) of the\n+     * specified {@code stream}, wrapped in a {@link ZeroReader}.\n+     */\n     protected Reader getReader(InputStream stream) throws IOException {\n-        // SRCROOT is read with UTF-8 as a default.\n-        return IOUtils.createBOMStrippedReader(stream,\n-            StandardCharsets.UTF_8.name());\n+        // sourceRoot is read with UTF-8 as a default.\n+        return new ZeroReader(IOUtils.createBOMStrippedReader(stream,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1587490ce2dbb99bdf0da1f28a8b16e4eba7a33"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5OTg5Mw==", "bodyText": "JFlex just advises that on some JRE implementations, they found readers returning 0 sometimes. JFlex prior to 1.6.1 did a guard against this, but afterward JFlex offered ZeroReader as the guard, which needs to be explicitly used. I'm putting ZeroReader then into OpenGrok, since the workaround is desirable.", "url": "https://github.com/oracle/opengrok/pull/3063#discussion_r456799893", "createdAt": "2020-07-18T15:22:47Z", "author": {"login": "idodeclare"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/analysis/TextAnalyzer.java", "diffHunk": "@@ -91,10 +91,13 @@ public Xrefer writeXref(WriteXrefArgs args) throws IOException {\n      */\n     protected abstract Xrefer newXref(Reader reader);\n \n+    /**\n+     * Gets a BOM-stripped {@link Reader} (default UTF-8 charset) of the\n+     * specified {@code stream}, wrapped in a {@link ZeroReader}.\n+     */\n     protected Reader getReader(InputStream stream) throws IOException {\n-        // SRCROOT is read with UTF-8 as a default.\n-        return IOUtils.createBOMStrippedReader(stream,\n-            StandardCharsets.UTF_8.name());\n+        // sourceRoot is read with UTF-8 as a default.\n+        return new ZeroReader(IOUtils.createBOMStrippedReader(stream,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyMjIxMQ=="}, "originalCommit": {"oid": "b1587490ce2dbb99bdf0da1f28a8b16e4eba7a33"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODgxMjMzOnYy", "diffSide": "RIGHT", "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/analysis/JFlexTokenizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTowOToyMlrOGyCxUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxNToyNDo0NFrOGzo3Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyNzM3OA==", "bodyText": "nit/question: why not use this.didSetAttribsValues like in setAttribs() ?", "url": "https://github.com/oracle/opengrok/pull/3063#discussion_r455127378", "createdAt": "2020-07-15T15:09:22Z", "author": {"login": "vladak"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/analysis/JFlexTokenizer.java", "diffHunk": "@@ -119,18 +128,44 @@ public void sourceCodeSeen(SourceCodeSeenEvent evt) {\n \n     /**\n      * Clears, and then resets the instances attributes per the specified\n-     * arguments.\n+     * arguments. If {@code start} or {@code end} is past\n+     * {@link Integer#MAX_VALUE}, then only the clearing occurs.\n      * @param str the matched symbol\n      * @param start the match start position\n      * @param end the match end position\n      */\n-    protected void setAttribs(String str, int start, int end) {\n+    protected void setAttribs(String str, long start, long end) {\n+        clearAttributesEtc();\n+        if (start < Integer.MAX_VALUE && end < Integer.MAX_VALUE) {\n+\n+            if (str.length() > LUCENE_MAX_TOKEN_LENGTH) {\n+                str = str.substring(0, LUCENE_MAX_TOKEN_LENGTH);\n+                /*\n+                 * Leave `end` unadjusted. The truncated string will represent\n+                 * the full source text, similar to how a Lucene synonym is an\n+                 * alternative representation of full source text.\n+                 */\n+            }\n+\n+            /*\n+             * FIXME increasing below by one(default) might be tricky, need more\n+             * analysis after lucene upgrade to 3.5 below is most probably not\n+             * even needed.\n+             */\n+            this.posIncrAtt.setPositionIncrement(1);\n+            this.termAtt.setEmpty();\n+            this.termAtt.append(str);\n+            this.offsetAtt.setOffset((int) start, (int) end);\n+            this.didSetAttribsValues = true;\n+        }\n+    }\n+\n+    /**\n+     * Calls {@link #clearAttributes()}, and also resets some additional tracked\n+     * state.\n+     */\n+    protected void clearAttributesEtc() {\n         clearAttributes();\n-        //FIXME increasing below by one(default) might be tricky, need more analysis\n-        // after lucene upgrade to 3.5 below is most probably not even needed        \n-        this.posIncrAtt.setPositionIncrement(1);\n-        this.termAtt.setEmpty();\n-        this.termAtt.append(str);\n-        this.offsetAtt.setOffset(start, end);\n+        didSetAttribsValues = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1587490ce2dbb99bdf0da1f28a8b16e4eba7a33"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwMDAyNg==", "bodyText": "Oh I preserved the former syntax by the previous author. In methods I don't normally use this. unless disambiguation is needed \u2014 e.g. often within setters. In the new clearAttributesEtc() there was no ambiguity.", "url": "https://github.com/oracle/opengrok/pull/3063#discussion_r456800026", "createdAt": "2020-07-18T15:24:44Z", "author": {"login": "idodeclare"}, "path": "opengrok-indexer/src/main/java/org/opengrok/indexer/analysis/JFlexTokenizer.java", "diffHunk": "@@ -119,18 +128,44 @@ public void sourceCodeSeen(SourceCodeSeenEvent evt) {\n \n     /**\n      * Clears, and then resets the instances attributes per the specified\n-     * arguments.\n+     * arguments. If {@code start} or {@code end} is past\n+     * {@link Integer#MAX_VALUE}, then only the clearing occurs.\n      * @param str the matched symbol\n      * @param start the match start position\n      * @param end the match end position\n      */\n-    protected void setAttribs(String str, int start, int end) {\n+    protected void setAttribs(String str, long start, long end) {\n+        clearAttributesEtc();\n+        if (start < Integer.MAX_VALUE && end < Integer.MAX_VALUE) {\n+\n+            if (str.length() > LUCENE_MAX_TOKEN_LENGTH) {\n+                str = str.substring(0, LUCENE_MAX_TOKEN_LENGTH);\n+                /*\n+                 * Leave `end` unadjusted. The truncated string will represent\n+                 * the full source text, similar to how a Lucene synonym is an\n+                 * alternative representation of full source text.\n+                 */\n+            }\n+\n+            /*\n+             * FIXME increasing below by one(default) might be tricky, need more\n+             * analysis after lucene upgrade to 3.5 below is most probably not\n+             * even needed.\n+             */\n+            this.posIncrAtt.setPositionIncrement(1);\n+            this.termAtt.setEmpty();\n+            this.termAtt.append(str);\n+            this.offsetAtt.setOffset((int) start, (int) end);\n+            this.didSetAttribsValues = true;\n+        }\n+    }\n+\n+    /**\n+     * Calls {@link #clearAttributes()}, and also resets some additional tracked\n+     * state.\n+     */\n+    protected void clearAttributesEtc() {\n         clearAttributes();\n-        //FIXME increasing below by one(default) might be tricky, need more analysis\n-        // after lucene upgrade to 3.5 below is most probably not even needed        \n-        this.posIncrAtt.setPositionIncrement(1);\n-        this.termAtt.setEmpty();\n-        this.termAtt.append(str);\n-        this.offsetAtt.setOffset(start, end);\n+        didSetAttribsValues = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEyNzM3OA=="}, "originalCommit": {"oid": "b1587490ce2dbb99bdf0da1f28a8b16e4eba7a33"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 195, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}