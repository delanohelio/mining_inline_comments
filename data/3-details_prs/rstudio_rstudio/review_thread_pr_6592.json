{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4NDYxNDQ1", "number": 6592, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyNDowMFrODvT4mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1Nzo0NlrODvUgCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTM1NDQ5OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/themes/AceThemes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyNDowMFrOGBqdBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyNDowMFrOGBqdBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NzMxNg==", "bodyText": "nit, update copyright year in header", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404397316", "createdAt": "2020-04-06T21:24:00Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/themes/AceThemes.java", "diffHunk": "@@ -28,6 +28,7 @@\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTM2MDM2OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/themes/AceThemes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyNTo1NFrOGBqgwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyNTo1NFrOGBqgwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5ODI3NA==", "bodyText": "Might as well move this down to line 89 where it is first used (and only used inside that block as far as I can see).", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404398274", "createdAt": "2020-04-06T21:25:54Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/themes/AceThemes.java", "diffHunk": "@@ -74,6 +78,33 @@ private void applyTheme(Document document, final AceTheme theme)\n       currentStyleEl.setRel(\"stylesheet\");\n       currentStyleEl.setId(linkId_);\n       currentStyleEl.setHref(themeUrl.toString());\n+      \n+      // In server mode, augment the theme with a font if we have one\n+      LinkElement fontEl = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTM2NzA3OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/themes/AceThemes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyODowOFrOGBqlHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyODowOFrOGBqlHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5OTM4OQ==", "bodyText": "fontId_ (and, actually, linkId_) could be local variables inside applyTheme().", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404399389", "createdAt": "2020-04-06T21:28:08Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/themes/AceThemes.java", "diffHunk": "@@ -249,6 +280,8 @@ public void onError(ServerError error)\n    private ThemeServerOperations themeServerOperations_;\n    private final EventBus events_;\n    private final Provider<UserState> state_;\n+   private final Provider<UserPrefs> prefs_;\n    private final String linkId_ = \"rstudio-acethemes-linkelement\";\n+   private final String fontId_ = \"rstudio-fontelement\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTM3MTUyOnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/prefs/views/AppearancePreferencesPane.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyOToyOFrOGBqn1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyOToyOFrOGBqn1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMDA4Ng==", "bodyText": "Don't think this is used.", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404400086", "createdAt": "2020-04-06T21:29:28Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/prefs/views/AppearancePreferencesPane.java", "diffHunk": "@@ -40,13 +43,19 @@\n import org.rstudio.studio.client.common.FileDialogs;\n import org.rstudio.studio.client.common.GlobalDisplay;\n import org.rstudio.studio.client.common.dependencies.DependencyManager;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n import org.rstudio.studio.client.workbench.WorkbenchContext;\n import org.rstudio.studio.client.workbench.prefs.model.UserPrefs;\n import org.rstudio.studio.client.workbench.prefs.model.UserState;\n import org.rstudio.studio.client.workbench.views.source.editors.text.themes.AceTheme;\n import org.rstudio.studio.client.workbench.views.source.editors.text.themes.AceThemes;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.themes.model.ThemeServerOperations;\n \n+import java.util.ArrayList;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTM4MDAwOnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/prefs/views/AppearancePreferencesPane.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTozMjozMFrOGBqtYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTozMjozMFrOGBqtYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMTUwNg==", "bodyText": "Can leave out String  in new, i.e. new TreeSet<>();", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404401506", "createdAt": "2020-04-06T21:32:30Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/prefs/views/AppearancePreferencesPane.java", "diffHunk": "@@ -617,16 +672,77 @@ public boolean execute()\n                return true;\n          \n             String[] fontList = fonts.split(\"\\\\n\");\n-            String value = fontFace_.getValue();\n-            value = value.replaceAll(\"\\\\\\\"\", \"\");\n-            fontFace_.setLabel(\"Editor font:\");\n-            fontFace_.setChoices(fontList, fontList);\n-            fontFace_.setValue(value);\n+            populateFontList(fontList);\n             return false;\n          }\n          \n       }, 100);\n    }\n+   \n+   private void getInstalledFontList()\n+   {\n+      // Search for installed fixed-width fonts on this web browser.\n+      final Set<String> browserFonts = new TreeSet<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTM4NDgyOnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/prefs/views/AceEditorPreview.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTozMzo0M1rOGBqwSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTozMzo0M1rOGBqwSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMjI0OA==", "bodyText": "nit, update copyright in header", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404402248", "createdAt": "2020-04-06T21:33:43Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/prefs/views/AceEditorPreview.java", "diffHunk": "@@ -26,6 +26,7 @@\n import org.rstudio.core.client.theme.ThemeFonts;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTM5NjE5OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/server/remote/RemoteServer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTozNzozNlrOGBq3cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTozNzozNlrOGBq3cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNDA4MA==", "bodyText": "nit, copyright year in header", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404404080", "createdAt": "2020-04-06T21:37:36Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/server/remote/RemoteServer.java", "diffHunk": "@@ -6154,6 +6154,12 @@ public void pandocListExtensions(String format, ServerRequestCallback<String> ca\n       sendRequest(RPC_SCOPE, PANDOC_LIST_EXTENSIONS, format, callback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTM5ODI2OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/common/sourcemarkers/SourceMarkerItemCodec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTozODoyMVrOGBq4xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTozODoyMVrOGBq4xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNDQyMQ==", "bodyText": "nit, copyright year in header", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404404421", "createdAt": "2020-04-06T21:38:21Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/common/sourcemarkers/SourceMarkerItemCodec.java", "diffHunk": "@@ -19,6 +19,7 @@\n import org.rstudio.core.client.CodeNavigationTarget;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTQxMzgxOnYy", "diffSide": "RIGHT", "path": "src/cpp/session/modules/SessionFonts.hpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo0Mzo0NFrOGBrCsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo0Mzo0NFrOGBrCsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2Mg==", "bodyText": "ultrai-nit: Most new files use Copyright (c) 2020 by RStudio, PBC. and leave out the 2009-", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404406962", "createdAt": "2020-04-06T21:43:44Z", "author": {"login": "gtritchie"}, "path": "src/cpp/session/modules/SessionFonts.hpp", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * SessionFonts.hpp\n+ *\n+ * Copyright (C) 2009-20 by RStudio, PBC", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTQzOTU5OnYy", "diffSide": "RIGHT", "path": "src/cpp/session/modules/SessionFonts.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1Mjo0MlrOGBrSiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1Mjo0MlrOGBrSiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTAxNw==", "bodyText": "Could use: for (const auto& fontExtension : s_fontExtensions) here and if (ext == fontExtension) below.", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404411017", "createdAt": "2020-04-06T21:52:42Z", "author": {"login": "gtritchie"}, "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTQ0MTA5OnYy", "diffSide": "RIGHT", "path": "src/cpp/session/modules/SessionFonts.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1MzoxNFrOGBrTeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1MzoxNFrOGBrTeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTI1OA==", "bodyText": "don't need this return", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404411258", "createdAt": "2020-04-06T21:53:14Z", "author": {"login": "gtritchie"}, "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+   {\n+      if (ext == s_fontExtensions.at(i))\n+         return true;\n+   }\n+\n+   // No extensions match\n+   return false;\n+}\n+\n+// The path to the user-specific font folder\n+core::FilePath userFontFolder()\n+{\n+   return core::system::xdg::userConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// The path to the system-wide font folder\n+core::FilePath systemFontFolder()\n+{\n+   return core::system::xdg::systemConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// Generates a CSS snippet from a font file.\n+Error generateCssFromFile(const FilePath& file,\n+                          const std::string& fontName,\n+                          const std::vector<std::string>& parents,\n+                          std::string *pCss)\n+{\n+   pCss->append(\"@font-face {\\n\"\n+                \"  font-family: \\\"\" + fontName + \"\\\";\\n\"\n+                \"  src: url('../files/\");\n+\n+   // Build URL to font file from parent folders. \n+   for (const auto& parent: parents)\n+   {\n+      pCss->append(parent + \"/\");\n+   }\n+   pCss->append(file.getFilename() + \"');\\n\");\n+\n+   // Convert each parent folder\n+   for (const auto& parent: parents)\n+   {\n+      // Check to see whether this directory looks like a font weight\n+      // font style.\n+      auto weight = safe_convert::stringTo<int>(parent);\n+      if (weight)\n+      {\n+         // Looks like a number, so generate a weight rule and recurse.\n+         pCss->append(\"  font-weight: \" + parent + \";\\n\");\n+      }\n+      else if (parent == \"oblique\" || parent == \"italic\")\n+      {\n+         // It's a style\n+         pCss->append(\"  font-style: \" + parent + \";\\n\");\n+      }\n+   }\n+\n+   pCss->append(\"}\\n\\n\");\n+   return Success();\n+}\n+\n+// Generates CSS from a directory representing a number of variants of a single font face. The\n+// directory structure is used to provide font metadata. For instance, a font with regular (400) and\n+// bold (700) weights might be stored as follows:\n+//\n+// + Victor Mono/\n+// |\n+// +--+ 400/\n+// |  |\n+// |  +-- Victor Mono Regular.woff\n+// |  \n+// +--+ 700/\n+//    |\n+//    +-- Victor Mono Bold.woff\n+//\n+Error generateCssFromDir(const FilePath& dir,\n+                         const std::string& fontName,\n+                         const std::vector<std::string>& parents,\n+                         std::string *pCss)\n+{\n+   std::vector<FilePath> files;\n+   Error error = dir.getChildren(files);\n+   if (error)\n+   {\n+      return error;\n+   }\n+   \n+   for (const auto& file: files)\n+   {\n+      std::string name = file.getFilename();\n+      if (file.isDirectory())\n+      {\n+         // This is a directory, probably representing a font weight or style\n+         std::vector<std::string> newParents(parents);\n+         newParents.push_back(name);\n+         error = generateCssFromDir(file, fontName, newParents, pCss);\n+      }\n+      else if (isFontFile(file))\n+      {\n+         // This is an ordinary font file\n+         error = generateCssFromFile(file, fontName, parents, pCss);\n+      }\n+\n+      if (error)\n+      {\n+         // Log and clear any errors encountered while processing this font\n+         LOG_ERROR(error);\n+         error = Success();\n+      }\n+   }\n+\n+   return error;\n+}\n+\n+// Handles an HTTP request for a specific font file.\n+void handleFontFileRequest(const http::Request& request,\n+                           http::Response* pResponse)\n+{\n+   std::string prefix = \"/\" kFontFiles;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+   \n+   // Check user font folder first\n+   FilePath fontFile = userFontFolder().completeChildPath(fileName);\n+   if (!fontFile.exists())\n+   {\n+      // Not found in user fonts; fall back to system\n+      fontFile = systemFontFolder().completeChildPath(fileName);\n+   }\n+\n+   pResponse->setCacheableFile(fontFile, request);\n+   return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTQ0NDY3OnYy", "diffSide": "RIGHT", "path": "src/cpp/session/modules/SessionFonts.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1NDoyNVrOGBrVvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1NDoyNVrOGBrVvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTgzOQ==", "bodyText": "Like earlier could use range-for loop here.", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404411839", "createdAt": "2020-04-06T21:54:25Z", "author": {"login": "gtritchie"}, "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+   {\n+      if (ext == s_fontExtensions.at(i))\n+         return true;\n+   }\n+\n+   // No extensions match\n+   return false;\n+}\n+\n+// The path to the user-specific font folder\n+core::FilePath userFontFolder()\n+{\n+   return core::system::xdg::userConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// The path to the system-wide font folder\n+core::FilePath systemFontFolder()\n+{\n+   return core::system::xdg::systemConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// Generates a CSS snippet from a font file.\n+Error generateCssFromFile(const FilePath& file,\n+                          const std::string& fontName,\n+                          const std::vector<std::string>& parents,\n+                          std::string *pCss)\n+{\n+   pCss->append(\"@font-face {\\n\"\n+                \"  font-family: \\\"\" + fontName + \"\\\";\\n\"\n+                \"  src: url('../files/\");\n+\n+   // Build URL to font file from parent folders. \n+   for (const auto& parent: parents)\n+   {\n+      pCss->append(parent + \"/\");\n+   }\n+   pCss->append(file.getFilename() + \"');\\n\");\n+\n+   // Convert each parent folder\n+   for (const auto& parent: parents)\n+   {\n+      // Check to see whether this directory looks like a font weight\n+      // font style.\n+      auto weight = safe_convert::stringTo<int>(parent);\n+      if (weight)\n+      {\n+         // Looks like a number, so generate a weight rule and recurse.\n+         pCss->append(\"  font-weight: \" + parent + \";\\n\");\n+      }\n+      else if (parent == \"oblique\" || parent == \"italic\")\n+      {\n+         // It's a style\n+         pCss->append(\"  font-style: \" + parent + \";\\n\");\n+      }\n+   }\n+\n+   pCss->append(\"}\\n\\n\");\n+   return Success();\n+}\n+\n+// Generates CSS from a directory representing a number of variants of a single font face. The\n+// directory structure is used to provide font metadata. For instance, a font with regular (400) and\n+// bold (700) weights might be stored as follows:\n+//\n+// + Victor Mono/\n+// |\n+// +--+ 400/\n+// |  |\n+// |  +-- Victor Mono Regular.woff\n+// |  \n+// +--+ 700/\n+//    |\n+//    +-- Victor Mono Bold.woff\n+//\n+Error generateCssFromDir(const FilePath& dir,\n+                         const std::string& fontName,\n+                         const std::vector<std::string>& parents,\n+                         std::string *pCss)\n+{\n+   std::vector<FilePath> files;\n+   Error error = dir.getChildren(files);\n+   if (error)\n+   {\n+      return error;\n+   }\n+   \n+   for (const auto& file: files)\n+   {\n+      std::string name = file.getFilename();\n+      if (file.isDirectory())\n+      {\n+         // This is a directory, probably representing a font weight or style\n+         std::vector<std::string> newParents(parents);\n+         newParents.push_back(name);\n+         error = generateCssFromDir(file, fontName, newParents, pCss);\n+      }\n+      else if (isFontFile(file))\n+      {\n+         // This is an ordinary font file\n+         error = generateCssFromFile(file, fontName, parents, pCss);\n+      }\n+\n+      if (error)\n+      {\n+         // Log and clear any errors encountered while processing this font\n+         LOG_ERROR(error);\n+         error = Success();\n+      }\n+   }\n+\n+   return error;\n+}\n+\n+// Handles an HTTP request for a specific font file.\n+void handleFontFileRequest(const http::Request& request,\n+                           http::Response* pResponse)\n+{\n+   std::string prefix = \"/\" kFontFiles;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+   \n+   // Check user font folder first\n+   FilePath fontFile = userFontFolder().completeChildPath(fileName);\n+   if (!fontFile.exists())\n+   {\n+      // Not found in user fonts; fall back to system\n+      fontFile = systemFontFolder().completeChildPath(fileName);\n+   }\n+\n+   pResponse->setCacheableFile(fontFile, request);\n+   return;\n+}\n+\n+// Handles an HTTP request for font CSS. This will typically look something like:\n+//\n+// GET /fonts/css/Victor Mono.css\n+//\n+// The request is fulfilled by automatically generating the appropriate CSS @font-face rule(s) for\n+// the font and returning them in the body of the request.\n+void handleFontCssRequest(const http::Request& request,\n+                          http::Response* pResponse)\n+{\n+   Error error;\n+   std::string css;\n+   std::string prefix = \"/\"  kFontCss;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+\n+   // Strip off \".css\" to get name of font\n+   size_t idx = fileName.find(\".css\");\n+   if (idx != std::string::npos)\n+   {\n+      fileName = fileName.substr(0, idx);\n+   }\n+   \n+   // Enumerate user and system font directories\n+   std::vector<FilePath> dirs;\n+   dirs.push_back(userFontFolder());\n+   dirs.push_back(systemFontFolder());\n+\n+   for (const auto& dir: dirs)\n+   {\n+      FilePath subDir = dir.completeChildPath(fileName);\n+      if (subDir.exists() && subDir.isDirectory())\n+      {\n+         // Folder full of font files\n+         std::vector<std::string> parents;\n+         parents.push_back(fileName);\n+         error = generateCssFromDir(subDir, fileName, parents, &css);\n+      }\n+      else\n+      {\n+         // An individual font file; determine extension\n+         for (size_t i = 0; i < s_fontExtensions.size(); i++)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTQ0NjUxOnYy", "diffSide": "RIGHT", "path": "src/cpp/session/modules/SessionFonts.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1NTowMFrOGBrW0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1NTowMFrOGBrW0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjExMg==", "bodyText": "don't need this return", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404412112", "createdAt": "2020-04-06T21:55:00Z", "author": {"login": "gtritchie"}, "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+   {\n+      if (ext == s_fontExtensions.at(i))\n+         return true;\n+   }\n+\n+   // No extensions match\n+   return false;\n+}\n+\n+// The path to the user-specific font folder\n+core::FilePath userFontFolder()\n+{\n+   return core::system::xdg::userConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// The path to the system-wide font folder\n+core::FilePath systemFontFolder()\n+{\n+   return core::system::xdg::systemConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// Generates a CSS snippet from a font file.\n+Error generateCssFromFile(const FilePath& file,\n+                          const std::string& fontName,\n+                          const std::vector<std::string>& parents,\n+                          std::string *pCss)\n+{\n+   pCss->append(\"@font-face {\\n\"\n+                \"  font-family: \\\"\" + fontName + \"\\\";\\n\"\n+                \"  src: url('../files/\");\n+\n+   // Build URL to font file from parent folders. \n+   for (const auto& parent: parents)\n+   {\n+      pCss->append(parent + \"/\");\n+   }\n+   pCss->append(file.getFilename() + \"');\\n\");\n+\n+   // Convert each parent folder\n+   for (const auto& parent: parents)\n+   {\n+      // Check to see whether this directory looks like a font weight\n+      // font style.\n+      auto weight = safe_convert::stringTo<int>(parent);\n+      if (weight)\n+      {\n+         // Looks like a number, so generate a weight rule and recurse.\n+         pCss->append(\"  font-weight: \" + parent + \";\\n\");\n+      }\n+      else if (parent == \"oblique\" || parent == \"italic\")\n+      {\n+         // It's a style\n+         pCss->append(\"  font-style: \" + parent + \";\\n\");\n+      }\n+   }\n+\n+   pCss->append(\"}\\n\\n\");\n+   return Success();\n+}\n+\n+// Generates CSS from a directory representing a number of variants of a single font face. The\n+// directory structure is used to provide font metadata. For instance, a font with regular (400) and\n+// bold (700) weights might be stored as follows:\n+//\n+// + Victor Mono/\n+// |\n+// +--+ 400/\n+// |  |\n+// |  +-- Victor Mono Regular.woff\n+// |  \n+// +--+ 700/\n+//    |\n+//    +-- Victor Mono Bold.woff\n+//\n+Error generateCssFromDir(const FilePath& dir,\n+                         const std::string& fontName,\n+                         const std::vector<std::string>& parents,\n+                         std::string *pCss)\n+{\n+   std::vector<FilePath> files;\n+   Error error = dir.getChildren(files);\n+   if (error)\n+   {\n+      return error;\n+   }\n+   \n+   for (const auto& file: files)\n+   {\n+      std::string name = file.getFilename();\n+      if (file.isDirectory())\n+      {\n+         // This is a directory, probably representing a font weight or style\n+         std::vector<std::string> newParents(parents);\n+         newParents.push_back(name);\n+         error = generateCssFromDir(file, fontName, newParents, pCss);\n+      }\n+      else if (isFontFile(file))\n+      {\n+         // This is an ordinary font file\n+         error = generateCssFromFile(file, fontName, parents, pCss);\n+      }\n+\n+      if (error)\n+      {\n+         // Log and clear any errors encountered while processing this font\n+         LOG_ERROR(error);\n+         error = Success();\n+      }\n+   }\n+\n+   return error;\n+}\n+\n+// Handles an HTTP request for a specific font file.\n+void handleFontFileRequest(const http::Request& request,\n+                           http::Response* pResponse)\n+{\n+   std::string prefix = \"/\" kFontFiles;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+   \n+   // Check user font folder first\n+   FilePath fontFile = userFontFolder().completeChildPath(fileName);\n+   if (!fontFile.exists())\n+   {\n+      // Not found in user fonts; fall back to system\n+      fontFile = systemFontFolder().completeChildPath(fileName);\n+   }\n+\n+   pResponse->setCacheableFile(fontFile, request);\n+   return;\n+}\n+\n+// Handles an HTTP request for font CSS. This will typically look something like:\n+//\n+// GET /fonts/css/Victor Mono.css\n+//\n+// The request is fulfilled by automatically generating the appropriate CSS @font-face rule(s) for\n+// the font and returning them in the body of the request.\n+void handleFontCssRequest(const http::Request& request,\n+                          http::Response* pResponse)\n+{\n+   Error error;\n+   std::string css;\n+   std::string prefix = \"/\"  kFontCss;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+\n+   // Strip off \".css\" to get name of font\n+   size_t idx = fileName.find(\".css\");\n+   if (idx != std::string::npos)\n+   {\n+      fileName = fileName.substr(0, idx);\n+   }\n+   \n+   // Enumerate user and system font directories\n+   std::vector<FilePath> dirs;\n+   dirs.push_back(userFontFolder());\n+   dirs.push_back(systemFontFolder());\n+\n+   for (const auto& dir: dirs)\n+   {\n+      FilePath subDir = dir.completeChildPath(fileName);\n+      if (subDir.exists() && subDir.isDirectory())\n+      {\n+         // Folder full of font files\n+         std::vector<std::string> parents;\n+         parents.push_back(fileName);\n+         error = generateCssFromDir(subDir, fileName, parents, &css);\n+      }\n+      else\n+      {\n+         // An individual font file; determine extension\n+         for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+         {\n+            FilePath fontFile = dir.completeChildPath(\n+                  fileName + s_fontExtensions[i]);\n+            if (fontFile.exists())\n+            {\n+               // Generate CSS for the font file\n+               error = generateCssFromFile(fontFile, fileName, std::vector<std::string>(), &css);\n+               if (error)\n+               {\n+                  LOG_ERROR(error);\n+               }\n+\n+               // We found a matching font; bail here\n+               break;\n+            }\n+         }\n+      }\n+   }\n+\n+   // It's okay if there was no matching font found at this point, since on RStudio Server the font\n+   // can be provided by the browser instead of the server. We will still generate a font-specific\n+   // stylesheet below.\n+   //\n+   // Append override rules for basic fixed-width elements. This stylesheet overrides a few key\n+   // styles in themeStyles.css with the specified font.\n+   //\n+   std::map<std::string,std::string> vars;\n+   vars[\"font\"] = fileName;\n+   std::ostringstream oss;\n+   error = core::text::renderTemplate(\n+      session::options().rResourcesPath().completeChildPath(\"themes/css/fonts.css\"), vars, oss);\n+   if (error)\n+   {\n+      LOG_ERROR(error);\n+   }\n+   else\n+   {\n+      css.append(oss.str());\n+   }\n+\n+   // Return the accumulated stylesheet\n+   pResponse->setContentType(\"text/css\");\n+   pResponse->setBody(css);\n+\n+   return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 277}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTQ1MTMzOnYy", "diffSide": "RIGHT", "path": "src/cpp/session/modules/SessionFonts.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1NjoxNlrOGBrZoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1NjoxNlrOGBrZoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjgzMw==", "bodyText": "Should you log this error or do something else with it, otherwise it's unused.", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404412833", "createdAt": "2020-04-06T21:56:16Z", "author": {"login": "gtritchie"}, "path": "src/cpp/session/modules/SessionFonts.cpp", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * SessionFonts.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include \"SessionFonts.hpp\"\n+\n+#include <core/http/Request.hpp>\n+#include <core/http/Response.hpp>\n+#include <core/Exec.hpp>\n+#include <core/text/TemplateFilter.hpp>\n+\n+#include <core/system/Xdg.hpp>\n+\n+#include <shared_core/FilePath.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <session/SessionModuleContext.hpp>\n+\n+#include <array>\n+\n+using namespace rstudio::core;\n+\n+#define kFontFolder    \"fonts\"\n+#define kFontsLocation \"fonts/\"\n+#define kFontFiles     kFontsLocation \"files/\"\n+#define kFontCss       kFontsLocation \"css/\"\n+\n+namespace rstudio {\n+namespace session {\n+namespace modules {\n+namespace fonts {\n+\n+namespace {\n+\n+// File extensions that we recognize as font files\n+std::array<std::string, 5> s_fontExtensions = {\n+   \".eot\",\n+   \".ttf\",\n+   \".otf\",\n+   \".woff\",\n+   \".woff2\"\n+};\n+\n+// Indicates whether the file is a font file (i.e. has a known font file extension)\n+bool isFontFile(const FilePath& file)\n+{\n+   // Test the file extension against known font formats\n+   std::string ext = file.getExtensionLowerCase();\n+   for (size_t i = 0; i < s_fontExtensions.size(); i++)\n+   {\n+      if (ext == s_fontExtensions.at(i))\n+         return true;\n+   }\n+\n+   // No extensions match\n+   return false;\n+}\n+\n+// The path to the user-specific font folder\n+core::FilePath userFontFolder()\n+{\n+   return core::system::xdg::userConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// The path to the system-wide font folder\n+core::FilePath systemFontFolder()\n+{\n+   return core::system::xdg::systemConfigDir().completeChildPath(kFontFolder);\n+}\n+\n+// Generates a CSS snippet from a font file.\n+Error generateCssFromFile(const FilePath& file,\n+                          const std::string& fontName,\n+                          const std::vector<std::string>& parents,\n+                          std::string *pCss)\n+{\n+   pCss->append(\"@font-face {\\n\"\n+                \"  font-family: \\\"\" + fontName + \"\\\";\\n\"\n+                \"  src: url('../files/\");\n+\n+   // Build URL to font file from parent folders. \n+   for (const auto& parent: parents)\n+   {\n+      pCss->append(parent + \"/\");\n+   }\n+   pCss->append(file.getFilename() + \"');\\n\");\n+\n+   // Convert each parent folder\n+   for (const auto& parent: parents)\n+   {\n+      // Check to see whether this directory looks like a font weight\n+      // font style.\n+      auto weight = safe_convert::stringTo<int>(parent);\n+      if (weight)\n+      {\n+         // Looks like a number, so generate a weight rule and recurse.\n+         pCss->append(\"  font-weight: \" + parent + \";\\n\");\n+      }\n+      else if (parent == \"oblique\" || parent == \"italic\")\n+      {\n+         // It's a style\n+         pCss->append(\"  font-style: \" + parent + \";\\n\");\n+      }\n+   }\n+\n+   pCss->append(\"}\\n\\n\");\n+   return Success();\n+}\n+\n+// Generates CSS from a directory representing a number of variants of a single font face. The\n+// directory structure is used to provide font metadata. For instance, a font with regular (400) and\n+// bold (700) weights might be stored as follows:\n+//\n+// + Victor Mono/\n+// |\n+// +--+ 400/\n+// |  |\n+// |  +-- Victor Mono Regular.woff\n+// |  \n+// +--+ 700/\n+//    |\n+//    +-- Victor Mono Bold.woff\n+//\n+Error generateCssFromDir(const FilePath& dir,\n+                         const std::string& fontName,\n+                         const std::vector<std::string>& parents,\n+                         std::string *pCss)\n+{\n+   std::vector<FilePath> files;\n+   Error error = dir.getChildren(files);\n+   if (error)\n+   {\n+      return error;\n+   }\n+   \n+   for (const auto& file: files)\n+   {\n+      std::string name = file.getFilename();\n+      if (file.isDirectory())\n+      {\n+         // This is a directory, probably representing a font weight or style\n+         std::vector<std::string> newParents(parents);\n+         newParents.push_back(name);\n+         error = generateCssFromDir(file, fontName, newParents, pCss);\n+      }\n+      else if (isFontFile(file))\n+      {\n+         // This is an ordinary font file\n+         error = generateCssFromFile(file, fontName, parents, pCss);\n+      }\n+\n+      if (error)\n+      {\n+         // Log and clear any errors encountered while processing this font\n+         LOG_ERROR(error);\n+         error = Success();\n+      }\n+   }\n+\n+   return error;\n+}\n+\n+// Handles an HTTP request for a specific font file.\n+void handleFontFileRequest(const http::Request& request,\n+                           http::Response* pResponse)\n+{\n+   std::string prefix = \"/\" kFontFiles;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+   \n+   // Check user font folder first\n+   FilePath fontFile = userFontFolder().completeChildPath(fileName);\n+   if (!fontFile.exists())\n+   {\n+      // Not found in user fonts; fall back to system\n+      fontFile = systemFontFolder().completeChildPath(fileName);\n+   }\n+\n+   pResponse->setCacheableFile(fontFile, request);\n+   return;\n+}\n+\n+// Handles an HTTP request for font CSS. This will typically look something like:\n+//\n+// GET /fonts/css/Victor Mono.css\n+//\n+// The request is fulfilled by automatically generating the appropriate CSS @font-face rule(s) for\n+// the font and returning them in the body of the request.\n+void handleFontCssRequest(const http::Request& request,\n+                          http::Response* pResponse)\n+{\n+   Error error;\n+   std::string css;\n+   std::string prefix = \"/\"  kFontCss;\n+   std::string fileName = http::util::pathAfterPrefix(request, prefix);\n+\n+   // Strip off \".css\" to get name of font\n+   size_t idx = fileName.find(\".css\");\n+   if (idx != std::string::npos)\n+   {\n+      fileName = fileName.substr(0, idx);\n+   }\n+   \n+   // Enumerate user and system font directories\n+   std::vector<FilePath> dirs;\n+   dirs.push_back(userFontFolder());\n+   dirs.push_back(systemFontFolder());\n+\n+   for (const auto& dir: dirs)\n+   {\n+      FilePath subDir = dir.completeChildPath(fileName);\n+      if (subDir.exists() && subDir.isDirectory())\n+      {\n+         // Folder full of font files\n+         std::vector<std::string> parents;\n+         parents.push_back(fileName);\n+         error = generateCssFromDir(subDir, fileName, parents, &css);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTQ1NTQ1OnYy", "diffSide": "RIGHT", "path": "src/cpp/server/ServerMain.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1Nzo0NlrOGBrcSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo1Nzo0NlrOGBrcSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMzUxMg==", "bodyText": "nit, copyright header year update", "url": "https://github.com/rstudio/rstudio/pull/6592#discussion_r404413512", "createdAt": "2020-04-06T21:57:46Z", "author": {"login": "gtritchie"}, "path": "src/cpp/server/ServerMain.cpp", "diffHunk": "@@ -231,6 +231,7 @@ void httpServerAddHandlers()\n    uri_handlers::add(\"/mathjax\", secureAsyncHttpHandler(proxyContentRequest));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f30c294e4e083e2ced06934272e84c107fd8db5e"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4015, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}