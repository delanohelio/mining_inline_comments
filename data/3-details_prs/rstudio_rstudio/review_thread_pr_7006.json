{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1Mjc1Mjky", "number": 7006, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTozODozMlrOEBA4IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTozODozMlrOEBA4IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDk4NDAwOnYy", "diffSide": "RIGHT", "path": "src/cpp/core/r_util/RTokenizer.cpp", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTozODozMlrOGcpn1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxOTozODozMlrOGcpn1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NTI1NA==", "bodyText": "\ud83d\ude31", "url": "https://github.com/rstudio/rstudio/pull/7006#discussion_r432695254", "createdAt": "2020-05-29T19:38:32Z", "author": {"login": "jmcphers"}, "path": "src/cpp/core/r_util/RTokenizer.cpp", "diffHunk": "@@ -217,6 +238,113 @@ RToken RTokenizer::matchWhitespace()\n    return consumeToken(RToken::WHITESPACE, tokenLength(tokenPatterns().WHITESPACE));\n }\n \n+Error RTokenizer::matchRawStringLiteral(RToken* pToken)\n+{\n+   auto start = pos_;\n+   \n+   // consume leading 'r' or 'R'\n+   wchar_t firstChar = eat();\n+   if (!(firstChar == L'r' || firstChar == L'R'))\n+   {\n+      pos_ = start;\n+      return tokenizeError(\n+               \"expected 'r' or 'R' at start of raw string literal\",\n+               ERROR_LOCATION);\n+   }\n+   \n+   // consume quote character\n+   wchar_t quoteChar = eat();\n+   if (!(quoteChar == L'\"' || quoteChar == L'\\''))\n+   {\n+      pos_ = start;\n+      return tokenizeError(\n+               \"expected quote character at start of raw string literal\",\n+               ERROR_LOCATION);\n+   }\n+   \n+   // consume an optional number of hyphens\n+   int hyphenCount = 0;\n+   wchar_t ch = eat();\n+   while (ch == L'-')\n+   {\n+      hyphenCount++;\n+      ch = eat();\n+   }\n+   \n+   // okay, we're now sitting on open parenthesis\n+   wchar_t lhs = ch;\n+   \n+   // form right boundary character based on consumed parenthesis.\n+   // if it wasn't a parenthesis, just look for the associated closing quote\n+   wchar_t rhs;\n+   if (lhs == L'(')\n+   {\n+      rhs = L')';\n+   }\n+   else if (lhs == L'{')\n+   {\n+      rhs = L'}';\n+   }\n+   else if (lhs == L'[')\n+   {\n+      rhs = L']';\n+   }\n+   else\n+   {\n+      pos_ = start;\n+      return tokenizeError(\n+               \"expected opening bracket at start of raw string literal\",\n+               ERROR_LOCATION);\n+   }\n+   \n+   // start searching for the end of the raw string\n+   bool valid = false;\n+   \n+   while (true)\n+   {\n+      // i know, i know -- a label!? we use that here just because\n+      // we need to 'break' out of a nested loop below, and just\n+      // using a simple goto is cleaner than having e.g. an extra\n+      // boolean flag tracking whether we should 'continue'\n+      LOOP:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dae0f9dfefe0a07298c9326b5458eb2607c4ea77"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4360, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}