{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMTEzMTAz", "number": 6356, "title": "Feature/database", "bodyText": "Add the ability to connect to databases.\nThere is a core database set of functions, and a server_core set which is specific to server processes to connect to an rstudio server database. The core set can be used to create additional SQLite databases to store things like user settings, if desired, whereas the server_core is focused on the central database that will be used by all server processes.", "createdAt": "2020-02-27T22:51:03Z", "url": "https://github.com/rstudio/rstudio/pull/6356", "merged": true, "mergeCommit": {"oid": "6d4d0c451809a29e9c5acc1310b117005bc7a1ad"}, "closed": true, "closedAt": "2020-03-06T13:43:47Z", "author": {"login": "kfeinauer"}, "timelineItems": {"totalCount": 49, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBxmBUgH2gAyMzgxMTEzMTAzOjY2MjBmNTE3YWI1NzMwNmZiNzI5MTYzMzk4YzRmYzE4MGU1ODA3OTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcLAT4hAH2gAyMzgxMTEzMTAzOjY5M2EzMDYyM2I1OGM0MGIzMWUzZGMwMjdmOTg3YjRlNzFkNmYzNjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6620f517ab57306fb729163398c4fc180e580790", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/6620f517ab57306fb729163398c4fc180e580790", "committedDate": "2020-02-06T21:26:53Z", "message": "Create basic SOCI dependency script, and test that SOCI builds and links properly with RStudio"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88ed41b962313ec5d81f37e79f89a1855523012d", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/88ed41b962313ec5d81f37e79f89a1855523012d", "committedDate": "2020-02-06T21:52:47Z", "message": "SOCI dependency installer script fixes for OSX"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a0fc0f3bdb2dc4ceb7d84c6ceb7c36297b25d83", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/6a0fc0f3bdb2dc4ceb7d84c6ceb7c36297b25d83", "committedDate": "2020-02-06T22:02:17Z", "message": "Update Linux installers to install SQLite and PostgreSQL client libs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c07836d2b061f624f014efa232da01ced5a458e0", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/c07836d2b061f624f014efa232da01ced5a458e0", "committedDate": "2020-02-06T22:14:27Z", "message": "Add postgres install for osx"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8414177e49e6199d0afd1130eec7907515c6b39", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/d8414177e49e6199d0afd1130eec7907515c6b39", "committedDate": "2020-02-07T17:01:00Z", "message": "Now copying db client libs to Linux package and setting RPATH="}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d819bd721d7ebc7ca32939edf8c5fa266f4a9354", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/d819bd721d7ebc7ca32939edf8c5fa266f4a9354", "committedDate": "2020-02-07T18:58:24Z", "message": "Add packaging of database libraries for OSX"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "239c431d0fde2dfb008e8cb7e881864a05dec4ae", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/239c431d0fde2dfb008e8cb7e881864a05dec4ae", "committedDate": "2020-02-10T18:37:45Z", "message": "Added install-soci Windows dependency script, which currently successfully builds soci_core and soci_sqlite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "994d252576378f409117b78b6697b0bdfbd11e65", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/994d252576378f409117b78b6697b0bdfbd11e65", "committedDate": "2020-02-10T20:37:00Z", "message": "Got SOCI+SQLite building/linking with RStudio codebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cfc91d9003a89a7e859b4cc7dd56d0b3a038708", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/5cfc91d9003a89a7e859b4cc7dd56d0b3a038708", "committedDate": "2020-02-10T23:03:47Z", "message": "Added support for both x86 and x64 SOCI and SQLite builds. Because of the dependency on OpenSSL, PostgreSQL will not support x86."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96907e7ac28bb23758e0bb30b996c19c317e867b", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/96907e7ac28bb23758e0bb30b996c19c317e867b", "committedDate": "2020-02-11T17:36:55Z", "message": "Now building and integrating libpq with Windows version of RStudio"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b5eb19db552c04159ecc63fbb6d8110a957e537", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/6b5eb19db552c04159ecc63fbb6d8110a957e537", "committedDate": "2020-02-11T20:26:45Z", "message": "Add SOCI to NOTICE file for copyright"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b8b46f5c5bef7dac89f4e2827651ff198152b25", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/5b8b46f5c5bef7dac89f4e2827651ff198152b25", "committedDate": "2020-02-18T16:25:07Z", "message": "Workaround fix to get PACKAGE_OS propagating to OSX builds. The  specifier is empty for some reason, but the build numbers propagate as expected"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94be71f95f290bbaae27058897ff4425a2b9ede1", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/94be71f95f290bbaae27058897ff4425a2b9ede1", "committedDate": "2020-02-18T16:26:13Z", "message": "Revert \"Workaround fix to get PACKAGE_OS propagating to OSX builds. The  specifier is empty for some reason, but the build numbers propagate as expected\"\n\nThis reverts commit 5b8b46f5c5bef7dac89f4e2827651ff198152b25."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00128e890783463ca66d4297d2b1a2e243876306", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/00128e890783463ca66d4297d2b1a2e243876306", "committedDate": "2020-02-19T17:46:47Z", "message": "Add basic database code - connection and statement execution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "074862008ec8c5a7fe04089bd838b11e704f064b", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/074862008ec8c5a7fe04089bd838b11e704f064b", "committedDate": "2020-02-19T19:03:13Z", "message": "Added integration of soci errors with boost error codes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8646405cabe55ae0c91ebeb83b42cb644d84f1d5", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/8646405cabe55ae0c91ebeb83b42cb644d84f1d5", "committedDate": "2020-02-19T20:29:41Z", "message": "Add postgresql connection code and rework db test to only use wrapper interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88134af8b064b89868963bc0fb5574941c20b430", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/88134af8b064b89868963bc0fb5574941c20b430", "committedDate": "2020-02-19T20:50:06Z", "message": "Fix postgresql connection string and add postgres test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40887684e82718eba3004ad1403d967e15907535", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/40887684e82718eba3004ad1403d967e15907535", "committedDate": "2020-02-21T20:41:58Z", "message": "Added transaction and connection pool support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb9335063ac58c45898b296db1b07346371f0527", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/bb9335063ac58c45898b296db1b07346371f0527", "committedDate": "2020-02-21T22:12:38Z", "message": "WIP - Database schema updater"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "400da671eb05d6e91157968a9c0401bcf9c32e4b", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/400da671eb05d6e91157968a9c0401bcf9c32e4b", "committedDate": "2020-02-24T22:21:56Z", "message": "First working implementation of database schema updater and associated tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "039eff769552981ad3d83dcf73634c816f2ccc91", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/039eff769552981ad3d83dcf73634c816f2ccc91", "committedDate": "2020-02-25T21:25:47Z", "message": "Added bulk select capability, and added testing of bulk inserts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a020fb86c0d4c39274ec247f1d2d89f26dd68b14", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/a020fb86c0d4c39274ec247f1d2d89f26dd68b14", "committedDate": "2020-02-25T21:29:03Z", "message": "Merge branch 'v1.4' into feature/database"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa484e3083d3c6d0a940f76ff51e16dbecca92ac", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/fa484e3083d3c6d0a940f76ff51e16dbecca92ac", "committedDate": "2020-02-26T21:44:45Z", "message": "Lay down first version of ServerDatabase for initializing database connection in server processes, and performing schema updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "273d94eee65ec5d69fa074c4f0ce5d33dd65826b", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/273d94eee65ec5d69fa074c4f0ce5d33dd65826b", "committedDate": "2020-02-26T22:17:18Z", "message": "Add default database.conf file on install"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad186b379e4a3de21e7c171aa8f596220e6cd946", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/ad186b379e4a3de21e7c171aa8f596220e6cd946", "committedDate": "2020-02-27T16:39:05Z", "message": "Fix SOCI library load paths on Linux and make default database.conf file user read write only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/ac749e316dbc2ab48842f19646e43301acb7c41e", "committedDate": "2020-02-27T20:59:12Z", "message": "Port revocation list storage to DB"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f", "committedDate": "2020-02-28T23:02:27Z", "message": "Linux SOCI build fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzMwMjYx", "url": "https://github.com/rstudio/rstudio/pull/6356#pullrequestreview-366730261", "createdAt": "2020-02-28T22:48:44Z", "commit": {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjo0ODo0NFrOFwE_DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzoyNToyNVrOFwFkGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NzY0NQ==", "bodyText": "I think it's more common to package the libraries in a separate folder; e.g. at $ORIGIN/../lib. Would that be workable here?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385957645", "createdAt": "2020-02-28T22:48:44Z", "author": {"login": "kevinushey"}, "path": "CMakeGlobals.txt", "diffHunk": "@@ -261,8 +261,15 @@ endfunction()\n # define custom installation macro to strip symbols from the binary\n macro(add_stripped_executable _target)\n    add_executable(${_target} ${ARGN})\n+\n+   # set RPATH=$ORIGIN to ensure that any bundled libraries are found in our binary dir\n+   set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)\n+   set_target_properties(${_target} PROPERTIES INSTALL_RPATH \\$ORIGIN)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1ODAyMw==", "bodyText": "This should be install-soci now.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385958023", "createdAt": "2020-02-28T22:50:11Z", "author": {"login": "kevinushey"}, "path": "dependencies/windows/install-soci/install-soci.R", "diffHunk": "@@ -0,0 +1,97 @@\n+# some laziness to ensure we move to the 'install-crashpad' folder\n+if (file.exists(\"rstudio.Rproj\"))\n+   setwd(\"dependencies/windows/install-crashpad\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1ODMxMQ==", "bodyText": "Nit: normalizePath() will emit an error if the path doesn't already exist, so you might want to use normalizePath(..., mustWork = FALSE) here.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385958311", "createdAt": "2020-02-28T22:51:11Z", "author": {"login": "kevinushey"}, "path": "dependencies/windows/install-soci/install-soci.R", "diffHunk": "@@ -0,0 +1,97 @@\n+# some laziness to ensure we move to the 'install-crashpad' folder\n+if (file.exists(\"rstudio.Rproj\"))\n+   setwd(\"dependencies/windows/install-crashpad\")\n+\n+source(\"../tools.R\")\n+section(\"The working directory is: '%s'\", getwd())\n+progress(\"Producing SOCI build\")\n+owd <- getwd()\n+\n+# initialize log directory (for when things go wrong)\n+unlink(\"logs\", recursive = TRUE)\n+dir.create(\"logs\")\n+options(log.dir = normalizePath(\"logs\"))\n+\n+# put RStudio tools on PATH\n+PATH$prepend(\"../tools\")\n+\n+# initialize variables\n+output_dir <- normalizePath(file.path(owd, \"..\"), winslash = \"\\\\\")\n+boost_dir <- normalizePath(file.path(output_dir, \"boost-1.69.0-win-msvc141-release-static\\\\boost64\"), winslash = \"\\\\\")\n+soci_branch <- \"release/4.0\"\n+soci_dir <- file.path(owd, \"soci\")\n+soci_build_dir <- file.path(soci_dir, \"build\")\n+sqlite_dir <- file.path(owd, \"sqlite\")\n+postgresql_dir <- file.path(owd, \"postgresql\")\n+sqlite_header_zip_url <- \"https://sqlite.org/2020/sqlite-amalgamation-3310100.zip\"\n+sqlite_header_zip <- file.path(sqlite_dir, \"sqlite-header.zip\")\n+sqlite_header_dir <- file.path(sqlite_dir, \"sqlite-amalgamation-3310100\")\n+postgresql_zip <- file.path(owd, \"win-postgresql.zip\")\n+postgresql_zip_url <- \"https://rstudio-buildtools.s3.amazonaws.com/win-postgresql.zip\"\n+\n+downloadAndUnzip <- function(outputFile, extractDir, url) {\n+   # download zip if we don't already have it\n+   if (!file.exists(outputFile)) {\n+      section(\"Downloading '%s' from '%s'\", outputFile, url)\n+\t  download(url, destfile = outputFile)\n+\t  if (!file.exists(outputFile))\n+\t     fatal(\"Failed to download '%s'\", outputFile)\n+   }\n+   \n+   # extract zip file\n+   progress(\"Extracting zip file '%s'\", outputFile)\n+   unzip(outputFile, exdir = extractDir)\n+}\n+\n+if (!file.exists(normalizePath(file.path(soci_build_dir, \"x64\\\\lib\\\\Release\\\\libsoci_core_4_0.lib\"), winslash = \"\\\\\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MDg0Mg==", "bodyText": "This will break if the version of postgresql installed by Brew happens to change. You can access the current path using:\nbrew --prefix postgresql\n\nOr, alternatively, Homebrew normally symlinks the current version of a formula to /usr/local/opt, so you could just check:\n/usr/local/opt/postgresql\n\ninstead.\nAside: libpq and postgresql are separate formula; are you sure you want to use the postgres includes here or do you want to use libpq specifically?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385960842", "createdAt": "2020-02-28T23:00:00Z", "author": {"login": "kevinushey"}, "path": "src/cpp/CMakeLists.txt", "diffHunk": "@@ -355,6 +361,110 @@ else()\n    endif()\n endif()\n \n+# SOCI\n+if(UNIX)\n+   set(RSTUDIO_TOOLS_SOCI \"/opt/rstudio-tools/soci\")\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/include\")\n+else()\n+   set(RSTUDIO_TOOLS_SOCI \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/soci\")\n+   if(RSTUDIO_SESSION_WIN32)\n+      set(SOCI_ARCH \"x86\")\n+   else()\n+      set(SOCI_ARCH \"x64\")\n+   endif()\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/include\")\n+endif()\n+\n+set(SOCI_INCLUDE_DIR \"${RSTUDIO_TOOLS_SOCI}/include\")\n+include_directories(SYSTEM ${SOCI_INCLUDE_DIR})\n+include_directories(SYSTEM ${SOCI_INCLUDE_BUILD_DIR})\n+\n+# database library includes\n+if (UNIX)\n+   if (APPLE)\n+      # We assume that libpq is available under the default brew install location\n+      # since we install postgresql via brew in install-dependencies-osx\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include\")\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include/libpq\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTM0OQ==", "bodyText": "Nit: because the above is a fatal error you could just endif() and save a level of indentation.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385961349", "createdAt": "2020-02-28T23:01:48Z", "author": {"login": "kevinushey"}, "path": "src/cpp/CMakeLists.txt", "diffHunk": "@@ -355,6 +361,110 @@ else()\n    endif()\n endif()\n \n+# SOCI\n+if(UNIX)\n+   set(RSTUDIO_TOOLS_SOCI \"/opt/rstudio-tools/soci\")\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/include\")\n+else()\n+   set(RSTUDIO_TOOLS_SOCI \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/soci\")\n+   if(RSTUDIO_SESSION_WIN32)\n+      set(SOCI_ARCH \"x86\")\n+   else()\n+      set(SOCI_ARCH \"x64\")\n+   endif()\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/include\")\n+endif()\n+\n+set(SOCI_INCLUDE_DIR \"${RSTUDIO_TOOLS_SOCI}/include\")\n+include_directories(SYSTEM ${SOCI_INCLUDE_DIR})\n+include_directories(SYSTEM ${SOCI_INCLUDE_BUILD_DIR})\n+\n+# database library includes\n+if (UNIX)\n+   if (APPLE)\n+      # We assume that libpq is available under the default brew install location\n+      # since we install postgresql via brew in install-dependencies-osx\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include\")\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include/libpq\")\n+   else()\n+      include_directories(SYSTEM \"/usr/include/postgresql\")\n+   endif()\n+elseif(WIN32)\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite-amalgamation-3310100\")\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/include\")\n+endif()\n+\n+# find SOCI libraries\n+if(UNIX)\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/lib\")\n+   if (NOT APPLE)\n+      set(LIB_SUFFIX \".so\")\n+      set(SOCI_LIB_SYMLINK \"${LIB_SUFFIX}.4.0\")\n+      set(SOCI_LIB_SUFFIX \"${LIB_SUFFIX}.4.0.0\")\n+   else()\n+      set(LIB_SUFFIX \".dylib\")\n+      set(SOCI_LIB_SYMLINK \".4.0${LIB_SUFFIX}\")\n+      set(SOCI_LIB_SUFFIX \".4.0.0${LIB_SUFFIX}\")\n+   endif()\n+   file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/*${LIB_SUFFIX}\")\n+else()\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/lib\")\n+   if(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Debug/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-debug-${SOCI_ARCH}.lib\")\n+   else()\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Release/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-release-${SOCI_ARCH}.lib\")\n+   endif()\n+endif()\n+list(LENGTH SOCI_LIBRARIES SOCI_LIB_COUNT)\n+\n+if (SOCI_LIB_COUNT EQUAL 0)\n+   message(FATAL_ERROR \"No SOCI libraries found under ${SOCI_LIBRARY_DIR}. Ensure the SOCI dependency is installed and try again.\")\n+else()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTg0MQ==", "bodyText": "Do we need to add something to NOTICE for libsqlite?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385961841", "createdAt": "2020-02-28T23:03:42Z", "author": {"login": "kevinushey"}, "path": "src/cpp/CMakeLists.txt", "diffHunk": "@@ -355,6 +361,110 @@ else()\n    endif()\n endif()\n \n+# SOCI\n+if(UNIX)\n+   set(RSTUDIO_TOOLS_SOCI \"/opt/rstudio-tools/soci\")\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/include\")\n+else()\n+   set(RSTUDIO_TOOLS_SOCI \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/soci\")\n+   if(RSTUDIO_SESSION_WIN32)\n+      set(SOCI_ARCH \"x86\")\n+   else()\n+      set(SOCI_ARCH \"x64\")\n+   endif()\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/include\")\n+endif()\n+\n+set(SOCI_INCLUDE_DIR \"${RSTUDIO_TOOLS_SOCI}/include\")\n+include_directories(SYSTEM ${SOCI_INCLUDE_DIR})\n+include_directories(SYSTEM ${SOCI_INCLUDE_BUILD_DIR})\n+\n+# database library includes\n+if (UNIX)\n+   if (APPLE)\n+      # We assume that libpq is available under the default brew install location\n+      # since we install postgresql via brew in install-dependencies-osx\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include\")\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include/libpq\")\n+   else()\n+      include_directories(SYSTEM \"/usr/include/postgresql\")\n+   endif()\n+elseif(WIN32)\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite-amalgamation-3310100\")\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/include\")\n+endif()\n+\n+# find SOCI libraries\n+if(UNIX)\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/lib\")\n+   if (NOT APPLE)\n+      set(LIB_SUFFIX \".so\")\n+      set(SOCI_LIB_SYMLINK \"${LIB_SUFFIX}.4.0\")\n+      set(SOCI_LIB_SUFFIX \"${LIB_SUFFIX}.4.0.0\")\n+   else()\n+      set(LIB_SUFFIX \".dylib\")\n+      set(SOCI_LIB_SYMLINK \".4.0${LIB_SUFFIX}\")\n+      set(SOCI_LIB_SUFFIX \".4.0.0${LIB_SUFFIX}\")\n+   endif()\n+   file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/*${LIB_SUFFIX}\")\n+else()\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/lib\")\n+   if(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Debug/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-debug-${SOCI_ARCH}.lib\")\n+   else()\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Release/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-release-${SOCI_ARCH}.lib\")\n+   endif()\n+endif()\n+list(LENGTH SOCI_LIBRARIES SOCI_LIB_COUNT)\n+\n+if (SOCI_LIB_COUNT EQUAL 0)\n+   message(FATAL_ERROR \"No SOCI libraries found under ${SOCI_LIBRARY_DIR}. Ensure the SOCI dependency is installed and try again.\")\n+else()\n+   message(STATUS \"SOCI libraries found under ${SOCI_LIBRARY_DIR}.\")\n+\n+   # ensure the soci/sqlite/postgres libraries are installed with the installation package\n+   if(UNIX)\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_core${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_sqlite3${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_postgresql${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+\n+      GET_PREREQUISITES(\"${SOCI_LIBRARY_DIR}/libsoci_sqlite3${SOCI_LIB_SUFFIX}\" SQLITE_LIBS \"0\" \"0\" \".\" \"\")\n+      foreach(LIBRARY IN LISTS SQLITE_LIBS)\n+         string(FIND \"${LIBRARY}\" \"libsqlite3\" INDEX)\n+         if(INDEX GREATER \"-1\")\n+            set(SQLITE_LIB \"${LIBRARY}\")\n+         endif()\n+      endforeach(LIBRARY)\n+\n+      GET_PREREQUISITES(\"${SOCI_LIBRARY_DIR}/libsoci_postgresql${SOCI_LIB_SUFFIX}\" POSTGRES_LIBS \"0\" \"0\" \".\" \"\")\n+      foreach(LIBRARY IN LISTS POSTGRES_LIBS)\n+         string(FIND \"${LIBRARY}\" \"libpq\" INDEX)\n+         if(INDEX GREATER \"-1\")\n+            set(POSTGRES_LIB \"${LIBRARY}\")\n+         endif()\n+      endforeach(LIBRARY)\n+\n+      get_filename_component(SQLITE_LIB \"${SQLITE_LIB}\" REALPATH)\n+      get_filename_component(POSTGRES_LIB \"${POSTGRES_LIB}\" REALPATH)\n+      message(STATUS \"SQLite lib: ${SQLITE_LIB}\")\n+      message(STATUS \"PostgreSQL lib: ${POSTGRES_LIB}\")\n+      install(PROGRAMS \"${SQLITE_LIB}\" DESTINATION ${RSTUDIO_INSTALL_BIN})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTk0MA==", "bodyText": "Similarly: NOTICE for libpq?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385961940", "createdAt": "2020-02-28T23:04:04Z", "author": {"login": "kevinushey"}, "path": "src/cpp/CMakeLists.txt", "diffHunk": "@@ -355,6 +361,110 @@ else()\n    endif()\n endif()\n \n+# SOCI\n+if(UNIX)\n+   set(RSTUDIO_TOOLS_SOCI \"/opt/rstudio-tools/soci\")\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/include\")\n+else()\n+   set(RSTUDIO_TOOLS_SOCI \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/soci\")\n+   if(RSTUDIO_SESSION_WIN32)\n+      set(SOCI_ARCH \"x86\")\n+   else()\n+      set(SOCI_ARCH \"x64\")\n+   endif()\n+   set(SOCI_INCLUDE_BUILD_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/include\")\n+endif()\n+\n+set(SOCI_INCLUDE_DIR \"${RSTUDIO_TOOLS_SOCI}/include\")\n+include_directories(SYSTEM ${SOCI_INCLUDE_DIR})\n+include_directories(SYSTEM ${SOCI_INCLUDE_BUILD_DIR})\n+\n+# database library includes\n+if (UNIX)\n+   if (APPLE)\n+      # We assume that libpq is available under the default brew install location\n+      # since we install postgresql via brew in install-dependencies-osx\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include\")\n+      include_directories(SYSTEM \"/usr/local/Cellar/postgresql/12.1/include/libpq\")\n+   else()\n+      include_directories(SYSTEM \"/usr/include/postgresql\")\n+   endif()\n+elseif(WIN32)\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite-amalgamation-3310100\")\n+   include_directories(SYSTEM \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/include\")\n+endif()\n+\n+# find SOCI libraries\n+if(UNIX)\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/lib\")\n+   if (NOT APPLE)\n+      set(LIB_SUFFIX \".so\")\n+      set(SOCI_LIB_SYMLINK \"${LIB_SUFFIX}.4.0\")\n+      set(SOCI_LIB_SUFFIX \"${LIB_SUFFIX}.4.0.0\")\n+   else()\n+      set(LIB_SUFFIX \".dylib\")\n+      set(SOCI_LIB_SYMLINK \".4.0${LIB_SUFFIX}\")\n+      set(SOCI_LIB_SUFFIX \".4.0.0${LIB_SUFFIX}\")\n+   endif()\n+   file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/*${LIB_SUFFIX}\")\n+else()\n+   set(SOCI_LIBRARY_DIR \"${RSTUDIO_TOOLS_SOCI}/build/${SOCI_ARCH}/lib\")\n+   if(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Debug/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-debug-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-debug-${SOCI_ARCH}.lib\")\n+   else()\n+       file(GLOB_RECURSE SOCI_LIBRARIES \"${SOCI_LIBRARY_DIR}/Release/*.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_LDAP_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${WIN_SSPI_LIBRARY}\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/sqlite/sqlite3-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpq-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgcommon-release-${SOCI_ARCH}.lib\")\n+       list(APPEND SOCI_LIBRARIES \"${RSTUDIO_WINDOWS_DEPENDENCIES_DIR}/install-soci/postgresql/lib/libpgport-release-${SOCI_ARCH}.lib\")\n+   endif()\n+endif()\n+list(LENGTH SOCI_LIBRARIES SOCI_LIB_COUNT)\n+\n+if (SOCI_LIB_COUNT EQUAL 0)\n+   message(FATAL_ERROR \"No SOCI libraries found under ${SOCI_LIBRARY_DIR}. Ensure the SOCI dependency is installed and try again.\")\n+else()\n+   message(STATUS \"SOCI libraries found under ${SOCI_LIBRARY_DIR}.\")\n+\n+   # ensure the soci/sqlite/postgres libraries are installed with the installation package\n+   if(UNIX)\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_core${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_sqlite3${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${SOCI_LIBRARY_DIR}/libsoci_postgresql${SOCI_LIB_SUFFIX}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+\n+      GET_PREREQUISITES(\"${SOCI_LIBRARY_DIR}/libsoci_sqlite3${SOCI_LIB_SUFFIX}\" SQLITE_LIBS \"0\" \"0\" \".\" \"\")\n+      foreach(LIBRARY IN LISTS SQLITE_LIBS)\n+         string(FIND \"${LIBRARY}\" \"libsqlite3\" INDEX)\n+         if(INDEX GREATER \"-1\")\n+            set(SQLITE_LIB \"${LIBRARY}\")\n+         endif()\n+      endforeach(LIBRARY)\n+\n+      GET_PREREQUISITES(\"${SOCI_LIBRARY_DIR}/libsoci_postgresql${SOCI_LIB_SUFFIX}\" POSTGRES_LIBS \"0\" \"0\" \".\" \"\")\n+      foreach(LIBRARY IN LISTS POSTGRES_LIBS)\n+         string(FIND \"${LIBRARY}\" \"libpq\" INDEX)\n+         if(INDEX GREATER \"-1\")\n+            set(POSTGRES_LIB \"${LIBRARY}\")\n+         endif()\n+      endforeach(LIBRARY)\n+\n+      get_filename_component(SQLITE_LIB \"${SQLITE_LIB}\" REALPATH)\n+      get_filename_component(POSTGRES_LIB \"${POSTGRES_LIB}\" REALPATH)\n+      message(STATUS \"SQLite lib: ${SQLITE_LIB}\")\n+      message(STATUS \"PostgreSQL lib: ${POSTGRES_LIB}\")\n+      install(PROGRAMS \"${SQLITE_LIB}\" DESTINATION ${RSTUDIO_INSTALL_BIN})\n+      install(PROGRAMS \"${POSTGRES_LIB}\" DESTINATION ${RSTUDIO_INSTALL_BIN})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac749e316dbc2ab48842f19646e43301acb7c41e"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MjY0MA==", "bodyText": "Will we need to worry about queries which include ; as part of e.g. strings or something similar?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385962640", "createdAt": "2020-02-28T23:07:05Z", "author": {"login": "kevinushey"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,635 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::split(queries, queryStr, boost::is_any_of(\";\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MzU3MQ==", "bodyText": "This seems useful enough to factor into a helper function somewhere (IIRC we need to ensure 0600 permissions on a variety of files like this)", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385963571", "createdAt": "2020-02-28T23:11:13Z", "author": {"login": "kevinushey"}, "path": "src/cpp/server_core/ServerDatabase.cpp", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * ServerDatabase.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <server_core/ServerDatabase.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/thread.hpp>\n+\n+#include <core/Log.hpp>\n+#include <core/Settings.hpp>\n+#include <core/system/Environment.hpp>\n+#include <core/system/System.hpp>\n+#include <shared_core/Error.hpp>\n+\n+namespace rstudio {\n+namespace server_core {\n+namespace database {\n+\n+using namespace core;\n+using namespace core::database;\n+\n+namespace {\n+\n+// settings constants\n+constexpr const char* kDatabaseProvider = \"provider\";\n+constexpr const char* kDatabaseProviderSqlite = \"sqlite\";\n+constexpr const char* kDatabaseProviderPostgresql = \"postgresql\";\n+constexpr const char* kSqliteDatabaseDirectory = \"directory\";\n+constexpr const char* kDefaultSqliteDatabaseDirectory = \"/var/run/rstudio-server\";\n+constexpr const char* kDatabaseHost = \"host\";\n+constexpr const char* kDefaultDatabaseHost = \"localhost\";\n+constexpr const char* kDatabasePort = \"port\";\n+constexpr const char* kDefaultPostgresqlDatabasePort = \"5432\";\n+constexpr const char* kDatabaseUser = \"user\";\n+constexpr const char* kDefaultPostgresqlDatabaseUser = \"postgres\";\n+constexpr const char* kDatabasePassword = \"password\";\n+constexpr const char* kPostgresqlDatabaseConnectionTimeoutSeconds = \"connnection-timeout-seconds\";\n+constexpr const int   kDefaultPostgresqlDatabaseConnectionTimeoutSeconds = 10;\n+\n+// environment variables\n+constexpr const char* kServerTmpDirEnvVar = \"RS_SERVER_TMP_DIR\";\n+constexpr const char* kDatabaseMigrationsPathEnvVar = \"RS_DB_MIGRATIONS_PATH\";\n+\n+//misc constants\n+constexpr const size_t kDefaultConnectionPoolSize = 4;\n+\n+boost::shared_ptr<ConnectionPool> s_connectionPool;\n+\n+Error readOptions(ConnectionOptions* pOptions)\n+{\n+   FilePath optionsFile(\"/etc/rstudio/database.conf\");\n+   if (optionsFile.exists())\n+   {\n+      // the database configuration file can potentially contain sensitive information\n+      // log a warning if permissions are too lax\n+      FileMode fileMode;\n+      Error error = optionsFile.getFileMode(fileMode);\n+      if (error)\n+      {\n+         LOG_ERROR_MESSAGE(\"Could not determine file permissions for database configuration file: \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NDQzMA==", "bodyText": "Does rserver still exit gracefully with this static variable?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385964430", "createdAt": "2020-02-28T23:14:42Z", "author": {"login": "kevinushey"}, "path": "src/cpp/server_core/ServerDatabase.cpp", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * ServerDatabase.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <server_core/ServerDatabase.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/thread.hpp>\n+\n+#include <core/Log.hpp>\n+#include <core/Settings.hpp>\n+#include <core/system/Environment.hpp>\n+#include <core/system/System.hpp>\n+#include <shared_core/Error.hpp>\n+\n+namespace rstudio {\n+namespace server_core {\n+namespace database {\n+\n+using namespace core;\n+using namespace core::database;\n+\n+namespace {\n+\n+// settings constants\n+constexpr const char* kDatabaseProvider = \"provider\";\n+constexpr const char* kDatabaseProviderSqlite = \"sqlite\";\n+constexpr const char* kDatabaseProviderPostgresql = \"postgresql\";\n+constexpr const char* kSqliteDatabaseDirectory = \"directory\";\n+constexpr const char* kDefaultSqliteDatabaseDirectory = \"/var/run/rstudio-server\";\n+constexpr const char* kDatabaseHost = \"host\";\n+constexpr const char* kDefaultDatabaseHost = \"localhost\";\n+constexpr const char* kDatabasePort = \"port\";\n+constexpr const char* kDefaultPostgresqlDatabasePort = \"5432\";\n+constexpr const char* kDatabaseUser = \"user\";\n+constexpr const char* kDefaultPostgresqlDatabaseUser = \"postgres\";\n+constexpr const char* kDatabasePassword = \"password\";\n+constexpr const char* kPostgresqlDatabaseConnectionTimeoutSeconds = \"connnection-timeout-seconds\";\n+constexpr const int   kDefaultPostgresqlDatabaseConnectionTimeoutSeconds = 10;\n+\n+// environment variables\n+constexpr const char* kServerTmpDirEnvVar = \"RS_SERVER_TMP_DIR\";\n+constexpr const char* kDatabaseMigrationsPathEnvVar = \"RS_DB_MIGRATIONS_PATH\";\n+\n+//misc constants\n+constexpr const size_t kDefaultConnectionPoolSize = 4;\n+\n+boost::shared_ptr<ConnectionPool> s_connectionPool;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NDg3Mg==", "bodyText": "I'd remove this and just ask users to reference the admin guide, as this could become stale as new databases are supported.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385964872", "createdAt": "2020-02-28T23:16:25Z", "author": {"login": "kevinushey"}, "path": "src/cpp/server/extras/conf/database.conf", "diffHunk": "@@ -0,0 +1,34 @@\n+# This file contains database configuration.\n+#\n+# RStudio Server needs an external database for storage of specific configuration and runtime information.\n+# At present, SQLite and PostgreSQL databases are supported.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NTM4Mw==", "bodyText": "Does this still work even with our copy of Boost? (a bit surprised it does since we do the extra symbol namespacing work for the bundles of Boost we build)", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385965383", "createdAt": "2020-02-28T23:18:30Z", "author": {"login": "kevinushey"}, "path": "dependencies/common/install-soci", "diffHunk": "@@ -0,0 +1,64 @@\n+#!/usr/bin/env bash\n+\n+#\n+# install-soci\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+set -e\n+\n+# install dir \n+INSTALL_DIR=`pwd`\n+\n+# vars\n+BOOST_VERSION=\"1_69_0\"\n+RSTUDIO_TOOLS_DIR=/opt/rstudio-tools\n+SOCI_DIR=$RSTUDIO_TOOLS_DIR/soci\n+SOCI_BIN_DIR=$SOCI_DIR/build\n+SOCI_BRANCH=release/4.0\n+BOOST_DIR=\"$RSTUDIO_TOOLS_DIR/boost/boost_$BOOST_VERSION\"\n+\n+# install SOCI if it isn't already installed\n+if ! ls $SOCI_BIN_DIR/lib/libsoci_core* &> /dev/null\n+then\n+   cd $RSTUDIO_TOOLS_DIR\n+\n+   # download SOCI from source\n+   if ! [ -d \"$SOCI_DIR\" ]\n+   then\n+      git clone git://github.com/SOCI/soci.git\n+   fi\n+   cd $SOCI_DIR\n+\n+   # checkout desired soci branch (version pinned)\n+   git checkout \"$SOCI_BRANCH\"  \n+\n+   # make build directory\n+   mkdir -p $SOCI_BIN_DIR\n+   cd $SOCI_BIN_DIR\n+\n+   # create symlink to our boost datetime library so it is properly discovered by the SOCI build\n+   ln -sf \"$BOOST_DIR/lib/libboost_date_time.a\" \"$BOOST_DIR/lib/rstudio_boost_date_time.a\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NjY1OA==", "bodyText": "Do we need to sanitize any of these strings? (I guess in theory these are only ever read from a config file, which should be considered safe / trusted but worth confirming this is true.)", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385966658", "createdAt": "2020-02-28T23:23:17Z", "author": {"login": "kevinushey"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,635 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NzEzMA==", "bodyText": "I'm not as familiar on what the best practices are re: database updates + schema versioning. Do you have any recommended resources for getting better acquainted?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r385967130", "createdAt": "2020-02-28T23:25:25Z", "author": {"login": "kevinushey"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,635 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::split(queries, queryStr, boost::is_any_of(\";\"));\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                              Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available\n+   boost::shared_ptr<Connection> connection;\n+   connections_.deque(&connection, boost::posix_time::pos_infin);\n+\n+   // create wrapper PooledConnection around retrieved Connection\n+   return boost::shared_ptr<IConnection>(new PooledConnection(shared_from_this(), connection));\n+}\n+\n+void ConnectionPool::returnConnection(const boost::shared_ptr<Connection>& connection)\n+{\n+   connections_.enque(connection);\n+}\n+\n+Transaction::Transaction(const boost::shared_ptr<IConnection>& connection) :\n+   connection_(connection),\n+   transaction_(connection->session())\n+{\n+}\n+\n+void Transaction::commit()\n+{\n+   transaction_.commit();\n+}\n+\n+void Transaction::rollback()\n+{\n+   transaction_.rollback();\n+}\n+\n+SchemaUpdater::SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                             const FilePath& migrationsPath) :\n+   connection_(connection),\n+   migrationsPath_(migrationsPath)\n+{\n+}\n+\n+Error SchemaUpdater::migrationFiles(std::vector<FilePath>* pMigrationFiles)\n+{\n+   std::vector<FilePath> children;\n+   Error error = migrationsPath_.getChildren(children);\n+   if (error)\n+      return error;\n+\n+   for (const FilePath& file : children)\n+   {\n+      std::string extension = file.getExtensionLowerCase();\n+      if (extension == SQL_EXTENSION ||\n+          extension == SQLITE_EXTENSION ||\n+          extension == POSTGRESQL_EXTENSION)\n+      {\n+         pMigrationFiles->push_back(file);\n+      }\n+   }\n+\n+   return Success();\n+}\n+\n+Error SchemaUpdater::highestMigrationVersion(std::string* pVersion)\n+{\n+   std::vector<FilePath> files;\n+   Error error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   if (files.empty())\n+   {\n+      // no migration files - we do not consider this an error, but instead\n+      // simply consider that this database cannot be migrated past version 0\n+      *pVersion = \"0\";\n+      return Success();\n+   }\n+\n+   // sort descending - highest version filename wins\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() > b.getStem();\n+   };\n+   std::sort(files.begin(), files.end(), comparator);\n+\n+   *pVersion = files.at(0).getStem();\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isSchemaVersionPresent(bool* pIsPresent)\n+{\n+   std::string queryStr;\n+   if (connection_->driverName() == SQLITE_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM sqlite_master WHERE type='table' AND name='\") + SCHEMA_TABLE + \"'\";\n+   }\n+   else if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM information_schema.tables WHERE table_name='\") + SCHEMA_TABLE +\n+                 \"' AND table_schema = current_schema\";\n+   }\n+   else\n+   {\n+      return DatabaseError(soci::soci_error(\"Unsupported database driver\"));\n+   }\n+\n+   int count = 0;\n+   Query query = connection_->query(queryStr)\n+         .withOutput(count);\n+   Error error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pIsPresent = count > 0;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::databaseSchemaVersion(std::string* pVersion)\n+{\n+   bool versionPresent = false;\n+   Error error = isSchemaVersionPresent(&versionPresent);\n+   if (error)\n+      return error;\n+\n+   std::string currentSchemaVersion = \"0\";\n+   if (!versionPresent)\n+   {\n+      // no schema version present - add the table to the database so it is available\n+      // for updating whenever migrations occur\n+      error = connection_->executeStr(std::string(\"CREATE TABLE \") + SCHEMA_TABLE + \"(current_version text)\");\n+      if (error)\n+         return error;\n+\n+      Query query = connection_->query(std::string(\"INSERT INTO \") + SCHEMA_TABLE + \" VALUES (:val)\")\n+            .withInput(currentSchemaVersion);\n+      error = connection_->execute(query);\n+      if (error)\n+         return error;\n+\n+      *pVersion = currentSchemaVersion;\n+      return Success();\n+   }\n+\n+   Query query = connection_->query(std::string(\"SELECT current_version FROM \") + SCHEMA_TABLE)\n+         .withOutput(currentSchemaVersion);\n+\n+   error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pVersion = currentSchemaVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isUpToDate(bool* pUpToDate)\n+{\n+   std::string version;\n+   Error error = databaseSchemaVersion(&version);\n+   if (error)\n+      return error;\n+\n+   std::string migrationVersion;\n+   error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   *pUpToDate = version >= migrationVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::update()\n+{\n+   std::string migrationVersion;\n+   Error error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   std::string currentVersion;\n+   error = databaseSchemaVersion(&currentVersion);\n+   if (currentVersion < migrationVersion)\n+      return updateToVersion(migrationVersion);\n+   else\n+      return Success();\n+}\n+\n+Error SchemaUpdater::updateToVersion(const std::string& maxVersion)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d89e3691af0cc87f60697e2c6f6ec5aed8b02f9f"}, "originalPosition": 509}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50194adcba2d3a866ba740dfda598e9a0a6a9997", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/50194adcba2d3a866ba740dfda598e9a0a6a9997", "committedDate": "2020-03-02T16:17:35Z", "message": "Code review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54da3323e95898c0149a32c909f2de06f9e618ff", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/54da3323e95898c0149a32c909f2de06f9e618ff", "committedDate": "2020-03-02T16:24:16Z", "message": "Code review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MzY0ODIy", "url": "https://github.com/rstudio/rstudio/pull/6356#pullrequestreview-367364822", "createdAt": "2020-03-02T16:59:28Z", "commit": {"oid": "54da3323e95898c0149a32c909f2de06f9e618ff"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/d9eeef71efcc2d0313246694bac62d2ac6ba7d34", "committedDate": "2020-03-02T17:59:26Z", "message": "Code review feedback - add support for nested ; within multi-query strings"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTA2MjEy", "url": "https://github.com/rstudio/rstudio/pull/6356#pullrequestreview-367506212", "createdAt": "2020-03-02T20:32:20Z", "commit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDozMjoyMFrOFwuPpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowMTozN1rOFxYK9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMzYzNg==", "bodyText": "Should this file (and some of the others that were added for installing DB dependencies) have a copyright comment at the top?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386633636", "createdAt": "2020-03-02T20:32:20Z", "author": {"login": "MariaSemple"}, "path": "dependencies/windows/install-soci/install-soci.R", "diffHunk": "@@ -0,0 +1,97 @@\n+# some laziness to ensure we move to the 'install-crashpad' folder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyODE2Mg==", "bodyText": "Does this regex prevent splitting on ; characters within literal strings? For example SELECT * FROM Users WHERE User.name LIKE '%;%'; ? It looks to me like it might cut off the last part of the query and cause syntax errors, but it also might not be an issue if no part of our queries are from user generated values.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386728162", "createdAt": "2020-03-03T00:13:01Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,638 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyODY3Nw==", "bodyText": "Nit: alignment is off here.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386728677", "createdAt": "2020-03-03T00:14:43Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,638 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                              Rowset& rowset)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNDI5Ng==", "bodyText": "Does the transaction need to be rolled back before returning here (and elsewhere), or will it automatically roll back on destruction?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386734296", "createdAt": "2020-03-03T00:33:18Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,638 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                              Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available\n+   boost::shared_ptr<Connection> connection;\n+   connections_.deque(&connection, boost::posix_time::pos_infin);\n+\n+   // create wrapper PooledConnection around retrieved Connection\n+   return boost::shared_ptr<IConnection>(new PooledConnection(shared_from_this(), connection));\n+}\n+\n+void ConnectionPool::returnConnection(const boost::shared_ptr<Connection>& connection)\n+{\n+   connections_.enque(connection);\n+}\n+\n+Transaction::Transaction(const boost::shared_ptr<IConnection>& connection) :\n+   connection_(connection),\n+   transaction_(connection->session())\n+{\n+}\n+\n+void Transaction::commit()\n+{\n+   transaction_.commit();\n+}\n+\n+void Transaction::rollback()\n+{\n+   transaction_.rollback();\n+}\n+\n+SchemaUpdater::SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                             const FilePath& migrationsPath) :\n+   connection_(connection),\n+   migrationsPath_(migrationsPath)\n+{\n+}\n+\n+Error SchemaUpdater::migrationFiles(std::vector<FilePath>* pMigrationFiles)\n+{\n+   std::vector<FilePath> children;\n+   Error error = migrationsPath_.getChildren(children);\n+   if (error)\n+      return error;\n+\n+   for (const FilePath& file : children)\n+   {\n+      std::string extension = file.getExtensionLowerCase();\n+      if (extension == SQL_EXTENSION ||\n+          extension == SQLITE_EXTENSION ||\n+          extension == POSTGRESQL_EXTENSION)\n+      {\n+         pMigrationFiles->push_back(file);\n+      }\n+   }\n+\n+   return Success();\n+}\n+\n+Error SchemaUpdater::highestMigrationVersion(std::string* pVersion)\n+{\n+   std::vector<FilePath> files;\n+   Error error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   if (files.empty())\n+   {\n+      // no migration files - we do not consider this an error, but instead\n+      // simply consider that this database cannot be migrated past version 0\n+      *pVersion = \"0\";\n+      return Success();\n+   }\n+\n+   // sort descending - highest version filename wins\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() > b.getStem();\n+   };\n+   std::sort(files.begin(), files.end(), comparator);\n+\n+   *pVersion = files.at(0).getStem();\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isSchemaVersionPresent(bool* pIsPresent)\n+{\n+   std::string queryStr;\n+   if (connection_->driverName() == SQLITE_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM sqlite_master WHERE type='table' AND name='\") + SCHEMA_TABLE + \"'\";\n+   }\n+   else if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM information_schema.tables WHERE table_name='\") + SCHEMA_TABLE +\n+                 \"' AND table_schema = current_schema\";\n+   }\n+   else\n+   {\n+      return DatabaseError(soci::soci_error(\"Unsupported database driver\"));\n+   }\n+\n+   int count = 0;\n+   Query query = connection_->query(queryStr)\n+         .withOutput(count);\n+   Error error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pIsPresent = count > 0;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::databaseSchemaVersion(std::string* pVersion)\n+{\n+   bool versionPresent = false;\n+   Error error = isSchemaVersionPresent(&versionPresent);\n+   if (error)\n+      return error;\n+\n+   std::string currentSchemaVersion = \"0\";\n+   if (!versionPresent)\n+   {\n+      // no schema version present - add the table to the database so it is available\n+      // for updating whenever migrations occur\n+      error = connection_->executeStr(std::string(\"CREATE TABLE \") + SCHEMA_TABLE + \"(CurrentVersion text)\");\n+      if (error)\n+         return error;\n+\n+      Query query = connection_->query(std::string(\"INSERT INTO \") + SCHEMA_TABLE + \" VALUES (:val)\")\n+            .withInput(currentSchemaVersion);\n+      error = connection_->execute(query);\n+      if (error)\n+         return error;\n+\n+      *pVersion = currentSchemaVersion;\n+      return Success();\n+   }\n+\n+   Query query = connection_->query(std::string(\"SELECT CurrentVersion FROM \") + SCHEMA_TABLE)\n+         .withOutput(currentSchemaVersion);\n+\n+   error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pVersion = currentSchemaVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isUpToDate(bool* pUpToDate)\n+{\n+   std::string version;\n+   Error error = databaseSchemaVersion(&version);\n+   if (error)\n+      return error;\n+\n+   std::string migrationVersion;\n+   error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   *pUpToDate = version >= migrationVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::update()\n+{\n+   std::string migrationVersion;\n+   Error error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   std::string currentVersion;\n+   error = databaseSchemaVersion(&currentVersion);\n+   if (currentVersion < migrationVersion)\n+      return updateToVersion(migrationVersion);\n+   else\n+      return Success();\n+}\n+\n+Error SchemaUpdater::updateToVersion(const std::string& maxVersion)\n+{\n+   // create a transaction to perform the following steps:\n+   // 1. Check the current database schema version\n+   // 2. Check if we need to update\n+   // 3. Update (if necessary)\n+   // 4. Save new database schema version\n+   // performing this in a transaction ensures that we rollback if anything\n+   // fails, and also ensures that other nodes cannot update concurrently\n+   Transaction transaction(connection_);\n+\n+   // for postgresql, specifically lock the version table in exclusive mode\n+   // to ensure that no other connection can use the version table AT ALL\n+   // during this schema update\n+   if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      Query query = connection_->query(std::string(\"LOCK \") + SCHEMA_TABLE + \" IN ACCESS EXCLUSIVE MODE\");\n+      Error error = connection_->execute(query);\n+      if (error)\n+         return error;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 531}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2MzA3Mw==", "bodyText": "Does returning here prevent the rest of the tests from running?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386763073", "createdAt": "2020-03-03T02:14:42Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/core/DatabaseTests.cpp", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * DatabaseTests.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <tests/TestThat.hpp>\n+\n+#include <core/Database.hpp>\n+#include <core/FileSerializer.hpp>\n+#include <core/system/System.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/boost-tuple.h>\n+#include <soci/session.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+namespace rstudio {\n+namespace unit_tests {\n+\n+using namespace core;\n+using namespace core::database;\n+\n+core::database::SqliteConnectionOptions sqliteConnectionOptions()\n+{\n+   return SqliteConnectionOptions { \"/tmp/rstudio-test-db\" };\n+}\n+\n+core::database::PostgresqlConnectionOptions postgresConnectionOptions()\n+{\n+   PostgresqlConnectionOptions options;\n+   options.connectionTimeoutSeconds = 10;\n+   options.database = \"rstudio-test\";\n+   options.host = \"localhost\";\n+   options.user = \"postgres\";\n+   options.password = \"postgres\";\n+\n+   return options;\n+}\n+\n+TEST_CASE(\"Database\", \"[.database]\")\n+{\n+   test_that(\"Test Setup\")\n+   {\n+      // ensure that the test databases do not exist\n+      FilePath sqliteDbPath(\"/tmp/rstudio-test-db\");\n+      sqliteDbPath.removeIfExists();\n+\n+      boost::shared_ptr<IConnection> connection;\n+      Error error = connect(postgresConnectionOptions(), &connection);\n+      if (error)\n+         return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NDU2Mg==", "bodyText": "What do you think about adding a test case for unusual characters on inserts or filters? Like \\ or ; in usernames or other fields?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386764562", "createdAt": "2020-03-03T02:20:56Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/core/DatabaseTests.cpp", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * DatabaseTests.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <tests/TestThat.hpp>\n+\n+#include <core/Database.hpp>\n+#include <core/FileSerializer.hpp>\n+#include <core/system/System.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/boost-tuple.h>\n+#include <soci/session.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+namespace rstudio {\n+namespace unit_tests {\n+\n+using namespace core;\n+using namespace core::database;\n+\n+core::database::SqliteConnectionOptions sqliteConnectionOptions()\n+{\n+   return SqliteConnectionOptions { \"/tmp/rstudio-test-db\" };\n+}\n+\n+core::database::PostgresqlConnectionOptions postgresConnectionOptions()\n+{\n+   PostgresqlConnectionOptions options;\n+   options.connectionTimeoutSeconds = 10;\n+   options.database = \"rstudio-test\";\n+   options.host = \"localhost\";\n+   options.user = \"postgres\";\n+   options.password = \"postgres\";\n+\n+   return options;\n+}\n+\n+TEST_CASE(\"Database\", \"[.database]\")\n+{\n+   test_that(\"Test Setup\")\n+   {\n+      // ensure that the test databases do not exist\n+      FilePath sqliteDbPath(\"/tmp/rstudio-test-db\");\n+      sqliteDbPath.removeIfExists();\n+\n+      boost::shared_ptr<IConnection> connection;\n+      Error error = connect(postgresConnectionOptions(), &connection);\n+      if (error)\n+         return;\n+\n+      std::string queryStr =\n+         R\"\"(\n+         DROP SCHEMA public CASCADE;\n+         CREATE SCHEMA public;\n+         GRANT ALL ON SCHEMA public TO postgres;\n+         GRANT ALL ON SCHEMA public TO public;\n+         )\"\";\n+\n+      connection->executeStr(queryStr);\n+   }\n+\n+   test_that(\"Can create SQLite database\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      Query query = connection->query(\"create table Test(id int, text varchar(255))\");\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      int id = 10;\n+      std::string text = \"Hello, database!\";\n+\n+      query = connection->query(\"insert into Test(id, text) values(:id, :text)\")\n+            .withInput(id)\n+            .withInput(text);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      boost::tuple<int, std::string> row;\n+      query = connection->query(\"select id, text from Test where id = (:id)\")\n+            .withInput(id)\n+            .withOutput(row);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      CHECK(row.get<0>() == id);\n+      CHECK(row.get<1>() == text);\n+   }\n+\n+   test_that(\"Can create PostgreSQL database\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(postgresConnectionOptions(), &connection));\n+\n+      Query query = connection->query(\"create table Test(id int, text varchar(255))\");\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      int id = 10;\n+      std::string text = \"Hello, database!\";\n+\n+      query = connection->query(\"insert into Test(id, text) values(:id, :text)\")\n+            .withInput(id)\n+            .withInput(text);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      boost::tuple<int, std::string> row;\n+      query = connection->query(\"select id, text from Test where id = (:id)\")\n+            .withInput(id)\n+            .withOutput(row);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      CHECK(row.get<0>() == id);\n+      CHECK(row.get<1>() == text);\n+   }\n+\n+   test_that(\"Can perform transactions\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      Transaction transaction(connection);\n+      int numFailed = 0;\n+      bool dataReturned = false;\n+\n+      // verify that we can commit a transaction\n+      Query query = connection->query(\"insert into Test(id, text) values(:id, :text)\");\n+      for (int id = 0; id < 100; ++id)\n+      {\n+         std::string text = \"Test text \" + core::safe_convert::numberToString(id);\n+         query.withInput(id).withInput(text);\n+\n+         if (connection->execute(query))\n+            ++numFailed;\n+      }\n+\n+      REQUIRE(numFailed == 0);\n+      transaction.commit();\n+\n+      boost::tuple<int, std::string> row;\n+      query = connection->query(\"select id, text from Test where id = 50\")\n+            .withOutput(row);\n+\n+      REQUIRE_FALSE(connection->execute(query, &dataReturned));\n+      REQUIRE(dataReturned);\n+      REQUIRE(row.get<0>() == 50);\n+      REQUIRE(row.get<1>() == \"Test text 50\");\n+\n+      // now attempt to rollback a transaction\n+      Transaction transaction2(connection);\n+      query = connection->query(\"insert into Test(id, text) values(:id, :text)\");\n+      for (int id = 100; id < 200; ++id)\n+      {\n+         std::string text = \"Test text \" + core::safe_convert::numberToString(id);\n+         query.withInput(id).withInput(text);\n+\n+         if (connection->execute(query))\n+            ++numFailed;\n+      }\n+\n+      REQUIRE(numFailed == 0);\n+      transaction2.rollback();\n+\n+      query = connection->query(\"select id, text from Test where id = 150\")\n+            .withOutput(row);\n+\n+      // expect no data\n+      REQUIRE_FALSE(connection->execute(query, &dataReturned));\n+      REQUIRE_FALSE(dataReturned);\n+   }\n+\n+   test_that(\"Can bulk select\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      Rowset rows;\n+      Query query = connection->query(\"select id, text from Test where id >= 50 and id <= 100\");\n+      REQUIRE_FALSE(connection->execute(query, rows));\n+\n+      int i = 0;\n+      for (RowsetIterator it = rows.begin(); it != rows.end(); ++it)\n+      {\n+         Row& row = *it;\n+         REQUIRE(row.get<int>(0) == i + 50);\n+         REQUIRE(row.get<std::string>(1) == \"Test text \" + safe_convert::numberToString(i+50));\n+         ++i;\n+      }\n+   }\n+\n+   test_that(\"Can bulk insert\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      std::vector<int> rowIds {1000, 2000, 3000, 4000, 5000};\n+      std::vector<std::string> rowTexts {\"1000\", \"2000\", \"3000\", \"4000\", \"5000\"};\n+\n+      Query query = connection->query(\"insert into Test values (:id, :txt)\")\n+            .withInput(rowIds)\n+            .withInput(rowTexts);\n+      REQUIRE_FALSE(connection->execute(query));\n+\n+      Query selectQuery = connection->query(\"select * from Test where id >= 1000\");\n+\n+      Rowset rowset;\n+      REQUIRE_FALSE(connection->execute(selectQuery, rowset));\n+      int i = 1;\n+      for (RowsetIterator it = rowset.begin(); it != rowset.end(); ++it)\n+      {\n+         Row& row = *it;\n+         REQUIRE(row.get<int>(0) == i * 1000);\n+         REQUIRE(row.get<std::string>(1) == safe_convert::numberToString(i*1000));\n+         ++i;\n+      }\n+   }\n+\n+   test_that(\"Can use connection pool\")\n+   {\n+      boost::shared_ptr<ConnectionPool> connectionPool;\n+      REQUIRE_FALSE(createConnectionPool(5, sqliteConnectionOptions(), &connectionPool));\n+\n+      boost::shared_ptr<IConnection> connection = connectionPool->getConnection();\n+      boost::tuple<int, std::string> row;\n+      Query query = connection->query(\"select id, text from Test where id = 50\")\n+            .withOutput(row);\n+\n+      bool dataReturned = false;\n+      REQUIRE_FALSE(connection->execute(query, &dataReturned));\n+      REQUIRE(dataReturned);\n+\n+      boost::shared_ptr<IConnection> connection2 = connectionPool->getConnection();\n+      Query query2 = connection2->query(\"select id, text from Test where id = 25\")\n+            .withOutput(row);\n+\n+      dataReturned = false;\n+      REQUIRE_FALSE(connection2->execute(query2, &dataReturned));\n+      REQUIRE(dataReturned);\n+   }\n+\n+   test_that(\"Can update schemas\")\n+   {\n+      // generate some schema files\n+      std::string schema1 =\n+         R\"\"(\n+         CREATE TABLE TestTable1_Persons(\n+            id int NOT NULL,\n+            first_name varchar(255),\n+            last_name varchar(255) NOT NULL,\n+            email_address varchar(255)\n+         );\n+\n+         CREATE TABLE TestTable2_AccountHolders(\n+            id int,\n+            fk_person_id int\n+         );\n+         )\"\";\n+\n+      // sqlite cannot alter tables very well, so adding constraints necessitates dropping\n+      // and re-creating the tables\n+      std::string schema2Sqlite =\n+         R\"\"(\n+         CREATE TABLE TestTable1_Persons_new(\n+            id int NOT NULL,\n+            first_name varchar(255),\n+            last_name varchar(255),\n+            email_address varchar(255),\n+            PRIMARY KEY (id)\n+         );\n+\n+         DROP TABLE TestTable1_Persons;\n+         ALTER TABLE TestTable1_Persons_new RENAME TO TestTable1_Persons;\n+\n+         CREATE TABLE TestTable2_AccountHolders_new(\n+            id int,\n+            fk_person_id int,\n+            PRIMARY KEY (id),\n+            FOREIGN KEY (fk_person_id) REFERENCES TestTable1_Persons(id)\n+         );\n+\n+         DROP TABLE TestTable2_AccountHolders;\n+         ALTER TABLE TestTable2_AccountHolders_new RENAME TO TestTable2_AccountHolders;\n+         )\"\";\n+\n+      // postgresql supports modification of tables\n+      std::string schema2Postgresql =\n+         R\"\"(\n+         ALTER TABLE TestTable1_Persons\n+         ADD PRIMARY KEY (id);\n+\n+         ALTER TABLE TestTable2_AccountHolders\n+         ADD PRIMARY KEY (id);\n+\n+         ALTER TABLE TestTable2_AccountHolders\n+         ADD FOREIGN KEY (fk_person_id) REFERENCES TestTable1_Persons(id);\n+         )\"\";\n+\n+      std::string schema3Sqlite =\n+         R\"\"(\n+         CREATE TABLE TestTable2_AccountHolders_new(\n+            id int,\n+            fk_person_id int,\n+            creation_time text,\n+            PRIMARY KEY (id),\n+            FOREIGN KEY (fk_person_id) REFERENCES TestTable1_Persons(id)\n+         );\n+\n+         DROP TABLE TestTable2_AccountHolders;\n+         ALTER TABLE TestTable2_AccountHolders_new RENAME TO TestTable2_AccountHolders;\n+         )\"\";\n+\n+      std::string schema3Postgresql =\n+         R\"\"(\n+         ALTER TABLE TestTable2_AccountHolders\n+         ADD COLUMN creation_time text;\n+         )\"\";\n+\n+      FilePath workingDir = core::system::currentWorkingDir(core::system::currentProcessId());\n+      FilePath outFile1 = workingDir.completeChildPath(\"1_InitialTables.sql\");\n+      FilePath outFile2Sqlite = workingDir.completeChildPath(\"2_ConstraintsForInitialTables.sqlite\");\n+      FilePath outFile2Postgresql = workingDir.completeChildPath(\"2_ConstraintsForInitialTables.postgresql\");\n+      FilePath outFile3Sqlite = workingDir.completeChildPath(\"3_AddAccountCreationTime.sqlite\");\n+      FilePath outFile3Postgresql = workingDir.completeChildPath(\"3_AddAccountCreationTime.postgresql\");\n+\n+      REQUIRE_FALSE(writeStringToFile(outFile1, schema1));\n+      REQUIRE_FALSE(writeStringToFile(outFile2Sqlite, schema2Sqlite));\n+      REQUIRE_FALSE(writeStringToFile(outFile2Postgresql, schema2Postgresql));\n+      REQUIRE_FALSE(writeStringToFile(outFile3Sqlite, schema3Sqlite));\n+      REQUIRE_FALSE(writeStringToFile(outFile3Postgresql, schema3Postgresql));\n+\n+      boost::shared_ptr<IConnection> sqliteConnection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &sqliteConnection));\n+\n+      boost::shared_ptr<IConnection> postgresConnection;\n+      REQUIRE_FALSE(connect(postgresConnectionOptions(), &postgresConnection));\n+\n+      SchemaUpdater sqliteUpdater(sqliteConnection, workingDir);\n+      SchemaUpdater postgresUpdater(postgresConnection, workingDir);\n+\n+      REQUIRE_FALSE(sqliteUpdater.update());\n+      REQUIRE_FALSE(postgresUpdater.update());\n+\n+      std::string currentSchemaVersion;\n+      REQUIRE_FALSE(sqliteUpdater.databaseSchemaVersion(&currentSchemaVersion));\n+      REQUIRE(currentSchemaVersion == \"3_AddAccountCreationTime\");\n+      currentSchemaVersion.clear();\n+      REQUIRE_FALSE(postgresUpdater.databaseSchemaVersion(&currentSchemaVersion));\n+      REQUIRE(currentSchemaVersion == \"3_AddAccountCreationTime\");\n+\n+      // ensure repeated calls to update work without error\n+      REQUIRE_FALSE(sqliteUpdater.update());\n+      REQUIRE_FALSE(postgresUpdater.update());\n+\n+      // ensure we can insert data as expected (given our expected constraints)\n+      int id = 1;\n+      std::string firstName = \"Billy\";\n+      std::string lastName = \"Joel\";\n+      std::string email = \"bjoel@example.com\";\n+      std::string creationTime = \"03/03/2020 12:00:00\";\n+\n+      // create queries - we will be executing them multiple times, so bind input just before execution\n+      Query sqliteInsertQuery = sqliteConnection->query(\"INSERT INTO TestTable1_Persons VALUES (:id, :fname, :lname, :email)\");\n+      Query postgresInsertQuery = postgresConnection->query(\"INSERT INTO TestTable1_Persons VALUES (:id, :fname, :lname, :email)\");\n+      Query sqliteInsertQuery2 = sqliteConnection->query(\"INSERT INTO TestTable2_AccountHolders VALUES (:id, :pid, :time)\");\n+      Query postgresInsertQuery2 = postgresConnection->query(\"INSERT INTO TestTable2_AccountHolders VALUES (:id, :pid, :time)\");\n+\n+      // should fail - FK constraint\n+      sqliteInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      postgresInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK(sqliteConnection->execute(sqliteInsertQuery2));\n+      CHECK(postgresConnection->execute(postgresInsertQuery2));\n+\n+      // should succeed - properly ordered\n+      sqliteInsertQuery\n+            .withInput(id, \"id\")\n+            .withInput(firstName, \"fname\")\n+            .withInput(lastName, \"lname\")\n+            .withInput(email, \"email\");\n+      CHECK_FALSE(sqliteConnection->execute(sqliteInsertQuery));\n+      sqliteInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK_FALSE(sqliteConnection->execute(sqliteInsertQuery2));\n+      postgresInsertQuery\n+            .withInput(id, \"id\")\n+            .withInput(firstName, \"fname\")\n+            .withInput(lastName, \"lname\")\n+            .withInput(email, \"email\");\n+      CHECK_FALSE(postgresConnection->execute(postgresInsertQuery));\n+      postgresInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK_FALSE(postgresConnection->execute(postgresInsertQuery2));\n+\n+      // should fail - PK constraint\n+      sqliteInsertQuery\n+            .withInput(id, \"id\")\n+            .withInput(firstName, \"fname\")\n+            .withInput(lastName, \"lname\")\n+            .withInput(email, \"email\");\n+      CHECK(sqliteConnection->execute(sqliteInsertQuery));\n+      sqliteInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK(sqliteConnection->execute(sqliteInsertQuery2));\n+      postgresInsertQuery\n+            .withInput(id, \"id\")\n+            .withInput(firstName, \"fname\")\n+            .withInput(lastName, \"lname\")\n+            .withInput(email, \"email\");\n+      CHECK(postgresConnection->execute(postgresInsertQuery));\n+      postgresInsertQuery2\n+            .withInput(id, \"id\")\n+            .withInput(id, \"pid\")\n+            .withInput(creationTime, \"time\");\n+      CHECK(postgresConnection->execute(postgresInsertQuery2));\n+   }\n+\n+   test_that(\"Can execute str with multiple queries\")\n+   {\n+      boost::shared_ptr<IConnection> connection;\n+      REQUIRE_FALSE(connect(sqliteConnectionOptions(), &connection));\n+\n+      std::string queryStr =\n+            \"CREATE TABLE TestTable_3(\"\n+            \"A text, B text\\n);            \\n\"\n+            \"INSERT INTO TestTable_3 VALUES (\\\"Hello\\\", \\\"World;      \\\");\\n\"\n+            \"INSERT INTO TestTable_3 VALUES (\\\"Hello2\\\", \\\";;;\\\");\";\n+\n+      REQUIRE_FALSE(connection->executeStr(queryStr));\n+\n+      Query selectQuery = connection->query(\"select * from TestTable_3 order by A asc\");\n+\n+      Rowset rowset;\n+      REQUIRE_FALSE(connection->execute(selectQuery, rowset));\n+      int i = 0;\n+      std::string vals[2][2];\n+      vals[0][0] = \"Hello\";\n+      vals[0][1] = \"World;      \";\n+      vals[1][0] = \"Hello2\";\n+      vals[1][1] = \";;;\";\n+      for (RowsetIterator it = rowset.begin(); it != rowset.end(); ++it)\n+      {\n+         Row& row = *it;\n+         REQUIRE(row.get<std::string>(0) == vals[i][0]);\n+         REQUIRE(row.get<std::string>(1) == vals[i][1]);\n+         ++i;\n+      }\n+   }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 468}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NTk4Nw==", "bodyText": "Nit: The variable name suggests it updates the schema to no higher than the provided version. Is that the behaviour, or will it always update to exactly the specified version?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r386765987", "createdAt": "2020-03-03T02:26:05Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/core/include/core/Database.hpp", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Database.hpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#ifndef CORE_DATABASE_HPP\n+#define CORE_DATABASE_HPP\n+\n+#include <core/Thread.hpp>\n+#include <shared_core/FilePath.hpp>\n+\n+#include <boost/optional.hpp>\n+#include <boost/shared_ptr.hpp>\n+#include <boost/variant.hpp>\n+\n+#define SOCI_USE_BOOST 1\n+#include <soci/soci.h>\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+struct SqliteConnectionOptions\n+{\n+   std::string file;\n+};\n+\n+struct PostgresqlConnectionOptions\n+{\n+   std::string database;\n+   std::string host;\n+   std::string port;\n+   std::string user;\n+   std::string password;\n+   int connectionTimeoutSeconds;\n+};\n+\n+typedef boost::variant<SqliteConnectionOptions, PostgresqlConnectionOptions> ConnectionOptions;\n+using InputParameter = soci::details::use_type_ptr;\n+using OutputParameter = soci::details::into_type_ptr;\n+\n+class Connection;\n+class ConnectionPool;\n+class Transaction;\n+\n+class Query\n+{\n+public:\n+   Query(const std::string& sqlStatement,\n+         soci::session& session);\n+\n+   template <typename T>\n+   Query& withInput(const T& val)\n+   {\n+      statement_.exchange(soci::use(val));\n+      return *this;\n+   }\n+\n+   template <typename T>\n+   Query& withInput(const T& val, const std::string& varName)\n+   {\n+      statement_.exchange(soci::use(val, varName));\n+      return *this;\n+   }\n+\n+   template <typename T>\n+   Query& withOutput(T& out)\n+   {\n+      statement_.exchange(soci::into(out));\n+      return *this;\n+   }\n+\n+   template <typename T>\n+   Query& withOutput(T& out, const std::string& varName)\n+   {\n+      statement_.exchange(soci::into(out, varName));\n+      return *this;\n+   }\n+\n+private:\n+   friend class Connection;\n+   friend class Rowset;\n+\n+   soci::statement statement_;\n+   boost::optional<soci::soci_error> prepareError_;\n+};\n+\n+using Row = soci::row;\n+using RowsetIterator = soci::rowset_iterator<Row>;\n+\n+class Rowset\n+{\n+public:\n+   RowsetIterator begin();\n+   RowsetIterator end();\n+\n+private:\n+   friend class Connection;\n+\n+   Row row_;\n+   boost::optional<Query&> query_;\n+};\n+\n+class IConnection\n+{\n+public:\n+   virtual Query query(const std::string& sqlStatement) = 0;\n+\n+   virtual Error execute(Query& query,\n+                         Rowset& rowset) = 0;\n+\n+   virtual Error execute(Query& query,\n+                         bool* pDataReturned = nullptr) = 0;\n+\n+   virtual Error executeStr(const std::string& queryStr) = 0;\n+\n+   virtual std::string driverName() const = 0;\n+\n+   virtual soci::session& session() = 0;\n+};\n+\n+class Connection : public IConnection\n+{\n+public:\n+   virtual ~Connection() {}\n+\n+   Query query(const std::string& sqlStatement) override;\n+\n+   Error execute(Query& query,\n+                 Rowset& rowset) override;\n+\n+   Error execute(Query& query,\n+                 bool* pDataReturned = nullptr) override;\n+\n+   Error executeStr(const std::string& queryStr) override;\n+\n+   std::string driverName() const override;\n+\n+   soci::session& session() override { return session_; }\n+\n+private:\n+   friend class ConnectVisitor;\n+   friend class Transaction;\n+\n+   // private constructor - use global connect function\n+   Connection(const soci::backend_factory& factory,\n+              const std::string& connectionStr);\n+\n+   soci::session session_;\n+};\n+\n+class PooledConnection : public IConnection\n+{\n+public:\n+   virtual ~PooledConnection();\n+\n+   Query query(const std::string& sqlStatement) override;\n+\n+   Error execute(Query& query,\n+                 Rowset& rowset) override;\n+\n+   Error execute(Query& query,\n+                 bool* pDataReturned = nullptr) override;\n+\n+   Error executeStr(const std::string& queryStr) override;\n+\n+   std::string driverName() const override;\n+\n+   soci::session& session() override { return connection_->session(); }\n+\n+private:\n+   friend class ConnectionPool;\n+\n+   // private constructor - get PooledConnection from ConnectionPool\n+   PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                    const boost::shared_ptr<Connection>& connection);\n+\n+   boost::shared_ptr<ConnectionPool> pool_;\n+   boost::shared_ptr<Connection> connection_;\n+};\n+\n+class ConnectionPool : public boost::enable_shared_from_this<ConnectionPool>\n+{\n+public:\n+   boost::shared_ptr<IConnection> getConnection();\n+\n+private:\n+   friend class PooledConnection;\n+   friend Error createConnectionPool(size_t poolSize,\n+                                     const ConnectionOptions& options,\n+                                     boost::shared_ptr<ConnectionPool>* pPool);\n+\n+   void returnConnection(const boost::shared_ptr<Connection>& connection);\n+\n+   thread::ThreadsafeQueue<boost::shared_ptr<Connection>> connections_;\n+};\n+\n+class Transaction\n+{\n+public:\n+   Transaction(const boost::shared_ptr<IConnection>& connection);\n+\n+   void commit();\n+   void rollback();\n+\n+   // when this class goes out of scope, the transaction\n+   // is automatically aborted if not previously committed\n+\n+private:\n+   boost::shared_ptr<IConnection> connection_;\n+   soci::transaction transaction_;\n+};\n+\n+static constexpr const char* SQLITE_DRIVER = \"sqlite3\";\n+static constexpr const char* POSTGRESQL_DRIVER = \"postgresql\";\n+\n+class SchemaUpdater\n+{\n+public:\n+   SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                 const FilePath& migrationsPath);\n+\n+   // updates the database schema to the highest version\n+   Error update();\n+\n+   // updates the database schema to the specified version\n+   Error updateToVersion(const std::string& maxVersion);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI4ODEwMg==", "bodyText": "Is it not possible to create the database on startup, if it doesn't exist?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387288102", "createdAt": "2020-03-03T20:55:54Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/extras/conf/database.conf", "diffHunk": "@@ -0,0 +1,32 @@\n+# This file contains database configuration.\n+#\n+# RStudio Server needs an external database for storage of specific configuration and runtime information.\n+#\n+# Simply uncomment the lines below and modify it to suit your needs.\n+# For more documentation, see the RStudio Server Pro Admin Guide.\n+#\n+#\n+# =========================================================================================================\n+# sqlite configuration\n+# =========================================================================================================\n+# Specifies the database provider to use\n+#provider=sqlite\n+# Directory in which the sqlite database will be written\n+#directory=/var/run/rstudio-server\n+# =========================================================================================================\n+# postgresql configuration\n+# =========================================================================================================\n+# Note: when connecting to a PostgreSQL database, a default empty rstudio database must first be created!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI5MjA0OA==", "bodyText": "Do you think it would be a good idea to update the diagnostics collection script to collect this file as part of this PR? I think we need to sanitize the password field whether or not it's commented out, as admins may edit the value to their real password and then later comment it out while they try to get things working.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387292048", "createdAt": "2020-03-03T21:03:36Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/extras/conf/database.conf", "diffHunk": "@@ -0,0 +1,32 @@\n+# This file contains database configuration.\n+#\n+# RStudio Server needs an external database for storage of specific configuration and runtime information.\n+#\n+# Simply uncomment the lines below and modify it to suit your needs.\n+# For more documentation, see the RStudio Server Pro Admin Guide.\n+#\n+#\n+# =========================================================================================================\n+# sqlite configuration\n+# =========================================================================================================\n+# Specifies the database provider to use\n+#provider=sqlite\n+# Directory in which the sqlite database will be written\n+#directory=/var/run/rstudio-server\n+# =========================================================================================================\n+# postgresql configuration\n+# =========================================================================================================\n+# Note: when connecting to a PostgreSQL database, a default empty rstudio database must first be created!\n+# Specifies the database provider to use\n+#provider=postgresql\n+# Specifies the host (hostname or IP address) of the database host\n+#host=localhost\n+# Specifies the TCP port where the database is listening for connections\n+#port=5432\n+# Specifies the database connection username\n+#username=postgres\n+# Specifies the database connection password\n+#password=postgres", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwNDc5NQ==", "bodyText": "When does this happen now? Is a DB required to run RSP after this change?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387304795", "createdAt": "2020-03-03T21:30:11Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/auth/ServerAuthHandler.cpp", "diffHunk": "@@ -93,39 +94,110 @@ void updateCredentialsNotSupported(\n    pConnection->writeResponse();\n }\n \n-bool isCookieRevoked(const std::string& cookie)\n+Error readRevocationListFromDatabase(std::vector<std::string>* pEntries)\n {\n-   boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n+   // establish a new transaction with the database\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   Transaction transaction(connection);\n+\n+   // first, delete all stale cookies from the database\n+   std::string expiration = date_time::format(boost::posix_time::microsec_clock::universal_time(),\n+                                              date_time::kIso8601Format);\n+   Query deleteQuery = connection->query(\"DELETE FROM RevokedCookie WHERE Expiration <= :val\")\n+         .withInput(expiration);\n+   Error error = connection->execute(deleteQuery);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not delete expired revoked cookies from the database\");\n+      return error;\n+   }\n+\n+   // get all cookie entries from the database\n+   Query fetchQuery = connection->query(\"SELECT CookieData FROM RevokedCookie\");\n+   Rowset rowset;\n+   error = connection->execute(fetchQuery, rowset);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not retrieve revoked cookies from the database\");\n+      return error;\n+   }\n+\n+   for (RowsetIterator it = rowset.begin(); it != rowset.end(); ++it)\n+   {\n+      Row& row = *it;\n+      pEntries->push_back(row.get<std::string>(0));\n+   }\n+\n+   transaction.commit();\n+   return Success();\n+}\n+\n+void removeStaleCookieFromDatabase(const RevokedCookie& cookie)\n+{\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   std::string expiration = date_time::format(cookie.expiration, date_time::kIso8601Format);\n+   Query query = connection->query(\"DELETE FROM RevokedCookie WHERE Expiration = :exp AND CookieData = :dat\")\n+         .withInput(expiration)\n+         .withInput(cookie.cookie);\n+\n+   Error error = connection->execute(query);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not delete expired revoked cookie from the database\");\n+      LOG_ERROR(error);\n+   }\n+}\n+\n+\n+Error writeRevokedCookieToDatabase(const RevokedCookie& cookie,\n+                                   boost::shared_ptr<IConnection> connection = boost::shared_ptr<IConnection>())\n+{\n+   std::string expiration = date_time::format(cookie.expiration, date_time::kIso8601Format);\n+\n+   // use existing connection if passed in, otherwise grab a new one\n+   if (!connection)\n+      connection = server_core::database::getConnection();\n+\n+   Query query = connection->query(\"INSERT INTO RevokedCookie VALUES (:exp, :dat)\")\n+         .withInput(expiration)\n+         .withInput(cookie.cookie);\n+\n+   Error error = connection->execute(query);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not insert revoked cookie into the database\");\n+      return error;\n+   }\n+\n+   return Success();\n+}\n+\n+Error writeRevokedCookiesToDatabase()\n+{\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   Transaction transaction(connection);\n \n    LOCK_MUTEX(s_mutex)\n    {\n-      // check for cookie in revocation list, deleting expired elements as we go\n-      for (auto it = s_revokedCookies.begin(); it != s_revokedCookies.end();)\n+      for (auto it = s_revokedCookies.begin(); it != s_revokedCookies.end(); ++it)\n       {\n-         const RevokedCookie& other = *it;\n-         if (other.cookie == cookie)\n-            return true;\n-\n-         if (other.expiration <= now)\n-         {\n-            it = s_revokedCookies.erase(it);\n-            continue;\n-         }\n-         else\n-         {\n-            ++it;\n-         }\n+         const RevokedCookie& cookie = *it;\n+         Error error = writeRevokedCookieToDatabase(cookie, connection);\n+         if (error)\n+            return error;\n       }\n    }\n    END_LOCK_MUTEX\n \n-   return false;\n+   transaction.commit();\n+   return Success();\n }\n \n-Error readRevocationList(std::vector<std::string>* pEntries)\n+Error readRevocationListFromFile(const FilePath& revocationList,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMwNzIyNA==", "bodyText": "Nit: there's no need to exit the first if and re-enter the second if as they have the same condition.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387307224", "createdAt": "2020-03-03T21:35:06Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/auth/ServerAuthHandler.cpp", "diffHunk": "@@ -444,98 +506,85 @@ Error initialize()\n {\n    // initialize by loading the current contents of the revocation list into memory\n \n-   // create revocation list directory and ensure the server user has permission to write to it\n+   // first, look for an existing file-based revocation list\n+   // RStudio versions prior to 1.4 wrote the list to a file, as database integration did not yet exist\n    FilePath rootDir = options().authRevocationListDir();\n-   Error error = rootDir.ensureDirectory();\n-   if (error)\n-   {\n-      error.addProperty(\"description\", \"Could not create revocation list directory \" + rootDir.getAbsolutePath());\n-      return error;\n-   }\n-\n-   core::system::User serverUser;\n-   if (core::system::effectiveUserIsRoot())\n-   {\n-      error = core::system::User::getUserFromIdentifier(options().serverUser(), serverUser);\n-      if (error)\n-      {\n-         error.addProperty(\"description\", \"Could not get server user details\");\n-         return error;\n-      }\n-\n-      error = rootDir.changeOwnership(serverUser);\n-      if (error)\n-      {\n-         error.addProperty(\"description\", \"Could not change ownership of revocation list directory \" + rootDir.getAbsolutePath());\n-         return error;\n-      }\n-   }\n-\n-   s_revocationList = rootDir.completeChildPath(\"revocation-list\");\n-   s_revocationLockFile = rootDir.completeChildPath(\"revocation-list.lock\");\n+   FilePath revocationList = rootDir.completeChildPath(\"revocation-list\");\n+   FilePath revocationLockFile = rootDir.completeChildPath(\"revocation-list.lock\");\n \n    // create a file lock to gain exclusive access to the revocation list\n    boost::shared_ptr<FileLock> lock = FileLock::createDefault();\n    int numTries = 0;\n \n+   bool lockAcquired = false;\n    while (numTries < 30)\n    {\n-      ScopedFileLock fileLock(lock, s_revocationLockFile);\n-      Error error = fileLock.error();\n-      if (error)\n+      // only attempt file locking if the revocation list exists\n+      // if it does not, then we have already previously migrated to the database\n+      if (revocationList.exists())\n       {\n-         // if we could not acquire the lock, some other rserver process has\n-         // keep trying for some time before giving up\n-         ++numTries;\n-         boost::this_thread::sleep(boost::posix_time::seconds(1));\n-         continue;\n+         Error error = lock->acquire(revocationLockFile);\n+         if (error)\n+         {\n+            // if we could not acquire the lock, some other rserver process has\n+            // keep trying for some time before giving up\n+            ++numTries;\n+            boost::this_thread::sleep(boost::posix_time::seconds(1));\n+            continue;\n+         }\n+\n+         lockAcquired = true;\n       }\n \n       // successfully acquired lock\n-      // create file if it does not exist\n-      error = s_revocationList.ensureFile();\n-      if (error)\n+      // migrate the revocation list file to the database if it exists\n+      if (revocationList.exists())\n       {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMTEwMQ==", "bodyText": "Would it be meaningfully more efficient to use multi-row insertion rather than inserting each individually? Also, do you think there'd be any efficiency gain by not inserting values which are already in the DB? Or is this method only called when the DB is empty?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387311101", "createdAt": "2020-03-03T21:42:48Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/auth/ServerAuthHandler.cpp", "diffHunk": "@@ -93,39 +94,110 @@ void updateCredentialsNotSupported(\n    pConnection->writeResponse();\n }\n \n-bool isCookieRevoked(const std::string& cookie)\n+Error readRevocationListFromDatabase(std::vector<std::string>* pEntries)\n {\n-   boost::posix_time::ptime now = boost::posix_time::second_clock::universal_time();\n+   // establish a new transaction with the database\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   Transaction transaction(connection);\n+\n+   // first, delete all stale cookies from the database\n+   std::string expiration = date_time::format(boost::posix_time::microsec_clock::universal_time(),\n+                                              date_time::kIso8601Format);\n+   Query deleteQuery = connection->query(\"DELETE FROM RevokedCookie WHERE Expiration <= :val\")\n+         .withInput(expiration);\n+   Error error = connection->execute(deleteQuery);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not delete expired revoked cookies from the database\");\n+      return error;\n+   }\n+\n+   // get all cookie entries from the database\n+   Query fetchQuery = connection->query(\"SELECT CookieData FROM RevokedCookie\");\n+   Rowset rowset;\n+   error = connection->execute(fetchQuery, rowset);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not retrieve revoked cookies from the database\");\n+      return error;\n+   }\n+\n+   for (RowsetIterator it = rowset.begin(); it != rowset.end(); ++it)\n+   {\n+      Row& row = *it;\n+      pEntries->push_back(row.get<std::string>(0));\n+   }\n+\n+   transaction.commit();\n+   return Success();\n+}\n+\n+void removeStaleCookieFromDatabase(const RevokedCookie& cookie)\n+{\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   std::string expiration = date_time::format(cookie.expiration, date_time::kIso8601Format);\n+   Query query = connection->query(\"DELETE FROM RevokedCookie WHERE Expiration = :exp AND CookieData = :dat\")\n+         .withInput(expiration)\n+         .withInput(cookie.cookie);\n+\n+   Error error = connection->execute(query);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not delete expired revoked cookie from the database\");\n+      LOG_ERROR(error);\n+   }\n+}\n+\n+\n+Error writeRevokedCookieToDatabase(const RevokedCookie& cookie,\n+                                   boost::shared_ptr<IConnection> connection = boost::shared_ptr<IConnection>())\n+{\n+   std::string expiration = date_time::format(cookie.expiration, date_time::kIso8601Format);\n+\n+   // use existing connection if passed in, otherwise grab a new one\n+   if (!connection)\n+      connection = server_core::database::getConnection();\n+\n+   Query query = connection->query(\"INSERT INTO RevokedCookie VALUES (:exp, :dat)\")\n+         .withInput(expiration)\n+         .withInput(cookie.cookie);\n+\n+   Error error = connection->execute(query);\n+   if (error)\n+   {\n+      error.addProperty(\"description\", \"Could not insert revoked cookie into the database\");\n+      return error;\n+   }\n+\n+   return Success();\n+}\n+\n+Error writeRevokedCookiesToDatabase()\n+{\n+   boost::shared_ptr<IConnection> connection = server_core::database::getConnection();\n+   Transaction transaction(connection);\n \n    LOCK_MUTEX(s_mutex)\n    {\n-      // check for cookie in revocation list, deleting expired elements as we go\n-      for (auto it = s_revokedCookies.begin(); it != s_revokedCookies.end();)\n+      for (auto it = s_revokedCookies.begin(); it != s_revokedCookies.end(); ++it)\n       {\n-         const RevokedCookie& other = *it;\n-         if (other.cookie == cookie)\n-            return true;\n-\n-         if (other.expiration <= now)\n-         {\n-            it = s_revokedCookies.erase(it);\n-            continue;\n-         }\n-         else\n-         {\n-            ++it;\n-         }\n+         const RevokedCookie& cookie = *it;\n+         Error error = writeRevokedCookieToDatabase(cookie, connection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDQ5Mw==", "bodyText": "Nit: Is it necessary to have both the expiration value and the cookie data to uniquely identify the revoked cookie, or would it suffice to just have the cookie data? I doubt it will come up though, since I don't think composite keys are really any more expensive than single-column primary keys (especially with only two columns), and it seems unlikely that we'll ever get two identical cookies with different expiration dates (assuming that's not something that we do on purpose).", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387314493", "createdAt": "2020-03-03T21:49:32Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/db/20200226141952248_AddRevokedCookie.sql", "diffHunk": "@@ -0,0 +1,5 @@\n+CREATE TABLE RevokedCookie(\n+   Expiration text NOT NULL,\n+   CookieData text NOT NULL,\n+   PRIMARY KEY (Expiration, CookieData)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNDkxNA==", "bodyText": "Could you add a comment to each SQL file to describe the purpose of the table and it's fields?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387314914", "createdAt": "2020-03-03T21:50:21Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/db/20200226141952248_AddRevokedCookie.sql", "diffHunk": "@@ -0,0 +1,5 @@\n+CREATE TABLE RevokedCookie(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxODU2Mw==", "bodyText": "Could this lead to a hang if we leak pooled connections anywhere? I suppose we probably won't leak a pooled connection, though, as they're always handed out using smart pointers.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387318563", "createdAt": "2020-03-03T21:57:38Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,638 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                              Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available\n+   boost::shared_ptr<Connection> connection;\n+   connections_.deque(&connection, boost::posix_time::pos_infin);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMDU2Nw==", "bodyText": "Do we ever initialize the server database without attempting to update the schema? If not, is the parameter there because we plan to in the future?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r387320567", "createdAt": "2020-03-03T22:01:37Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/ServerMain.cpp", "diffHunk": "@@ -622,6 +624,11 @@ int main(int argc, char * const argv[])\n       if (error)\n          return core::system::exitFailure(error, ERROR_LOCATION);\n \n+      // initialize database connectivity\n+      error = server_core::database::initialize(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9eeef71efcc2d0313246694bac62d2ac6ba7d34"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9fcf257e32a059f946f2072a6379b381079efdc", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/e9fcf257e32a059f946f2072a6379b381079efdc", "committedDate": "2020-03-03T22:51:24Z", "message": "Code review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d174a9c90eef4057fa6a1a9551e21fc0a159f1d", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/1d174a9c90eef4057fa6a1a9551e21fc0a159f1d", "committedDate": "2020-03-03T22:57:36Z", "message": "Code review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eef353b619055cb6b15b603f87ddd23d44bddb2a", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/eef353b619055cb6b15b603f87ddd23d44bddb2a", "committedDate": "2020-03-03T22:59:53Z", "message": "Code review feedback - remove redundant if statement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1faec5b4b791b2e6e3a5dec4f523db32c3a7ec0", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/f1faec5b4b791b2e6e3a5dec4f523db32c3a7ec0", "committedDate": "2020-03-03T23:00:22Z", "message": "Fix compile error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c357455a5bdf7a509d8978e34acd41057cc9561", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/2c357455a5bdf7a509d8978e34acd41057cc9561", "committedDate": "2020-03-03T23:04:28Z", "message": "Fix whitespace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ae86cc2d06e203d0ed524b495467492a83485f7", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/4ae86cc2d06e203d0ed524b495467492a83485f7", "committedDate": "2020-03-03T23:27:24Z", "message": "Quote current version table name to ensure that the casing is honored. Because we have to select from metadata tables to check for its existence, it is important that it has the correct casing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7f2a6293e5fae410c124986800c435b181ed445", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/a7f2a6293e5fae410c124986800c435b181ed445", "committedDate": "2020-03-04T16:37:28Z", "message": "Code review feedback - rework index on RevokedCookie table and add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc45ebcd8f1990f9c68f53eecd389f86b01df511", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/dc45ebcd8f1990f9c68f53eecd389f86b01df511", "committedDate": "2020-03-05T15:32:53Z", "message": "Code review feedback - introduce the timeout concept for grabbing a connection from the pool, and spit out errors for long periods of blocking time when no timeout is specified"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODc0OTY4", "url": "https://github.com/rstudio/rstudio/pull/6356#pullrequestreview-369874968", "createdAt": "2020-03-05T20:03:53Z", "commit": {"oid": "dc45ebcd8f1990f9c68f53eecd389f86b01df511"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDowMzo1M1rOFyiJZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxODoxMVrOFyimag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzMjU4MQ==", "bodyText": "We don't formally have a dependency on homebrew for dev machines, although in practice I think we all use it. I'm fine with introducing one, but make sure you also update the wikis if you do, and maybe add check here to see if homebrew is installed (so attempting to set up a machine w/o homebrew will give a more useful error).", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388532581", "createdAt": "2020-03-05T20:03:53Z", "author": {"login": "jmcphers"}, "path": "dependencies/osx/install-dependencies-osx", "diffHunk": "@@ -22,6 +22,9 @@ then\n   ./install-overlay\n fi\n \n+# install postgres, needed by SOCI\n+brew install postgres", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc45ebcd8f1990f9c68f53eecd389f86b01df511"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNTUzMg==", "bodyText": "Isn't this going to use character ordering (\"2\" > \"11\")?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388535532", "createdAt": "2020-03-05T20:10:05Z", "author": {"login": "jmcphers"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,665 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available, but log an error\n+   // if this takes a long time, because we want to ensure that if we are in a hang\n+   // condition (i.e. threads are not properly returning connections to the pool) we\n+   // let the users/developers know that something is fishy\n+   boost::shared_ptr<Connection> connection;\n+   while (true)\n+   {\n+      if (connections_.deque(&connection, boost::posix_time::seconds(30)))\n+      {\n+         // create wrapper PooledConnection around retrieved Connection\n+         return boost::shared_ptr<IConnection>(new PooledConnection(shared_from_this(), connection));\n+      }\n+      else\n+      {\n+         LOG_ERROR_MESSAGE(\"Potential hang detected: could not get database connection from pool \"\n+                           \"after 30 seconds. If issue persists, please notify RStudio Support\");\n+      }\n+   }\n+}\n+\n+bool ConnectionPool::getConnection(boost::shared_ptr<IConnection>* pConnection,\n+                                   const boost::posix_time::time_duration& maxWait)\n+{\n+   boost::shared_ptr<Connection> connection;\n+   if (!connections_.deque(&connection, maxWait))\n+      return false;\n+\n+   pConnection->reset(new PooledConnection(shared_from_this(), connection));\n+   return true;\n+}\n+\n+void ConnectionPool::returnConnection(const boost::shared_ptr<Connection>& connection)\n+{\n+   connections_.enque(connection);\n+}\n+\n+Transaction::Transaction(const boost::shared_ptr<IConnection>& connection) :\n+   connection_(connection),\n+   transaction_(connection->session())\n+{\n+}\n+\n+void Transaction::commit()\n+{\n+   transaction_.commit();\n+}\n+\n+void Transaction::rollback()\n+{\n+   transaction_.rollback();\n+}\n+\n+SchemaUpdater::SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                             const FilePath& migrationsPath) :\n+   connection_(connection),\n+   migrationsPath_(migrationsPath)\n+{\n+}\n+\n+Error SchemaUpdater::migrationFiles(std::vector<FilePath>* pMigrationFiles)\n+{\n+   std::vector<FilePath> children;\n+   Error error = migrationsPath_.getChildren(children);\n+   if (error)\n+      return error;\n+\n+   for (const FilePath& file : children)\n+   {\n+      std::string extension = file.getExtensionLowerCase();\n+      if (extension == SQL_EXTENSION ||\n+          extension == SQLITE_EXTENSION ||\n+          extension == POSTGRESQL_EXTENSION)\n+      {\n+         pMigrationFiles->push_back(file);\n+      }\n+   }\n+\n+   return Success();\n+}\n+\n+Error SchemaUpdater::highestMigrationVersion(std::string* pVersion)\n+{\n+   std::vector<FilePath> files;\n+   Error error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   if (files.empty())\n+   {\n+      // no migration files - we do not consider this an error, but instead\n+      // simply consider that this database cannot be migrated past version 0\n+      *pVersion = \"0\";\n+      return Success();\n+   }\n+\n+   // sort descending - highest version filename wins\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() > b.getStem();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc45ebcd8f1990f9c68f53eecd389f86b01df511"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjAxMw==", "bodyText": "As above re: string comparison of versions.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388536013", "createdAt": "2020-03-05T20:11:05Z", "author": {"login": "jmcphers"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,665 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available, but log an error\n+   // if this takes a long time, because we want to ensure that if we are in a hang\n+   // condition (i.e. threads are not properly returning connections to the pool) we\n+   // let the users/developers know that something is fishy\n+   boost::shared_ptr<Connection> connection;\n+   while (true)\n+   {\n+      if (connections_.deque(&connection, boost::posix_time::seconds(30)))\n+      {\n+         // create wrapper PooledConnection around retrieved Connection\n+         return boost::shared_ptr<IConnection>(new PooledConnection(shared_from_this(), connection));\n+      }\n+      else\n+      {\n+         LOG_ERROR_MESSAGE(\"Potential hang detected: could not get database connection from pool \"\n+                           \"after 30 seconds. If issue persists, please notify RStudio Support\");\n+      }\n+   }\n+}\n+\n+bool ConnectionPool::getConnection(boost::shared_ptr<IConnection>* pConnection,\n+                                   const boost::posix_time::time_duration& maxWait)\n+{\n+   boost::shared_ptr<Connection> connection;\n+   if (!connections_.deque(&connection, maxWait))\n+      return false;\n+\n+   pConnection->reset(new PooledConnection(shared_from_this(), connection));\n+   return true;\n+}\n+\n+void ConnectionPool::returnConnection(const boost::shared_ptr<Connection>& connection)\n+{\n+   connections_.enque(connection);\n+}\n+\n+Transaction::Transaction(const boost::shared_ptr<IConnection>& connection) :\n+   connection_(connection),\n+   transaction_(connection->session())\n+{\n+}\n+\n+void Transaction::commit()\n+{\n+   transaction_.commit();\n+}\n+\n+void Transaction::rollback()\n+{\n+   transaction_.rollback();\n+}\n+\n+SchemaUpdater::SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                             const FilePath& migrationsPath) :\n+   connection_(connection),\n+   migrationsPath_(migrationsPath)\n+{\n+}\n+\n+Error SchemaUpdater::migrationFiles(std::vector<FilePath>* pMigrationFiles)\n+{\n+   std::vector<FilePath> children;\n+   Error error = migrationsPath_.getChildren(children);\n+   if (error)\n+      return error;\n+\n+   for (const FilePath& file : children)\n+   {\n+      std::string extension = file.getExtensionLowerCase();\n+      if (extension == SQL_EXTENSION ||\n+          extension == SQLITE_EXTENSION ||\n+          extension == POSTGRESQL_EXTENSION)\n+      {\n+         pMigrationFiles->push_back(file);\n+      }\n+   }\n+\n+   return Success();\n+}\n+\n+Error SchemaUpdater::highestMigrationVersion(std::string* pVersion)\n+{\n+   std::vector<FilePath> files;\n+   Error error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   if (files.empty())\n+   {\n+      // no migration files - we do not consider this an error, but instead\n+      // simply consider that this database cannot be migrated past version 0\n+      *pVersion = \"0\";\n+      return Success();\n+   }\n+\n+   // sort descending - highest version filename wins\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() > b.getStem();\n+   };\n+   std::sort(files.begin(), files.end(), comparator);\n+\n+   *pVersion = files.at(0).getStem();\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isSchemaVersionPresent(bool* pIsPresent)\n+{\n+   std::string queryStr;\n+   if (connection_->driverName() == SQLITE_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM sqlite_master WHERE type='table' AND name='\") + SCHEMA_TABLE + \"'\";\n+   }\n+   else if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      queryStr = std::string(\"SELECT COUNT(1) FROM information_schema.tables WHERE table_name='\") + SCHEMA_TABLE +\n+                 \"' AND table_schema = current_schema\";\n+   }\n+   else\n+   {\n+      return DatabaseError(soci::soci_error(\"Unsupported database driver\"));\n+   }\n+\n+   int count = 0;\n+   Query query = connection_->query(queryStr)\n+         .withOutput(count);\n+   Error error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pIsPresent = count > 0;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::databaseSchemaVersion(std::string* pVersion)\n+{\n+   bool versionPresent = false;\n+   Error error = isSchemaVersionPresent(&versionPresent);\n+   if (error)\n+      return error;\n+\n+   std::string currentSchemaVersion = \"0\";\n+   if (!versionPresent)\n+   {\n+      // no schema version present - add the table to the database so it is available\n+      // for updating whenever migrations occur\n+      error = connection_->executeStr(std::string(\"CREATE TABLE \\\"\") + SCHEMA_TABLE + \"\\\" (CurrentVersion text)\");\n+      if (error)\n+         return error;\n+\n+      Query query = connection_->query(std::string(\"INSERT INTO \\\"\") + SCHEMA_TABLE + \"\\\" VALUES (:val)\")\n+            .withInput(currentSchemaVersion);\n+      error = connection_->execute(query);\n+      if (error)\n+         return error;\n+\n+      *pVersion = currentSchemaVersion;\n+      return Success();\n+   }\n+\n+   Query query = connection_->query(std::string(\"SELECT CurrentVersion FROM \\\"\") + SCHEMA_TABLE + \"\\\"\")\n+         .withOutput(currentSchemaVersion);\n+\n+   error = connection_->execute(query);\n+   if (error)\n+      return error;\n+\n+   *pVersion = currentSchemaVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::isUpToDate(bool* pUpToDate)\n+{\n+   std::string version;\n+   Error error = databaseSchemaVersion(&version);\n+   if (error)\n+      return error;\n+\n+   std::string migrationVersion;\n+   error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   *pUpToDate = version >= migrationVersion;\n+   return Success();\n+}\n+\n+Error SchemaUpdater::update()\n+{\n+   std::string migrationVersion;\n+   Error error = highestMigrationVersion(&migrationVersion);\n+   if (error)\n+      return error;\n+\n+   std::string currentVersion;\n+   error = databaseSchemaVersion(&currentVersion);\n+   if (currentVersion < migrationVersion)\n+      return updateToVersion(migrationVersion);\n+   else\n+      return Success();\n+}\n+\n+Error SchemaUpdater::updateToVersion(const std::string& maxVersion)\n+{\n+   // create a transaction to perform the following steps:\n+   // 1. Check the current database schema version\n+   // 2. Check if we need to update\n+   // 3. Update (if necessary)\n+   // 4. Save new database schema version\n+   // performing this in a transaction ensures that we rollback if anything\n+   // fails, and also ensures that other nodes cannot update concurrently\n+   Transaction transaction(connection_);\n+\n+   // for postgresql, specifically lock the version table in exclusive mode\n+   // to ensure that no other connection can use the version table AT ALL\n+   // during this schema update\n+   if (connection_->driverName() == POSTGRESQL_DRIVER)\n+   {\n+      Query query = connection_->query(std::string(\"LOCK \\\"\") + SCHEMA_TABLE + \"\\\" IN ACCESS EXCLUSIVE MODE\");\n+      Error error = connection_->execute(query);\n+      if (error)\n+         return error;\n+   }\n+\n+   std::string currentVersion;\n+   Error error = databaseSchemaVersion(&currentVersion);\n+   if (error)\n+      return error;\n+\n+   if (currentVersion >= maxVersion)\n+      return Success();\n+\n+   std::vector<FilePath> files;\n+   error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   // sort ascending\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() < b.getStem();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc45ebcd8f1990f9c68f53eecd389f86b01df511"}, "originalPosition": 573}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNzY4MQ==", "bodyText": "Can we add a README to this parent folder that explains how to name files and perform schema upgrades for devs?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388537681", "createdAt": "2020-03-05T20:13:49Z", "author": {"login": "jmcphers"}, "path": "src/cpp/server/db/20200226141952248_AddRevokedCookie.sql", "diffHunk": "@@ -0,0 +1,19 @@\n+/* Stores revoked auth cookies - cookies that are not yet expired, but", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc45ebcd8f1990f9c68f53eecd389f86b01df511"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MDAxMA==", "bodyText": "Upon further review I see that the filenames are formatted by convention so that character ordering is sufficient. I think we might make this clearer by using an \"initial version\" that looks like the incremental additional versions, and/or adding some docs stating explicitly how to format the filenames so this constraint is maintained.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388540010", "createdAt": "2020-03-05T20:18:11Z", "author": {"login": "jmcphers"}, "path": "src/cpp/core/Database.cpp", "diffHunk": "@@ -0,0 +1,665 @@\n+/*\n+ * Database.cpp\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+#include <core/Database.hpp>\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/format.hpp>\n+#include <boost/regex.hpp>\n+\n+#include <core/FileSerializer.hpp>\n+#include <shared_core/Error.hpp>\n+#include <shared_core/SafeConvert.hpp>\n+\n+#include <soci/row-exchange.h>\n+#include <soci/postgresql/soci-postgresql.h>\n+#include <soci/sqlite3/soci-sqlite3.h>\n+\n+// Database Boost Errors\n+// Declare soci errors as boost errors.\n+// =================================================================================================================\n+namespace RSTUDIO_BOOST_NAMESPACE {\n+namespace system {\n+\n+template <>\n+struct is_error_code_enum<soci::soci_error::error_category>\n+{\n+   static const bool value = true;\n+};\n+\n+} // namespace system\n+} // namespace boost\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+   const boost::system::error_category& databaseErrorCategory();\n+}\n+}\n+}\n+\n+namespace soci {\n+\n+inline boost::system::error_code make_error_code(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+inline boost::system::error_condition make_error_condition(soci::soci_error::error_category e)\n+{\n+   return { e, rstudio::core::database::databaseErrorCategory() };\n+}\n+\n+}\n+\n+namespace rstudio {\n+namespace core {\n+namespace database {\n+\n+class DatabaseErrorCategory : public boost::system::error_category\n+{\n+public:\n+   const char* name() const BOOST_NOEXCEPT override;\n+\n+   std::string message(int ev) const override;\n+};\n+\n+const boost::system::error_category& databaseErrorCategory()\n+{\n+   static DatabaseErrorCategory databaseErrorCategoryConst;\n+   return databaseErrorCategoryConst;\n+}\n+\n+const char* DatabaseErrorCategory::name() const BOOST_NOEXCEPT\n+{\n+   return \"database\";\n+}\n+\n+std::string DatabaseErrorCategory::message(int ev) const\n+{\n+   switch (ev)\n+   {\n+      case soci::soci_error::error_category::connection_error:\n+         return \"Connection Error\";\n+      case soci::soci_error::error_category::invalid_statement:\n+         return \"Invalid Statement\";\n+      case soci::soci_error::error_category::no_privilege:\n+         return \"No Privilege\";\n+      case soci::soci_error::error_category::no_data:\n+         return \"No Data\";\n+      case soci::soci_error::error_category::constraint_violation:\n+         return \"Constraint Violation\";\n+      case soci::soci_error::error_category::unknown_transaction_state:\n+         return \"Unknown Transaction State\";\n+      case soci::soci_error::error_category::system_error:\n+         return \"System Error\";\n+      case soci::soci_error::error_category::unknown:\n+      default:\n+         return \"Unknown Error\";\n+   }\n+}\n+\n+#define DatabaseError(sociError) Error(sociError.get_error_category(), sociError.get_error_message(), ERROR_LOCATION);\n+\n+// Database errors =================================================================================================\n+\n+class ConnectVisitor : public boost::static_visitor<Error>\n+{\n+public:\n+   ConnectVisitor(boost::shared_ptr<IConnection>* pPtrConnection) :\n+      pPtrConnection_(pPtrConnection)\n+   {\n+   }\n+\n+   Error operator()(const SqliteConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::sqlite3, \"dbname=\\\"\" + options.file + \"\\\"\"));\n+\n+         // foreign keys must explicitly be enabled for sqlite\n+         Error error = pConnection->executeStr(\"PRAGMA foreign_keys = ON;\");\n+         if (error)\n+            return error;\n+\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+   Error operator()(const PostgresqlConnectionOptions& options) const\n+   {\n+      try\n+      {\n+         boost::format fmt(\"host='%1%' port='%2%' dbname='%3%' user='%4%' password='%5%' connect_timeout='%6%'\");\n+         std::string connectionStr =\n+               boost::str(fmt %\n+                          options.host %\n+                          options.port %\n+                          options.database %\n+                          options.user %\n+                          options.password %\n+                          safe_convert::numberToString(options.connectionTimeoutSeconds, \"0\"));\n+\n+         boost::shared_ptr<IConnection> pConnection(new Connection(soci::postgresql, connectionStr));\n+         *pPtrConnection_ = pConnection;\n+         return Success();\n+      }\n+      catch (soci::soci_error& error)\n+      {\n+         return DatabaseError(error);\n+      }\n+   }\n+\n+private:\n+   boost::shared_ptr<IConnection>* pPtrConnection_;\n+};\n+\n+Query::Query(const std::string& sqlStatement,\n+             soci::session& session) :\n+   statement_(session)\n+{\n+   // it's possible that prepare can throw a database exception, but we\n+   // do not want to surface errors until execute() is called\n+   try\n+   {\n+      statement_.alloc();\n+      statement_.prepare(sqlStatement);\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      prepareError_ = error;\n+   }\n+}\n+\n+RowsetIterator Rowset::begin()\n+{\n+   if (query_)\n+      return RowsetIterator(query_.get().statement_, row_);\n+\n+   return end();\n+}\n+\n+RowsetIterator Rowset::end()\n+{\n+   return RowsetIterator();\n+}\n+\n+Connection::Connection(const soci::backend_factory& factory,\n+                       const std::string& connectionStr) :\n+   session_(factory, connectionStr)\n+{\n+}\n+\n+Query Connection::query(const std::string& sqlStatement)\n+{\n+   return Query(sqlStatement, session_);\n+}\n+\n+Error Connection::execute(Query& query,\n+                          bool* pDataReturned)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      bool result = query.statement_.execute(true);\n+\n+      if (pDataReturned)\n+         *pDataReturned = result;\n+\n+      query.statement_.bind_clean_up();\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::execute(Query& query,\n+                          Rowset& rowset)\n+{\n+   if (query.prepareError_)\n+      return DatabaseError(query.prepareError_.get());\n+\n+   try\n+   {\n+      query.statement_.define_and_bind();\n+      query.statement_.exchange_for_rowset(soci::into(rowset.row_));\n+      query.statement_.execute(false);\n+\n+      rowset.query_ = query;\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+Error Connection::executeStr(const std::string& queryStr)\n+{\n+   try\n+   {\n+      // SOCI backends do not necessarily support running multiple statements\n+      // in one invocation - to work around this, we split any passed in SQL\n+      // into one invocation per SQL statement (delimited by ;)\n+      std::vector<std::string> queries;\n+      boost::regex regex(\";[ \\\\t\\\\r\\\\f\\\\v]*\\\\n\");\n+      std::string queryStrCopy = queryStr;\n+      boost::regex_split(std::back_inserter(queries), queryStrCopy, regex);\n+      for (std::string& query : queries)\n+      {\n+         query = string_utils::trimWhitespace(query);\n+         if (!query.empty())\n+            session_ << query;\n+      }\n+\n+      return Success();\n+   }\n+   catch (soci::soci_error& error)\n+   {\n+      return DatabaseError(error);\n+   }\n+}\n+\n+std::string Connection::driverName() const\n+{\n+   return session_.get_backend_name();\n+}\n+\n+PooledConnection::PooledConnection(const boost::shared_ptr<ConnectionPool>& pool,\n+                                   const boost::shared_ptr<Connection>& connection) :\n+   pool_(pool),\n+   connection_(connection)\n+{\n+}\n+\n+PooledConnection::~PooledConnection()\n+{\n+   pool_->returnConnection(connection_);\n+}\n+\n+Query PooledConnection::query(const std::string& sqlStatement)\n+{\n+   return connection_->query(sqlStatement);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                Rowset& rowset)\n+{\n+   return connection_->execute(query, rowset);\n+}\n+\n+Error PooledConnection::execute(Query& query,\n+                                bool* pDataReturned)\n+{\n+   return connection_->execute(query, pDataReturned);\n+}\n+\n+Error PooledConnection::executeStr(const std::string& queryStr)\n+{\n+   return connection_->executeStr(queryStr);\n+}\n+\n+std::string PooledConnection::driverName() const\n+{\n+   return connection_->driverName();\n+}\n+\n+boost::shared_ptr<IConnection> ConnectionPool::getConnection()\n+{\n+   // block until a connection is available, but log an error\n+   // if this takes a long time, because we want to ensure that if we are in a hang\n+   // condition (i.e. threads are not properly returning connections to the pool) we\n+   // let the users/developers know that something is fishy\n+   boost::shared_ptr<Connection> connection;\n+   while (true)\n+   {\n+      if (connections_.deque(&connection, boost::posix_time::seconds(30)))\n+      {\n+         // create wrapper PooledConnection around retrieved Connection\n+         return boost::shared_ptr<IConnection>(new PooledConnection(shared_from_this(), connection));\n+      }\n+      else\n+      {\n+         LOG_ERROR_MESSAGE(\"Potential hang detected: could not get database connection from pool \"\n+                           \"after 30 seconds. If issue persists, please notify RStudio Support\");\n+      }\n+   }\n+}\n+\n+bool ConnectionPool::getConnection(boost::shared_ptr<IConnection>* pConnection,\n+                                   const boost::posix_time::time_duration& maxWait)\n+{\n+   boost::shared_ptr<Connection> connection;\n+   if (!connections_.deque(&connection, maxWait))\n+      return false;\n+\n+   pConnection->reset(new PooledConnection(shared_from_this(), connection));\n+   return true;\n+}\n+\n+void ConnectionPool::returnConnection(const boost::shared_ptr<Connection>& connection)\n+{\n+   connections_.enque(connection);\n+}\n+\n+Transaction::Transaction(const boost::shared_ptr<IConnection>& connection) :\n+   connection_(connection),\n+   transaction_(connection->session())\n+{\n+}\n+\n+void Transaction::commit()\n+{\n+   transaction_.commit();\n+}\n+\n+void Transaction::rollback()\n+{\n+   transaction_.rollback();\n+}\n+\n+SchemaUpdater::SchemaUpdater(const boost::shared_ptr<IConnection>& connection,\n+                             const FilePath& migrationsPath) :\n+   connection_(connection),\n+   migrationsPath_(migrationsPath)\n+{\n+}\n+\n+Error SchemaUpdater::migrationFiles(std::vector<FilePath>* pMigrationFiles)\n+{\n+   std::vector<FilePath> children;\n+   Error error = migrationsPath_.getChildren(children);\n+   if (error)\n+      return error;\n+\n+   for (const FilePath& file : children)\n+   {\n+      std::string extension = file.getExtensionLowerCase();\n+      if (extension == SQL_EXTENSION ||\n+          extension == SQLITE_EXTENSION ||\n+          extension == POSTGRESQL_EXTENSION)\n+      {\n+         pMigrationFiles->push_back(file);\n+      }\n+   }\n+\n+   return Success();\n+}\n+\n+Error SchemaUpdater::highestMigrationVersion(std::string* pVersion)\n+{\n+   std::vector<FilePath> files;\n+   Error error = migrationFiles(&files);\n+   if (error)\n+      return error;\n+\n+   if (files.empty())\n+   {\n+      // no migration files - we do not consider this an error, but instead\n+      // simply consider that this database cannot be migrated past version 0\n+      *pVersion = \"0\";\n+      return Success();\n+   }\n+\n+   // sort descending - highest version filename wins\n+   auto comparator = [](const FilePath& a, const FilePath& b)\n+   {\n+      return a.getStem() > b.getStem();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNTUzMg=="}, "originalCommit": {"oid": "dc45ebcd8f1990f9c68f53eecd389f86b01df511"}, "originalPosition": 431}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dbc43f186e42197fbe2a085f87515ed57046b4a", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/0dbc43f186e42197fbe2a085f87515ed57046b4a", "committedDate": "2020-03-05T22:09:58Z", "message": "Code review feedback - make script to generate schema files and add readme"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "144891e8e9739ef94d229418c7cb1706b994a80c", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/144891e8e9739ef94d229418c7cb1706b994a80c", "committedDate": "2020-03-05T22:13:52Z", "message": "Script early exit for bad invocation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c08b6314bfa74a120e79cc0731c6b33918b6d96f", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/c08b6314bfa74a120e79cc0731c6b33918b6d96f", "committedDate": "2020-03-05T22:18:05Z", "message": "Spell out that homebrew is required for osx depdencies script"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTkwMDQx", "url": "https://github.com/rstudio/rstudio/pull/6356#pullrequestreview-369990041", "createdAt": "2020-03-05T23:42:26Z", "commit": {"oid": "c08b6314bfa74a120e79cc0731c6b33918b6d96f"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzo0MjoyN1rOFyoDBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzo0ODowN1rOFyoJKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyOTI1NQ==", "bodyText": "Nit: I think we normally put output parameters last.", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388629255", "createdAt": "2020-03-05T23:42:27Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/core/include/core/Database.hpp", "diffHunk": "@@ -192,8 +192,15 @@ class PooledConnection : public IConnection\n class ConnectionPool : public boost::enable_shared_from_this<ConnectionPool>\n {\n public:\n+   // get a connection from the connection pool, blocking until one becomes available\n    boost::shared_ptr<IConnection> getConnection();\n \n+   // get a connection from the connection pool, waiting for at most maxWait for one\n+   // to become available. if no connection becomes available, false is returned and\n+   // the connection is empty, otherwise the connection is set and true is returned\n+   bool getConnection(boost::shared_ptr<IConnection>* pConnection,\n+                      const boost::posix_time::time_duration& maxWait);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c08b6314bfa74a120e79cc0731c6b33918b6d96f"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDM1Ng==", "bodyText": "Nit: Is it necessary to have such a detailed timestamp? Are we likely to publish multiple versions of the same table that differ only by microseconds (or even hours)?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388630356", "createdAt": "2020-03-05T23:46:22Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/db/README.md", "diffHunk": "@@ -0,0 +1,23 @@\n+## Server Database Schemas\n+\n+This folder contains the database schemas for the RStudio Server database. These schemas are copied to the build output directory, and are applied to the database every time `rserver` is started.\n+\n+Schema files rely on a file format convention containing the following:\n+* The date time at which the script was generated in the format YYYYMMDDHHmmssuuu (where uuu is microseconds)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c08b6314bfa74a120e79cc0731c6b33918b6d96f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDgyNg==", "bodyText": "Out of curiosity, what happens when there is a .sql and a .sqlite/.postgresql file for the same table? Is the most specific file type run?", "url": "https://github.com/rstudio/rstudio/pull/6356#discussion_r388630826", "createdAt": "2020-03-05T23:48:07Z", "author": {"login": "MariaSemple"}, "path": "src/cpp/server/db/README.md", "diffHunk": "@@ -0,0 +1,23 @@\n+## Server Database Schemas\n+\n+This folder contains the database schemas for the RStudio Server database. These schemas are copied to the build output directory, and are applied to the database every time `rserver` is started.\n+\n+Schema files rely on a file format convention containing the following:\n+* The date time at which the script was generated in the format YYYYMMDDHHmmssuuu (where uuu is microseconds)\n+* An underscore separating the date time from the friendly name\n+* A friendly name for what the script does\n+* A file extension, which can be `.sql`, `.sqlite`, or `.postgresql`. `.sql` files will be run for any database type, but the other two extensions are reserved for only running if the database in use corresponds to that file extension.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c08b6314bfa74a120e79cc0731c6b33918b6d96f"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74c563ac6606e522fed8b91b4ce7b8935ed6b33a", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/74c563ac6606e522fed8b91b4ce7b8935ed6b33a", "committedDate": "2020-03-06T13:35:09Z", "message": "Update README"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5b55894f9b72752c0274b0f802be4525c974bd6", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/d5b55894f9b72752c0274b0f802be4525c974bd6", "committedDate": "2020-03-06T13:36:27Z", "message": "Merge branch 'feature/database' of https://github.com/rstudio/rstudio into feature/database"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "693a30623b58c40b31e3dc027f987b4e71d6f360", "author": {"user": {"login": "kfeinauer", "name": "Karl Feinauer"}}, "url": "https://github.com/rstudio/rstudio/commit/693a30623b58c40b31e3dc027f987b4e71d6f360", "committedDate": "2020-03-06T13:40:58Z", "message": "Code review feedback - change parameter order"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 277, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}