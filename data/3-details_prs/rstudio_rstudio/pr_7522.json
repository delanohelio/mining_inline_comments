{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNzU4MDA1", "number": 7522, "title": "priority task queue for initializing visual editor contents", "bodyText": "This PR attempts to mitigate some of the expensive startup cost incurred per IDE tab that has an activated visual editor.\nFor each visual editor tab to initialize, a number of things need to occur:\n\nInitialize the visual editor\nCall the server to render pandoc markdown into the pandoc AST (this involves 3 calls to pandoc, all fast/cheap but it is 3 process launches)\nRender the pandoc AST into the visual editor\nInitialize embedded Ace editor instances (this is currently done on a queue that prioritizes currently visible editors)\n\nAll of these operations are asynchronous (except the first) so don't in principle \"block\" use of the IDE. In practice though they are tying up cycles on the server (using multiple cores) and the client (using the single core dedicated to the UI thread), making the IDE pretty unresponsive (delay when typing, etc.) as long as visual editors are being initialized.\nMy current benchmark is the Mastering Shiny book. I load up visual editor instances for all 29 chapters of the book, then reload the IDE. On my new MacBook Pro it takes ~18 seconds for the active editor tab to load and become responsive. I think this is borderline tolerable but far from ideal. Note that 4.5 seconds of this time is for core IDE startup (i.e. that's how long it takes to load if all 29 chapters are in source mode). For comparison, loading the same project w/ no tabs takes 0.5 seconds. So a perfect optimization of the visual editor startup cost would get us to no better than 4.5 seconds.\nI've previously evaluated ways to only enter the initialization sequence for a visual editor (steps 1-4 above) when it's actually an activated tab. Unfortunately the IDE doesn't have unambiguous semantics for this (since during the loading of the source pane all of the tabs become \"active\" as they are replayed back into the pane). I've attempted to engineer a logical state for this a few times but it gets very complicated and even unreliable (I've had times where an editor tab flat out never loads b/c we don't detect the activated state correctly). It's also very tricky to manage the variation between \"logical\" activation state (visual mode enabled for a tab) and \"physical\" activation state (visual editor actually loaded and ready to rock).\nThis PR takes a more conservative approach, essentially allowing all of the visual editor tabs to perform step 1 (basic initialization) and then placing the more expensive steps 2-4 on a priority task queue (where priority is dynamically granted to the active editor tab). This yields startup performance of ~ 9 seconds (compared to ~18 for the current behavior). Note that 4.5 of these seconds are unavoidable (happen w/ 29 source mode tabs) so even w/ more aggressive/risky optimization schemes we can't improve that much more before we hit the baseline.\nNote that after the active tab becomes available for editing, the other non active tabs are loading in the background. The background loading takes ~30 seconds (I think b/c we don't take advantage of server parallelism on pandoc calls) but this seems \"free\" to me b/c if the user activates one of the background tabs it's brought immediately to the front of the queue.\nSo we've essentially traded down on total initialization time but halved the time required for the editor/IDE to be available for interaction.\n@jmcphers If you could review the PriorityTaskQueue for correctness that would be great. Also interested in your take on whether we should do more to try to bring down startup cost or if we are happy with where this PR gets us to .", "createdAt": "2020-08-04T13:12:08Z", "url": "https://github.com/rstudio/rstudio/pull/7522", "merged": true, "mergeCommit": {"oid": "082b95f73ef78b81256f5d2db80380b2656ba52d"}, "closed": true, "closedAt": "2020-08-06T00:20:52Z", "author": {"login": "jjallaire"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7l8m1AH2gAyNDYyNzU4MDA1Ojk0NWI5YWFhODMzZmYxMDc0NDM1YTRiOTkzYTRkNThiYmJiMWEwZDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8EiuKgH2gAyNDYyNzU4MDA1OmE5YzA4MDgxM2MzMDEwOWVhMTcyZTY0NWE1ZDg5MGE4YjZjMTE5ZTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "945b9aaa833ff1074435a4b993a4d58bbbb1a0d6", "author": {"user": {"login": "jjallaire", "name": "J.J. Allaire"}}, "url": "https://github.com/rstudio/rstudio/commit/945b9aaa833ff1074435a4b993a4d58bbbb1a0d6", "committedDate": "2020-08-04T12:40:18Z", "message": "priority task queue for initializing visual editor contents"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMDg2MTk4", "url": "https://github.com/rstudio/rstudio/pull/7522#pullrequestreview-462086198", "createdAt": "2020-08-05T23:17:28Z", "commit": {"oid": "945b9aaa833ff1074435a4b993a4d58bbbb1a0d6"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMzoxNzoyOFrOG8dx_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMzoyMDo1MVrOG8d2Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NTY3Ng==", "bodyText": "For nomenclature I'd suggest a different name for this class since a \"priority queue\" is a well known data structure but doesn't have much in common with what's done here. Maybe PreemptiveTaskQueue since the active document can preempt the other queued tasks?", "url": "https://github.com/rstudio/rstudio/pull/7522#discussion_r466055676", "createdAt": "2020-08-05T23:17:28Z", "author": {"login": "jmcphers"}, "path": "src/gwt/src/org/rstudio/core/client/PriorityTaskQueue.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * PriorityTaskQueue.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+\n+package org.rstudio.core.client;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import com.google.gwt.user.client.Command;\n+\n+// Task queue that allows tasks to bump themselves up in priority (even after\n+// they have been added to the queue).\n+\n+public class PriorityTaskQueue", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "945b9aaa833ff1074435a4b993a4d58bbbb1a0d6"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjcxOQ==", "bodyText": "If the intent here (and elsewhere) is to handle a lot of expensive work, should we defer the processing of the next task so that the browser event loop has a chance to run between tasks?", "url": "https://github.com/rstudio/rstudio/pull/7522#discussion_r466056719", "createdAt": "2020-08-05T23:20:51Z", "author": {"login": "jmcphers"}, "path": "src/gwt/src/org/rstudio/core/client/PriorityTaskQueue.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * PriorityTaskQueue.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+\n+\n+package org.rstudio.core.client;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import com.google.gwt.user.client.Command;\n+\n+// Task queue that allows tasks to bump themselves up in priority (even after\n+// they have been added to the queue).\n+\n+public class PriorityTaskQueue\n+{\n+   public interface Task\n+   {\n+      String getLabel(); // used for debug/log output \n+      boolean hasPriority();\n+      void execute(Command done);\n+   }\n+   \n+   public PriorityTaskQueue()\n+   {\n+      this(true, false);\n+   }\n+   \n+   public PriorityTaskQueue(boolean safe)\n+   {\n+      this(safe, false);\n+   }\n+   \n+   public PriorityTaskQueue(boolean safe, boolean log)\n+   {\n+      log_ = log;\n+      safe_ = safe;\n+   }\n+   \n+   public void addTask(Task task)\n+   {\n+      log(\"adding \" + task.getLabel());\n+      taskQueue_.add(task);\n+      processQueue();\n+   }\n+   \n+   private void processQueue()\n+   {\n+      if (processing_)\n+      {\n+         log(\"already running\");\n+         return;\n+      }\n+      \n+      processing_ = true;\n+      processNextTask();\n+   }\n+   \n+   private void processNextTask()\n+   {\n+      log(\"process next task\");\n+      \n+      if (taskQueue_.isEmpty())\n+      {\n+         log(\"done\");\n+         processing_ = false;\n+         return;\n+      }\n+      \n+      // see if any of the tasks have priority\n+      Task nextTask = null;\n+      for (Task task : taskQueue_)\n+      {\n+         if (task.hasPriority())\n+         {\n+            nextTask = task;\n+            log(\"executing \" + nextTask.getLabel() + \" [Priority]\");\n+            break;\n+         }\n+      }\n+      \n+      // if there is no priority task then just remove from the queue\n+      if (nextTask == null)\n+      {\n+         nextTask = taskQueue_.peek();\n+         log(\"executing \" + nextTask.getLabel());  \n+      }\n+      \n+      // remove the task\n+      taskQueue_.remove(nextTask);\n+      \n+      // run the next task and then continue processing. catch any exceptions\n+      // so that we can continue processing if 'safe' was requested\n+      try\n+      {\n+         nextTask.execute(() -> {\n+            log(\"continuation\");\n+            processNextTask(); ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "945b9aaa833ff1074435a4b993a4d58bbbb1a0d6"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "077a67e5b98d67a0c4d5737c776baf9c19d238be", "author": {"user": {"login": "jjallaire", "name": "J.J. Allaire"}}, "url": "https://github.com/rstudio/rstudio/commit/077a67e5b98d67a0c4d5737c776baf9c19d238be", "committedDate": "2020-08-05T23:58:49Z", "message": "Merge branch 'feature/panmirror-dev' into feature/panmirror-load-queue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9c080813c30109ea172e645a5d890a8b6c119e8", "author": {"user": {"login": "jjallaire", "name": "J.J. Allaire"}}, "url": "https://github.com/rstudio/rstudio/commit/a9c080813c30109ea172e645a5d890a8b6c119e8", "committedDate": "2020-08-06T00:19:05Z", "message": "address pr feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 46, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}