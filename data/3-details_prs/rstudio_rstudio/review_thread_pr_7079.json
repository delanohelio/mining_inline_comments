{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMTAwNzg2", "number": 7079, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToxNTozMVrOEEdpGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODoxNDoyMFrOEFpN1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTE1NDE4OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/core/client/theme/DocTabLayoutPanel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToxNTozMVrOGiGlZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToxNTozMVrOGiGlZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxMjY0NA==", "bodyText": "Did you intend to leave this in? If you remove it also remove the related import.", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438412644", "createdAt": "2020-06-10T21:15:31Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/core/client/theme/DocTabLayoutPanel.java", "diffHunk": "@@ -1003,6 +1010,7 @@ public void endDrag(final Event evt, int action)\n                      events_.fireEvent(new PopoutDocInitiatedEvent(\n                            initDragParams_.getDocId(), Point.create(\n                                  evt.getScreenX(), evt.getScreenY())));\n+                     Debug.logToConsole(\"initiating event from DocTabLayoutPanel for: \" + initDragParams_.getDocId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTM3NjYxOnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/ui/MainSplitPanel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo0ODoxOFrOGiIy-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMToyMzoyN1rOGiLbzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0ODg4OA==", "bodyText": "Should this be ===?", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438448888", "createdAt": "2020-06-10T22:48:18Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/ui/MainSplitPanel.java", "diffHunk": "@@ -41,14 +43,14 @@\n       protected State() {}\n \n       public native final boolean hasSplitterPos() /*-{\n-         return typeof(this.splitterpos) != 'undefined';\n+         return this.splitterpos == 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MjExMQ==", "bodyText": "This line isn't doing what it's supposed to, I've fixed it.", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438492111", "createdAt": "2020-06-11T01:23:27Z", "author": {"login": "melissa-barca"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/ui/MainSplitPanel.java", "diffHunk": "@@ -41,14 +43,14 @@\n       protected State() {}\n \n       public native final boolean hasSplitterPos() /*-{\n-         return typeof(this.splitterpos) != 'undefined';\n+         return this.splitterpos == 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0ODg4OA=="}, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQwNDQzOnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/Source.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzowMjoyN1rOGiJEmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMjowNToyN1rOGiMFJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1MzQwMg==", "bodyText": "Might as well comment it!!!", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438453402", "createdAt": "2020-06-10T23:02:27Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/Source.java", "diffHunk": "@@ -627,7 +495,16 @@ else if (userPrefs_.editorKeybindings().getValue() == UserPrefs.EDITOR_KEYBINDIN\n          ShortcutManager.INSTANCE.setEditorMode(KeyboardShortcut.MODE_SUBLIME);\n       else\n          ShortcutManager.INSTANCE.setEditorMode(KeyboardShortcut.MODE_DEFAULT);\n-   \n+\n+      initialized_ = true;\n+\n+      // !!! comment why this is needed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 658}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUwMjY5NA==", "bodyText": "If I remembered :( I did some testing without the event and didn't notice anything breaking. I will continue to test but for now I've removed it.", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438502694", "createdAt": "2020-06-11T02:05:27Z", "author": {"login": "melissa-barca"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/Source.java", "diffHunk": "@@ -627,7 +495,16 @@ else if (userPrefs_.editorKeybindings().getValue() == UserPrefs.EDITOR_KEYBINDIN\n          ShortcutManager.INSTANCE.setEditorMode(KeyboardShortcut.MODE_SUBLIME);\n       else\n          ShortcutManager.INSTANCE.setEditorMode(KeyboardShortcut.MODE_DEFAULT);\n-   \n+\n+      initialized_ = true;\n+\n+      // !!! comment why this is needed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1MzQwMg=="}, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 658}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQzMzkwOnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxNzoxMFrOGiJWnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxNzoxMFrOGiJWnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODAxMw==", "bodyText": "spelling: availability", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438458013", "createdAt": "2020-06-10T23:17:10Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO\n+   }\n+\n+   public int getTabCount()\n+   {\n+      return display_.getTabCount();\n+   }\n+   \n+   public void manageChevronVisibility()\n+   {\n+\t   display_.manageChevronVisibility();\n+   }\n+   \n+   public void moveTab(int index, int delta)\n+   {\n+\t   display_.moveTab(index, delta);\n+   }\n+   \n+   public void selectTab(Widget widget)\n+   {\n+\t   display_.selectTab(widget);\n+   }\n+   \n+   public void showOverflowPopout()\n+   {\n+\t   display_.showOverflowPopup();\n+   }\n+   \n+   public void showUnsavedChangesDialog(\n+         String title,\n+         ArrayList<UnsavedChangesTarget> dirtyTargets,\n+         OperationWithInput<UnsavedChangesDialog.Result> saveOperation,\n+         Command onCancelled)\n+   {\n+      display_.showUnsavedChangesDialog(title, dirtyTargets, saveOperation, onCancelled);\n+   }\n+   \n+   public void initialSelect(int index)\n+   {\n+      if (index >= 0 && display_.getTabCount() > index)\n+         display_.selectTab(index);\n+      if (display_.getTabCount() > 0 && display_.getActiveTabIndex() >= 0)\n+         editors_.get(index).onInitiallyLoaded();\n+   }\n+\n+   /**\n+    * @param isNewTabPending True if a new tab is about to be created. (If\n+    *    false and there are no tabs already, then a new source doc might\n+    *    be created to make sure we don't end up with a source pane showing\n+    *    with no tabs in it.)\n+    */\n+   public void ensureVisible(boolean isNewTabPending)\n+   {\n+      newTabPending_++;\n+      try\n+      {\n+         display_.ensureVisible();\n+      }\n+      finally\n+      {\n+         newTabPending_--;\n+      }\n+   }\n+\n+   // when tabs have been reordered in the session, the physical layout of the\n+   // tabs doesn't match the logical order of editors_. it's occasionally\n+   // necessary to get or set the tabs by their physical order.\n+   public int getPhysicalTabIndex()\n+   {\n+      int idx = display_.getActiveTabIndex();\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.indexOf(idx);\n+      }\n+      return idx;\n+   }\n+\n+   public void setPhysicalTabIndex(int idx)\n+   {\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.get(idx);\n+      }\n+      display_.selectTab(idx);\n+   }\n+\n+   private void onActivate(EditingTarget target)\n+   {\n+       // return if we're already set properly\n+       if (activeEditor_ != null && activeEditor_ == target)\n+          return;\n+\n+       // deactivate prior active editor\n+       if (activeEditor_ != null)\n+          activeEditor_.onDeactivate();\n+\n+       // set and active editor\n+       activeEditor_ = target;\n+       if (activeEditor_ != null)\n+          activeEditor_.onActivate();\n+       manageCommands();\n+   }\n+\n+   void setActiveEditor()\n+   {\n+       if (activeEditor_ == null &&\n+           editors_.size() > display_.getActiveTabIndex())\n+          onActivate(editors_.get(display_.getActiveTabIndex()));\n+   }\n+\n+   EditingTarget setActiveEditor(String docId)\n+   {\n+      if (StringUtil.isNullOrEmpty(docId) &&\n+          activeEditor_ != null)\n+      {\n+         activeEditor_.onDeactivate();\n+         activeEditor_ = null;\n+         return null;\n+      }\n+\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.getId().equals(docId))\n+         {\n+             onActivate(target);\n+            return target;\n+         }\n+      }\n+      return null;\n+   }\n+\n+   public void setActiveEditor(EditingTarget target)\n+   {\n+      // This should never happen\n+      if (!editors_.contains(target))\n+      {\n+         Debug.logWarning(\"Attempting to set active editor to an unknown target.\");\n+         return;\n+      }\n+      onActivate(target);\n+   }\n+\n+   private void syncTabOrder()\n+   {\n+      // ensure the tab order is synced to the list of editors\n+      for (int i = tabOrder_.size(); i < editors_.size(); i++)\n+      {\n+         tabOrder_.add(i);\n+      }\n+      for (int i = editors_.size(); i < tabOrder_.size(); i++)\n+      {\n+         tabOrder_.remove(i);\n+      }\n+   }\n+\n+   public void fireDocTabsChanged()\n+   {\n+      if (!initialized_)\n+         return;\n+\n+      // ensure we have a tab order (we want the popup list to match the order\n+      // of the tabs)\n+      syncTabOrder();\n+\n+      ArrayList<EditingTarget> editors = editors_;\n+      String[] ids = new String[editors.size()];\n+      FileIcon[] icons = new FileIcon[editors.size()];\n+      String[] names = new String[editors.size()];\n+      String[] paths = new String[editors.size()];\n+      for (int i = 0; i < ids.length; i++)\n+      {\n+         EditingTarget target = editors.get(getTabOrder().get(i));\n+         ids[i] = target.getId();\n+         icons[i] = target.getIcon();\n+         names[i] = target.getName().getValue();\n+         paths[i] = target.getPath();\n+      }\n+\n+      String activeId = (activeEditor_ != null)\n+            ? activeEditor_.getId()\n+            : null;\n+\n+      events_.fireEvent(new DocTabsChangedEvent(activeId, ids, icons, names, paths));\n+\n+      manageChevronVisibility();\n+   }\n+\n+   public boolean hasDoc(String docId)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(docId, target.getId()))\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public boolean hasDoc()\n+   {\n+      return editors_.size() > 0;\n+   }\n+\n+   public boolean isSaveCommandActive()\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.isSaveCommandActive())\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public EditingTarget getDoc(String docId)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(docId, target.getId()))\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   public boolean hasDocWithPath(String path)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(path, target.getPath()))\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public EditingTarget getEditorWithPath(String path)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(path, target.getPath()))\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   private Widget createWidget(EditingTarget target)\n+   {\n+      return target.asWidget();\n+   }\n+   \n+   public EditingTarget addTab(SourceDocument doc, int mode)\n+   {\n+      return addTab(doc, false, mode);\n+   }\n+   \n+   public EditingTarget addTab(SourceDocument doc, boolean atEnd,\n+         int mode)\n+   {\n+      // by default, add at the tab immediately after the current tab\n+      return addTab(doc, atEnd ? null : getPhysicalTabIndex() + 1,\n+            mode);\n+   }\n+\n+   public EditingTarget addTab(SourceDocument doc, Integer position, int mode)\n+   {\n+      final String defaultNamePrefix = editingTargetSource_.getDefaultNamePrefix(doc);\n+      final EditingTarget target = editingTargetSource_.getEditingTarget(\n+            doc, fileContext_, () -> getNextDefaultName(defaultNamePrefix));\n+      final Widget widget = createWidget(target);\n+\n+      if (position == null)\n+      {\n+         editors_.add(target);\n+      }\n+      else\n+      {\n+         // we're inserting into an existing permuted tabset -- push aside\n+         // any tabs physically to the right of this tab\n+         editors_.add(position, target);\n+         for (int i = 0; i < tabOrder_.size(); i++)\n+         {\n+            int pos = tabOrder_.get(i);\n+            if (pos >= position)\n+               tabOrder_.set(i, pos + 1);\n+         }\n+\n+         // add this tab in its \"natural\" position\n+         tabOrder_.add(position, position);\n+      }\n+\n+      display_.addTab(widget,\n+                      target.getIcon(),\n+                      target.getId(),\n+                      target.getName().getValue(),\n+                      target.getTabTooltip(), // used as tooltip, if non-null\n+                      position,\n+                      true);\n+      fireDocTabsChanged();\n+\n+      target.getName().addValueChangeHandler(event -> {\n+         display_.renameTab(widget,\n+                            target.getIcon(),\n+                            event.getValue(),\n+                            target.getPath());\n+         fireDocTabsChanged();\n+      });\n+\n+      display_.setDirty(widget, target.dirtyState().getValue());\n+      target.dirtyState().addValueChangeHandler(event -> {\n+         display_.setDirty(widget, event.getValue());\n+         manageCommands(false);\n+      });\n+\n+      target.addEnsureVisibleHandler(new EnsureVisibleHandler()\n+      {\n+         @Override\n+         public void onEnsureVisible(EnsureVisibleEvent event)\n+         {\n+            display_.selectTab(widget);\n+         }\n+      });\n+\n+      target.addCloseHandler(voidCloseEvent -> closeTab(widget, false));\n+\n+      events_.fireEvent(new SourceDocAddedEvent(doc, mode, getName()));\n+\n+      if (target instanceof TextEditingTarget && doc.isReadOnly())\n+      {\n+         ((TextEditingTarget) target).setIntendedAsReadOnly(\n+            JsUtil.toList(doc.getReadOnlyAlternatives()));\n+      }\n+\n+      // adding a tab may enable commands that are only available when\n+      // multiple documents are open; if this is the second document, go check\n+      if (editors_.size() == 2)\n+         manageMultiTabCommands();\n+\n+      // if the target had an editing session active, attempt to resume it\n+      if (doc.getCollabParams() != null)\n+         target.beginCollabSession(doc.getCollabParams());\n+\n+      return target;\n+   }\n+\n+   public void addTab(Widget widget,\n+                      FileIcon icon,\n+                      String id,\n+                      String value,\n+                      String tabTooltip,\n+                      Integer position,\n+                      boolean switchToTab)\n+   {\n+      display_.addTab(widget, icon, id, value, tabTooltip, position, switchToTab);\n+   }\n+\n+   public void closeDoc(String docId)\n+   {\n+      suspendDocumentClose_ = true;\n+      for (int i = 0; i < editors_.size(); i++)\n+      {\n+         if (editors_.get(i).getId().equals(docId))\n+         {\n+            display_.closeTab(i, false);\n+            break;\n+         }\n+      }\n+      suspendDocumentClose_ = false;\n+   }\n+\n+   public void closeTabs(JsArrayString ids)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (JsArrayUtil.jsArrayStringContains(ids, target.getId()))\n+         {\n+            closeTab(target.asWidget(), false /* non interactive */);\n+         }\n+      }\n+   }\n+\n+   public void setPendingDebugSelection()\n+   {\n+      if (!isDebugSelectionPending())\n+      {\n+         debugSelectionTimer_ = new Timer()\n+         {\n+            public void run()\n+            {\n+               debugSelectionTimer_ = null;\n+            }\n+         };\n+         debugSelectionTimer_.schedule(250);\n+      }\n+   }\n+\n+   public boolean insertCode(String code, boolean isBlock)\n+   {\n+      if (activeEditor_ != null &&\n+          activeEditor_ instanceof TextEditingTarget &&\n+          commands_.executeCode().isEnabled())\n+      {\n+         TextEditingTarget textEditor = (TextEditingTarget) activeEditor_;\n+         textEditor.insertCode(code, isBlock);\n+         return true;\n+      }\n+      return false;\n+   }\n+\n+   public void incrementNewTabPending()\n+   {\n+       newTabPending_++;\n+   }\n+\n+   public void decrementNewTabPending()\n+   {\n+      newTabPending_--;\n+   }\n+\n+   public int getUntitledNum(String prefix)\n+   {\n+      int max = 0;\n+      for (EditingTarget target : editors_)\n+      {\n+         String name = target.getName().getValue();\n+         max = Math.max(max, manager_.getUntitledNum(name, prefix));\n+      }\n+      return max;\n+   }\n+\n+   private String getNextDefaultName(String defaultNamePrefix)\n+   {\n+      if (StringUtil.isNullOrEmpty(defaultNamePrefix))\n+         defaultNamePrefix = \"Untitled\";\n+\n+      int max = manager_.getUntitledNum(defaultNamePrefix);\n+      return defaultNamePrefix + (max + 1);\n+   }\n+\n+   private boolean isDebugSelectionPending()\n+   {\n+      return debugSelectionTimer_ != null;\n+   }\n+\n+   private boolean isUnsavedTarget(EditingTarget target, int type)\n+   {\n+      boolean fileBacked = target.getPath() != null;\n+      return target.dirtyState().getValue() &&\n+         ((type == Source.TYPE_FILE_BACKED &&  fileBacked) ||\n+            (type == Source.TYPE_UNTITLED    && !fileBacked));\n+   }\n+\n+   private void clearPendingDebugSelection()\n+   {\n+      if (debugSelectionTimer_ != null)\n+      {\n+         debugSelectionTimer_.cancel();\n+         debugSelectionTimer_ = null;\n+      }\n+   }\n+\n+   public void manageCommands(boolean forceSync)\n+   {\n+      boolean hasDocs = hasDoc();\n+\n+      commands_.newSourceDoc().setEnabled(true);\n+      commands_.closeSourceDoc().setEnabled(hasDocs);\n+      commands_.closeAllSourceDocs().setEnabled(hasDocs);\n+      commands_.nextTab().setEnabled(hasDocs);\n+      commands_.previousTab().setEnabled(hasDocs);\n+      commands_.firstTab().setEnabled(hasDocs);\n+      commands_.lastTab().setEnabled(hasDocs);\n+      commands_.switchToTab().setEnabled(hasDocs);\n+      commands_.setWorkingDirToActiveDoc().setEnabled(hasDocs);\n+\n+      HashSet<AppCommand> newCommands = activeEditor_ != null\n+              ? activeEditor_.getSupportedCommands()\n+              : new HashSet<>();\n+\n+      if (forceSync)\n+      {\n+         for (AppCommand command : activeCommands_)\n+         {\n+            command.setEnabled(false);\n+            command.setVisible(false);\n+         }\n+\n+         for (AppCommand command : newCommands)\n+         {\n+            command.setEnabled(true);\n+            command.setVisible(true);\n+         }\n+      }\n+      else\n+      {\n+         HashSet<AppCommand> commandsToEnable = new HashSet<>(newCommands);\n+         commandsToEnable.removeAll(activeCommands_);\n+\n+         HashSet<AppCommand> commandsToDisable = new HashSet<>(activeCommands_);\n+         commandsToDisable.removeAll(newCommands);\n+\n+         for (AppCommand command : commandsToEnable)\n+         {\n+            command.setEnabled(true);\n+            command.setVisible(true);\n+         }\n+\n+         for (AppCommand command : commandsToDisable)\n+         {\n+            command.setEnabled(false);\n+            command.setVisible(false);\n+         }\n+      }\n+\n+      // commands which should always be visible even when disabled\n+      commands_.saveSourceDoc().setVisible(true);\n+      commands_.saveSourceDocAs().setVisible(true);\n+      commands_.printSourceDoc().setVisible(true);\n+      commands_.setWorkingDirToActiveDoc().setVisible(true);\n+      commands_.debugBreakpoint().setVisible(true);\n+\n+      // manage synctex commands\n+      manageSynctexCommands();\n+\n+      // manage vcs commands\n+      manageVcsCommands();\n+\n+      // manage save and save all\n+      manageSaveCommands();\n+\n+      // manage source navigation\n+      manageSourceNavigationCommands();\n+\n+      // manage RSConnect commands\n+      manageRSConnectCommands();\n+\n+      // manage R Markdown commands\n+      manageRMarkdownCommands();\n+\n+      // manage multi-tab commands\n+      manageMultiTabCommands();\n+\n+      manageTerminalCommands();\n+\n+      activeCommands_ = newCommands;\n+\n+      // give the active editor a chance to manage commands\n+      if (activeEditor_ != null)\n+         activeEditor_.manageCommands();\n+\n+      assert verifyNoUnsupportedCommands(newCommands)\n+              : \"Unsupported commands detected (please add to SourceColumnManager.getDynamicCommands())\";\n+   }\n+\n+   private void manageSynctexCommands()\n+   {\n+      // synctex commands are enabled if we have synctex for the active editor\n+      boolean synctexAvailable = manager_.getSynctex().isSynctexAvailable();\n+      if (synctexAvailable)\n+      {\n+         if ((activeEditor_ != null) &&\n+                 (activeEditor_.getPath() != null) &&\n+                 activeEditor_.canCompilePdf())\n+         {\n+            synctexAvailable = manager_.getSynctex().isSynctexAvailable();\n+         }\n+         else\n+         {\n+            synctexAvailable = false;\n+         }\n+      }\n+\n+      manager_.getSynctex().enableCommands(synctexAvailable);\n+   }\n+\n+   private void manageVcsCommands()\n+   {\n+      // manage availablity of vcs commands", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 777}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQzNDk2OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxNzo0OFrOGiJXTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxNzo0OFrOGiJXTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODE5MQ==", "bodyText": "nit: could use lambda", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438458191", "createdAt": "2020-06-10T23:17:48Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO\n+   }\n+\n+   public int getTabCount()\n+   {\n+      return display_.getTabCount();\n+   }\n+   \n+   public void manageChevronVisibility()\n+   {\n+\t   display_.manageChevronVisibility();\n+   }\n+   \n+   public void moveTab(int index, int delta)\n+   {\n+\t   display_.moveTab(index, delta);\n+   }\n+   \n+   public void selectTab(Widget widget)\n+   {\n+\t   display_.selectTab(widget);\n+   }\n+   \n+   public void showOverflowPopout()\n+   {\n+\t   display_.showOverflowPopup();\n+   }\n+   \n+   public void showUnsavedChangesDialog(\n+         String title,\n+         ArrayList<UnsavedChangesTarget> dirtyTargets,\n+         OperationWithInput<UnsavedChangesDialog.Result> saveOperation,\n+         Command onCancelled)\n+   {\n+      display_.showUnsavedChangesDialog(title, dirtyTargets, saveOperation, onCancelled);\n+   }\n+   \n+   public void initialSelect(int index)\n+   {\n+      if (index >= 0 && display_.getTabCount() > index)\n+         display_.selectTab(index);\n+      if (display_.getTabCount() > 0 && display_.getActiveTabIndex() >= 0)\n+         editors_.get(index).onInitiallyLoaded();\n+   }\n+\n+   /**\n+    * @param isNewTabPending True if a new tab is about to be created. (If\n+    *    false and there are no tabs already, then a new source doc might\n+    *    be created to make sure we don't end up with a source pane showing\n+    *    with no tabs in it.)\n+    */\n+   public void ensureVisible(boolean isNewTabPending)\n+   {\n+      newTabPending_++;\n+      try\n+      {\n+         display_.ensureVisible();\n+      }\n+      finally\n+      {\n+         newTabPending_--;\n+      }\n+   }\n+\n+   // when tabs have been reordered in the session, the physical layout of the\n+   // tabs doesn't match the logical order of editors_. it's occasionally\n+   // necessary to get or set the tabs by their physical order.\n+   public int getPhysicalTabIndex()\n+   {\n+      int idx = display_.getActiveTabIndex();\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.indexOf(idx);\n+      }\n+      return idx;\n+   }\n+\n+   public void setPhysicalTabIndex(int idx)\n+   {\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.get(idx);\n+      }\n+      display_.selectTab(idx);\n+   }\n+\n+   private void onActivate(EditingTarget target)\n+   {\n+       // return if we're already set properly\n+       if (activeEditor_ != null && activeEditor_ == target)\n+          return;\n+\n+       // deactivate prior active editor\n+       if (activeEditor_ != null)\n+          activeEditor_.onDeactivate();\n+\n+       // set and active editor\n+       activeEditor_ = target;\n+       if (activeEditor_ != null)\n+          activeEditor_.onActivate();\n+       manageCommands();\n+   }\n+\n+   void setActiveEditor()\n+   {\n+       if (activeEditor_ == null &&\n+           editors_.size() > display_.getActiveTabIndex())\n+          onActivate(editors_.get(display_.getActiveTabIndex()));\n+   }\n+\n+   EditingTarget setActiveEditor(String docId)\n+   {\n+      if (StringUtil.isNullOrEmpty(docId) &&\n+          activeEditor_ != null)\n+      {\n+         activeEditor_.onDeactivate();\n+         activeEditor_ = null;\n+         return null;\n+      }\n+\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.getId().equals(docId))\n+         {\n+             onActivate(target);\n+            return target;\n+         }\n+      }\n+      return null;\n+   }\n+\n+   public void setActiveEditor(EditingTarget target)\n+   {\n+      // This should never happen\n+      if (!editors_.contains(target))\n+      {\n+         Debug.logWarning(\"Attempting to set active editor to an unknown target.\");\n+         return;\n+      }\n+      onActivate(target);\n+   }\n+\n+   private void syncTabOrder()\n+   {\n+      // ensure the tab order is synced to the list of editors\n+      for (int i = tabOrder_.size(); i < editors_.size(); i++)\n+      {\n+         tabOrder_.add(i);\n+      }\n+      for (int i = editors_.size(); i < tabOrder_.size(); i++)\n+      {\n+         tabOrder_.remove(i);\n+      }\n+   }\n+\n+   public void fireDocTabsChanged()\n+   {\n+      if (!initialized_)\n+         return;\n+\n+      // ensure we have a tab order (we want the popup list to match the order\n+      // of the tabs)\n+      syncTabOrder();\n+\n+      ArrayList<EditingTarget> editors = editors_;\n+      String[] ids = new String[editors.size()];\n+      FileIcon[] icons = new FileIcon[editors.size()];\n+      String[] names = new String[editors.size()];\n+      String[] paths = new String[editors.size()];\n+      for (int i = 0; i < ids.length; i++)\n+      {\n+         EditingTarget target = editors.get(getTabOrder().get(i));\n+         ids[i] = target.getId();\n+         icons[i] = target.getIcon();\n+         names[i] = target.getName().getValue();\n+         paths[i] = target.getPath();\n+      }\n+\n+      String activeId = (activeEditor_ != null)\n+            ? activeEditor_.getId()\n+            : null;\n+\n+      events_.fireEvent(new DocTabsChangedEvent(activeId, ids, icons, names, paths));\n+\n+      manageChevronVisibility();\n+   }\n+\n+   public boolean hasDoc(String docId)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(docId, target.getId()))\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public boolean hasDoc()\n+   {\n+      return editors_.size() > 0;\n+   }\n+\n+   public boolean isSaveCommandActive()\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.isSaveCommandActive())\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public EditingTarget getDoc(String docId)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(docId, target.getId()))\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   public boolean hasDocWithPath(String path)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(path, target.getPath()))\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   public EditingTarget getEditorWithPath(String path)\n+   {\n+      for (EditingTarget target : editors_)\n+      {\n+         if (StringUtil.equals(path, target.getPath()))\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   private Widget createWidget(EditingTarget target)\n+   {\n+      return target.asWidget();\n+   }\n+   \n+   public EditingTarget addTab(SourceDocument doc, int mode)\n+   {\n+      return addTab(doc, false, mode);\n+   }\n+   \n+   public EditingTarget addTab(SourceDocument doc, boolean atEnd,\n+         int mode)\n+   {\n+      // by default, add at the tab immediately after the current tab\n+      return addTab(doc, atEnd ? null : getPhysicalTabIndex() + 1,\n+            mode);\n+   }\n+\n+   public EditingTarget addTab(SourceDocument doc, Integer position, int mode)\n+   {\n+      final String defaultNamePrefix = editingTargetSource_.getDefaultNamePrefix(doc);\n+      final EditingTarget target = editingTargetSource_.getEditingTarget(\n+            doc, fileContext_, () -> getNextDefaultName(defaultNamePrefix));\n+      final Widget widget = createWidget(target);\n+\n+      if (position == null)\n+      {\n+         editors_.add(target);\n+      }\n+      else\n+      {\n+         // we're inserting into an existing permuted tabset -- push aside\n+         // any tabs physically to the right of this tab\n+         editors_.add(position, target);\n+         for (int i = 0; i < tabOrder_.size(); i++)\n+         {\n+            int pos = tabOrder_.get(i);\n+            if (pos >= position)\n+               tabOrder_.set(i, pos + 1);\n+         }\n+\n+         // add this tab in its \"natural\" position\n+         tabOrder_.add(position, position);\n+      }\n+\n+      display_.addTab(widget,\n+                      target.getIcon(),\n+                      target.getId(),\n+                      target.getName().getValue(),\n+                      target.getTabTooltip(), // used as tooltip, if non-null\n+                      position,\n+                      true);\n+      fireDocTabsChanged();\n+\n+      target.getName().addValueChangeHandler(event -> {\n+         display_.renameTab(widget,\n+                            target.getIcon(),\n+                            event.getValue(),\n+                            target.getPath());\n+         fireDocTabsChanged();\n+      });\n+\n+      display_.setDirty(widget, target.dirtyState().getValue());\n+      target.dirtyState().addValueChangeHandler(event -> {\n+         display_.setDirty(widget, event.getValue());\n+         manageCommands(false);\n+      });\n+\n+      target.addEnsureVisibleHandler(new EnsureVisibleHandler()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 514}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQzNjU5OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoxODo0NlrOGiJYaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMToyMzoxOVrOGiLbsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODQ3Mw==", "bodyText": "Is this intentionally left as \"TODO\"?", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438458473", "createdAt": "2020-06-10T23:18:46Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ5MjA4MQ==", "bodyText": "No, I remove this and added an option to SouceColumnManager's closeAllLocalSourceDocs function to accept a single column.", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438492081", "createdAt": "2020-06-11T01:23:19Z", "author": {"login": "melissa-barca"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1ODQ3Mw=="}, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ0MTUyOnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyMToyMVrOGiJblg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDoyMDoxOFrOGiKdQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1OTI4Ng==", "bodyText": "Is this right? At first glance seems like this won't work but I might be misunderstanding.", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438459286", "createdAt": "2020-06-10T23:21:21Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO\n+   }\n+\n+   public int getTabCount()\n+   {\n+      return display_.getTabCount();\n+   }\n+   \n+   public void manageChevronVisibility()\n+   {\n+\t   display_.manageChevronVisibility();\n+   }\n+   \n+   public void moveTab(int index, int delta)\n+   {\n+\t   display_.moveTab(index, delta);\n+   }\n+   \n+   public void selectTab(Widget widget)\n+   {\n+\t   display_.selectTab(widget);\n+   }\n+   \n+   public void showOverflowPopout()\n+   {\n+\t   display_.showOverflowPopup();\n+   }\n+   \n+   public void showUnsavedChangesDialog(\n+         String title,\n+         ArrayList<UnsavedChangesTarget> dirtyTargets,\n+         OperationWithInput<UnsavedChangesDialog.Result> saveOperation,\n+         Command onCancelled)\n+   {\n+      display_.showUnsavedChangesDialog(title, dirtyTargets, saveOperation, onCancelled);\n+   }\n+   \n+   public void initialSelect(int index)\n+   {\n+      if (index >= 0 && display_.getTabCount() > index)\n+         display_.selectTab(index);\n+      if (display_.getTabCount() > 0 && display_.getActiveTabIndex() >= 0)\n+         editors_.get(index).onInitiallyLoaded();\n+   }\n+\n+   /**\n+    * @param isNewTabPending True if a new tab is about to be created. (If\n+    *    false and there are no tabs already, then a new source doc might\n+    *    be created to make sure we don't end up with a source pane showing\n+    *    with no tabs in it.)\n+    */\n+   public void ensureVisible(boolean isNewTabPending)\n+   {\n+      newTabPending_++;\n+      try\n+      {\n+         display_.ensureVisible();\n+      }\n+      finally\n+      {\n+         newTabPending_--;\n+      }\n+   }\n+\n+   // when tabs have been reordered in the session, the physical layout of the\n+   // tabs doesn't match the logical order of editors_. it's occasionally\n+   // necessary to get or set the tabs by their physical order.\n+   public int getPhysicalTabIndex()\n+   {\n+      int idx = display_.getActiveTabIndex();\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.indexOf(idx);\n+      }\n+      return idx;\n+   }\n+\n+   public void setPhysicalTabIndex(int idx)\n+   {\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.get(idx);\n+      }\n+      display_.selectTab(idx);\n+   }\n+\n+   private void onActivate(EditingTarget target)\n+   {\n+       // return if we're already set properly\n+       if (activeEditor_ != null && activeEditor_ == target)\n+          return;\n+\n+       // deactivate prior active editor\n+       if (activeEditor_ != null)\n+          activeEditor_.onDeactivate();\n+\n+       // set and active editor\n+       activeEditor_ = target;\n+       if (activeEditor_ != null)\n+          activeEditor_.onActivate();\n+       manageCommands();\n+   }\n+\n+   void setActiveEditor()\n+   {\n+       if (activeEditor_ == null &&\n+           editors_.size() > display_.getActiveTabIndex())\n+          onActivate(editors_.get(display_.getActiveTabIndex()));\n+   }\n+\n+   EditingTarget setActiveEditor(String docId)\n+   {\n+      if (StringUtil.isNullOrEmpty(docId) &&\n+          activeEditor_ != null)\n+      {\n+         activeEditor_.onDeactivate();\n+         activeEditor_ = null;\n+         return null;\n+      }\n+\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.getId().equals(docId))\n+         {\n+             onActivate(target);\n+            return target;\n+         }\n+      }\n+      return null;\n+   }\n+\n+   public void setActiveEditor(EditingTarget target)\n+   {\n+      // This should never happen\n+      if (!editors_.contains(target))\n+      {\n+         Debug.logWarning(\"Attempting to set active editor to an unknown target.\");\n+         return;\n+      }\n+      onActivate(target);\n+   }\n+\n+   private void syncTabOrder()\n+   {\n+      // ensure the tab order is synced to the list of editors\n+      for (int i = tabOrder_.size(); i < editors_.size(); i++)\n+      {\n+         tabOrder_.add(i);\n+      }\n+      for (int i = editors_.size(); i < tabOrder_.size(); i++)\n+      {\n+         tabOrder_.remove(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NjA5OQ==", "bodyText": "Yes, because each time we are only modifying tabOrder. This is taken from today's Source.java https://github.com/rstudio/rstudio/blob/master/src/gwt/src/org/rstudio/studio/client/workbench/views/source/Source.java#L3818-L3829", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438476099", "createdAt": "2020-06-11T00:20:18Z", "author": {"login": "melissa-barca"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumn.java", "diffHunk": "@@ -0,0 +1,1215 @@\n+/*\n+ * SourceColumn.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.core.client.Scheduler;\n+import com.google.gwt.event.logical.shared.SelectionEvent;\n+import com.google.gwt.event.logical.shared.SelectionHandler;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.Timer;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import org.rstudio.core.client.Debug;\n+import org.rstudio.core.client.JsArrayUtil;\n+import org.rstudio.core.client.ResultCallback;\n+import org.rstudio.core.client.StringUtil;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.CommandBinder;\n+import org.rstudio.core.client.events.*;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.theme.DocTabSelectionEvent;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.filetypes.EditableFileType;\n+import org.rstudio.studio.client.common.filetypes.FileIcon;\n+import org.rstudio.studio.client.common.filetypes.FileTypeRegistry;\n+import org.rstudio.studio.client.common.filetypes.TextFileType;\n+import org.rstudio.studio.client.common.synctex.events.SynctexStatusChangedEvent;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.model.RemoteFileSystemContext;\n+import org.rstudio.studio.client.workbench.model.SessionUtils;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.FileTypeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.SourceOnSaveChangedEvent;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceDocument;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceNavigation;\n+import org.rstudio.studio.client.workbench.views.source.model.SourceServerOperations;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class SourceColumn implements SelectionHandler<Integer>,\n+                                     TabClosingHandler,\n+                                     TabCloseHandler,\n+                                     TabClosedHandler,\n+                                     TabReorderHandler\n+{\n+   interface Binder extends CommandBinder<Commands, SourceColumn>\n+   {\n+   }\n+\n+   SourceColumn()\n+   {\n+      RStudioGinjector.INSTANCE.injectMembers(this);\n+   }\n+\n+   @Inject\n+   public void initialize(Binder binder,\n+                          Commands commands,\n+                          EventBus events,\n+                          EditingTargetSource editingTargetSource,\n+                          RemoteFileSystemContext fileContext,\n+                          SourceServerOperations sourceServerOperations)\n+   {\n+      commands_ = commands;\n+      binder.bind(commands_, this);\n+\n+      events_ = events;\n+      editingTargetSource_ = editingTargetSource;\n+      fileContext_ = fileContext;\n+      server_ = sourceServerOperations;\n+\n+\n+      events_.addHandler(FileTypeChangedEvent.TYPE, event -> manageCommands(false));\n+      events_.addHandler(SourceOnSaveChangedEvent.TYPE, event -> manageSaveCommands());\n+      events_.addHandler(SynctexStatusChangedEvent.TYPE, event -> manageSynctexCommands());\n+\n+      initialized_ = true;\n+   }\n+\n+   public void loadDisplay(String name,\n+                           Source.Display display,\n+                           SourceColumnManager manager)\n+   {\n+      name_ = name;\n+      display_ = display;\n+      manager_ = manager;\n+\n+      display_.addSelectionHandler(this);\n+      display_.addTabClosingHandler(this);\n+      display_.addTabCloseHandler(this);\n+      display_.addTabClosedHandler(this);\n+      display_.addTabReorderHandler(this);\n+\n+      ensureVisible(false);\n+   }\n+\n+   public String getName()\n+   {\n+      return name_;\n+   }\n+\n+   public EditingTarget getActiveEditor()\n+   {\n+      return activeEditor_;\n+   }\n+\n+   public ArrayList<EditingTarget> getEditors()\n+   {\n+      return editors_;\n+   }\n+\n+   public ArrayList<EditingTarget> getDirtyEditors(final EditingTarget excludeEditor)\n+   {\n+      ArrayList<EditingTarget> dirtyEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (excludeEditor != null && target == excludeEditor)\n+            continue;\n+         if (target.dirtyState().getValue())\n+            dirtyEditors.add(target);\n+      }\n+      return dirtyEditors;\n+   }\n+\n+   public ArrayList<EditingTarget> getUnsavedEditors(int type, Set<String> ids)\n+   {\n+      ArrayList<EditingTarget> unsavedEditors = new ArrayList<>();\n+      for (EditingTarget target : editors_)\n+      {\n+         if (!isUnsavedTarget(target, type))\n+            continue;\n+         if (ids != null && !ids.contains(target.getId()))\n+            continue;\n+         unsavedEditors.add(target);\n+      }\n+      return unsavedEditors;\n+   }\n+\n+   public ArrayList<Integer> getTabOrder()\n+   {\n+      return tabOrder_;\n+   }\n+\n+   public Widget asWidget()\n+   {\n+      return display_.asWidget();\n+   }\n+\n+   // Display wrapper methods\n+   public void cancelTabDrag()\n+   {\n+      display_.cancelTabDrag();\n+   }\n+   \n+   public void closeTab(Widget child, boolean interactive)\n+   {\n+      display_.closeTab(child, interactive);\n+   }\n+\n+   public void closeTab(Widget child, boolean interactive, Command onClosed)\n+   {\n+      display_.closeTab(child, interactive, onClosed);\n+   }\n+   \n+   public void closeTab(int index, boolean interactive)\n+   {\n+      display_.closeTab(index, interactive);\n+   }\n+\n+   public void closeTab(int index, boolean interactive, Command onClosed)\n+   {\n+\t   display_.closeTab(index, interactive, onClosed);\n+   }\n+\n+   public void closeAllLocalSourceDocs()\n+   {\n+      // TODO\n+   }\n+\n+   public int getTabCount()\n+   {\n+      return display_.getTabCount();\n+   }\n+   \n+   public void manageChevronVisibility()\n+   {\n+\t   display_.manageChevronVisibility();\n+   }\n+   \n+   public void moveTab(int index, int delta)\n+   {\n+\t   display_.moveTab(index, delta);\n+   }\n+   \n+   public void selectTab(Widget widget)\n+   {\n+\t   display_.selectTab(widget);\n+   }\n+   \n+   public void showOverflowPopout()\n+   {\n+\t   display_.showOverflowPopup();\n+   }\n+   \n+   public void showUnsavedChangesDialog(\n+         String title,\n+         ArrayList<UnsavedChangesTarget> dirtyTargets,\n+         OperationWithInput<UnsavedChangesDialog.Result> saveOperation,\n+         Command onCancelled)\n+   {\n+      display_.showUnsavedChangesDialog(title, dirtyTargets, saveOperation, onCancelled);\n+   }\n+   \n+   public void initialSelect(int index)\n+   {\n+      if (index >= 0 && display_.getTabCount() > index)\n+         display_.selectTab(index);\n+      if (display_.getTabCount() > 0 && display_.getActiveTabIndex() >= 0)\n+         editors_.get(index).onInitiallyLoaded();\n+   }\n+\n+   /**\n+    * @param isNewTabPending True if a new tab is about to be created. (If\n+    *    false and there are no tabs already, then a new source doc might\n+    *    be created to make sure we don't end up with a source pane showing\n+    *    with no tabs in it.)\n+    */\n+   public void ensureVisible(boolean isNewTabPending)\n+   {\n+      newTabPending_++;\n+      try\n+      {\n+         display_.ensureVisible();\n+      }\n+      finally\n+      {\n+         newTabPending_--;\n+      }\n+   }\n+\n+   // when tabs have been reordered in the session, the physical layout of the\n+   // tabs doesn't match the logical order of editors_. it's occasionally\n+   // necessary to get or set the tabs by their physical order.\n+   public int getPhysicalTabIndex()\n+   {\n+      int idx = display_.getActiveTabIndex();\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.indexOf(idx);\n+      }\n+      return idx;\n+   }\n+\n+   public void setPhysicalTabIndex(int idx)\n+   {\n+      if (idx < tabOrder_.size())\n+      {\n+         idx = tabOrder_.get(idx);\n+      }\n+      display_.selectTab(idx);\n+   }\n+\n+   private void onActivate(EditingTarget target)\n+   {\n+       // return if we're already set properly\n+       if (activeEditor_ != null && activeEditor_ == target)\n+          return;\n+\n+       // deactivate prior active editor\n+       if (activeEditor_ != null)\n+          activeEditor_.onDeactivate();\n+\n+       // set and active editor\n+       activeEditor_ = target;\n+       if (activeEditor_ != null)\n+          activeEditor_.onActivate();\n+       manageCommands();\n+   }\n+\n+   void setActiveEditor()\n+   {\n+       if (activeEditor_ == null &&\n+           editors_.size() > display_.getActiveTabIndex())\n+          onActivate(editors_.get(display_.getActiveTabIndex()));\n+   }\n+\n+   EditingTarget setActiveEditor(String docId)\n+   {\n+      if (StringUtil.isNullOrEmpty(docId) &&\n+          activeEditor_ != null)\n+      {\n+         activeEditor_.onDeactivate();\n+         activeEditor_ = null;\n+         return null;\n+      }\n+\n+      for (EditingTarget target : editors_)\n+      {\n+         if (target.getId().equals(docId))\n+         {\n+             onActivate(target);\n+            return target;\n+         }\n+      }\n+      return null;\n+   }\n+\n+   public void setActiveEditor(EditingTarget target)\n+   {\n+      // This should never happen\n+      if (!editors_.contains(target))\n+      {\n+         Debug.logWarning(\"Attempting to set active editor to an unknown target.\");\n+         return;\n+      }\n+      onActivate(target);\n+   }\n+\n+   private void syncTabOrder()\n+   {\n+      // ensure the tab order is synced to the list of editors\n+      for (int i = tabOrder_.size(); i < editors_.size(); i++)\n+      {\n+         tabOrder_.add(i);\n+      }\n+      for (int i = editors_.size(); i < tabOrder_.size(); i++)\n+      {\n+         tabOrder_.remove(i);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1OTI4Ng=="}, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ0Nzk4OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumnManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNDo1OFrOGiJftg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNDo1OFrOGiJftg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDM0Mg==", "bodyText": "Could replace with:\n         ArrayList<UnsavedChangesTarget> unsavedTargets = new ArrayList<>(editingTargets);", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438460342", "createdAt": "2020-06-10T23:24:58Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumnManager.java", "diffHunk": "@@ -0,0 +1,2377 @@\n+/*\n+ * SourceColumnManager.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.GWT;\n+import com.google.gwt.core.client.JavaScriptObject;\n+import com.google.gwt.core.client.JsArray;\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.event.dom.client.ChangeEvent;\n+import com.google.gwt.event.dom.client.ChangeHandler;\n+import com.google.gwt.json.client.JSONString;\n+import com.google.gwt.json.client.JSONValue;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.rstudio.core.client.*;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.Handler;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.widget.Operation;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.core.client.widget.ProgressIndicator;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.FilePathUtils;\n+import org.rstudio.studio.client.common.GlobalDisplay;\n+import org.rstudio.studio.client.common.GlobalProgressDelayer;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.dependencies.DependencyManager;\n+import org.rstudio.studio.client.common.filetypes.*;\n+import org.rstudio.studio.client.common.synctex.Synctex;\n+import org.rstudio.studio.client.events.GetEditorContextEvent;\n+import org.rstudio.studio.client.palette.model.CommandPaletteEntrySource;\n+import org.rstudio.studio.client.palette.model.CommandPaletteItem;\n+import org.rstudio.studio.client.rmarkdown.model.RmdChosenTemplate;\n+import org.rstudio.studio.client.rmarkdown.model.RmdFrontMatter;\n+import org.rstudio.studio.client.rmarkdown.model.RmdOutputFormat;\n+import org.rstudio.studio.client.rmarkdown.model.RmdTemplateData;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.FileMRUList;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.events.SessionInitEvent;\n+import org.rstudio.studio.client.workbench.events.SessionInitHandler;\n+import org.rstudio.studio.client.workbench.model.ClientState;\n+import org.rstudio.studio.client.workbench.model.Session;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.model.helper.JSObjectStateValue;\n+import org.rstudio.studio.client.workbench.prefs.model.UserPrefs;\n+import org.rstudio.studio.client.workbench.prefs.model.UserState;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.environment.events.DebugModeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.output.find.events.FindInFilesEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.data.DataEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.explorer.ObjectExplorerEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.explorer.model.ObjectExplorerHandle;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.AceEditor;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.DocDisplay;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTargetRMarkdownHelper;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Position;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Range;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Selection;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.EditingTargetSelectedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ui.NewRMarkdownDialog;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.*;\n+\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+@Singleton\n+public class SourceColumnManager implements SessionInitHandler,\n+                                            CommandPaletteEntrySource,\n+                                            SourceExtendedTypeDetectedEvent.Handler,\n+                                            DebugModeChangedEvent.Handler\n+{\n+   public interface CPSEditingTargetCommand\n+   {\n+      void execute(EditingTarget editingTarget, Command continuation);\n+   }\n+\n+   public static class State extends JavaScriptObject\n+   {\n+      public static native State createState(JsArrayString names) /*-{\n+         return {\n+            names: names\n+         }\n+      }-*/;\n+\n+      protected State()\n+      {}\n+\n+      public final String[] getNames()\n+      {\n+         return JsUtil.toStringArray(getNamesNative());\n+      }\n+\n+      private native JsArrayString getNamesNative() /*-{\n+          return this.names;\n+      }-*/;\n+   }\n+\n+   @Inject\n+   public SourceColumnManager(Source.Display display,\n+                              SourceServerOperations server,\n+                              GlobalDisplay globalDisplay,\n+                              Commands commands,\n+                              EditingTargetSource editingTargetSource,\n+                              FileTypeRegistry fileTypeRegistry,\n+                              EventBus events,\n+                              DependencyManager dependencyManager,\n+                              final Session session,\n+                              Synctex synctex,\n+                              UserPrefs userPrefs,\n+                              UserState userState,\n+                              Provider<FileMRUList> pMruList,\n+                              Provider<SourceWindowManager> pWindowManager)\n+   {\n+      SourceColumn column = GWT.create(SourceColumn.class);\n+      column.loadDisplay(MAIN_SOURCE_NAME, display, this);\n+      columnList_.add(column);\n+      setActive(column.getName());\n+\n+      server_ = server;\n+      commands_ = commands;\n+      globalDisplay_ = globalDisplay;\n+      editingTargetSource_ = editingTargetSource;\n+      fileTypeRegistry_ = fileTypeRegistry;\n+      events_ = events;\n+      dependencyManager_ = dependencyManager;\n+      session_ = session;\n+      synctex_ = synctex;\n+      userPrefs_ = userPrefs;\n+      userState_ = userState;\n+      pMruList_ = pMruList;\n+      pWindowManager_ = pWindowManager;\n+\n+      rmarkdown_ = new TextEditingTargetRMarkdownHelper();\n+      vimCommands_ = new SourceVimCommands();\n+      columnState_ = null;\n+      initDynamicCommands();\n+\n+      events_.addHandler(SourceExtendedTypeDetectedEvent.TYPE, this);\n+      events_.addHandler(DebugModeChangedEvent.TYPE, this);\n+\n+      events_.addHandler(SessionInitEvent.TYPE,this);\n+\n+      events_.addHandler(EditingTargetSelectedEvent.TYPE, new EditingTargetSelectedEvent.Handler()\n+      {\n+         @Override\n+         public void onEditingTargetSelected(EditingTargetSelectedEvent event)\n+         {\n+            setActive(event.getTarget());\n+         }\n+      });\n+\n+      events_.addHandler(SourceFileSavedEvent.TYPE, new SourceFileSavedHandler()\n+      {\n+         public void onSourceFileSaved(SourceFileSavedEvent event)\n+         {\n+            pMruList_.get().add(event.getPath());\n+         }\n+      });\n+\n+      events_.addHandler(DocTabActivatedEvent.TYPE, new DocTabActivatedEvent.Handler()\n+      {\n+         public void onDocTabActivated(DocTabActivatedEvent event)\n+         {\n+            setActiveDocId(event.getId());\n+         }\n+      });\n+\n+      sourceNavigationHistory_.addChangeHandler(new ChangeHandler()\n+      {\n+\n+         @Override\n+         public void onChange(ChangeEvent event)\n+         {\n+            columnList_.forEach((column) ->\n+               column.manageSourceNavigationCommands());\n+         }\n+      });\n+   }\n+\n+   public String add()\n+   {\n+      Source.Display display = GWT.create(SourcePane.class);\n+      return add(display, false);\n+   }\n+\n+   public String add(Source.Display display)\n+   {\n+      return add(display, false);\n+   }\n+\n+   public String add(String name, boolean updateState)\n+   {\n+      return add(name, false, updateState);\n+   }\n+\n+   public String add (String name, boolean activate, boolean updateState)\n+   {\n+      Source.Display display = GWT.create(SourcePane.class);\n+      return add(name, display, activate, updateState);\n+   }\n+\n+   public String add(Source.Display display, boolean activate)\n+   {\n+      return add(display, activate, true);\n+   }\n+\n+   public String add(Source.Display display, boolean activate, boolean updateState)\n+   {\n+      return add(COLUMN_PREFIX + StringUtil.makeRandomId(12),\n+                  display,\n+                  activate,\n+                  updateState);\n+   }\n+\n+   public String add(String name, Source.Display display, boolean activate, boolean updateState)\n+   {\n+      if (contains(name))\n+         return \"\";\n+\n+      SourceColumn column = GWT.create(SourceColumn.class);\n+      column.loadDisplay(name, display, this);\n+      columnList_.add(column);\n+\n+      if (activate || activeColumn_ == null)\n+         activeColumn_ = column;\n+\n+      if (updateState)\n+         columnState_ = State.createState(JsUtil.toJsArrayString(getNames(false)));\n+      return column.getName();\n+   }\n+\n+   public void initialSelect(int index)\n+   {\n+      getActive().initialSelect(index);\n+   }\n+\n+   public void setActive(String name)\n+   {\n+      if (StringUtil.isNullOrEmpty(name))\n+      {\n+         activeColumn_.setActiveEditor(\"\");\n+         activeColumn_ = null;\n+         return;\n+      }\n+\n+      String prevColumn = activeColumn_ == null ? \"\" : activeColumn_.getName();\n+      activeColumn_ = getByName(name);\n+\n+      // If the active column changed, we need to update the active editor\n+      if (!StringUtil.isNullOrEmpty(prevColumn) && !StringUtil.equals(name, prevColumn))\n+      {\n+         SourceColumn column = getByName(prevColumn);\n+         if (column == null)\n+            return;\n+         if (!hasActiveEditor())\n+         {\n+            Debug.logWarning(\"Setting to random editor.\");\n+            column.setActiveEditor();\n+         }\n+      }\n+   }\n+\n+   public void setActive(EditingTarget target)\n+   {\n+      activeColumn_ = findByDocument(target.getId());\n+      activeColumn_.setActiveEditor(target);\n+   }\n+\n+   public void setActiveDocId(String docId)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget target = column.setActiveEditor(docId);\n+         if (target != null)\n+         {\n+            setActive(target);\n+            return;\n+         }\n+      }\n+      Debug.logWarning(\"Attempted to set unknown doc to active \" + docId);\n+   }\n+\n+   public void setOpeningForSourceNavigation(boolean value)\n+   {\n+      openingForSourceNavigation_ = value;\n+   }\n+\n+   public void activateColumns(final Command afterActivation)\n+   {\n+      if (!hasActiveEditor())\n+      {\n+         if (activeColumn_ == null)\n+            setActive(MAIN_SOURCE_NAME);\n+         newDoc(FileTypeRegistry.R, new ResultCallback<EditingTarget, ServerError>()\n+         {\n+            @Override\n+            public void onSuccess(EditingTarget target)\n+            {\n+               setActive(target);\n+               doActivateSource(afterActivation);\n+            }\n+         });\n+      } else\n+      {\n+         doActivateSource(afterActivation);\n+      }\n+   }\n+\n+   // This method sets activeColumn_ to the main column if it is null. It should be used in cases\n+   // where it is better for the column to be the main column than null.\n+   public SourceColumn getActive()\n+   {\n+      if (activeColumn_ != null)\n+         return activeColumn_;\n+      setActive(MAIN_SOURCE_NAME);\n+\n+      return activeColumn_;\n+   }\n+\n+   public String getActiveDocId()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getId();\n+      return null;\n+   }\n+\n+   public String getActiveDocPath()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getPath();\n+      return null;\n+   }\n+\n+   public boolean hasActiveEditor()\n+   {\n+      return activeColumn_ != null && activeColumn_.getActiveEditor() != null;\n+   }\n+\n+   public boolean isActiveEditor(EditingTarget editingTarget)\n+   {\n+      return hasActiveEditor() && activeColumn_.getActiveEditor() == editingTarget;\n+   }\n+\n+   // see if there are additional command pallette items made available\n+   // by the active editor\n+   public List<CommandPaletteItem> getCommandPaletteItems()\n+   {\n+      if (!hasActiveEditor())\n+         return null;\n+\n+      return activeColumn_.getActiveEditor().getCommandPaletteItems();\n+   }\n+\n+   public int getTabCount()\n+   {\n+      return activeColumn_.getTabCount();\n+   }\n+\n+   public int getPhysicalTabIndex()\n+   {\n+      return activeColumn_.getPhysicalTabIndex();\n+   }\n+\n+   public ArrayList<String> getNames(boolean excludeMain)\n+   {\n+      ArrayList<String> result = new ArrayList<>();\n+      columnList_.forEach((column) ->{\n+         if (!excludeMain || !StringUtil.equals(column.getName(), MAIN_SOURCE_NAME))\n+            result.add(column.getName());\n+      });\n+      return result;\n+   }\n+\n+   public ArrayList<Widget> getWidgets(boolean excludeMain)\n+   {\n+      ArrayList<Widget> result = new ArrayList<Widget>();\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (!excludeMain || !StringUtil.equals(column.getName(), MAIN_SOURCE_NAME))\n+            result.add(column.asWidget());\n+      }\n+      return result;\n+   }\n+\n+   public ArrayList<SourceColumn> getColumnList()\n+   {\n+      return columnList_;\n+   }\n+\n+   public Widget getWidget(String name)\n+   {\n+      return getByName(name) == null ? null : getByName(name).asWidget();\n+   }\n+\n+   public Session getSession()\n+   {\n+      return session_;\n+   }\n+\n+   public SourceNavigationHistory getSourceNavigationHistory()\n+   {\n+      return sourceNavigationHistory_;\n+   }\n+\n+   public void recordCurrentNavigationHistoryPosition()\n+   {\n+      if (hasActiveEditor())\n+         activeColumn_.getActiveEditor().recordCurrentNavigationPosition();\n+   }\n+\n+   public String getEditorPositionString()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getCurrentStatus();\n+      return \"No document tabs open\";\n+   }\n+\n+   public Synctex getSynctex()\n+   {\n+      return synctex_;\n+   }\n+\n+   public UserState getUserState()\n+   {\n+      return userState_;\n+   }\n+\n+   public int getSize()\n+   {\n+      return columnList_.size();\n+   }\n+\n+   public int getUntitledNum(String prefix)\n+   {\n+      AtomicInteger max = new AtomicInteger();\n+      columnList_.forEach((column) ->\n+          max.set(Math.max(max.get(), column.getUntitledNum(prefix))));\n+      return max.intValue();\n+   }\n+\n+   public native final int getUntitledNum(String name, String prefix) /*-{\n+       var match = (new RegExp(\"^\" + prefix + \"([0-9]{1,5})$\")).exec(name);\n+       if (!match)\n+           return 0;\n+       return parseInt(match[1]);\n+   }-*/;\n+\n+   public void clearSourceNavigationHistory()\n+   {\n+      if (!hasDoc())\n+         sourceNavigationHistory_.clear();\n+   }\n+\n+   public void manageCommands(boolean forceSync)\n+   {\n+      columnList_.forEach((column) -> column.manageCommands(forceSync));\n+   }\n+\n+   public EditingTarget addTab(SourceDocument doc, int mode, SourceColumn column)\n+   {\n+      if (column == null)\n+         column = activeColumn_;\n+      return column.addTab(doc, mode);\n+   }\n+\n+   public EditingTarget addTab(SourceDocument doc, boolean atEnd,\n+                               int mode, SourceColumn column)\n+   {\n+      if (column == null)\n+         column = activeColumn_;\n+      return column.addTab(doc, atEnd, mode);\n+   }\n+\n+   public EditingTarget findEditor(String docId)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget target = column.getDoc(docId);\n+         if (target != null)\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   public EditingTarget findEditorByPath(String path)\n+   {\n+      if (StringUtil.isNullOrEmpty(path))\n+         return null;\n+\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget target = column.getEditorWithPath(path);\n+         if (target != null)\n+            return target;\n+      }\n+      return null;\n+   }\n+\n+   public SourceColumn findByDocument(String docId)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (column.hasDoc(docId))\n+            return column;\n+      }\n+      return null;\n+   }\n+\n+   public SourceColumn findByName(String name)\n+   {\n+      return getByName(name);\n+   }\n+\n+   public SourceColumn findByPosition(int x)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+\n+         Widget w = column.asWidget();\n+         int left = w.getAbsoluteLeft();\n+         int right = w.getAbsoluteLeft() + w.getOffsetWidth();\n+\n+         if (x > left && x < right)\n+            return column;\n+      }\n+      return null;\n+   }\n+\n+   public boolean isEmpty(String name)\n+   {\n+      return getByName(name) == null || getByName(name).getTabCount() == 0;\n+   }\n+\n+   public boolean areSourceWindowsOpen()\n+   {\n+      return pWindowManager_.get().areSourceWindowsOpen();\n+   }\n+\n+   public boolean attemptTextEditorActivate()\n+   {\n+      if (!(hasActiveEditor() ||\n+            activeColumn_.getActiveEditor() instanceof TextEditingTarget))\n+         return false;\n+\n+      TextEditingTarget editingTarget = (TextEditingTarget) activeColumn_.getActiveEditor();\n+      editingTarget.ensureTextEditorActive(() -> {\n+         getEditorContext(\n+            editingTarget.getId(),\n+            editingTarget.getPath(),\n+            editingTarget.getDocDisplay()\n+         );\n+      });\n+      return true;\n+   }\n+\n+\n+   public void activateCodeBrowser(\n+      final String codeBrowserPath,\n+      boolean replaceIfActive,\n+      final ResultCallback<CodeBrowserEditingTarget, ServerError> callback)\n+   {\n+      // first check to see if this request can be fulfilled with an existing\n+      // code browser tab\n+      EditingTarget target = selectTabWithDocPath(codeBrowserPath);\n+      if (target != null)\n+      {\n+         callback.onSuccess((CodeBrowserEditingTarget) target);\n+         return;\n+      }\n+\n+      // then check to see if the active editor is a code browser -- if it is,\n+      // we'll use it as is, replacing its contents\n+      if (replaceIfActive &&\n+          hasActiveEditor() &&\n+          activeColumn_.getActiveEditor() instanceof CodeBrowserEditingTarget)\n+      {\n+         events_.fireEvent(new CodeBrowserCreatedEvent(activeColumn_.getActiveEditor().getId(),\n+            codeBrowserPath));\n+         callback.onSuccess((CodeBrowserEditingTarget) activeColumn_.getActiveEditor());\n+         return;\n+      }\n+\n+      // create a new one\n+      newDoc(FileTypeRegistry.CODEBROWSER,\n+         new ResultCallback<EditingTarget, ServerError>()\n+         {\n+            @Override\n+            public void onSuccess(EditingTarget arg)\n+            {\n+               events_.fireEvent(new CodeBrowserCreatedEvent(\n+                  arg.getId(), codeBrowserPath));\n+               callback.onSuccess((CodeBrowserEditingTarget) arg);\n+            }\n+\n+            @Override\n+            public void onFailure(ServerError error)\n+            {\n+               callback.onFailure(error);\n+            }\n+\n+            @Override\n+            public void onCancelled()\n+            {\n+               callback.onCancelled();\n+            }\n+\n+         });\n+   }\n+\n+   public void activateObjectExplorer(ObjectExplorerHandle handle)\n+   {\n+      columnList_.forEach((column) -> {\n+         for (EditingTarget target : column.getEditors())\n+         {\n+            // bail if this isn't an object explorer filetype\n+            FileType fileType = target.getFileType();\n+            if (!(fileType instanceof ObjectExplorerFileType))\n+               continue;\n+\n+            // check for identical titles\n+            if (handle.getTitle() == target.getTitle())\n+            {\n+               ((ObjectExplorerEditingTarget) target).update(handle);\n+               ensureVisible(false);\n+               column.selectTab(target.asWidget());\n+               return;\n+            }\n+         }\n+      });\n+\n+      ensureVisible(true);\n+      server_.newDocument(\n+         FileTypeRegistry.OBJECT_EXPLORER.getTypeId(),\n+         null,\n+         (JsObject) handle.cast(),\n+         new SimpleRequestCallback<SourceDocument>(\"Show Object Explorer\")\n+         {\n+            @Override\n+            public void onResponseReceived(SourceDocument response)\n+            {\n+               activeColumn_.addTab(response, Source.OPEN_INTERACTIVE);\n+            }\n+         });\n+   }\n+\n+   public void showOverflowPopout()\n+   {\n+      ensureVisible(false);\n+      activeColumn_.showOverflowPopout();\n+   }\n+\n+   public void showDataItem(DataItem data)\n+   {\n+      columnList_.forEach((column) -> {\n+         for (EditingTarget target : column.getEditors())\n+         {\n+            String path = target.getPath();\n+            if (path != null && path.equals(data.getURI()))\n+            {\n+               ((DataEditingTarget) target).updateData(data);\n+\n+               ensureVisible(false);\n+               column.selectTab(target.asWidget());\n+               return;\n+            }\n+         }\n+      });\n+\n+      ensureVisible(true);\n+      server_.newDocument(\n+         FileTypeRegistry.DATAFRAME.getTypeId(),\n+         null,\n+         (JsObject) data.cast(),\n+         new SimpleRequestCallback<SourceDocument>(\"Show Data Frame\")\n+         {\n+            @Override\n+            public void onResponseReceived(SourceDocument response)\n+            {\n+               activeColumn_.addTab(response, Source.OPEN_INTERACTIVE);\n+            }\n+         });\n+   }\n+\n+   public void showUnsavedChangesDialog(\n+      String title,\n+      ArrayList<UnsavedChangesTarget> dirtyTargets,\n+      OperationWithInput<UnsavedChangesDialog.Result> saveOperation,\n+      Command onCancelled)\n+   {\n+      activeColumn_.showUnsavedChangesDialog(title, dirtyTargets, saveOperation, onCancelled);\n+   }\n+\n+   public boolean insertSource(String code, boolean isBlock)\n+   {\n+      if (!hasActiveEditor())\n+         return false;\n+      return activeColumn_.insertCode(code, isBlock);\n+   }\n+\n+   @Handler\n+   public void onMoveTabRight()\n+   {\n+      activeColumn_.moveTab(activeColumn_.getPhysicalTabIndex(), 1);\n+   }\n+\n+   @Handler\n+   public void onMoveTabLeft()\n+   {\n+      activeColumn_.moveTab(activeColumn_.getPhysicalTabIndex(), -1);\n+   }\n+\n+   @Handler\n+   public void onMoveTabToFirst()\n+   {\n+      activeColumn_.moveTab(activeColumn_.getPhysicalTabIndex(),\n+         activeColumn_.getPhysicalTabIndex() * -1);\n+   }\n+\n+   @Handler\n+   public void onMoveTabToLast()\n+   {\n+      activeColumn_.moveTab(activeColumn_.getPhysicalTabIndex(),\n+         (activeColumn_.getTabCount() -\n+            activeColumn_.getPhysicalTabIndex()) - 1);\n+   }\n+\n+   @Handler\n+   public void onSwitchToTab()\n+   {\n+      if (activeColumn_.getTabCount() == 0)\n+         return;\n+      showOverflowPopout();\n+   }\n+\n+   @Handler\n+   public void onFirstTab()\n+   {\n+      if (activeColumn_.getTabCount() == 0)\n+         return;\n+\n+      ensureVisible(false);\n+      if (activeColumn_.getTabCount() > 0)\n+         activeColumn_.setPhysicalTabIndex(0);\n+   }\n+\n+   @Handler\n+   public void onPreviousTab()\n+   {\n+      switchToTab(-1, userPrefs_.wrapTabNavigation().getValue());\n+   }\n+\n+   @Handler\n+   public void onNextTab()\n+   {\n+      switchToTab(1, userPrefs_.wrapTabNavigation().getValue());\n+   }\n+\n+   @Handler\n+   public void onLastTab()\n+   {\n+      if (activeColumn_.getTabCount() == 0)\n+         return;\n+\n+      activeColumn_.ensureVisible(false);\n+      if (activeColumn_.getTabCount() > 0)\n+         activeColumn_.setPhysicalTabIndex(activeColumn_.getTabCount() - 1);\n+   }\n+\n+   @Handler\n+   public void onCloseSourceDoc()\n+   {\n+      closeSourceDoc(true);\n+   }\n+\n+   @Handler\n+   public void onFindInFiles()\n+   {\n+      String searchPattern = \"\";\n+      if (hasActiveEditor() && activeColumn_.getActiveEditor() instanceof TextEditingTarget)\n+      {\n+         TextEditingTarget textEditor = (TextEditingTarget) activeColumn_.getActiveEditor();\n+         String selection = textEditor.getSelectedText();\n+         boolean multiLineSelection = selection.indexOf('\\n') != -1;\n+\n+         if ((selection.length() != 0) && !multiLineSelection)\n+            searchPattern = selection;\n+      }\n+\n+      events_.fireEvent(new FindInFilesEvent(searchPattern));\n+   }\n+\n+   @Override\n+   public void onDebugModeChanged(DebugModeChangedEvent evt)\n+   {\n+      // when debugging ends, always disengage any active debug highlights\n+      if (!evt.debugging() && hasActiveEditor())\n+      {\n+         activeColumn_.getActiveEditor().endDebugHighlighting();\n+      }\n+   }\n+\n+   @Override\n+   public void onSessionInit(SessionInitEvent event)\n+   {\n+      new JSObjectStateValue(\n+         \"source-column-manager\",\n+         \"column-info\",\n+         ClientState.PROJECT_PERSISTENT,\n+         session_.getSessionInfo().getClientState(),\n+         false)\n+      {\n+         @Override\n+         protected void onInit(JsObject value)\n+         {\n+            if (value == null)\n+            {\n+               columnState_ = State.createState(JsUtil.toJsArrayString(getNames(false)));\n+               return;\n+            }\n+            columnState_ = value.cast();\n+            ArrayList<String> names = getNames(false);\n+            for (int i = 0;\n+                 i < columnState_.getNames().length && getSize()< columnState_.getNames().length;\n+                 i++)\n+            {\n+               String name = columnState_.getNames()[i];\n+               if (getByName(name) == null)\n+                  add(name, false);\n+               else\n+                  names.remove(name);\n+            }\n+         }\n+\n+         @Override\n+         protected JsObject getValue()\n+         {\n+            if (columnState_ != null)\n+               return columnState_.cast();\n+\n+            columnState_ = State.createState(JsUtil.toJsArrayString(getNames(false)));\n+            JsObject object = columnState_.<JsObject>cast().clone();\n+            return object;\n+         }\n+      };\n+   }\n+\n+   @Override\n+   public void onSourceExtendedTypeDetected(SourceExtendedTypeDetectedEvent e)\n+   {\n+      // set the extended type of the specified source file\n+\n+      EditingTarget target = findEditor(e.getDocId());\n+      if (target != null)\n+         target.adaptToExtendedFileType(e.getExtendedType());\n+   }\n+\n+   public void nextTabWithWrap()\n+   {\n+      switchToTab(1, true);\n+   }\n+\n+   public void prevTabWithWrap()\n+   {\n+      switchToTab(-1, true);\n+   }\n+\n+   private void switchToTab(int delta, boolean wrap)\n+   {\n+      if (getActive().getTabCount() == 0)\n+         return;\n+\n+      activeColumn_.ensureVisible(false);\n+\n+      int targetIndex = activeColumn_.getPhysicalTabIndex() + delta;\n+      if (targetIndex > (activeColumn_.getTabCount() - 1))\n+      {\n+         if (wrap)\n+            targetIndex = 0;\n+         else\n+            return;\n+      } else if (targetIndex < 0)\n+      {\n+         if (wrap)\n+            targetIndex = activeColumn_.getTabCount() - 1;\n+         else\n+            return;\n+      }\n+      activeColumn_.setPhysicalTabIndex(targetIndex);\n+   }\n+\n+   private void doActivateSource(final Command afterActivation)\n+   {\n+      activeColumn_.ensureVisible(false);\n+      if (hasActiveEditor())\n+      {\n+         activeColumn_.getActiveEditor().focus();\n+         activeColumn_.getActiveEditor().ensureCursorVisible();\n+      }\n+\n+      if (afterActivation != null)\n+         afterActivation.execute();\n+   }\n+\n+   // new doc functions\n+\n+   public void newRMarkdownV1Doc()\n+   {\n+      newSourceDocWithTemplate(FileTypeRegistry.RMARKDOWN,\n+         \"\",\n+         \"v1.Rmd\",\n+         Position.create(3, 0));\n+   }\n+\n+   public void newRMarkdownV2Doc()\n+   {\n+      rmarkdown_.showNewRMarkdownDialog(\n+         new OperationWithInput<NewRMarkdownDialog.Result>()\n+         {\n+            @Override\n+            public void execute(final NewRMarkdownDialog.Result result)\n+            {\n+               if (result == null)\n+               {\n+                  // No document chosen, just create an empty one\n+                  newSourceDocWithTemplate(FileTypeRegistry.RMARKDOWN, \"\", \"default.Rmd\");\n+               } else if (result.isNewDocument())\n+               {\n+                  NewRMarkdownDialog.RmdNewDocument doc =\n+                     result.getNewDocument();\n+                  String author = doc.getAuthor();\n+                  if (author.length() > 0)\n+                  {\n+                     userPrefs_.documentAuthor().setGlobalValue(author);\n+                     userPrefs_.writeUserPrefs();\n+                  }\n+                  newRMarkdownV2Doc(doc);\n+               } else\n+               {\n+                  newDocFromRmdTemplate(result);\n+               }\n+            }\n+         });\n+   }\n+\n+   private void newDocFromRmdTemplate(final NewRMarkdownDialog.Result result)\n+   {\n+      final RmdChosenTemplate template = result.getFromTemplate();\n+      if (template.createDir())\n+      {\n+         rmarkdown_.createDraftFromTemplate(template);\n+         return;\n+      }\n+\n+      rmarkdown_.getTemplateContent(template,\n+         new OperationWithInput<String>()\n+         {\n+            @Override\n+            public void execute(final String content)\n+            {\n+               if (content.length() == 0)\n+                  globalDisplay_.showErrorMessage(\"Template Content Missing\",\n+                     \"The template at \" + template.getTemplatePath() +\n+                        \" is missing.\");\n+               newDoc(FileTypeRegistry.RMARKDOWN, content, null);\n+            }\n+         });\n+   }\n+\n+\n+   private void newRMarkdownV2Doc(\n+      final NewRMarkdownDialog.RmdNewDocument doc)\n+   {\n+      rmarkdown_.frontMatterToYAML((RmdFrontMatter) doc.getJSOResult().cast(),\n+         null,\n+         new CommandWithArg<String>()\n+         {\n+            @Override\n+            public void execute(final String yaml)\n+            {\n+               String template = \"\";\n+               // select a template appropriate to the document type we're creating\n+               if (doc.getTemplate().equals(RmdTemplateData.PRESENTATION_TEMPLATE))\n+                  template = \"presentation.Rmd\";\n+               else if (doc.isShiny())\n+               {\n+                  if (doc.getFormat().endsWith(\n+                     RmdOutputFormat.OUTPUT_PRESENTATION_SUFFIX))\n+                     template = \"shiny_presentation.Rmd\";\n+                  else\n+                     template = \"shiny.Rmd\";\n+               } else\n+                  template = \"document.Rmd\";\n+               newSourceDocWithTemplate(FileTypeRegistry.RMARKDOWN,\n+                  \"\",\n+                  template,\n+                  Position.create(1, 0),\n+                  null,\n+                  new TransformerCommand<String>()\n+                  {\n+                     @Override\n+                     public String transform(String input)\n+                     {\n+                        return RmdFrontMatter.FRONTMATTER_SEPARATOR +\n+                           yaml +\n+                           RmdFrontMatter.FRONTMATTER_SEPARATOR + \"\\n\" +\n+                           input;\n+                     }\n+                  });\n+            }\n+         });\n+   }\n+\n+   public void newSourceDocWithTemplate(final TextFileType fileType,\n+                                        String name,\n+                                        String template)\n+   {\n+      newSourceDocWithTemplate(fileType, name, template, null);\n+   }\n+\n+   public void newSourceDocWithTemplate(final TextFileType fileType,\n+                                        String name,\n+                                        String template,\n+                                        final Position cursorPosition)\n+   {\n+      newSourceDocWithTemplate(fileType, name, template, cursorPosition, null);\n+   }\n+\n+   public void newSourceDocWithTemplate(\n+      final TextFileType fileType,\n+      String name,\n+      String template,\n+      final Position cursorPosition,\n+      final CommandWithArg<EditingTarget> onSuccess)\n+   {\n+      newSourceDocWithTemplate(fileType, name, template, cursorPosition, onSuccess, null);\n+   }\n+\n+   public void startDebug()\n+   {\n+      activeColumn_.setPendingDebugSelection();\n+   }\n+\n+   private EditingTarget selectTabWithDocPath(String path)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget editor = column.getEditorWithPath(path);\n+         if (editor != null)\n+         {\n+            column.selectTab(editor.asWidget());\n+            return editor;\n+         }\n+      }\n+      return null;\n+   }\n+\n+   private void newSourceDocWithTemplate(\n+      final TextFileType fileType,\n+      String name,\n+      String template,\n+      final Position cursorPosition,\n+      final CommandWithArg<EditingTarget> onSuccess,\n+      final TransformerCommand<String> contentTransformer)\n+   {\n+      final ProgressIndicator indicator = new GlobalProgressDelayer(\n+         globalDisplay_, 500, \"Creating new document...\").getIndicator();\n+\n+      server_.getSourceTemplate(name,\n+         template,\n+         new ServerRequestCallback<String>()\n+         {\n+            @Override\n+            public void onResponseReceived(String templateContents)\n+            {\n+               indicator.onCompleted();\n+\n+               if (contentTransformer != null)\n+                  templateContents = contentTransformer.transform(templateContents);\n+\n+               newDoc(fileType,\n+                  templateContents,\n+                  new ResultCallback<EditingTarget, ServerError>()\n+                  {\n+                     @Override\n+                     public void onSuccess(EditingTarget target)\n+                     {\n+                        if (cursorPosition != null)\n+                           target.setCursorPosition(cursorPosition);\n+\n+                        if (onSuccess != null)\n+                           onSuccess.execute(target);\n+                     }\n+                  });\n+            }\n+\n+            @Override\n+            public void onError(ServerError error)\n+            {\n+               indicator.onError(error.getUserMessage());\n+            }\n+         });\n+   }\n+\n+   public void newDoc(EditableFileType fileType,\n+                      ResultCallback<EditingTarget, ServerError> callback)\n+   {\n+      getActive().newDoc(fileType, callback);\n+   }\n+\n+   public void newDoc(EditableFileType fileType,\n+                      final String contents,\n+                      final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      getActive().newDoc(fileType, contents, resultCallback);\n+   }\n+\n+   public void disownDoc(String docId)\n+   {\n+      SourceColumn column = findByDocument(docId);\n+      column.closeDoc(docId);\n+   }\n+\n+   // When dragging between columns/windows, we need to be specific about which column we're\n+   // removing the document from as it may exist in more than one column. If the column is null,\n+   // it is assumed that we are a satellite window and do now have multiple displays.\n+   public void disownDocOnDrag(String docId, SourceColumn column)\n+   {\n+      if (column == null)\n+      {\n+         if (getSize() > 1)\n+            Debug.logWarning(\"Warning: No column was provided to remove the doc from.\");\n+         column = getActive();\n+      }\n+      column.closeDoc(docId);\n+      column.cancelTabDrag();\n+   }\n+\n+   public void selectTab(EditingTarget target)\n+   {\n+      SourceColumn column = findByDocument(target.getId());\n+      column.ensureVisible(false);\n+      column.selectTab(target.asWidget());\n+   }\n+\n+   public void closeTabs(JsArrayString ids)\n+   {\n+      if (ids != null)\n+         columnList_.forEach((column) -> column.closeTabs(ids));\n+   }\n+\n+   public void closeTabWithPath(String path, boolean interactive)\n+   {\n+      EditingTarget target = findEditorByPath(path);\n+      closeTab(target, interactive);\n+   }\n+\n+   public void closeTab(boolean interactive)\n+   {\n+      closeTab(activeColumn_.getActiveEditor(), interactive);\n+   }\n+\n+   public void closeTab(EditingTarget target, boolean interactive)\n+   {\n+      findByDocument(target.getId()).closeTab(target.asWidget(), interactive, null);\n+   }\n+\n+   public void closeTab(EditingTarget target, boolean interactive, Command onClosed)\n+   {\n+      findByDocument(target.getId()).closeTab(\n+         target.asWidget(), interactive, onClosed);\n+   }\n+\n+   public void closeAllTabs(boolean excludeActive, boolean excludeMain)\n+   {\n+      columnList_.forEach((column) -> {\n+         if (!excludeMain || !StringUtil.equals(column.getName(), MAIN_SOURCE_NAME))\n+         {\n+            cpsExecuteForEachEditor(column.getEditors(),\n+               new CPSEditingTargetCommand()\n+               {\n+                  @Override\n+                  public void execute(EditingTarget target, Command continuation)\n+                  {\n+                     if (excludeActive && target == activeColumn_.getActiveEditor())\n+                     {\n+                        continuation.execute();\n+                        return;\n+                     } else\n+                     {\n+                        column.closeTab(target.asWidget(), false, continuation);\n+                     }\n+                  }\n+               });\n+         }\n+      });\n+   }\n+\n+   void closeSourceDoc(boolean interactive)\n+   {\n+      if (activeColumn_.getTabCount() == 0)\n+         return;\n+\n+      closeTab(interactive);\n+   }\n+\n+   public void saveAllSourceDocs()\n+   {\n+      columnList_.forEach((column) -> cpsExecuteForEachEditor(\n+          column.getEditors(),\n+          (editingTarget, continuation) -> {\n+             if (editingTarget.dirtyState().getValue())\n+             {\n+                editingTarget.save(continuation);\n+             } else\n+             {\n+                continuation.execute();\n+             }\n+          }));\n+   }\n+\n+   public void revertUnsavedTargets(Command onCompleted)\n+   {\n+      ArrayList<EditingTarget> unsavedTargets = new ArrayList<>();\n+      columnList_.forEach((column) -> unsavedTargets.addAll(\n+          column.getUnsavedEditors(Source.TYPE_FILE_BACKED, null)));\n+\n+      // revert all of them\n+      cpsExecuteForEachEditor(\n+\n+         // targets the user chose not to save\n+         unsavedTargets,\n+\n+         // save each editor\n+          (saveTarget, continuation) -> {\n+             if (saveTarget.getPath() != null)\n+             {\n+                // file backed document -- revert it\n+                saveTarget.revertChanges(continuation);\n+             } else\n+             {\n+                // untitled document -- just close the tab non-interactively\n+                closeTab(saveTarget, false, continuation);\n+             }\n+          },\n+\n+         // onCompleted at the end\n+         onCompleted\n+      );\n+   }\n+\n+   public void closeAllLocalSourceDocs(String caption,\n+                                       Command onCompleted,\n+                                       final boolean excludeActive)\n+   {\n+      // save active editor for exclusion (it changes as we close tabs)\n+      final EditingTarget excludeEditor = (excludeActive) ? activeColumn_.getActiveEditor() :\n+         null;\n+\n+      // collect up a list of dirty documents\n+      ArrayList<EditingTarget> dirtyTargets = new ArrayList<>();\n+      columnList_.forEach((column) ->\n+          dirtyTargets.addAll(column.getDirtyEditors(excludeEditor)));\n+\n+      // create a command used to close all tabs\n+      final Command closeAllTabsCommand = () -> closeAllTabs(excludeActive, false);\n+\n+      saveEditingTargetsWithPrompt(caption,\n+         dirtyTargets,\n+         CommandUtil.join(closeAllTabsCommand,\n+            onCompleted),\n+         null);\n+   }\n+\n+   public ArrayList<Widget> consolidateColumns(int num)\n+   {\n+      // We are only removing the column from the column manager's knowledge.\n+      // Its widget still needs to be removed from the display so we return the widgets to be removed.\n+      ArrayList<Widget> result = new ArrayList<>();\n+      if (num >= columnList_.size() || num < 1)\n+         return result;\n+\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (!column.hasDoc())\n+         {\n+            if (column == activeColumn_)\n+               setActive(\"\");\n+            result.add(column.asWidget());\n+            columnList_.remove(column);\n+            if (num >= columnList_.size() || num == 1)\n+               break;\n+         }\n+      }\n+\n+      ArrayList<EditingTarget> moveEditors = new ArrayList<>();\n+      // if we could not remove empty columns to get to the desired amount, consolidate editors\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (!StringUtil.equals(column.getName(), MAIN_SOURCE_NAME))\n+         {\n+            moveEditors.addAll(column.getEditors());\n+            column.closeAllLocalSourceDocs();\n+            closeColumn(column.getName());\n+            if (columnList_.size() >= num || num == 1)\n+               break;\n+         }\n+      }\n+\n+      SourceColumn column = getByName(MAIN_SOURCE_NAME);\n+      assert(column != null);\n+      for (EditingTarget target : moveEditors)\n+      {\n+         column.addTab(\n+            target.asWidget(),\n+            target.getIcon(),\n+            target.getId(),\n+            target.getName().getValue(),\n+            target.getTabTooltip(), // used as tooltip, if non-null\n+            null,\n+            true);\n+      }\n+\n+      return result;\n+   }\n+\n+   public void closeAllColumns()\n+   {\n+      columnList_.forEach((column) -> closeColumn(column.getName()));\n+      Debug.logToConsole(\"closed all columns, new size: \" + getSize());\n+      assert getSize() == 0;\n+   }\n+\n+   public void closeColumn(String name)\n+   {\n+      SourceColumn column = getByName(name);\n+      if (column.getTabCount() > 0)\n+         return;\n+      if (column == activeColumn_)\n+         setActive(\"\");\n+\n+      columnList_.remove(getByName(name));\n+   }\n+\n+   public void ensureVisible(boolean newTabPending)\n+   {\n+      activeColumn_.ensureVisible(newTabPending);\n+   }\n+\n+   public void openFile(FileSystemItem file)\n+   {\n+      openFile(file, fileTypeRegistry_.getTextTypeForFile(file));\n+   }\n+\n+   public void openFile(FileSystemItem file, TextFileType fileType)\n+   {\n+      openFile(file,\n+         fileType,\n+         new CommandWithArg<EditingTarget>()\n+         {\n+            @Override\n+            public void execute(EditingTarget arg)\n+            {\n+\n+            }\n+         });\n+   }\n+\n+   public void openFile(final FileSystemItem file,\n+                        final TextFileType fileType,\n+                        final CommandWithArg<EditingTarget> executeOnSuccess)\n+   {\n+      // add this work to the queue\n+      openFileQueue_.add(new OpenFileEntry(file, fileType, executeOnSuccess));\n+\n+      // begin queue processing if it's the only work in the queue\n+      if (openFileQueue_.size() == 1)\n+         processOpenFileQueue();\n+   }\n+\n+   private void editFile(final String path)\n+   {\n+      server_.ensureFileExists(\n+         path,\n+         new ServerRequestCallback<Boolean>()\n+         {\n+            @Override\n+            public void onResponseReceived(Boolean success)\n+            {\n+               if (success)\n+               {\n+                  FileSystemItem file = FileSystemItem.createFile(path);\n+                  openFile(file);\n+               }\n+            }\n+\n+            @Override\n+            public void onError(ServerError error)\n+            {\n+               Debug.logError(error);\n+            }\n+         });\n+   }\n+\n+   public void openProjectDocs(final Session session, boolean mainColumn)\n+   {\n+      if (mainColumn && activeColumn_ != getByName(MAIN_SOURCE_NAME))\n+         setActive(MAIN_SOURCE_NAME);\n+\n+      JsArrayString openDocs = session.getSessionInfo().getProjectOpenDocs();\n+      if (openDocs.length() > 0)\n+      {\n+         // set new tab pending for the duration of the continuation\n+         activeColumn_.incrementNewTabPending();\n+\n+         // create a continuation for opening the source docs\n+         SerializedCommandQueue openCommands = new SerializedCommandQueue();\n+\n+         for (int i = 0; i < openDocs.length(); i++)\n+         {\n+            String doc = openDocs.get(i);\n+            final FileSystemItem fsi = FileSystemItem.createFile(doc);\n+\n+            openCommands.addCommand(new SerializedCommand()\n+            {\n+\n+               @Override\n+               public void onExecute(final Command continuation)\n+               {\n+                  openFile(fsi,\n+                     fileTypeRegistry_.getTextTypeForFile(fsi),\n+                     new CommandWithArg<EditingTarget>()\n+                     {\n+                        @Override\n+                        public void execute(EditingTarget arg)\n+                        {\n+                           continuation.execute();\n+                        }\n+                     });\n+               }\n+            });\n+         }\n+\n+         // decrement newTabPending and select first tab when done\n+         openCommands.addCommand(new SerializedCommand()\n+         {\n+\n+            @Override\n+            public void onExecute(Command continuation)\n+            {\n+               activeColumn_.decrementNewTabPending();\n+               onFirstTab();\n+               continuation.execute();\n+            }\n+         });\n+\n+         // execute the continuation\n+         openCommands.run();\n+      }\n+   }\n+\n+   public void fireDocTabsChanged()\n+   {\n+      activeColumn_.fireDocTabsChanged();\n+   }\n+\n+   private boolean hasDoc()\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         if (column.hasDoc())\n+            return true;\n+      }\n+      return false;\n+   }\n+\n+   private void vimSetTabIndex(int index)\n+   {\n+      int tabCount = activeColumn_.getTabCount();\n+      if (index >= tabCount)\n+         return;\n+      activeColumn_.setPhysicalTabIndex(index);\n+   }\n+\n+   private void processOpenFileQueue()\n+   {\n+      // no work to do\n+      if (openFileQueue_.isEmpty())\n+         return;\n+\n+      // find the first work unit\n+      final OpenFileEntry entry = openFileQueue_.peek();\n+\n+      // define command to advance queue\n+      final Command processNextEntry = new Command()\n+      {\n+         @Override\n+         public void execute()\n+         {\n+            openFileQueue_.remove();\n+            if (!openFileQueue_.isEmpty())\n+               processOpenFileQueue();\n+\n+         }\n+      };\n+      openFile(\n+         entry.file,\n+         entry.fileType,\n+         new ResultCallback<EditingTarget, ServerError>()\n+         {\n+            @Override\n+            public void onSuccess(EditingTarget target)\n+            {\n+               processNextEntry.execute();\n+               if (entry.executeOnSuccess != null)\n+                  entry.executeOnSuccess.execute(target);\n+            }\n+\n+            @Override\n+            public void onCancelled()\n+            {\n+               super.onCancelled();\n+               processNextEntry.execute();\n+            }\n+\n+            @Override\n+            public void onFailure(ServerError error)\n+            {\n+               String message = error.getUserMessage();\n+\n+               // see if a special message was provided\n+               JSONValue errValue = error.getClientInfo();\n+               if (errValue != null)\n+               {\n+                  JSONString errMsg = errValue.isString();\n+                  if (errMsg != null)\n+                     message = errMsg.stringValue();\n+               }\n+\n+               globalDisplay_.showMessage(GlobalDisplay.MSG_ERROR,\n+                  \"Error while opening file\",\n+                  message);\n+\n+               processNextEntry.execute();\n+            }\n+         });\n+   }\n+\n+   // top-level wrapper for opening files. takes care of:\n+   //  - making sure the view is visible\n+   //  - checking whether it is already open and re-selecting its tab\n+   //  - prohibit opening very large files (>500KB)\n+   //  - confirmation of opening large files (>100KB)\n+   //  - finally, actually opening the file from the server\n+   //    via the call to the lower level openFile method\n+   public void openFile(final FileSystemItem file,\n+                        final TextFileType fileType,\n+                        final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      activeColumn_.ensureVisible(true);\n+\n+      if (fileType.isRNotebook())\n+      {\n+         openNotebook(file, fileType, resultCallback);\n+         return;\n+      }\n+\n+      if (file == null)\n+      {\n+         newDoc(fileType, resultCallback);\n+         return;\n+      }\n+\n+      if (openFileAlreadyOpen(file, resultCallback))\n+         return;\n+\n+      EditingTarget target = editingTargetSource_.getEditingTarget(fileType);\n+\n+      if (file.getLength() > target.getFileSizeLimit())\n+      {\n+         if (resultCallback != null)\n+            resultCallback.onCancelled();\n+         showFileTooLargeWarning(file, target.getFileSizeLimit());\n+      } else if (file.getLength() > target.getLargeFileSize())\n+      {\n+         confirmOpenLargeFile(file, new Operation()\n+         {\n+            public void execute()\n+            {\n+               openFileFromServer(file, fileType, resultCallback);\n+            }\n+         }, new Operation()\n+         {\n+            public void execute()\n+            {\n+               // user (wisely) cancelled\n+               if (resultCallback != null)\n+                  resultCallback.onCancelled();\n+            }\n+         });\n+      } else\n+      {\n+         openFileFromServer(file, fileType, resultCallback);\n+      }\n+   }\n+\n+   public void openNotebook(\n+      final FileSystemItem rmdFile,\n+      final SourceDocumentResult doc,\n+      final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      if (!StringUtil.isNullOrEmpty(doc.getDocPath()))\n+      {\n+         // this happens if we created the R Markdown file, or if the R Markdown\n+         // file on disk matched the one inside the notebook\n+         openFileFromServer(rmdFile,\n+            FileTypeRegistry.RMARKDOWN, resultCallback);\n+      } else if (!StringUtil.isNullOrEmpty(doc.getDocId()))\n+      {\n+         // this happens when we have to open an untitled buffer for the the\n+         // notebook (usually because the of a conflict between the Rmd on disk\n+         // and the one in the .nb.html file)\n+         server_.getSourceDocument(doc.getDocId(),\n+            new ServerRequestCallback<SourceDocument>()\n+            {\n+               @Override\n+               public void onResponseReceived(SourceDocument doc)\n+               {\n+                  // create the editor\n+                  EditingTarget target = getActive().addTab(doc, Source.OPEN_INTERACTIVE);\n+\n+                  // show a warning bar\n+                  if (target instanceof TextEditingTarget)\n+                  {\n+                     ((TextEditingTarget) target).showWarningMessage(\n+                        \"This notebook has the same name as an R Markdown \" +\n+                           \"file, but doesn't match it.\");\n+                  }\n+                  resultCallback.onSuccess(target);\n+               }\n+\n+               @Override\n+               public void onError(ServerError error)\n+               {\n+                  globalDisplay_.showErrorMessage(\n+                     \"Notebook Open Failed\",\n+                     \"This notebook could not be opened. \" +\n+                        \"If the error persists, try removing the \" +\n+                        \"accompanying R Markdown file. \\n\\n\" +\n+                        error.getMessage());\n+                  resultCallback.onFailure(error);\n+               }\n+            });\n+      }\n+   }\n+\n+   public void beforeShow()\n+   {\n+      columnList_.forEach((column) -> column.onBeforeShow());\n+   }\n+\n+   public void beforeShow(String name)\n+   {\n+      SourceColumn column = getByName(name);\n+      if (column == null)\n+      {\n+         Debug.logWarning(\"WARNING: Unknown column \" + name);\n+         return;\n+      }\n+      column.onBeforeShow();\n+   }\n+\n+   public void inEditorForId(String id, OperationWithInput<EditingTarget> onEditorLocated)\n+   {\n+      EditingTarget editor = findEditor(id);\n+      if (editor != null)\n+         onEditorLocated.execute(editor);\n+   }\n+\n+   public void inEditorForPath(String path, OperationWithInput<EditingTarget> onEditorLocated)\n+   {\n+      EditingTarget editor = findEditorByPath(path);\n+      if (editor != null)\n+         onEditorLocated.execute(editor);\n+   }\n+\n+   public void withTarget(String id, CommandWithArg<TextEditingTarget> command)\n+   {\n+      withTarget(id, command, null);\n+   }\n+\n+   public void withTarget(String id,\n+                          CommandWithArg<TextEditingTarget> command,\n+                          Command onFailure)\n+   {\n+      EditingTarget target = StringUtil.isNullOrEmpty(id)\n+         ? activeColumn_.getActiveEditor()\n+         : findEditor(id);\n+\n+      if (target == null)\n+      {\n+         if (onFailure != null)\n+            onFailure.execute();\n+         return;\n+      }\n+\n+      if (!(target instanceof TextEditingTarget))\n+      {\n+         if (onFailure != null)\n+            onFailure.execute();\n+         return;\n+      }\n+\n+      command.execute((TextEditingTarget) target);\n+   }\n+\n+   public HashSet<AppCommand> getDynamicCommands()\n+   {\n+      return dynamicCommands_;\n+   }\n+\n+   private void getEditorContext(String id, String path, DocDisplay docDisplay)\n+   {\n+      getEditorContext(id, path, docDisplay, server_);\n+   }\n+\n+   public static void getEditorContext(String id, String path, DocDisplay docDisplay,\n+                                       SourceServerOperations server)\n+   {\n+      AceEditor editor = (AceEditor) docDisplay;\n+      Selection selection = editor.getNativeSelection();\n+      Range[] ranges = selection.getAllRanges();\n+\n+      // clamp ranges to document boundaries\n+      for (Range range : ranges)\n+      {\n+         Position start = range.getStart();\n+         start.setRow(MathUtil.clamp(start.getRow(), 0, editor.getRowCount()));\n+         start.setColumn(MathUtil.clamp(start.getColumn(), 0, editor.getLine(start.getRow()).length()));\n+\n+         Position end = range.getEnd();\n+         end.setRow(MathUtil.clamp(end.getRow(), 0, editor.getRowCount()));\n+         end.setColumn(MathUtil.clamp(end.getColumn(), 0, editor.getLine(end.getRow()).length()));\n+      }\n+\n+      JsArray<GetEditorContextEvent.DocumentSelection> docSelections = JavaScriptObject.createArray().cast();\n+      for (Range range : ranges)\n+      {\n+         docSelections.push(GetEditorContextEvent.DocumentSelection.create(\n+            range,\n+            editor.getTextForRange(range)));\n+      }\n+\n+      id = StringUtil.notNull(id);\n+      path = StringUtil.notNull(path);\n+\n+      GetEditorContextEvent.SelectionData data =\n+         GetEditorContextEvent.SelectionData.create(id, path, editor.getCode(), docSelections);\n+\n+      server.getEditorContextCompleted(data, new VoidServerRequestCallback());\n+   }\n+\n+   private void initDynamicCommands()\n+   {\n+      dynamicCommands_ = new HashSet<AppCommand>();\n+      dynamicCommands_.add(commands_.saveSourceDoc());\n+      dynamicCommands_.add(commands_.reopenSourceDocWithEncoding());\n+      dynamicCommands_.add(commands_.saveSourceDocAs());\n+      dynamicCommands_.add(commands_.saveSourceDocWithEncoding());\n+      dynamicCommands_.add(commands_.printSourceDoc());\n+      dynamicCommands_.add(commands_.vcsFileLog());\n+      dynamicCommands_.add(commands_.vcsFileDiff());\n+      dynamicCommands_.add(commands_.vcsFileRevert());\n+      dynamicCommands_.add(commands_.executeCode());\n+      dynamicCommands_.add(commands_.executeCodeWithoutFocus());\n+      dynamicCommands_.add(commands_.executeAllCode());\n+      dynamicCommands_.add(commands_.executeToCurrentLine());\n+      dynamicCommands_.add(commands_.executeFromCurrentLine());\n+      dynamicCommands_.add(commands_.executeCurrentFunction());\n+      dynamicCommands_.add(commands_.executeCurrentSection());\n+      dynamicCommands_.add(commands_.executeLastCode());\n+      dynamicCommands_.add(commands_.insertChunk());\n+      dynamicCommands_.add(commands_.insertSection());\n+      dynamicCommands_.add(commands_.executeSetupChunk());\n+      dynamicCommands_.add(commands_.executePreviousChunks());\n+      dynamicCommands_.add(commands_.executeSubsequentChunks());\n+      dynamicCommands_.add(commands_.executeCurrentChunk());\n+      dynamicCommands_.add(commands_.executeNextChunk());\n+      dynamicCommands_.add(commands_.previewJS());\n+      dynamicCommands_.add(commands_.previewSql());\n+      dynamicCommands_.add(commands_.sourceActiveDocument());\n+      dynamicCommands_.add(commands_.sourceActiveDocumentWithEcho());\n+      dynamicCommands_.add(commands_.knitDocument());\n+      dynamicCommands_.add(commands_.toggleRmdVisualMode());\n+      dynamicCommands_.add(commands_.enableProsemirrorDevTools());\n+      dynamicCommands_.add(commands_.previewHTML());\n+      dynamicCommands_.add(commands_.compilePDF());\n+      dynamicCommands_.add(commands_.compileNotebook());\n+      dynamicCommands_.add(commands_.synctexSearch());\n+      dynamicCommands_.add(commands_.popoutDoc());\n+      dynamicCommands_.add(commands_.returnDocToMain());\n+      dynamicCommands_.add(commands_.findReplace());\n+      dynamicCommands_.add(commands_.findNext());\n+      dynamicCommands_.add(commands_.findPrevious());\n+      dynamicCommands_.add(commands_.findFromSelection());\n+      dynamicCommands_.add(commands_.replaceAndFind());\n+      dynamicCommands_.add(commands_.extractFunction());\n+      dynamicCommands_.add(commands_.extractLocalVariable());\n+      dynamicCommands_.add(commands_.commentUncomment());\n+      dynamicCommands_.add(commands_.reindent());\n+      dynamicCommands_.add(commands_.reflowComment());\n+      dynamicCommands_.add(commands_.jumpTo());\n+      dynamicCommands_.add(commands_.jumpToMatching());\n+      dynamicCommands_.add(commands_.goToHelp());\n+      dynamicCommands_.add(commands_.goToDefinition());\n+      dynamicCommands_.add(commands_.setWorkingDirToActiveDoc());\n+      dynamicCommands_.add(commands_.debugDumpContents());\n+      dynamicCommands_.add(commands_.debugImportDump());\n+      dynamicCommands_.add(commands_.goToLine());\n+      dynamicCommands_.add(commands_.checkSpelling());\n+      dynamicCommands_.add(commands_.wordCount());\n+      dynamicCommands_.add(commands_.codeCompletion());\n+      dynamicCommands_.add(commands_.findUsages());\n+      dynamicCommands_.add(commands_.debugBreakpoint());\n+      dynamicCommands_.add(commands_.vcsViewOnGitHub());\n+      dynamicCommands_.add(commands_.vcsBlameOnGitHub());\n+      dynamicCommands_.add(commands_.editRmdFormatOptions());\n+      dynamicCommands_.add(commands_.reformatCode());\n+      dynamicCommands_.add(commands_.showDiagnosticsActiveDocument());\n+      dynamicCommands_.add(commands_.renameInScope());\n+      dynamicCommands_.add(commands_.insertRoxygenSkeleton());\n+      dynamicCommands_.add(commands_.expandSelection());\n+      dynamicCommands_.add(commands_.shrinkSelection());\n+      dynamicCommands_.add(commands_.toggleDocumentOutline());\n+      dynamicCommands_.add(commands_.knitWithParameters());\n+      dynamicCommands_.add(commands_.clearKnitrCache());\n+      dynamicCommands_.add(commands_.goToNextSection());\n+      dynamicCommands_.add(commands_.goToPrevSection());\n+      dynamicCommands_.add(commands_.goToNextChunk());\n+      dynamicCommands_.add(commands_.goToPrevChunk());\n+      dynamicCommands_.add(commands_.profileCode());\n+      dynamicCommands_.add(commands_.profileCodeWithoutFocus());\n+      dynamicCommands_.add(commands_.saveProfileAs());\n+      dynamicCommands_.add(commands_.restartRClearOutput());\n+      dynamicCommands_.add(commands_.restartRRunAllChunks());\n+      dynamicCommands_.add(commands_.notebookCollapseAllOutput());\n+      dynamicCommands_.add(commands_.notebookExpandAllOutput());\n+      dynamicCommands_.add(commands_.notebookClearOutput());\n+      dynamicCommands_.add(commands_.notebookClearAllOutput());\n+      dynamicCommands_.add(commands_.notebookToggleExpansion());\n+      dynamicCommands_.add(commands_.sendToTerminal());\n+      dynamicCommands_.add(commands_.openNewTerminalAtEditorLocation());\n+      dynamicCommands_.add(commands_.sendFilenameToTerminal());\n+      dynamicCommands_.add(commands_.renameSourceDoc());\n+      dynamicCommands_.add(commands_.sourceAsLauncherJob());\n+      dynamicCommands_.add(commands_.sourceAsJob());\n+      dynamicCommands_.add(commands_.runSelectionAsJob());\n+      dynamicCommands_.add(commands_.runSelectionAsLauncherJob());\n+      dynamicCommands_.add(commands_.toggleSoftWrapMode());\n+      for (AppCommand command : dynamicCommands_)\n+      {\n+         command.setVisible(false);\n+         command.setEnabled(false);\n+      }\n+   }\n+\n+   public void initVimCommands()\n+   {\n+      vimCommands_.save(this);\n+      vimCommands_.selectTabIndex(this);\n+      vimCommands_.selectNextTab(this);\n+      vimCommands_.selectPreviousTab(this);\n+      vimCommands_.closeActiveTab(this);\n+      vimCommands_.closeAllTabs(this);\n+      vimCommands_.createNewDocument(this);\n+      vimCommands_.saveAndCloseActiveTab(this);\n+      vimCommands_.readFile(this, userPrefs_.defaultEncoding().getValue());\n+      vimCommands_.runRScript(this);\n+      vimCommands_.reflowText(this);\n+      vimCommands_.showVimHelp(\n+          RStudioGinjector.INSTANCE.getShortcutViewer());\n+      vimCommands_.showHelpAtCursor(this);\n+      vimCommands_.reindent(this);\n+      vimCommands_.expandShrinkSelection(this);\n+      vimCommands_.openNextFile(this);\n+      vimCommands_.openPreviousFile(this);\n+      vimCommands_.addStarRegister();\n+   }\n+\n+   private void openNotebook(final FileSystemItem rnbFile,\n+                             final TextFileType fileType,\n+                             final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      // construct path to .Rmd\n+      final String rnbPath = rnbFile.getPath();\n+      final String rmdPath = FilePathUtils.filePathSansExtension(rnbPath) + \".Rmd\";\n+      final FileSystemItem rmdFile = FileSystemItem.createFile(rmdPath);\n+\n+      // if we already have associated .Rmd file open, then just edit it\n+      // TODO: should we perform conflict resolution here as well?\n+      if (openFileAlreadyOpen(rmdFile, resultCallback))\n+         return;\n+\n+      // ask the server to extract the .Rmd, then open that\n+      Command extractRmdCommand = new Command()\n+      {\n+         @Override\n+         public void execute()\n+         {\n+            server_.extractRmdFromNotebook(\n+                  rnbPath,\n+                  new ServerRequestCallback<SourceDocumentResult>()\n+                  {\n+                     @Override\n+                     public void onResponseReceived(SourceDocumentResult doc)\n+                     {\n+                        openNotebook(rmdFile, doc, resultCallback);\n+                     }\n+\n+                     @Override\n+                     public void onError(ServerError error)\n+                     {\n+                        globalDisplay_.showErrorMessage(\"Notebook Open Failed\",\n+                              \"This notebook could not be opened. \\n\\n\" +\n+                              error.getMessage());\n+                        resultCallback.onFailure(error);\n+                     }\n+                  });\n+         }\n+      };\n+\n+      dependencyManager_.withRMarkdown(\"R Notebook\", \"Using R Notebooks\", extractRmdCommand);\n+   }\n+\n+   private void openFileFromServer(\n+         final FileSystemItem file,\n+         final TextFileType fileType,\n+         final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      final Command dismissProgress = globalDisplay_.showProgress(\n+                                                         \"Opening file...\");\n+\n+      server_.openDocument(\n+            file.getPath(),\n+            fileType.getTypeId(),\n+            userPrefs_.defaultEncoding().getValue(),\n+            new ServerRequestCallback<SourceDocument>()\n+            {\n+               @Override\n+               public void onError(ServerError error)\n+               {\n+                  dismissProgress.execute();\n+                  pMruList_.get().remove(file.getPath());\n+                  Debug.logError(error);\n+                  if (resultCallback != null)\n+                     resultCallback.onFailure(error);\n+               }\n+\n+               @Override\n+               public void onResponseReceived(SourceDocument document)\n+               {\n+                  // if we are opening for a source navigation then we\n+                  // need to force Rmds into source mode\n+                  if (openingForSourceNavigation_)\n+                  {\n+                     document.getProperties()._setBoolean(\n+                        TextEditingTarget.RMD_VISUAL_MODE,\n+                        false\n+                     );\n+                  }\n+\n+                  dismissProgress.execute();\n+                  pMruList_.get().add(document.getPath());\n+                  EditingTarget target = getActive().addTab(document, Source.OPEN_INTERACTIVE);\n+                  if (resultCallback != null)\n+                     resultCallback.onSuccess(target);\n+               }\n+            });\n+   }\n+\n+   private boolean openFileAlreadyOpen(final FileSystemItem file,\n+                                       final ResultCallback<EditingTarget, ServerError> resultCallback)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         // check to see if any local editors have the file open\n+         for (int i = 0; i < column.getEditors().size(); i++)\n+         {\n+            EditingTarget target = column.getEditors().get(i);\n+            String thisPath = target.getPath();\n+            if (thisPath != null\n+                && thisPath.equalsIgnoreCase(file.getPath()))\n+            {\n+               column.selectTab(target.asWidget());\n+               pMruList_.get().add(thisPath);\n+               if (resultCallback != null)\n+                  resultCallback.onSuccess(target);\n+               return true;\n+            }\n+         }\n+      }\n+      return false;\n+   }\n+\n+   private void showFileTooLargeWarning(FileSystemItem file,\n+                                        long sizeLimit)\n+   {\n+      StringBuilder msg = new StringBuilder();\n+      msg.append(\"The file '\" + file.getName() + \"' is too \");\n+      msg.append(\"large to open in the source editor (the file is \");\n+      msg.append(StringUtil.formatFileSize(file.getLength()) + \" and the \");\n+      msg.append(\"maximum file size is \");\n+      msg.append(StringUtil.formatFileSize(sizeLimit) + \")\");\n+\n+      globalDisplay_.showMessage(GlobalDisplay.MSG_WARNING,\n+                                 \"Selected File Too Large\",\n+                                 msg.toString());\n+   }\n+\n+   private void confirmOpenLargeFile(FileSystemItem file,\n+                                     Operation openOperation,\n+                                     Operation noOperation)\n+   {\n+      StringBuilder msg = new StringBuilder();\n+      msg.append(\"The source file '\" + file.getName() + \"' is large (\");\n+      msg.append(StringUtil.formatFileSize(file.getLength()) + \") \");\n+      msg.append(\"and may take some time to open. \");\n+      msg.append(\"Are you sure you want to continue opening it?\");\n+      globalDisplay_.showYesNoMessage(GlobalDisplay.MSG_WARNING,\n+                                      \"Confirm Open\",\n+                                      msg.toString(),\n+                                      false, // Don't include cancel\n+                                      openOperation,\n+                                      noOperation,\n+                                      false);   // 'No' is default\n+   }\n+\n+   private void saveEditingTargetsWithPrompt(\n+      String title,\n+      ArrayList<EditingTarget> editingTargets,\n+      final Command onCompleted,\n+      final Command onCancelled)\n+   {\n+      // execute on completed right away if the list is empty\n+      if (editingTargets.size() ==  0)\n+      {\n+         onCompleted.execute();\n+      }\n+\n+      // if there is just one thing dirty then go straight to the save dialog\n+      else if (editingTargets.size() == 1)\n+      {\n+         editingTargets.get(0).saveWithPrompt(onCompleted, onCancelled);\n+      }\n+\n+      // otherwise use the multi save changes dialog\n+      else\n+      {\n+         // convert to UnsavedChangesTarget collection\n+         ArrayList<UnsavedChangesTarget> unsavedTargets =\n+            new ArrayList<UnsavedChangesTarget>();\n+         unsavedTargets.addAll(editingTargets);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 2087}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ1MTgzOnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumnManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNzowOVrOGiJiJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNzowOVrOGiJiJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDk2Ng==", "bodyText": "spelling: palette", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438460966", "createdAt": "2020-06-10T23:27:09Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/SourceColumnManager.java", "diffHunk": "@@ -0,0 +1,2377 @@\n+/*\n+ * SourceColumnManager.java\n+ *\n+ * Copyright (C) 2020 by RStudio, PBC\n+ *\n+ * Unless you have received this program directly from RStudio pursuant\n+ * to the terms of a commercial license agreement with RStudio, then\n+ * this program is licensed to you under the terms of version 3 of the\n+ * GNU Affero General Public License. This program is distributed WITHOUT\n+ * ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+ * AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+ *\n+ */\n+package org.rstudio.studio.client.workbench.views.source;\n+\n+import com.google.gwt.core.client.GWT;\n+import com.google.gwt.core.client.JavaScriptObject;\n+import com.google.gwt.core.client.JsArray;\n+import com.google.gwt.core.client.JsArrayString;\n+import com.google.gwt.event.dom.client.ChangeEvent;\n+import com.google.gwt.event.dom.client.ChangeHandler;\n+import com.google.gwt.json.client.JSONString;\n+import com.google.gwt.json.client.JSONValue;\n+import com.google.gwt.user.client.Command;\n+import com.google.gwt.user.client.ui.Widget;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.rstudio.core.client.*;\n+import org.rstudio.core.client.command.AppCommand;\n+import org.rstudio.core.client.command.Handler;\n+import org.rstudio.core.client.files.FileSystemItem;\n+import org.rstudio.core.client.js.JsObject;\n+import org.rstudio.core.client.js.JsUtil;\n+import org.rstudio.core.client.widget.Operation;\n+import org.rstudio.core.client.widget.OperationWithInput;\n+import org.rstudio.core.client.widget.ProgressIndicator;\n+import org.rstudio.studio.client.RStudioGinjector;\n+import org.rstudio.studio.client.application.events.EventBus;\n+import org.rstudio.studio.client.common.FilePathUtils;\n+import org.rstudio.studio.client.common.GlobalDisplay;\n+import org.rstudio.studio.client.common.GlobalProgressDelayer;\n+import org.rstudio.studio.client.common.SimpleRequestCallback;\n+import org.rstudio.studio.client.common.dependencies.DependencyManager;\n+import org.rstudio.studio.client.common.filetypes.*;\n+import org.rstudio.studio.client.common.synctex.Synctex;\n+import org.rstudio.studio.client.events.GetEditorContextEvent;\n+import org.rstudio.studio.client.palette.model.CommandPaletteEntrySource;\n+import org.rstudio.studio.client.palette.model.CommandPaletteItem;\n+import org.rstudio.studio.client.rmarkdown.model.RmdChosenTemplate;\n+import org.rstudio.studio.client.rmarkdown.model.RmdFrontMatter;\n+import org.rstudio.studio.client.rmarkdown.model.RmdOutputFormat;\n+import org.rstudio.studio.client.rmarkdown.model.RmdTemplateData;\n+import org.rstudio.studio.client.server.ServerError;\n+import org.rstudio.studio.client.server.ServerRequestCallback;\n+import org.rstudio.studio.client.server.VoidServerRequestCallback;\n+import org.rstudio.studio.client.workbench.FileMRUList;\n+import org.rstudio.studio.client.workbench.commands.Commands;\n+import org.rstudio.studio.client.workbench.events.SessionInitEvent;\n+import org.rstudio.studio.client.workbench.events.SessionInitHandler;\n+import org.rstudio.studio.client.workbench.model.ClientState;\n+import org.rstudio.studio.client.workbench.model.Session;\n+import org.rstudio.studio.client.workbench.model.UnsavedChangesTarget;\n+import org.rstudio.studio.client.workbench.model.helper.JSObjectStateValue;\n+import org.rstudio.studio.client.workbench.prefs.model.UserPrefs;\n+import org.rstudio.studio.client.workbench.prefs.model.UserState;\n+import org.rstudio.studio.client.workbench.ui.unsaved.UnsavedChangesDialog;\n+import org.rstudio.studio.client.workbench.views.environment.events.DebugModeChangedEvent;\n+import org.rstudio.studio.client.workbench.views.output.find.events.FindInFilesEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.EditingTargetSource;\n+import org.rstudio.studio.client.workbench.views.source.editors.codebrowser.CodeBrowserEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.data.DataEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.explorer.ObjectExplorerEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.explorer.model.ObjectExplorerHandle;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.AceEditor;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.DocDisplay;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTarget;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.TextEditingTargetRMarkdownHelper;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Position;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Range;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ace.Selection;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.events.EditingTargetSelectedEvent;\n+import org.rstudio.studio.client.workbench.views.source.editors.text.ui.NewRMarkdownDialog;\n+import org.rstudio.studio.client.workbench.views.source.events.*;\n+import org.rstudio.studio.client.workbench.views.source.model.*;\n+\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+@Singleton\n+public class SourceColumnManager implements SessionInitHandler,\n+                                            CommandPaletteEntrySource,\n+                                            SourceExtendedTypeDetectedEvent.Handler,\n+                                            DebugModeChangedEvent.Handler\n+{\n+   public interface CPSEditingTargetCommand\n+   {\n+      void execute(EditingTarget editingTarget, Command continuation);\n+   }\n+\n+   public static class State extends JavaScriptObject\n+   {\n+      public static native State createState(JsArrayString names) /*-{\n+         return {\n+            names: names\n+         }\n+      }-*/;\n+\n+      protected State()\n+      {}\n+\n+      public final String[] getNames()\n+      {\n+         return JsUtil.toStringArray(getNamesNative());\n+      }\n+\n+      private native JsArrayString getNamesNative() /*-{\n+          return this.names;\n+      }-*/;\n+   }\n+\n+   @Inject\n+   public SourceColumnManager(Source.Display display,\n+                              SourceServerOperations server,\n+                              GlobalDisplay globalDisplay,\n+                              Commands commands,\n+                              EditingTargetSource editingTargetSource,\n+                              FileTypeRegistry fileTypeRegistry,\n+                              EventBus events,\n+                              DependencyManager dependencyManager,\n+                              final Session session,\n+                              Synctex synctex,\n+                              UserPrefs userPrefs,\n+                              UserState userState,\n+                              Provider<FileMRUList> pMruList,\n+                              Provider<SourceWindowManager> pWindowManager)\n+   {\n+      SourceColumn column = GWT.create(SourceColumn.class);\n+      column.loadDisplay(MAIN_SOURCE_NAME, display, this);\n+      columnList_.add(column);\n+      setActive(column.getName());\n+\n+      server_ = server;\n+      commands_ = commands;\n+      globalDisplay_ = globalDisplay;\n+      editingTargetSource_ = editingTargetSource;\n+      fileTypeRegistry_ = fileTypeRegistry;\n+      events_ = events;\n+      dependencyManager_ = dependencyManager;\n+      session_ = session;\n+      synctex_ = synctex;\n+      userPrefs_ = userPrefs;\n+      userState_ = userState;\n+      pMruList_ = pMruList;\n+      pWindowManager_ = pWindowManager;\n+\n+      rmarkdown_ = new TextEditingTargetRMarkdownHelper();\n+      vimCommands_ = new SourceVimCommands();\n+      columnState_ = null;\n+      initDynamicCommands();\n+\n+      events_.addHandler(SourceExtendedTypeDetectedEvent.TYPE, this);\n+      events_.addHandler(DebugModeChangedEvent.TYPE, this);\n+\n+      events_.addHandler(SessionInitEvent.TYPE,this);\n+\n+      events_.addHandler(EditingTargetSelectedEvent.TYPE, new EditingTargetSelectedEvent.Handler()\n+      {\n+         @Override\n+         public void onEditingTargetSelected(EditingTargetSelectedEvent event)\n+         {\n+            setActive(event.getTarget());\n+         }\n+      });\n+\n+      events_.addHandler(SourceFileSavedEvent.TYPE, new SourceFileSavedHandler()\n+      {\n+         public void onSourceFileSaved(SourceFileSavedEvent event)\n+         {\n+            pMruList_.get().add(event.getPath());\n+         }\n+      });\n+\n+      events_.addHandler(DocTabActivatedEvent.TYPE, new DocTabActivatedEvent.Handler()\n+      {\n+         public void onDocTabActivated(DocTabActivatedEvent event)\n+         {\n+            setActiveDocId(event.getId());\n+         }\n+      });\n+\n+      sourceNavigationHistory_.addChangeHandler(new ChangeHandler()\n+      {\n+\n+         @Override\n+         public void onChange(ChangeEvent event)\n+         {\n+            columnList_.forEach((column) ->\n+               column.manageSourceNavigationCommands());\n+         }\n+      });\n+   }\n+\n+   public String add()\n+   {\n+      Source.Display display = GWT.create(SourcePane.class);\n+      return add(display, false);\n+   }\n+\n+   public String add(Source.Display display)\n+   {\n+      return add(display, false);\n+   }\n+\n+   public String add(String name, boolean updateState)\n+   {\n+      return add(name, false, updateState);\n+   }\n+\n+   public String add (String name, boolean activate, boolean updateState)\n+   {\n+      Source.Display display = GWT.create(SourcePane.class);\n+      return add(name, display, activate, updateState);\n+   }\n+\n+   public String add(Source.Display display, boolean activate)\n+   {\n+      return add(display, activate, true);\n+   }\n+\n+   public String add(Source.Display display, boolean activate, boolean updateState)\n+   {\n+      return add(COLUMN_PREFIX + StringUtil.makeRandomId(12),\n+                  display,\n+                  activate,\n+                  updateState);\n+   }\n+\n+   public String add(String name, Source.Display display, boolean activate, boolean updateState)\n+   {\n+      if (contains(name))\n+         return \"\";\n+\n+      SourceColumn column = GWT.create(SourceColumn.class);\n+      column.loadDisplay(name, display, this);\n+      columnList_.add(column);\n+\n+      if (activate || activeColumn_ == null)\n+         activeColumn_ = column;\n+\n+      if (updateState)\n+         columnState_ = State.createState(JsUtil.toJsArrayString(getNames(false)));\n+      return column.getName();\n+   }\n+\n+   public void initialSelect(int index)\n+   {\n+      getActive().initialSelect(index);\n+   }\n+\n+   public void setActive(String name)\n+   {\n+      if (StringUtil.isNullOrEmpty(name))\n+      {\n+         activeColumn_.setActiveEditor(\"\");\n+         activeColumn_ = null;\n+         return;\n+      }\n+\n+      String prevColumn = activeColumn_ == null ? \"\" : activeColumn_.getName();\n+      activeColumn_ = getByName(name);\n+\n+      // If the active column changed, we need to update the active editor\n+      if (!StringUtil.isNullOrEmpty(prevColumn) && !StringUtil.equals(name, prevColumn))\n+      {\n+         SourceColumn column = getByName(prevColumn);\n+         if (column == null)\n+            return;\n+         if (!hasActiveEditor())\n+         {\n+            Debug.logWarning(\"Setting to random editor.\");\n+            column.setActiveEditor();\n+         }\n+      }\n+   }\n+\n+   public void setActive(EditingTarget target)\n+   {\n+      activeColumn_ = findByDocument(target.getId());\n+      activeColumn_.setActiveEditor(target);\n+   }\n+\n+   public void setActiveDocId(String docId)\n+   {\n+      for (SourceColumn column : columnList_)\n+      {\n+         EditingTarget target = column.setActiveEditor(docId);\n+         if (target != null)\n+         {\n+            setActive(target);\n+            return;\n+         }\n+      }\n+      Debug.logWarning(\"Attempted to set unknown doc to active \" + docId);\n+   }\n+\n+   public void setOpeningForSourceNavigation(boolean value)\n+   {\n+      openingForSourceNavigation_ = value;\n+   }\n+\n+   public void activateColumns(final Command afterActivation)\n+   {\n+      if (!hasActiveEditor())\n+      {\n+         if (activeColumn_ == null)\n+            setActive(MAIN_SOURCE_NAME);\n+         newDoc(FileTypeRegistry.R, new ResultCallback<EditingTarget, ServerError>()\n+         {\n+            @Override\n+            public void onSuccess(EditingTarget target)\n+            {\n+               setActive(target);\n+               doActivateSource(afterActivation);\n+            }\n+         });\n+      } else\n+      {\n+         doActivateSource(afterActivation);\n+      }\n+   }\n+\n+   // This method sets activeColumn_ to the main column if it is null. It should be used in cases\n+   // where it is better for the column to be the main column than null.\n+   public SourceColumn getActive()\n+   {\n+      if (activeColumn_ != null)\n+         return activeColumn_;\n+      setActive(MAIN_SOURCE_NAME);\n+\n+      return activeColumn_;\n+   }\n+\n+   public String getActiveDocId()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getId();\n+      return null;\n+   }\n+\n+   public String getActiveDocPath()\n+   {\n+      if (hasActiveEditor())\n+         return activeColumn_.getActiveEditor().getPath();\n+      return null;\n+   }\n+\n+   public boolean hasActiveEditor()\n+   {\n+      return activeColumn_ != null && activeColumn_.getActiveEditor() != null;\n+   }\n+\n+   public boolean isActiveEditor(EditingTarget editingTarget)\n+   {\n+      return hasActiveEditor() && activeColumn_.getActiveEditor() == editingTarget;\n+   }\n+\n+   // see if there are additional command pallette items made available", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 370}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ1OTI1OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/TextEditingTargetVisualMode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozMDo1NFrOGiJmrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozMDo1NFrOGiJmrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MjEyNQ==", "bodyText": "not used", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438462125", "createdAt": "2020-06-10T23:30:54Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/TextEditingTargetVisualMode.java", "diffHunk": "@@ -47,6 +47,7 @@\n import org.rstudio.studio.client.panmirror.PanmirrorWidget;\n import org.rstudio.studio.client.panmirror.PanmirrorWidget.FormatSource;\n import org.rstudio.studio.client.panmirror.PanmirrorWriterOptions;\n+import org.rstudio.studio.client.panmirror.command.PanmirrorCommandUI;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ2MDI4OnYy", "diffSide": "RIGHT", "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/events/EditingTargetSelectedEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozMToyOFrOGiJnQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozMToyOFrOGiJnQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MjI3NQ==", "bodyText": "This source file needs our standard comment block header.", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r438462275", "createdAt": "2020-06-10T23:31:28Z", "author": {"login": "gtritchie"}, "path": "src/gwt/src/org/rstudio/studio/client/workbench/views/source/editors/text/events/EditingTargetSelectedEvent.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.rstudio.studio.client.workbench.views.source.editors.text.events;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b05e15e98d5dec936f440319aa15d74615743fc3"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzUzNDcyOnYy", "diffSide": "RIGHT", "path": "src/cpp/session/resources/schema/user-prefs-schema.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODoxMzo0NVrOGj9UBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODoxMzo0NVrOGj9UBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1Nzg5NA==", "bodyText": "Putting the option in this object will cause it to get reset if you use an older version of RStudio (i.e. if you make any layout changes in 1.3 then they will destroy your 1.4 layout as 1.3 will write out an object that doesn't include additional_source_columns). This is probably acceptable but if you need to work around it you could create a new pref that has layout for 1.4 only.", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r440357894", "createdAt": "2020-06-15T18:13:45Z", "author": {"login": "jmcphers"}, "path": "src/cpp/session/resources/schema/user-prefs-schema.json", "diffHunk": "@@ -187,6 +187,11 @@\n                 \"console_right_on_top\": {\n                     \"type\": \"boolean\",\n                     \"description\": \"Whether the console is on top when it is on the right side of the workbench.\"\n+                },\n+                \"additional_source_columns\": {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bc8a43b18ee18668c2e243dbeafbb44a3149d6f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzUzNjIyOnYy", "diffSide": "RIGHT", "path": "src/cpp/session/resources/schema/user-prefs-schema.json", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODoxNDoyMFrOGj9U-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxOToyMDoxN1rOGj_etQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1ODEzOQ==", "bodyText": "Recommend adding a title to this pref so that it can be toggled from the Command Palette (you'll also need to regenerate prefs afterward)", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r440358139", "createdAt": "2020-06-15T18:14:20Z", "author": {"login": "jmcphers"}, "path": "src/cpp/session/resources/schema/user-prefs-schema.json", "diffHunk": "@@ -200,10 +205,16 @@\n                 \"tabSet2\": [\"Files\", \"Plots\", \"Packages\", \"Help\", \"Viewer\"],\n                 \"hiddenTabSet\": [],\n                 \"console_left_on_top\": false,\n-                \"console_right_on_top\": true\n+                \"console_right_on_top\": true,\n+                \"additional_source_columns\": 0\n             },\n             \"description\": \"Layout of panes in the RStudio workbench.\"\n         },\n+        \"enable_additional_columns\": {\n+           \"type\": \"boolean\",\n+           \"default\": false,\n+           \"description\": \"Temporary flag to enable additional source columns.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bc8a43b18ee18668c2e243dbeafbb44a3149d6f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5MzM5Nw==", "bodyText": "Done!", "url": "https://github.com/rstudio/rstudio/pull/7079#discussion_r440393397", "createdAt": "2020-06-15T19:20:17Z", "author": {"login": "melissa-barca"}, "path": "src/cpp/session/resources/schema/user-prefs-schema.json", "diffHunk": "@@ -200,10 +205,16 @@\n                 \"tabSet2\": [\"Files\", \"Plots\", \"Packages\", \"Help\", \"Viewer\"],\n                 \"hiddenTabSet\": [],\n                 \"console_left_on_top\": false,\n-                \"console_right_on_top\": true\n+                \"console_right_on_top\": true,\n+                \"additional_source_columns\": 0\n             },\n             \"description\": \"Layout of panes in the RStudio workbench.\"\n         },\n+        \"enable_additional_columns\": {\n+           \"type\": \"boolean\",\n+           \"default\": false,\n+           \"description\": \"Temporary flag to enable additional source columns.\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1ODEzOQ=="}, "originalCommit": {"oid": "8bc8a43b18ee18668c2e243dbeafbb44a3149d6f"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4378, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}