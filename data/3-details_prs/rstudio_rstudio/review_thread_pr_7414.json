{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0NzcwMDg2", "number": 7414, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMToxODoxMVrOEQ2lCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMToxODoxMVrOEQ2lCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTA2ODkxOnYy", "diffSide": "RIGHT", "path": "src/gwt/acesupport/loader.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMToxODoxMVrOG1PQZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMToxODoxMVrOG1PQZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3NzY3MA==", "bodyText": "Are these APIs available on IE11? (Do we need to worry about IE11 for visual mode, or will we drop support for that in time for the 1.4 release?)", "url": "https://github.com/rstudio/rstudio/pull/7414#discussion_r458477670", "createdAt": "2020-07-22T01:18:11Z", "author": {"login": "kevinushey"}, "path": "src/gwt/acesupport/loader.js", "diffHunk": "@@ -253,33 +254,192 @@ oop.inherits(RStudioUndoManager, UndoManager);\n }).call(RStudioUndoManager.prototype);\n \n \n+// RStudioFontMetrics ----\n+\n+// This class is intended to provide font metrics to multiple Ace editor\n+// instances. This is useful because otherwise each editor does its own font\n+// metrics measurement, which can be expensive when there are many editors on\n+// the same page.\n+//\n+// See https://github.com/ajaxorg/ace/issues/2153 for more background on this\n+// issue.\n+\n+var RStudioFontMetrics = function(parentEl) {\n+    FontMetrics.call(this, parentEl);\n+};\n+oop.inherits(RStudioFontMetrics, FontMetrics);\n+\n+(function() {\n+\n+   this.checkForSizeChanges = function(size) {\n+      // compute size if we weren't given the size\n+      if (typeof(size) === \"undefined\") {\n+         size = this.$measureSizes();\n+      }\n+\n+      // don't attempt to recompute when container is hidden\n+      if (size && (size.height === 0 || size.width === 0)) {\n+         return;\n+      }\n+\n+      // update cached size and perform check for size\n+      this.$cachedSize = size;\n+      FontMetrics.prototype.checkForSizeChanges.call(this, size);\n+   };\n+\n+}).call(RStudioFontMetrics.prototype);\n \n // RStudioRenderer ----\n \n-var RStudioRenderer = function(container, theme) {\n+// queue of virtual renderers that need to be resized (redrawn)\n+var ResizeQueue = [];\n+\n+// method called on a timer to redraw all renderers that need it\n+var ProcessResizeQueue = function() {\n+   // sort the resize queue so that elements closer to the top get priority. if\n+   // we ever need to support opening a document with the viewport positioned\n+   // somewhere other than the top by default, this would need to take\n+   // scrollTop and friends into consideration\n+   ResizeQueue.sort(function(a, b) {\n+      return a.pos - b.pos;\n+   });\n+\n+   // walk the resize queue and schedule the actual work of resizing each\n+   // element; we do this on a zero timer so that it doesn't block the UI if\n+   // e.g. 200 resizes need to get processed at once\n+   for (var idx = 0; idx < ResizeQueue.length; idx++) {\n+      window.setTimeout(function(renderer, args) {\n+         // call base class resize method\n+         Renderer.prototype.onResize.apply(renderer, args);\n+      }, 0, ResizeQueue[idx].renderer, ResizeQueue[idx].args);\n+   }\n+\n+   // clear queue\n+   ResizeQueue = [];\n+   ResizeQueueTimer = 0;\n+};\n+\n+// id of window timer to process resize queue\n+var ResizeQueueTimer = 0;\n+\n+var RStudioRenderer = function(container, theme, fontMetrics) {\n    Renderer.call(this, container, theme);\n+\n+   // use caller-supplied font metrics when specified\n+   if (fontMetrics) {\n+      var self = this;\n+\n+      // destroy original font metrics object (so we don't have a dangling observer)\n+      if (self.$fontMetrics) {\n+         self.$fontMetrics.destroy();\n+      }\n+\n+      // replace with caller-supplied object\n+      self.$fontMetrics = fontMetrics;\n+      self.$textLayer.$setFontMetrics(fontMetrics);\n+\n+      // typically the font metrics change is what triggers a redraw when the\n+      // size becomes nonzero; this is needed so that e.g. an editor that was\n+      // initially rendered in an unselected tab can re-render itself with the\n+      // correct metrics when it becomes visible.\n+      //\n+      // without font the font metrics system, we need another way to trigger\n+      // that redraw, so we implement a direct resize observer here.\n+      self.$cachedHeight = 0;\n+      self.$resizeObserver = new window.ResizeObserver(function(e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074bf6dfadc35bcdbea99ad7fdf7f4296c8037d2"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4338, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}