{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMTA4Mjk1", "number": 6355, "title": "Ensure packages are installed in correct order to eliminate duplication", "bodyText": "Earlier in 1.3, we started installing R package dependencies one by one in a background job. This provides progress, makes it possible to get work done while packages are installing, and makes it easy to see any errors or information emitted during installation.\nHowever, it also created a problem (detailed in #6145) in which packages could be installed multiple times, which can be a significant issue when they're compiled.\nThis change fixes the issue by doing the following:\n\nReading the database of available packages (virtually guaranteed to be cached) to determine the dependencies of the packages that are about to be installed.\nTopologically sorting the package installation queue so that dependencies always appear before the packages that depend on them.\nInstalling the packages one by one in the sorted order.\n\nThis change is larger than we'd usually take so close to release. For this reason I've included a safety fallback which allows us to use an alternate installation script that's effectively identical to what we had in 1.2 -- it installs all the dependencies at once. This codepath will be used if an error occurs while trying to sort out dependencies, and it can also be permanently engaged with a preference (no UI for setting it since we don't think it will be common).\nFixes #6145.", "createdAt": "2020-02-27T22:36:26Z", "url": "https://github.com/rstudio/rstudio/pull/6355", "merged": true, "mergeCommit": {"oid": "8a723c5f7f75889aa81a4ade7ae7eeae3a4ff87a"}, "closed": true, "closedAt": "2020-03-03T18:45:23Z", "author": {"login": "jmcphers"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcH2pdxgH2gAyMzgxMTA4Mjk1OmI1Mzc0ODEwNzhhYmNiZTI1YzNmNjFhOTA2OGQ5MzFmMGMzNTk3Mjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKG09WAH2gAyMzgxMTA4Mjk1OjNmMzA4OTZiM2YwZWMxNDI1NTVhZjZmYzJhMDdmZGIzZjNkYzg1Njc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b537481078abcbe25c3f61a9068d931f0c359728", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/b537481078abcbe25c3f61a9068d931f0c359728", "committedDate": "2020-02-25T18:43:43Z", "message": "stubs and outline for capturing deps (WIP)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c27f2889e980fe2897ee2d275b227ecd41b22444", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/c27f2889e980fe2897ee2d275b227ecd41b22444", "committedDate": "2020-02-25T23:19:39Z", "message": "add test for simple topological sorting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65f4ff98845829e0119987dba1be7ccc64c62ff5", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/65f4ff98845829e0119987dba1be7ccc64c62ff5", "committedDate": "2020-02-26T00:16:29Z", "message": "map sorted packages to full dependency records"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c89ea1282c1542129d97176aa5d1b52816fcfc1", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/2c89ea1282c1542129d97176aa5d1b52816fcfc1", "committedDate": "2020-02-26T20:28:40Z", "message": "complete R side of dependency graph resolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1b48c8404b066895e3edade4a1e31a238aef923", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/e1b48c8404b066895e3edade4a1e31a238aef923", "committedDate": "2020-02-27T19:55:16Z", "message": "add user pref and generate appropriate installation script"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e6bee165929cb2bdaf24b31b15116c9aa20a7e1", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/3e6bee165929cb2bdaf24b31b15116c9aa20a7e1", "committedDate": "2020-02-27T22:13:03Z", "message": "omit dependencies already installed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb938ec9ed4ff811bf22ae28d7cc7d623f72f7c3", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/fb938ec9ed4ff811bf22ae28d7cc7d623f72f7c3", "committedDate": "2020-02-27T22:25:13Z", "message": "use renv to install packages even in combined mode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5", "committedDate": "2020-02-27T22:38:22Z", "message": "balance parens"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MTI2NDA4", "url": "https://github.com/rstudio/rstudio/pull/6355#pullrequestreview-366126408", "createdAt": "2020-02-28T02:24:26Z", "commit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMjoyNDoyN1rOFvnsJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzo0ODo1OVrOFvoxBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3NzY2OQ==", "bodyText": "Double-checking: if a package is installed, but its dependencies are not installed (or not up-to-date), those dependencies would still get installed. Is that correct?", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385477669", "createdAt": "2020-02-28T02:24:27Z", "author": {"login": "kevinushey"}, "path": "src/cpp/session/modules/SessionDependencies.R", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# SessionDependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+# Topographically sorts a list of packages (nodes) by their dependencies (edges). Note that this is\n+# not meant to be a general-purpose topo sort algorithm, and that it returns packages in the correct\n+# installation order, which is the exact reverse of traditional topological order. For example,\n+# given packages with dependencies a -> b -> c, we would want to install packages in the order \"c\",\n+# \"b\", and then \"a\".\n+.rs.addFunction(\"topoSortPackages\", function(nodes, edges) {\n+   # List of sorted packages\n+   sorted <- c()\n+\n+   # All nodes are unvisited to begin with\n+   visited <- c()\n+\n+   # Define recursive descent function for dependencies\n+   visit <- function(node, stack) {\n+      if (node %in% visited) {\n+         return()\n+      }\n+      if (node %in% stack) {\n+         # We visited this node while visiting itself; this is a dependency loop.\n+         stop(\"Package dependency graph is not a directed acyclic graph.\")\n+      }\n+\n+      # Visit all the edges of this node\n+      stack <- c(stack, node)\n+      for (edge in edges) {\n+         if (identical(edge$from, node)) {\n+            visit(edge$to, stack)\n+         }\n+      }\n+\n+      visited <<- c(visited, node)\n+      sorted <<- c(sorted, node)\n+   }\n+\n+   # Keep visiting unvisited nodes until we have visited all of them\n+   while (length(visited) < length(nodes)) {\n+      for (node in nodes) {\n+         if (!(node %in% visited)) {\n+            visit(node, c())\n+            break\n+         }\n+      }\n+   }\n+\n+   # Return topologically sorted list\n+   sorted\n+})\n+\n+.rs.addFunction(\"expandPkgDependencies\", function(dependencies) {\n+   .rs.expandDependencies(available.packages(), installed.packages(), dependencies)\n+})\n+\n+.rs.addFunction(\"expandDependencies\", function(available, installed, dependencies) {\n+   # A list of nodes (package names) to be installed\n+   nodes <- c()\n+\n+   # A list of details for packages to be installed\n+   packages <- dependencies\n+\n+   # A vector of lists, with \"from\" and \"to\" named elements giving the dependencies\n+   edges <- list()\n+\n+   # Get the dependencies of each package\n+   for (dep in dependencies) {\n+      # Add the package itself to the list of nodes\n+      nodes <- c(nodes, dep$name)\n+   }\n+\n+   # Look for dependencies of each package\n+   for (dep in dependencies) {\n+      # Dependencies are discovered from these three fields\n+      fields <- c(\"Depends\", \"Imports\", \"LinkingTo\")\n+      for (field in fields) {\n+         # Read contents for field (ignore if no contents)\n+         contents <- available[dep$name, field]\n+         if (!is.character(contents))\n+            next\n+\n+         # Split into a list of individual package names, using comma/whitespace as a delimiter\n+         prereqs <- strsplit(contents, \"\\\\s*,\\\\s*\")[[1]]\n+\n+         # Parse the package names into groups:\n+         # 1. The package name\n+         # 2. The package's requirements\n+         # 3. The package's version\n+         parsed <- regexec(\"([a-zA-Z0-9._]+)(?:\\\\s*\\\\(([><=]+)\\\\s*([0-9.-]+)\\\\))?\", prereqs)\n+         matches <- regmatches(prereqs, parsed)\n+\n+         # Decompose matches into additional nodes\n+         for (match in matches) {\n+            if (length(match) < 2)\n+               next\n+\n+            # Extract package name from regex result\n+            pkgName <- match[[2]]\n+\n+            # Ignore packages that don't have an entry in the availability list\n+            if (!(pkgName %in% rownames(available)))\n+                next\n+\n+            # Append to node list if we don't know about it already...\n+            if (!pkgName %in% nodes) {\n+               nodes <- c(nodes, pkgName)\n+\n+               # ... and it isn't already installed.\n+               if (!(pkgName %in% rownames(installed)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3ODUzNA==", "bodyText": "Nit: setting this explicitly will fail on Linux and may fail on macOS:\n> install.packages(\"digest\", type = \"both\")\nInstalling package into '/root/R/x86_64-pc-linux-gnu-library/3.4'\n(as 'lib' is unspecified)\nError in install.packages(\"digest\", type = \"both\") :\n  type == \"both\" can only be used on Windows or a CRAN build for macOS\n\nI'd recommend just leaving this unset / to the default value.", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385478534", "createdAt": "2020-02-28T02:28:16Z", "author": {"login": "kevinushey"}, "path": "src/cpp/session/modules/SessionDependencies.cpp", "diffHunk": "@@ -381,6 +463,10 @@ Error installDependencies(const json::JsonRpcRequest& request,\n             {\n                script += \"options(pkgType = 'source'); \";\n             }\n+            else\n+            {\n+               script += \"options(pkgType = 'both'); \";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3ODk1Mg==", "bodyText": "Nit: the result of available.packages() is normally a matrix rather than a data frame, and I don't think we explicitly convert the matrix to a data.frame when we use it. Would be worth testing with a matrix just to be sure we're mocking everything as expected.", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385478952", "createdAt": "2020-02-28T02:30:21Z", "author": {"login": "kevinushey"}, "path": "src/cpp/tests/testthat/test-dependencies.R", "diffHunk": "@@ -0,0 +1,115 @@\n+#\n+# test-dependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+context(\"dependencies\")\n+\n+test_that(\"simple topological sort works\", {\n+   # unsorted nodes\n+   nodes <- c(\"b\", \"a\", \"c\")\n+\n+   # edges a -> b -> c\n+   edges <- list(\n+      list(from = \"a\", to = \"b\"),\n+      list(from = \"b\", to = \"c\"))\n+   \n+   # in this configuration we'd expect to install package c, then package b, then package a\n+   expect_equal(.rs.topoSortPackages(nodes, edges), \n+                c(\"c\", \"b\", \"a\"))\n+})\n+\n+test_that(\"simple expansion and sorting is done correctly\", {\n+   # simulation of available.packages for a simple set of packages, foo -> bar -> baz\n+   available <- data.frame(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MTUyNA==", "bodyText": "Could we also add a test case where multiple packages depend on the same package?", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385491524", "createdAt": "2020-02-28T03:28:53Z", "author": {"login": "kevinushey"}, "path": "src/cpp/tests/testthat/test-dependencies.R", "diffHunk": "@@ -0,0 +1,115 @@\n+#\n+# test-dependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+context(\"dependencies\")\n+\n+test_that(\"simple topological sort works\", {\n+   # unsorted nodes\n+   nodes <- c(\"b\", \"a\", \"c\")\n+\n+   # edges a -> b -> c\n+   edges <- list(\n+      list(from = \"a\", to = \"b\"),\n+      list(from = \"b\", to = \"c\"))\n+   \n+   # in this configuration we'd expect to install package c, then package b, then package a\n+   expect_equal(.rs.topoSortPackages(nodes, edges), \n+                c(\"c\", \"b\", \"a\"))\n+})\n+\n+test_that(\"simple expansion and sorting is done correctly\", {\n+   # simulation of available.packages for a simple set of packages, foo -> bar -> baz\n+   available <- data.frame(\n+         Package   = c(\"foo\",                      \"bar\", \"baz\"),\n+         Version   = c(\"1.0\",                      \"1.1\", \"2.0\"),\n+         Depends   = c(\"R (>= 3.2), bar (>= 1.1)\",  NA,    NA),\n+         Imports   = c(NA,                          \"baz\", NA),\n+         LinkingTo = c(NA,                          NA,    NA),\n+         stringsAsFactors = FALSE)\n+   rownames(available) <- available[[1]]\n+\n+   # simulation of the dependencies we want to install; just one package\n+   dependencies <- list(list(\n+         name     = \"foo\",\n+         location = \"cran\",\n+         version  = \"1.0\",\n+         source   = FALSE))\n+\n+   result <- .rs.expandDependencies(available, data.frame(), dependencies)\n+\n+   expect_equal(!!result, list(\n+         list(name     = \"bar\",\n+              location = \"cran\",\n+              version  = \"1.1\",\n+              source   = FALSE),\n+         list(name     = \"foo\",\n+              location = \"cran\",\n+              version  = \"1.0\",\n+              source   = FALSE)))\n+})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MTc5MQ==", "bodyText": "I think we should test for is.na() here as well (since this could be NA_character_)", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385491791", "createdAt": "2020-02-28T03:30:13Z", "author": {"login": "kevinushey"}, "path": "src/cpp/session/modules/SessionDependencies.R", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# SessionDependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+# Topographically sorts a list of packages (nodes) by their dependencies (edges). Note that this is\n+# not meant to be a general-purpose topo sort algorithm, and that it returns packages in the correct\n+# installation order, which is the exact reverse of traditional topological order. For example,\n+# given packages with dependencies a -> b -> c, we would want to install packages in the order \"c\",\n+# \"b\", and then \"a\".\n+.rs.addFunction(\"topoSortPackages\", function(nodes, edges) {\n+   # List of sorted packages\n+   sorted <- c()\n+\n+   # All nodes are unvisited to begin with\n+   visited <- c()\n+\n+   # Define recursive descent function for dependencies\n+   visit <- function(node, stack) {\n+      if (node %in% visited) {\n+         return()\n+      }\n+      if (node %in% stack) {\n+         # We visited this node while visiting itself; this is a dependency loop.\n+         stop(\"Package dependency graph is not a directed acyclic graph.\")\n+      }\n+\n+      # Visit all the edges of this node\n+      stack <- c(stack, node)\n+      for (edge in edges) {\n+         if (identical(edge$from, node)) {\n+            visit(edge$to, stack)\n+         }\n+      }\n+\n+      visited <<- c(visited, node)\n+      sorted <<- c(sorted, node)\n+   }\n+\n+   # Keep visiting unvisited nodes until we have visited all of them\n+   while (length(visited) < length(nodes)) {\n+      for (node in nodes) {\n+         if (!(node %in% visited)) {\n+            visit(node, c())\n+            break\n+         }\n+      }\n+   }\n+\n+   # Return topologically sorted list\n+   sorted\n+})\n+\n+.rs.addFunction(\"expandPkgDependencies\", function(dependencies) {\n+   .rs.expandDependencies(available.packages(), installed.packages(), dependencies)\n+})\n+\n+.rs.addFunction(\"expandDependencies\", function(available, installed, dependencies) {\n+   # A list of nodes (package names) to be installed\n+   nodes <- c()\n+\n+   # A list of details for packages to be installed\n+   packages <- dependencies\n+\n+   # A vector of lists, with \"from\" and \"to\" named elements giving the dependencies\n+   edges <- list()\n+\n+   # Get the dependencies of each package\n+   for (dep in dependencies) {\n+      # Add the package itself to the list of nodes\n+      nodes <- c(nodes, dep$name)\n+   }\n+\n+   # Look for dependencies of each package\n+   for (dep in dependencies) {\n+      # Dependencies are discovered from these three fields\n+      fields <- c(\"Depends\", \"Imports\", \"LinkingTo\")\n+      for (field in fields) {\n+         # Read contents for field (ignore if no contents)\n+         contents <- available[dep$name, field]\n+         if (!is.character(contents))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MjY1Ng==", "bodyText": "Nit: do we need to be careful about the type argument here? Since we might want to install some packages from sources, and others from binaries, and the result of available.packages(type = \"source\") versus available.packages(type = \"binary\") could differ.", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385492656", "createdAt": "2020-02-28T03:34:25Z", "author": {"login": "kevinushey"}, "path": "src/cpp/session/modules/SessionDependencies.R", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# SessionDependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+# Topographically sorts a list of packages (nodes) by their dependencies (edges). Note that this is\n+# not meant to be a general-purpose topo sort algorithm, and that it returns packages in the correct\n+# installation order, which is the exact reverse of traditional topological order. For example,\n+# given packages with dependencies a -> b -> c, we would want to install packages in the order \"c\",\n+# \"b\", and then \"a\".\n+.rs.addFunction(\"topoSortPackages\", function(nodes, edges) {\n+   # List of sorted packages\n+   sorted <- c()\n+\n+   # All nodes are unvisited to begin with\n+   visited <- c()\n+\n+   # Define recursive descent function for dependencies\n+   visit <- function(node, stack) {\n+      if (node %in% visited) {\n+         return()\n+      }\n+      if (node %in% stack) {\n+         # We visited this node while visiting itself; this is a dependency loop.\n+         stop(\"Package dependency graph is not a directed acyclic graph.\")\n+      }\n+\n+      # Visit all the edges of this node\n+      stack <- c(stack, node)\n+      for (edge in edges) {\n+         if (identical(edge$from, node)) {\n+            visit(edge$to, stack)\n+         }\n+      }\n+\n+      visited <<- c(visited, node)\n+      sorted <<- c(sorted, node)\n+   }\n+\n+   # Keep visiting unvisited nodes until we have visited all of them\n+   while (length(visited) < length(nodes)) {\n+      for (node in nodes) {\n+         if (!(node %in% visited)) {\n+            visit(node, c())\n+            break\n+         }\n+      }\n+   }\n+\n+   # Return topologically sorted list\n+   sorted\n+})\n+\n+.rs.addFunction(\"expandPkgDependencies\", function(dependencies) {\n+   .rs.expandDependencies(available.packages(), installed.packages(), dependencies)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5Mjg3MQ==", "bodyText": "Also, IIUC this doesn't check whether the installed package is new enough (e.g. pkg 1.0.0 is installed but 1.0.1 is required)", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385492871", "createdAt": "2020-02-28T03:35:39Z", "author": {"login": "kevinushey"}, "path": "src/cpp/session/modules/SessionDependencies.R", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# SessionDependencies.R\n+#\n+# Copyright (C) 2020 by RStudio, PBC\n+#\n+# Unless you have received this program directly from RStudio pursuant\n+# to the terms of a commercial license agreement with RStudio, then\n+# this program is licensed to you under the terms of version 3 of the\n+# GNU Affero General Public License. This program is distributed WITHOUT\n+# ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING THOSE OF NON-INFRINGEMENT,\n+# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Please refer to the\n+# AGPL (http://www.gnu.org/licenses/agpl-3.0.txt) for more details.\n+#\n+#\n+\n+# Topographically sorts a list of packages (nodes) by their dependencies (edges). Note that this is\n+# not meant to be a general-purpose topo sort algorithm, and that it returns packages in the correct\n+# installation order, which is the exact reverse of traditional topological order. For example,\n+# given packages with dependencies a -> b -> c, we would want to install packages in the order \"c\",\n+# \"b\", and then \"a\".\n+.rs.addFunction(\"topoSortPackages\", function(nodes, edges) {\n+   # List of sorted packages\n+   sorted <- c()\n+\n+   # All nodes are unvisited to begin with\n+   visited <- c()\n+\n+   # Define recursive descent function for dependencies\n+   visit <- function(node, stack) {\n+      if (node %in% visited) {\n+         return()\n+      }\n+      if (node %in% stack) {\n+         # We visited this node while visiting itself; this is a dependency loop.\n+         stop(\"Package dependency graph is not a directed acyclic graph.\")\n+      }\n+\n+      # Visit all the edges of this node\n+      stack <- c(stack, node)\n+      for (edge in edges) {\n+         if (identical(edge$from, node)) {\n+            visit(edge$to, stack)\n+         }\n+      }\n+\n+      visited <<- c(visited, node)\n+      sorted <<- c(sorted, node)\n+   }\n+\n+   # Keep visiting unvisited nodes until we have visited all of them\n+   while (length(visited) < length(nodes)) {\n+      for (node in nodes) {\n+         if (!(node %in% visited)) {\n+            visit(node, c())\n+            break\n+         }\n+      }\n+   }\n+\n+   # Return topologically sorted list\n+   sorted\n+})\n+\n+.rs.addFunction(\"expandPkgDependencies\", function(dependencies) {\n+   .rs.expandDependencies(available.packages(), installed.packages(), dependencies)\n+})\n+\n+.rs.addFunction(\"expandDependencies\", function(available, installed, dependencies) {\n+   # A list of nodes (package names) to be installed\n+   nodes <- c()\n+\n+   # A list of details for packages to be installed\n+   packages <- dependencies\n+\n+   # A vector of lists, with \"from\" and \"to\" named elements giving the dependencies\n+   edges <- list()\n+\n+   # Get the dependencies of each package\n+   for (dep in dependencies) {\n+      # Add the package itself to the list of nodes\n+      nodes <- c(nodes, dep$name)\n+   }\n+\n+   # Look for dependencies of each package\n+   for (dep in dependencies) {\n+      # Dependencies are discovered from these three fields\n+      fields <- c(\"Depends\", \"Imports\", \"LinkingTo\")\n+      for (field in fields) {\n+         # Read contents for field (ignore if no contents)\n+         contents <- available[dep$name, field]\n+         if (!is.character(contents))\n+            next\n+\n+         # Split into a list of individual package names, using comma/whitespace as a delimiter\n+         prereqs <- strsplit(contents, \"\\\\s*,\\\\s*\")[[1]]\n+\n+         # Parse the package names into groups:\n+         # 1. The package name\n+         # 2. The package's requirements\n+         # 3. The package's version\n+         parsed <- regexec(\"([a-zA-Z0-9._]+)(?:\\\\s*\\\\(([><=]+)\\\\s*([0-9.-]+)\\\\))?\", prereqs)\n+         matches <- regmatches(prereqs, parsed)\n+\n+         # Decompose matches into additional nodes\n+         for (match in matches) {\n+            if (length(match) < 2)\n+               next\n+\n+            # Extract package name from regex result\n+            pkgName <- match[[2]]\n+\n+            # Ignore packages that don't have an entry in the availability list\n+            if (!(pkgName %in% rownames(available)))\n+                next\n+\n+            # Append to node list if we don't know about it already...\n+            if (!pkgName %in% nodes) {\n+               nodes <- c(nodes, pkgName)\n+\n+               # ... and it isn't already installed.\n+               if (!(pkgName %in% rownames(installed)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3NzY2OQ=="}, "originalCommit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NTMwMA==", "bodyText": "What happens if a CRAN package depends on a CRAN source package (ie: something installed in the next step)?", "url": "https://github.com/rstudio/rstudio/pull/6355#discussion_r385495300", "createdAt": "2020-02-28T03:48:59Z", "author": {"login": "kevinushey"}, "path": "src/cpp/session/modules/SessionDependencies.cpp", "diffHunk": "@@ -291,67 +326,114 @@ Error unsatisfiedDependencies(const json::JsonRpcRequest& request,\n    return Success();\n }\n \n-Error installDependencies(const json::JsonRpcRequest& request,\n-                          json::JsonRpcResponse* pResponse)\n+// Builds an installation script which will install all the dependencies at once. \n+std::string buildCombinedInstallScript(const std::vector<Dependency>& deps)\n {\n-   // get list of dependencies\n-   json::Array depsJson;\n-   std::string context;\n-   Error error = json::readParams(request.params, &context, &depsJson);\n-   if (error)\n-      return error;\n-   std::vector<Dependency> deps = dependenciesFromJson(depsJson);\n+   bool isRenv = module_context::isRenvActive();\n+   std::vector<std::string> cranPackages;\n+   std::vector<std::string> cranSourcePackages;\n+   std::vector<std::string> embeddedPackages;\n+   std::string cmd;\n+\n+   // Sort the dependencies into CRAN packages installed with defaults, CRAN packages explicitly\n+   // installed as source, and embedded packages.\n+   for (const Dependency& dep: deps)\n+   {\n+      if (dep.location == kCRANPackageDependency)\n+      {\n+         if (dep.source)\n+            cranSourcePackages.push_back(\"'\" + dep.name + \"'\");\n+         else\n+            cranPackages.push_back(\"'\" + dep.name + \"'\");\n+      }\n+      else if (dep.location == kEmbeddedPackageDependency)\n+      {\n+         EmbeddedPackage pkg = embeddedPackageInfo(dep.name);\n+         if (!pkg.empty())\n+            embeddedPackages.push_back(pkg.archivePath);\n+      }\n+   }\n \n-   // Ensure we have a writeable user library\n-   error = r::exec::RFunction(\".rs.ensureWriteableUserLibrary\").call();\n-   if (error)\n-      return error;\n+   // Install the CRAN packages with a single call\n+   if (!cranPackages.empty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec977a7806dc0fd7ca2817c0b84c8d49d180c5b5"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67adb796e70f7e8b2807224d894c261448197595", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/67adb796e70f7e8b2807224d894c261448197595", "committedDate": "2020-03-02T23:02:50Z", "message": "Merge remote-tracking branch 'origin/master' into bugfix/package-deps-topo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d8b7ed40b64b50a5669179ee3cc9d44e41ec021", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/0d8b7ed40b64b50a5669179ee3cc9d44e41ec021", "committedDate": "2020-03-02T23:29:37Z", "message": "use a matrix for more realistic tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a2343b6eeb99bf59aba3752dbee19b8a84a95db", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/9a2343b6eeb99bf59aba3752dbee19b8a84a95db", "committedDate": "2020-03-03T00:17:17Z", "message": "ensure dependencies replaced when too old"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7042725efb4a36f6d1a2e773ee241a6187fee236", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/7042725efb4a36f6d1a2e773ee241a6187fee236", "committedDate": "2020-03-03T00:32:51Z", "message": "save and restore default renv package install type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fad551295e474809c407c35300a6dbfad74293e", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/1fad551295e474809c407c35300a6dbfad74293e", "committedDate": "2020-03-03T00:33:08Z", "message": "add a test for multiple dependencies on one package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2861e2cccfccd3b6914d0d5bb05b07639fe52092", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/2861e2cccfccd3b6914d0d5bb05b07639fe52092", "committedDate": "2020-03-03T00:35:15Z", "message": "test contents for NA missing values"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MTkxMDY1", "url": "https://github.com/rstudio/rstudio/pull/6355#pullrequestreview-368191065", "createdAt": "2020-03-03T17:46:13Z", "commit": {"oid": "2861e2cccfccd3b6914d0d5bb05b07639fe52092"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f30896b3f0ec142555af6fc2a07fdb3f3dc8567", "author": {"user": {"login": "jmcphers", "name": "Jonathan"}}, "url": "https://github.com/rstudio/rstudio/commit/3f30896b3f0ec142555af6fc2a07fdb3f3dc8567", "committedDate": "2020-03-03T18:42:36Z", "message": "explicitly get source and binary packages on Win/MacOS"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 272, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}