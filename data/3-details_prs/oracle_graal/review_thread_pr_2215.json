{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzMzAwOTE1", "number": 2215, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNjo1NDozN1rODlgJtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNjo1NDozN1rODlgJtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNjUwNjc3OnYy", "diffSide": "LEFT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageGenerator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNjo1NDozN1rOFybr0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxNzozNjo1M1rOFydOyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQyNjcwNA==", "bodyText": "This line should remain the last one before the catch, otherwise we could miss unsupported features that get accumulated in the UnsupportedFeatures object.", "url": "https://github.com/oracle/graal/pull/2215#discussion_r388426704", "createdAt": "2020-03-05T16:54:37Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageGenerator.java", "diffHunk": "@@ -565,31 +565,31 @@ private void doRun(Map<Method, CEntryPointData> entryPoints,\n                     throw UserError.abort(\"Warning: no entry points found, i.e., no method annotated with @\" + CEntryPoint.class.getSimpleName());\n                 }\n \n+                bigbang.getUnsupportedFeatures().report(bigbang);\n+\n+                recordMethodsWithStackValues();\n+                recordRestrictHeapAccessCallees(aUniverse.getMethods());\n+\n+                /*\n+                 * After this point, all TypeFlow (and therefore also TypeState) objects are\n+                 * unreachable and can be garbage collected. This is important to keep the overall\n+                 * memory footprint low. However, this also means we no longer have complete call\n+                 * chain information. Only the summarized information stored in the\n+                 * StaticAnalysisResult objects is available after this point.\n+                 */\n+                bigbang.cleanupAfterAnalysis();\n+\n                 ImageHeapLayouter heapLayouter = ImageSingletons.lookup(ImageHeapLayouter.class);\n                 heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess, heapLayouter);\n \n                 BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug, runtime);\n                 featureHandler.forEachFeature(feature -> feature.beforeCompilation(config));\n \n                 runtime.updateLazyState(hMetaAccess);\n-\n-                bigbang.getUnsupportedFeatures().report(bigbang);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f0ca59cf246b9a24e78790c1a490d56f3a7c30f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQzNzU4Mw==", "bodyText": "The ShortestInvokeChainPrinter used by the unsupported features reporting needs AnalysisMethod.typeFlow which is cleaned up by  bigbang.cleanupAfterAnalysis(). I think we should actually move everything after  bigbang.cleanupAfterAnalysis(); outside of the catch, beforeCompilation should not accumulate unspported features.", "url": "https://github.com/oracle/graal/pull/2215#discussion_r388437583", "createdAt": "2020-03-05T17:11:09Z", "author": {"login": "cstancu"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageGenerator.java", "diffHunk": "@@ -565,31 +565,31 @@ private void doRun(Map<Method, CEntryPointData> entryPoints,\n                     throw UserError.abort(\"Warning: no entry points found, i.e., no method annotated with @\" + CEntryPoint.class.getSimpleName());\n                 }\n \n+                bigbang.getUnsupportedFeatures().report(bigbang);\n+\n+                recordMethodsWithStackValues();\n+                recordRestrictHeapAccessCallees(aUniverse.getMethods());\n+\n+                /*\n+                 * After this point, all TypeFlow (and therefore also TypeState) objects are\n+                 * unreachable and can be garbage collected. This is important to keep the overall\n+                 * memory footprint low. However, this also means we no longer have complete call\n+                 * chain information. Only the summarized information stored in the\n+                 * StaticAnalysisResult objects is available after this point.\n+                 */\n+                bigbang.cleanupAfterAnalysis();\n+\n                 ImageHeapLayouter heapLayouter = ImageSingletons.lookup(ImageHeapLayouter.class);\n                 heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess, heapLayouter);\n \n                 BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug, runtime);\n                 featureHandler.forEachFeature(feature -> feature.beforeCompilation(config));\n \n                 runtime.updateLazyState(hMetaAccess);\n-\n-                bigbang.getUnsupportedFeatures().report(bigbang);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQyNjcwNA=="}, "originalCommit": {"oid": "4f0ca59cf246b9a24e78790c1a490d56f3a7c30f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ1MjA0MQ==", "bodyText": "Yes, sounds good", "url": "https://github.com/oracle/graal/pull/2215#discussion_r388452041", "createdAt": "2020-03-05T17:36:53Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/NativeImageGenerator.java", "diffHunk": "@@ -565,31 +565,31 @@ private void doRun(Map<Method, CEntryPointData> entryPoints,\n                     throw UserError.abort(\"Warning: no entry points found, i.e., no method annotated with @\" + CEntryPoint.class.getSimpleName());\n                 }\n \n+                bigbang.getUnsupportedFeatures().report(bigbang);\n+\n+                recordMethodsWithStackValues();\n+                recordRestrictHeapAccessCallees(aUniverse.getMethods());\n+\n+                /*\n+                 * After this point, all TypeFlow (and therefore also TypeState) objects are\n+                 * unreachable and can be garbage collected. This is important to keep the overall\n+                 * memory footprint low. However, this also means we no longer have complete call\n+                 * chain information. Only the summarized information stored in the\n+                 * StaticAnalysisResult objects is available after this point.\n+                 */\n+                bigbang.cleanupAfterAnalysis();\n+\n                 ImageHeapLayouter heapLayouter = ImageSingletons.lookup(ImageHeapLayouter.class);\n                 heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess, heapLayouter);\n \n                 BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug, runtime);\n                 featureHandler.forEachFeature(feature -> feature.beforeCompilation(config));\n \n                 runtime.updateLazyState(hMetaAccess);\n-\n-                bigbang.getUnsupportedFeatures().report(bigbang);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQyNjcwNA=="}, "originalCommit": {"oid": "4f0ca59cf246b9a24e78790c1a490d56f3a7c30f"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 834, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}