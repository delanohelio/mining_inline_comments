{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2NTA1NTQ1", "number": 2248, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzo0NjowNlrODnFMbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNTo0MTo0NlrOEEjE-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzA2MTU2OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzo0NjowNlrOF03iyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzo0NjowNlrOF03iyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4MDI5Ng==", "bodyText": "minor: remove this.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390980296", "createdAt": "2020-03-11T13:46:06Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzA2MzA5OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzo0NjoyOFrOF03j0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzo0NjoyOFrOF03j0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4MDU2Mw==", "bodyText": "minor: remove this.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390980563", "createdAt": "2020-03-11T13:46:28Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzA4NDA5OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzo1MToyNlrOF03xFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNjo0NDo0MVrOF1S0YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4Mzk1Ng==", "bodyText": "I might be wrong, but IIRC all LIR phases should be able to deal with nulls in the instruction list. Deleting them manually should not be necessary.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390983956", "createdAt": "2020-03-11T13:51:26Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));\n+                    }\n+                }\n+            };\n+\n+            int opId = 0;\n+            for (LIRInstruction inst : lir.getLIRforBlock(block)) {\n+                inst.setId(opId++);\n+                inst.visitEachOutput(defConsumer);\n+                inst.visitEachInput(useConsumer);\n+                inst.visitEachAlive(useConsumer);\n+                inst.visitEachTemp(useConsumer);\n+                inst.visitEachState(useConsumer);\n+            }\n+        }\n+\n+        /**\n+         * Currently we only find the unused constant load instructions that can be safely removed.\n+         * If there are any other kinds of eligible instructions, please extend the condition here.\n+         */\n+        private static boolean isEligibleOp(LIRInstruction inst) {\n+            return inst.isLoadConstantOp();\n+        }\n+\n+        /**\n+         * Remove unused instructions for a {@code block}.\n+         */\n+        private void removeUnusedInBlock(AbstractBlockBase<?> block) {\n+            boolean hasDead = false;\n+            ArrayList<LIRInstruction> instructions = lir.getLIRforBlock(block);\n+            for (LIRInstruction instruction : instructions) {\n+                if (instruction == null) {\n+                    hasDead = true;\n+                } else {\n+                    instruction.setId(-1);\n+                }\n+            }\n+\n+            // delete unused instructions\n+            if (hasDead) {\n+                instructions.removeAll(Collections.singleton(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQyMjE5Nw==", "bodyText": "I'm not quite sure about this, but I think this is not guaranteed. For example null value LIRInstruction will cause NullPointerException in MarkBasePointersPhase. So I think it's necessary to delete them here.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r391422197", "createdAt": "2020-03-12T06:26:12Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));\n+                    }\n+                }\n+            };\n+\n+            int opId = 0;\n+            for (LIRInstruction inst : lir.getLIRforBlock(block)) {\n+                inst.setId(opId++);\n+                inst.visitEachOutput(defConsumer);\n+                inst.visitEachInput(useConsumer);\n+                inst.visitEachAlive(useConsumer);\n+                inst.visitEachTemp(useConsumer);\n+                inst.visitEachState(useConsumer);\n+            }\n+        }\n+\n+        /**\n+         * Currently we only find the unused constant load instructions that can be safely removed.\n+         * If there are any other kinds of eligible instructions, please extend the condition here.\n+         */\n+        private static boolean isEligibleOp(LIRInstruction inst) {\n+            return inst.isLoadConstantOp();\n+        }\n+\n+        /**\n+         * Remove unused instructions for a {@code block}.\n+         */\n+        private void removeUnusedInBlock(AbstractBlockBase<?> block) {\n+            boolean hasDead = false;\n+            ArrayList<LIRInstruction> instructions = lir.getLIRforBlock(block);\n+            for (LIRInstruction instruction : instructions) {\n+                if (instruction == null) {\n+                    hasDead = true;\n+                } else {\n+                    instruction.setId(-1);\n+                }\n+            }\n+\n+            // delete unused instructions\n+            if (hasDead) {\n+                instructions.removeAll(Collections.singleton(null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4Mzk1Ng=="}, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQyNzE2OQ==", "bodyText": "Right, only later phases (after RA) can deal with that.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r391427169", "createdAt": "2020-03-12T06:44:41Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));\n+                    }\n+                }\n+            };\n+\n+            int opId = 0;\n+            for (LIRInstruction inst : lir.getLIRforBlock(block)) {\n+                inst.setId(opId++);\n+                inst.visitEachOutput(defConsumer);\n+                inst.visitEachInput(useConsumer);\n+                inst.visitEachAlive(useConsumer);\n+                inst.visitEachTemp(useConsumer);\n+                inst.visitEachState(useConsumer);\n+            }\n+        }\n+\n+        /**\n+         * Currently we only find the unused constant load instructions that can be safely removed.\n+         * If there are any other kinds of eligible instructions, please extend the condition here.\n+         */\n+        private static boolean isEligibleOp(LIRInstruction inst) {\n+            return inst.isLoadConstantOp();\n+        }\n+\n+        /**\n+         * Remove unused instructions for a {@code block}.\n+         */\n+        private void removeUnusedInBlock(AbstractBlockBase<?> block) {\n+            boolean hasDead = false;\n+            ArrayList<LIRInstruction> instructions = lir.getLIRforBlock(block);\n+            for (LIRInstruction instruction : instructions) {\n+                if (instruction == null) {\n+                    hasDead = true;\n+                } else {\n+                    instruction.setId(-1);\n+                }\n+            }\n+\n+            // delete unused instructions\n+            if (hasDead) {\n+                instructions.removeAll(Collections.singleton(null));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4Mzk1Ng=="}, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMzEyMjA1OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDowMDoxN1rOF04Jdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMTozOTo1NFrOF1bIkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5MDE5OQ==", "bodyText": "At some point we tried to avoid allocating lambdas. I'd replace d -> (!d.instruction.equals(inst)) with a static method (e.g. RedundantInstructionElimination::filterDefEntry).", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390990199", "createdAt": "2020-03-11T14:00:17Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQyOTUyNQ==", "bodyText": "Thanks for your review! Yeah, it makes sense. However, since VariableMap has the public API public void filter(Predicate<T> predicate)  to specially handle the filtration. I think it's better not to create another one. Another problem to use a static method in RedundantInstructionElimination is that the members of VariableMap are private and they are not expected to be public. We need to add another API to expose them if we want to go through them outside of class VariableMap .  But if you insist your opinion, I will try to fix it. Thanks!", "url": "https://github.com/oracle/graal/pull/2248#discussion_r391429525", "createdAt": "2020-03-12T06:52:46Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5MDE5OQ=="}, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MzQwOA==", "bodyText": "Ah, I missed that you are binding the local variable inst. Forget what I said.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r391563408", "createdAt": "2020-03-12T11:39:54Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5MDE5OQ=="}, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjUxMTQzOnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/VariableMap.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzowMzoxMVrOGcRDNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODoyOTo0MlrOGcTmnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5MjY2Mw==", "bodyText": "I'd rewrite this to\n        for (T e : content) {\n            if (e != null) {\n                return false;\n            }\n        }\n        return true;\nNot a blocker, though.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432292663", "createdAt": "2020-05-29T07:03:11Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/VariableMap.java", "diffHunk": "@@ -87,4 +85,38 @@ public void filter(Predicate<T> predicate) {\n         }\n     }\n \n+    public boolean isEmpty() {\n+        if (content.isEmpty()) {\n+            return true;\n+        }\n+\n+        boolean empty = true;\n+        for (T e : content) {\n+            if (e != null) {\n+                empty = false;\n+                break;\n+            }\n+        }\n+        return empty;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNDQ5Mg==", "bodyText": "Good catch! Thanks!", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432334492", "createdAt": "2020-05-29T08:29:42Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/VariableMap.java", "diffHunk": "@@ -87,4 +85,38 @@ public void filter(Predicate<T> predicate) {\n         }\n     }\n \n+    public boolean isEmpty() {\n+        if (content.isEmpty()) {\n+            return true;\n+        }\n+\n+        boolean empty = true;\n+        for (T e : content) {\n+            if (e != null) {\n+                empty = false;\n+                break;\n+            }\n+        }\n+        return empty;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5MjY2Mw=="}, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjU0MjQzOnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoxNDo0NFrOGcRV7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODozNTowNlrOGcTx5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw==", "bodyText": "Since we are in SSA form, there can be only one instruction defining a variable. Thus, I think the code can be changed to unUsedDefs.remove((asVariable(value)).", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432297453", "createdAt": "2020-05-29T07:14:44Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNDQ0OQ==", "bodyText": "Actually, directly calling remove is all right for ConstantLoadOp. Thanks! My original concern is the Def with an array type like @Def({REG, STACK}) private Value[] incomingValues; of LabelOp. If an instruction has a definition with an array type. It actually has multiply definition values. And if any of the member is used, the instruction should not be removed. So I use the filter instead of \"remove\".  Anyway it seems this might not be possible for all the existed ConstantLoadOp.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432314449", "createdAt": "2020-05-29T07:50:39Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzQyMw==", "bodyText": "If an instruction has a definition with an array type. It actually has multiply definition values.\n\nThat is right. In that case, there is still no need to use filter (which can be expensive I think) but do something like this (more or less pseudocode):\nInstructionValueConsumer removeConsumer = (instruction, value, mode, flags) -> {\n    if (isVariable(value)) {\n        unUsedDefs.remove(asVariable(value));\n    }\n};\n...\ninst.visitEachOutput(removeConsumer);", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432323423", "createdAt": "2020-05-29T08:08:32Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMzA5Ng==", "bodyText": "OK, it seems reasonable! So as a conclusion, which do you think is better:  add these codes to handle the corner case, or just a directly unUsedDefs.remove(asVariable(value)) is enough? I think the latter is ok. Your opinion? Thanks!", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432333096", "createdAt": "2020-05-29T08:27:04Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNjM5MA==", "bodyText": "I agree, remove is fine. However, I'd add a comment why this is OK and an assertion that inst in no longer in any entry of the unUsedDefs map to catch error early if our assumption changes.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432336390", "createdAt": "2020-05-29T08:33:15Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNzM4Mg==", "bodyText": "Good idea! I will update the patch soon! Thank you!", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432337382", "createdAt": "2020-05-29T08:35:06Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjU0NzkyOnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoxNjo0OVrOGcRZig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODoyOToyN1rOGcTmJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5ODM3OA==", "bodyText": "We usually use LIRValueUtil.asVariable(value) instead of a direct cast, often with a static import so the code would change to unUsedDefs.put(asVariable(value)), def);. But it is a question of style preference and not a blocker.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432298378", "createdAt": "2020-05-29T07:16:49Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNDM3Mg==", "bodyText": "Godd catch! I will update it soon! Thank you!", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432334372", "createdAt": "2020-05-29T08:29:27Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5ODM3OA=="}, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTk4MjkxOnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToxMDoyM1rOGgsaaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwODo1NToyMlrOGhregw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNTI3NQ==", "bodyText": "Why is this necessary?  I don't think this is safe is the return operand is a virtual register.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r436935275", "createdAt": "2020-06-08T19:10:23Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -171,6 +174,10 @@ protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeVal\n     @Override\n     public Value operand(Node node) {\n         Value operand = getOperand(node);\n+        if (node instanceof ValueNode && operand instanceof SharedMatchValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126f62c924d8b155b9549c13ae220542eeae20cd"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1NTc1OA==", "bodyText": "This is to handle the case when ConstantNode is matched but not swallowed by the matched rule.  This is an example on aarch64:\n @MatchRule(\"(Add=op (UnsignedRightShift=x src Constant=shiftAmt1) (LeftShift src Constant=shiftAmt2))\")\n public ComplexMatchResult rotationConstant(ValueNode op, ValueNode x, ValueNode src, ConstantNode shiftAmt1, ConstantNode shiftAmt2) {\n    assert src.getStackKind().isNumericInteger();\n    assert shiftAmt1.getStackKind().getBitCount() == 32;\n    assert shiftAmt2.getStackKind().getBitCount() == 32;\n\n    int shift1 = shiftAmt1.asJavaConstant().asInt();\n    int shift2 = shiftAmt2.asJavaConstant().asInt();\n    if (op instanceof AddNode && (0 == shift1 || 0 == shift2)) {\n        return null;\n    }\n    if ((0 == shift1 + shift2) || (src.getStackKind().getBitCount() == shift1 + shift2)) {\n    return builder -> {\n                Value a = operand(src);\n                Value b = x instanceof LeftShiftNode ? operand(shiftAmt2) : operand(shiftAmt1);\n                return getArithmeticLIRGenerator().emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.ROR, false, a, b);\n            };\n    }\n    return null;\n  }\n\nThe ConstantNode shiftAmt1 and shiftAmt2 are all matched to the rule. However, it's still used as an operand of the final ROR. See:\nValue b = x instanceof LeftShiftNode ? operand(shiftAmt2) : operand(shiftAmt1);\n\nThe compiler cannot know the real usages inside of the evaluate function of the ComplexMatchValue during matching.\nAnother way to fix is to make it wrong when operand() of a matched ConstantNode is called. For the above rule, it needs some more modification at aarch64 backend which I don't think is friendly if fixing it.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r437155758", "createdAt": "2020-06-09T06:00:29Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -171,6 +174,10 @@ protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeVal\n     @Override\n     public Value operand(Node node) {\n         Value operand = getOperand(node);\n+        if (node instanceof ValueNode && operand instanceof SharedMatchValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNTI3NQ=="}, "originalCommit": {"oid": "126f62c924d8b155b9549c13ae220542eeae20cd"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYyNTA5Mw==", "bodyText": "I think if it wants them as a constant then it needs to construct them in that form instead of going through operand.  Why can't it call emitBinaryConst directly using the JavaConstant from the node?  You can't safely do potentially lazy evaluation using doRoot since it might be called in a non-dominating position.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r437625093", "createdAt": "2020-06-09T18:13:11Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -171,6 +174,10 @@ protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeVal\n     @Override\n     public Value operand(Node node) {\n         Value operand = getOperand(node);\n+        if (node instanceof ValueNode && operand instanceof SharedMatchValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNTI3NQ=="}, "originalCommit": {"oid": "126f62c924d8b155b9549c13ae220542eeae20cd"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2ODUxNQ==", "bodyText": "Yes, I greatly agree with you. I was thinking that it needs more effort to fix the rules, since this case also exists on AMD64. It seems easier and simpler than what I thought before.  I will fix it later. Thanks!", "url": "https://github.com/oracle/graal/pull/2248#discussion_r437968515", "createdAt": "2020-06-10T08:55:22Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -171,6 +174,10 @@ protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeVal\n     @Override\n     public Value operand(Node node) {\n         Value operand = getOperand(node);\n+        if (node instanceof ValueNode && operand instanceof SharedMatchValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNTI3NQ=="}, "originalCommit": {"oid": "126f62c924d8b155b9549c13ae220542eeae20cd"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMjA0NDczOnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNTo0MTo0N1rOGiPNfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNjo1ODo0OVrOGiQ1cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU1Mzk4Mw==", "bodyText": "You know I don't really thing we need SharedMatchValue.  If we're going to maintain a side table we can just as easily store an Integer to track the count.  Then when it's equal to getUsageCount() we can store INTERIOR_MATCH into nodeOperands.  I could make that change if you're amenable to it.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r438553983", "createdAt": "2020-06-11T05:41:47Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -226,6 +229,19 @@ public void setMatchResult(Node x, Value operand) {\n         nodeOperands.set(x, operand);\n     }\n \n+    public void setSharedMatchResult(Node node) {\n+        assert nodeOperands != null && nodeOperands.get(node) == null : \"operand cannot be set twice\";\n+        SharedMatchValue matchValue = sharedMatchValues.get(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5875c7ff7fce960c2a364a276b4197dee132f1d3"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4MDU5Mg==", "bodyText": "Yeah, agree! Actually the additional SharedMatchValue is not needed, and I think it's ok to remove it. Thanks for your review! And it's great that you could help to make it better. Thanks so much!", "url": "https://github.com/oracle/graal/pull/2248#discussion_r438580592", "createdAt": "2020-06-11T06:58:49Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -226,6 +229,19 @@ public void setMatchResult(Node x, Value operand) {\n         nodeOperands.set(x, operand);\n     }\n \n+    public void setSharedMatchResult(Node node) {\n+        assert nodeOperands != null && nodeOperands.get(node) == null : \"operand cannot be set twice\";\n+        SharedMatchValue matchValue = sharedMatchValues.get(node);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU1Mzk4Mw=="}, "originalCommit": {"oid": "5875c7ff7fce960c2a364a276b4197dee132f1d3"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 838, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}