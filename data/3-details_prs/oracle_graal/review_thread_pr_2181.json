{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4ODM0OTIw", "number": 2181, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNjo1Njo0MlrODiOX4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzowMTowNVrOECptrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3MjEzNjY2OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNjo1Njo0MlrOFtW5ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNTo1NDoyMlrOGe2yMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwNTQ0Mw==", "bodyText": "Temporarily insert a full barrier after each atomic operations, even though it is a non-conservative model. This is added here to resolve the renassiance banchmark hang issue (#2045) when \"STLXR\" is used together with \"LDR/DMB\" for java volatile read. This issue can also be resolved once \"LDAR/STLR\" is used for java volatile access. So once the PR #1772 is merged, the temporarily codes can be deleted.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r383105443", "createdAt": "2020-02-24T06:56:42Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java", "diffHunk": "@@ -80,23 +85,35 @@ public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n             Register address = asRegister(addressValue);\n             Register result = asRegister(resultValue);\n             Register newVal = asRegister(newValue);\n+            if (masm.isFlagSet(AArch64.Flag.UseBarriersForVolatile) || useBarriers) {\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                emitCompareAndSwap(masm, size, address, result, newVal, false /* acquire */, false /* release */);\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+            } else {\n+                emitCompareAndSwap(masm, size, address, result, newVal, true /* acquire */, true /* release */);\n+                if (!AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n+                    // Temporarily add a fullbarrier after STLXR. This can be removed when LDAR is\n+                    // used for java volatile read.\n+                    masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8db37bc7a888351be06ccab499852a11057e291"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MDcyNg==", "bodyText": "Yes that will do until the other PR gets pushed.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397240726", "createdAt": "2020-03-24T15:25:57Z", "author": {"login": "adinn"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java", "diffHunk": "@@ -80,23 +85,35 @@ public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n             Register address = asRegister(addressValue);\n             Register result = asRegister(resultValue);\n             Register newVal = asRegister(newValue);\n+            if (masm.isFlagSet(AArch64.Flag.UseBarriersForVolatile) || useBarriers) {\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                emitCompareAndSwap(masm, size, address, result, newVal, false /* acquire */, false /* release */);\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+            } else {\n+                emitCompareAndSwap(masm, size, address, result, newVal, true /* acquire */, true /* release */);\n+                if (!AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n+                    // Temporarily add a fullbarrier after STLXR. This can be removed when LDAR is\n+                    // used for java volatile read.\n+                    masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwNTQ0Mw=="}, "originalCommit": {"oid": "c8db37bc7a888351be06ccab499852a11057e291"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjUwNg==", "bodyText": "That condition on \"useLSE\" doesn't make much sense to me. LSE instructions don't have full barrier semantics any more than LDAXR/STLXR instructions do.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425072506", "createdAt": "2020-05-14T11:42:13Z", "author": {"login": "theRealAph"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java", "diffHunk": "@@ -80,23 +85,35 @@ public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n             Register address = asRegister(addressValue);\n             Register result = asRegister(resultValue);\n             Register newVal = asRegister(newValue);\n+            if (masm.isFlagSet(AArch64.Flag.UseBarriersForVolatile) || useBarriers) {\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                emitCompareAndSwap(masm, size, address, result, newVal, false /* acquire */, false /* release */);\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+            } else {\n+                emitCompareAndSwap(masm, size, address, result, newVal, true /* acquire */, true /* release */);\n+                if (!AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n+                    // Temporarily add a fullbarrier after STLXR. This can be removed when LDAR is\n+                    // used for java volatile read.\n+                    masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwNTQ0Mw=="}, "originalCommit": {"oid": "c8db37bc7a888351be06ccab499852a11057e291"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAwODA1MQ==", "bodyText": "This temporary codes have been removed since PR 1772 has been merged. Thanks!", "url": "https://github.com/oracle/graal/pull/2181#discussion_r435008051", "createdAt": "2020-06-04T05:54:22Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java", "diffHunk": "@@ -80,23 +85,35 @@ public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n             Register address = asRegister(addressValue);\n             Register result = asRegister(resultValue);\n             Register newVal = asRegister(newValue);\n+            if (masm.isFlagSet(AArch64.Flag.UseBarriersForVolatile) || useBarriers) {\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                emitCompareAndSwap(masm, size, address, result, newVal, false /* acquire */, false /* release */);\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+            } else {\n+                emitCompareAndSwap(masm, size, address, result, newVal, true /* acquire */, true /* release */);\n+                if (!AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n+                    // Temporarily add a fullbarrier after STLXR. This can be removed when LDAR is\n+                    // used for java volatile read.\n+                    masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwNTQ0Mw=="}, "originalCommit": {"oid": "c8db37bc7a888351be06ccab499852a11057e291"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjU0MTU4OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTozMzowNFrOF61_rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMDo0Mzo1N1rOGUr2cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0NjM4Mg==", "bodyText": "I think it would be cleaner to pass a new flag into the existing methods instead of adding a whole new method.  Other platforms might ignore it but that's fine.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397246382", "createdAt": "2020-03-24T15:33:04Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java", "diffHunk": "@@ -155,6 +155,15 @@ default boolean mayEmbedConstantLoad(Constant constant) {\n \n     Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue);\n \n+    default Variable emitJavaLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3ODk4NQ==", "bodyText": "Yes, in a sense it should be better. I was expecting to not have too much modifications for other platforms, especially the modifications to the common existing API. That's why I decided to add a new function here.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397578985", "createdAt": "2020-03-25T02:46:19Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java", "diffHunk": "@@ -155,6 +155,15 @@ default boolean mayEmbedConstantLoad(Constant constant) {\n \n     Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue);\n \n+    default Variable emitJavaLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0NjM4Mg=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM0MzE1Mg==", "bodyText": "Update the patch to use a new flag!", "url": "https://github.com/oracle/graal/pull/2181#discussion_r424343152", "createdAt": "2020-05-13T10:43:57Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java", "diffHunk": "@@ -155,6 +155,15 @@ default boolean mayEmbedConstantLoad(Constant constant) {\n \n     Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue);\n \n+    default Variable emitJavaLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0NjM4Mg=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjU2NzQ3OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "isResolved": true, "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTozODoyNFrOF62QDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwOTozNjozOFrOGV9uHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA==", "bodyText": "I think I understand the practical meaning of this flag but I'm not sure the naming is clear enough.  So basically in ARM there are 2 ways of doing volatiles and this flag is meant to distinguish between these 2 cases?  In almost all cases Java volatile should be considered the normal one I think and maybe this flag should be something like isNonStandardVolatile?  Actually what are there cases where we use a CompareAndSwapNode against a location which is acquired using the other sequence?", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397250574", "createdAt": "2020-03-24T15:38:24Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3MjMwNQ==", "bodyText": "There are indeed two ways of generating compare and swap code. The choice of generation strategy depends on two factors: what location is being updated and what value has been set for a AArch64 flag (UseBarriersForVolatile).\nIf UseBarriersForVolatile is true then all compare and swap operations use ldxr and stxr combined with dmb instructions.\nIf UseBarriersForVolatile is false then the nature of the memory location comes into play.\nWhen the location is a Java field then ldaxr and stlxr need to be be used. This is consistent with the semantics employed for generating Java volatile reads and implemented in PR 1772 where they translate to ldar and stlr.\nHowever, since PR has not yet been merged1772 XiahongGong has added an extra dmb at the end of ldax/stlxr sequence to deal with the disparity between the translation this patch implements and the current translation for volatiles a combination of ldr/str with dmb instructions.\nWhen the location is not a Java field then the code must use ldxr, stxr combined with dmb instructions. This is consistent with normal expectations regarding memory synchronization  non-Java data.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397272305", "createdAt": "2020-03-24T16:05:23Z", "author": {"login": "adinn"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI4NTQ5Ng==", "bodyText": "Ok, but why are the other locations that are using isJavaVolatile == false correct?  Are all of those clearly non-Java locations?  For instance in the context of SVM I think everything is a Java volatile.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397285496", "createdAt": "2020-03-24T16:22:08Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM0MzAzMA==", "bodyText": "As I understand it (I hope XiaohongHong will correct me if I misrepresent things) XiaohongHong has only wired up the unsafe plugins for compare and exchange/swap to pass true. Those are cases that are known to correspond to a Java application program explicitly posting a read or write to Java data. The relaxing of the semantics in these cases is compatible with the optimization implemented by PR 1772 when UseBarriersForVolatile is false and improves performance. Or rather it will be when 1772 is merged and we can omit the trailing barriers that are still in place for this patch.\nIn other cases where code internal to the JIT or Substrate creates an UnsafeCompareAndSwapNode or UnsafeCompareAndExchangeNode via the original constructor the value defaults to false which means the generator uses a more heavyweight barrier-based translation. This alternative is always consistent (on all known AArch64 arches) whether or not PR 1772 is in place. It is just less performant.\nThe reason the other cases have not been changed to use ldaxr/stlxr  is because it was not clear whether these internal uses were expecting other accesses to the target locations to be simple Java volatile field reads and writes (which would be correctly handled by the JIT once PR 1772 was merged) or to require the full semantics that is normally expected for compare and swap. The idea was to leave them as is and then convert the relevant uses one by one as needed. If you can confirm that all cases where the existing code explicitly constructs an UnsafeCompareAndSwapNode or UnsafeCompareAndExchangeNode are compatible with PR 1772 then we don't need to worry about the isJavaVolatile == false case and can always use this optimization.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397343030", "createdAt": "2020-03-24T17:41:31Z", "author": {"login": "adinn"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM3MzY4MA==", "bodyText": "Yes that's what I'm getting at.  So for instance does the CompareAndSwapNode that we emit in the MonitorSnippets using Pointer.compareAndSwapWord need to use the conservative pattern because HotSpot uses a different pattern or can it use the more optimal pattern?  In the context of this PR it might be helpful to eliminate the constructor that passes the default value to make it more clear where we have to think about the setting of this flag.\nIn the context of SVM it's really only talking to itself I think so I would guess that always using the optimal pattern would be possible though it could necessary to have an escape hatch.\nApart from the Unsafe plugin, selecting the kind of volatile based on the LocationIdentity might work fairly well.  In the MonitorSnippets case for instance the MARK_WORD_LOCATION could be used to select the right kind for Hotspot if it needs something different but still do the normal thing for SVM.  Anyway, I'd like to get more clarity on which cases we actually need.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397373680", "createdAt": "2020-03-24T18:29:36Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTc4NA==", "bodyText": "We mainly concerns the usages in SVM, like in JNIJavaVM.addJavaVM and others in isolated, and its future usages in the internal VM of native image like GC. I'm not very much sure about where we should add the conservative barriers. But just in case, I think we should add a choice for the developer.\nFor the MonitorSnippets in HotSpot, interpreter and C1 always uses the conservative model while C2 uses the same one with Graal now.\nFor the isJavaVolatile flag, do you mean we should eliminate the constructor that will set the default value to it, or just delete it because we could also decide the memory model based on the LocationIdentity?", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397599784", "createdAt": "2020-03-25T04:11:44Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY5MDQwMg==", "bodyText": "Anyway, I'd like to get more clarity on which cases we actually need\n\nWell, yeah, me too ;-) Only I'm not really in a position to determine that. That's why the current change was chosen: to be conservative and minimally invasive while still allowing further optimizations to be applied gradually as opportunities were  identified.\nYou are right that compilation for Substrate can probably always use the optimized model and that includes, say, the MonitorSnippets case. However, that code is currently shared with the Hotspot generation case. I'm not really clear how to separate those cases and apply the right transformation and I don't believe XiahongGong is. Advice would be very welcome.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397690402", "createdAt": "2020-03-25T08:50:41Z", "author": {"login": "adinn"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzMzQ4OQ==", "bodyText": "Hi @tkrodriguez , I have renamed the isJavaVolatile flag to useBarriers and eliminated the constructor that sets the default value to it. Besides, I did the modifications compared to the last version:\n\nAdd a conservative field for LocationIdentity to decide whether to use the full semantic barriers for VM internal atomic operations. I only set the flag for the CAS used LocationIdentity in MonitorSnippets currently. People can set the flag for other atomic operations if needed in future.\nRemove the reference of UseBarriersForVolatile, always use the optimized ldaxr/stlxr pattern for java Unsafe atomics.\n\nCould you please take a look whether this version is more reasonable? Thanks!", "url": "https://github.com/oracle/graal/pull/2181#discussion_r424833489", "createdAt": "2020-05-14T02:19:11Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAxMzc5Mg==", "bodyText": "The reason HotSpot uses the \"conservative\" memory barriers is that it's very old code, and no-one could guarantee that \"merely\" sequentially-consistent operations would be adequate. However, I believe that SC is really adequate for HotSpot and we quietly used such operations in the AArch64 port for years until someone noticed. Graal shouldn't need anything more than SC, and if it does anywhere, that's a bug in Graal. IMO.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425013792", "createdAt": "2020-05-14T09:53:30Z", "author": {"login": "theRealAph"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAzODI1Mw==", "bodyText": "Hi @theRealAph, thanks for looking at this PR. So do you mean \"ldaxr/stlxr\" is SC enough for vm internal atomics like monitor operations in Graal?  Actually we didn't met any issue for it.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425038253", "createdAt": "2020-05-14T10:35:16Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3NDA5Ng==", "bodyText": "Yes, that's what I mean. However, it is possible that there is (broken) code elsewhere in Graal which assumes monitors, CAS, etc. have full-barrier semantics. I have no idea how to find such code.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425074096", "createdAt": "2020-05-14T11:45:19Z", "author": {"login": "theRealAph"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4NDUxMQ==", "bodyText": "Yes, I'm also worried about the possible scenario and actually have no idea to make a decision. However, the main purpose of this PR is to add the full-barrier alternative implementation for CAS, so that people can have a chance to use it if needed in future.  If there is not any known issue for the current pattern (ldaxr/stlxr) used in hotspot monitor (since we have used it for long times in C2), I think we can keep using it currently in Graal. But it's still worth to add the full-barrier alternative implementation in Graal.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r425684511", "createdAt": "2020-05-15T09:36:38Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA=="}, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjE2MDQ0OnYy", "diffSide": "LEFT", "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzowMTowNVrOGfPXbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwMzoyMDo0MVrOGffIuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMDc5Ng==", "bodyText": "Shouldn't this be checking that true and false are 1 and 0 respectively?", "url": "https://github.com/oracle/graal/pull/2181#discussion_r435410796", "createdAt": "2020-06-04T17:01:05Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java", "diffHunk": "@@ -151,21 +151,23 @@ public AArch64AddressValue asAddressValue(Value address) {\n     }\n \n     @Override\n-    public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {\n-        Variable prevValue = newVariable(expectedValue.getValueKind());\n-        Variable scratch = newVariable(LIRKind.value(AArch64Kind.DWORD));\n-        append(new CompareAndSwapOp(prevValue, loadReg(expectedValue), loadReg(newValue), asAllocatable(address), scratch));\n+    public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue, boolean useBarriers) {\n+        emitCompareAndSwap(address, expectedValue, newValue, useBarriers);\n         assert trueValue.getValueKind().equals(falseValue.getValueKind());\n         Variable result = newVariable(trueValue.getValueKind());\n-        append(new CondMoveOp(result, ConditionFlag.EQ, asAllocatable(trueValue), asAllocatable(falseValue)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f01e36c3eb0328d00058eb4d627be84850e6673"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY2OTE3Ng==", "bodyText": "It's 1 and 0 respectively. However, I think adding an assert is better. I will fix it. Thanks for reminding!", "url": "https://github.com/oracle/graal/pull/2181#discussion_r435669176", "createdAt": "2020-06-05T03:20:41Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java", "diffHunk": "@@ -151,21 +151,23 @@ public AArch64AddressValue asAddressValue(Value address) {\n     }\n \n     @Override\n-    public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {\n-        Variable prevValue = newVariable(expectedValue.getValueKind());\n-        Variable scratch = newVariable(LIRKind.value(AArch64Kind.DWORD));\n-        append(new CompareAndSwapOp(prevValue, loadReg(expectedValue), loadReg(newValue), asAllocatable(address), scratch));\n+    public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue, boolean useBarriers) {\n+        emitCompareAndSwap(address, expectedValue, newValue, useBarriers);\n         assert trueValue.getValueKind().equals(falseValue.getValueKind());\n         Variable result = newVariable(trueValue.getValueKind());\n-        append(new CondMoveOp(result, ConditionFlag.EQ, asAllocatable(trueValue), asAllocatable(falseValue)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMDc5Ng=="}, "originalCommit": {"oid": "2f01e36c3eb0328d00058eb4d627be84850e6673"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 822, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}