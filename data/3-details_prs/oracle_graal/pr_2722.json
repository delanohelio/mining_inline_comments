{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4Mjc5NjA0", "number": 2722, "title": "enable C++/LLVM interoperability calls of (class) methods and constructors", "bodyText": "These changes enable calling methods of classes and constructors of classes that have been written in C++ and have been compiled to LLVM code. This is done via Sulong and the Truffle Interoperability framework.\nThis PR is also for discussion with the Sulong team.", "createdAt": "2020-07-29T08:29:21Z", "url": "https://github.com/oracle/graal/pull/2722", "merged": true, "mergeCommit": {"oid": "cabd6619099eaf06c6338f4ae535722f519bd350"}, "closed": true, "closedAt": "2020-10-19T16:13:42Z", "author": {"login": "pichristoph"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdE6FPYgFqTQ4MDY2ODg3Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdSHHQaABqjM4NzA4MzY1OTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNjY4ODcy", "url": "https://github.com/oracle/graal/pull/2722#pullrequestreview-480668872", "createdAt": "2020-09-02T10:02:37Z", "commit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMDowMjozN1rOHLoBqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMToxMDozMlrOHLqNXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1MjE3MQ==", "bodyText": "I don't think we need this, since this is identical to POLYGLOT_DECLARE_TYPE. Maybe we'll need to do something more later, as we introduce more features, but for now let's remove it. It's always easier to add stuff than to remove stuff in a backwards compatible manner.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481952171", "createdAt": "2020-09-02T10:02:37Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.libraries.bitcode/include/polyglot.h", "diffHunk": "@@ -655,6 +655,32 @@ __POLYGLOT_DECLARE_GENERIC_ARRAY(double, double)\n  */\n #define POLYGLOT_DECLARE_STRUCT(type) __POLYGLOT_DECLARE_GENERIC_TYPE(struct type, type)\n \n+/**\n+ * Declare polyglot conversion functions for a user-defined class type.\n+ *\n+ * Given this class definition:\n+ * \\code\n+ * class MyClass {\n+ *   int someMember;\n+ *   int someMethod();\n+ *   ...\n+ * };\n+ *\n+ * POLYGLOT_DECLARE_CLASS(MyStruct)\n+ * \\endcode\n+ *\n+ * This macro will generate the following functions:\n+ *\n+ * \\code\n+ * polyglot_typeid polyglot_MyClass_typeid();\n+ * MyClass *polyglot_as_MyClass(void *value);\n+ * MyClass *polyglot_as_MyClass_array(void *value);\n+ * void *polyglot_from_MyClass(MyClass *s);\n+ * void *polyglot_from_MyClass_array(MyClass *arr, uint64_t len);\n+ * \\endcode\n+ */\n+#define POLYGLOT_DECLARE_CLASS(type) __POLYGLOT_DECLARE_GENERIC_TYPE(type, type)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1NTY4NA==", "bodyText": "Style issue: I think that assertion is redundant. We have a cast on the next line, so this code will fail with a good error message anyway if it's not true.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481955684", "createdAt": "2020-09-02T10:09:13Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java", "diffHunk": "@@ -83,13 +89,31 @@ CallTarget getForeignCallTarget() {\n             CompilerDirectives.transferToInterpreter();\n             LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n             LLVMInteropType interopType = context.getInteropType(sourceType);\n-            LLVMForeignCallNode foreignCall = new LLVMForeignCallNode(context.getLanguage(), this, interopType, sourceType);\n+            LLVMForeignCallNode foreignCall = LLVMForeignFunctionCallNode.create(context.getLanguage(), this, interopType, sourceType);\n             foreignCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n             assert foreignCallTarget != null;\n         }\n         return foreignCallTarget;\n     }\n \n+    CallTarget getForeignConstructorCallTarget() {\n+        if (foreignCallTarget == null) {\n+            CompilerDirectives.transferToInterpreter();\n+            LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n+            LLVMInteropType interopType = context.getInteropType(sourceType);\n+            assert (interopType instanceof Function);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1NzMxMA==", "bodyText": "Reusing the same variable foreignCallTarget for both getForeignCallTarget and getForeignConstructorCallTarget looks dangerous. True, a function is either a constructor or a method, not both. But what if the user somehow gets their hand on a constructor function pointer, and tries to execute it?", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481957310", "createdAt": "2020-09-02T10:12:23Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/LLVMFunctionDescriptor.java", "diffHunk": "@@ -83,13 +89,31 @@ CallTarget getForeignCallTarget() {\n             CompilerDirectives.transferToInterpreter();\n             LLVMSourceFunctionType sourceType = functionCode.getFunction().getSourceType();\n             LLVMInteropType interopType = context.getInteropType(sourceType);\n-            LLVMForeignCallNode foreignCall = new LLVMForeignCallNode(context.getLanguage(), this, interopType, sourceType);\n+            LLVMForeignCallNode foreignCall = LLVMForeignFunctionCallNode.create(context.getLanguage(), this, interopType, sourceType);\n             foreignCallTarget = Truffle.getRuntime().createCallTarget(foreignCall);\n             assert foreignCallTarget != null;\n         }\n         return foreignCallTarget;\n     }\n \n+    CallTarget getForeignConstructorCallTarget() {\n+        if (foreignCallTarget == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MDg2NA==", "bodyText": "This assertion doesn't do anything when behind a @TruffleBoundary.\nAlso logically speaking it's a contradiction: The assertion means that this method is not supposed to be used from runtime compiled code. The boundary means that it can be used from runtime compiled code even though something inside it can't.\nSince this is a parser datastructure, I would guess that the assertion is correct, and the boundary is wrong. Same thing for all the other boundaries in that file.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481960864", "createdAt": "2020-09-02T10:19:06Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MTkzMw==", "bodyText": "This code is copied from the superclass. This could be simplified to super.getElementCount() + methods.size().", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481961933", "createdAt": "2020-09-02T10:21:10Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MzEzMg==", "bodyText": "Duplicate code from superclass. Please simplify to use super.getElementName().\nFor the index, in the else branch you can just use index -= super.getElementCount(), right?", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481963132", "createdAt": "2020-09-02T10:23:40Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MzQ3NA==", "bodyText": "Duplicate code from superclass.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481963474", "createdAt": "2020-09-02T10:24:18Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MzU3MQ==", "bodyText": "Duplicate code from superclass.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481963571", "createdAt": "2020-09-02T10:24:32Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {\n+            if (member.getOffset() == offset) {\n+                return member.getName();\n+            }\n+        }\n+        for (LLVMSourceFunctionType method : methods) {\n+            if (method.getOffset() == offset) {\n+                return method.getName();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2Mzg5OQ==", "bodyText": "Duplicate code from superclass.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481963899", "createdAt": "2020-09-02T10:25:06Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {\n+            if (member.getOffset() == offset) {\n+                return member.getName();\n+            }\n+        }\n+        for (LLVMSourceFunctionType method : methods) {\n+            if (method.getOffset() == offset) {\n+                return method.getName();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return staticMembers;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getOffsetElementType();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getReturnType();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        for (final LLVMSourceMemberType member : dynamicMembers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2NDE0NA==", "bodyText": "Duplicate code from superclass.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481964144", "createdAt": "2020-09-02T10:25:26Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {\n+            if (member.getOffset() == offset) {\n+                return member.getName();\n+            }\n+        }\n+        for (LLVMSourceFunctionType method : methods) {\n+            if (method.getOffset() == offset) {\n+                return method.getName();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return staticMembers;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getOffsetElementType();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getReturnType();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        for (final LLVMSourceMemberType member : dynamicMembers) {\n+            if (name.equals(member.getName())) {\n+                return member.getOffsetElementType();\n+            }\n+        }\n+        int idx = getMethodIndexByName(name);\n+        if (idx >= 0) {\n+            return methods.get(idx).getReturnType();\n+        }\n+        if (LLVMSourceStaticMemberType.CollectionType.MEMBERNAME.equals(name)) {\n+            return staticMembers;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceLocation getElementDeclaration(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2NDMyOQ==", "bodyText": "Duplicate code from superclass.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481964329", "createdAt": "2020-09-02T10:25:49Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/debug/type/LLVMSourceClassLikeType.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.debug.type;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\n+import com.oracle.truffle.llvm.runtime.debug.scope.LLVMSourceLocation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public final class LLVMSourceClassLikeType extends LLVMSourceStructLikeType {\n+\n+    private final List<LLVMSourceMethodType> methods;\n+\n+    @TruffleBoundary\n+    public LLVMSourceClassLikeType(String name, long size, long align, long offset, LLVMSourceLocation location) {\n+        super(name, size, align, offset, location);\n+        this.methods = new ArrayList<>();\n+    }\n+\n+    private LLVMSourceClassLikeType(Supplier<String> name, long size, long align, long offset, List<LLVMSourceMemberType> dynamicMembers, LLVMSourceStaticMemberType.CollectionType staticMembers,\n+                    List<LLVMSourceMethodType> methods, LLVMSourceLocation location) {\n+        super(name, size, align, offset, dynamicMembers, staticMembers, location);\n+        this.methods = methods;\n+    }\n+\n+    @TruffleBoundary\n+    public void addMethod(String name, String linkageName, LLVMSourceFunctionType function) {\n+        CompilerAsserts.neverPartOfCompilation();\n+        final LLVMSourceMethodType method = new LLVMSourceMethodType(function.getParameterTypes(), name, linkageName, this);\n+        methods.add(method);\n+    }\n+\n+    @Override\n+    public LLVMSourceType getOffset(long newOffset) {\n+        return new LLVMSourceClassLikeType(this::getName, getSize(), getAlign(), newOffset, dynamicMembers, staticMembers, methods, getLocation());\n+    }\n+\n+    @Override\n+    public boolean isAggregate() {\n+        return true;\n+    }\n+\n+    public int getMethodCount() {\n+        return methods.size();\n+    }\n+\n+    public LLVMSourceFunctionType getMethod(int i) {\n+        return methods.get(i);\n+    }\n+\n+    public String getMethodName(int i) {\n+        return methods.get(i).getName();\n+    }\n+\n+    public String getMethodLinkageName(int i) {\n+        return methods.get(i).getLinkageName();\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public int getElementCount() {\n+        int elementCount = dynamicMembers.size() + methods.size();\n+        if (staticMembers.getElementCount() != 0) {\n+            elementCount++;\n+        }\n+        return elementCount;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementName(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return LLVMSourceStaticMemberType.CollectionType.MEMBERNAME;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getName();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getName();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public String getElementNameByOffset(long offset) {\n+        for (LLVMSourceMemberType member : dynamicMembers) {\n+            if (member.getOffset() == offset) {\n+                return member.getName();\n+            }\n+        }\n+        for (LLVMSourceFunctionType method : methods) {\n+            if (method.getOffset() == offset) {\n+                return method.getName();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return staticMembers;\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getOffsetElementType();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getReturnType();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceType getElementType(String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        for (final LLVMSourceMemberType member : dynamicMembers) {\n+            if (name.equals(member.getName())) {\n+                return member.getOffsetElementType();\n+            }\n+        }\n+        int idx = getMethodIndexByName(name);\n+        if (idx >= 0) {\n+            return methods.get(idx).getReturnType();\n+        }\n+        if (LLVMSourceStaticMemberType.CollectionType.MEMBERNAME.equals(name)) {\n+            return staticMembers;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceLocation getElementDeclaration(long i) {\n+        int index = (int) i;\n+        if (staticMembers.getElementCount() != 0) {\n+            if (index == 0) {\n+                return staticMembers.getLocation();\n+            } else {\n+                index--;\n+            }\n+        }\n+        if (0 <= index && index < dynamicMembers.size()) {\n+            return dynamicMembers.get(index).getLocation();\n+        } else {\n+            index -= dynamicMembers.size();\n+        }\n+        if (0 <= index && index < methods.size()) {\n+            return methods.get(index).getLocation();\n+        }\n+        return null;\n+    }\n+\n+    private int getMethodIndexByName(String name) {\n+        for (int i = 0; i < methods.size(); i++) {\n+            LLVMSourceMethodType method = methods.get(i);\n+            if (name.contentEquals(method.getLinkageName()) || name.contentEquals(method.getName())) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @TruffleBoundary\n+    public LLVMSourceLocation getElementDeclaration(String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        for (final LLVMSourceMemberType member : dynamicMembers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3MzY0MQ==", "bodyText": "I don't think this is really correct. This is the equivalent of calling malloc, but I think we should actually call the new operator. Not sure how to best do this though, especially since the new operator can be overloaded.\nThis will also make problems with managed mode (--llvm.managed, and EE only feature), since there malloc is swapped out with a different implementation. Calling new would solve this, too, since the default new operator will in turn call malloc.\nI'm inclined to leave it as it is now, and fix it in a followup PR, since this is quite tricky to solve. We'd have to somehow get the correct new operator to call from the debug info, and call that.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481973641", "createdAt": "2020-09-02T10:42:53Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.interop;\n+\n+import com.oracle.truffle.api.frame.VirtualFrame;\n+import com.oracle.truffle.api.interop.ArityException;\n+import com.oracle.truffle.llvm.runtime.LLVMFunctionDescriptor;\n+import com.oracle.truffle.llvm.runtime.LLVMLanguage;\n+import com.oracle.truffle.llvm.runtime.debug.type.LLVMSourceFunctionType;\n+import com.oracle.truffle.llvm.runtime.interop.access.LLVMInteropType;\n+import com.oracle.truffle.llvm.runtime.memory.LLVMStack.StackPointer;\n+import com.oracle.truffle.llvm.runtime.types.Type;\n+import com.oracle.truffle.llvm.runtime.types.Type.TypeOverflowException;\n+\n+public class LLVMForeignConstructorCallNode extends LLVMForeignCallNode {\n+    private final Type clazzType;\n+    private final LLVMLanguage language;\n+\n+    public static LLVMForeignConstructorCallNode create(LLVMLanguage language, LLVMFunctionDescriptor function, LLVMInteropType interopType, LLVMSourceFunctionType sourceType,\n+                    LLVMInteropType.Structured structuredType) {\n+        Type escapeType = function.getLLVMFunction().getType().getArgumentType(0);\n+        return new LLVMForeignConstructorCallNode(language, function, interopType, sourceType, structuredType, escapeType);\n+\n+    }\n+\n+    protected LLVMForeignConstructorCallNode(LLVMLanguage language, LLVMFunctionDescriptor function, LLVMInteropType interopType, LLVMSourceFunctionType sourceType,\n+                    LLVMInteropType.Structured structuredType, Type escapeType) {\n+        super(language, function, interopType, sourceType, structuredType, escapeType);\n+        this.language = language;\n+        this.clazzType = escapeType;\n+    }\n+\n+    @Override\n+    protected Object doCall(VirtualFrame frame, StackPointer stackPointer) throws ArityException, TypeOverflowException {\n+        Object[] rawArguments = frame.getArguments();\n+        rawArguments[0] = language.getLLVMMemory().allocateMemory(this, clazzType.getBitSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3NTg0Mg==", "bodyText": "You can't store an LLVMLanguage directly in a node, you have to use LanguageReference<LLVMLanguage>.\nYou can get it with lookupLanguageReference(LLVMLanguage.class), and then you can use languageRef.get() to get the LLVMLanguage back in the doCall method.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481975842", "createdAt": "2020-09-02T10:46:43Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignConstructorCallNode.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.runtime.interop;\n+\n+import com.oracle.truffle.api.frame.VirtualFrame;\n+import com.oracle.truffle.api.interop.ArityException;\n+import com.oracle.truffle.llvm.runtime.LLVMFunctionDescriptor;\n+import com.oracle.truffle.llvm.runtime.LLVMLanguage;\n+import com.oracle.truffle.llvm.runtime.debug.type.LLVMSourceFunctionType;\n+import com.oracle.truffle.llvm.runtime.interop.access.LLVMInteropType;\n+import com.oracle.truffle.llvm.runtime.memory.LLVMStack.StackPointer;\n+import com.oracle.truffle.llvm.runtime.types.Type;\n+import com.oracle.truffle.llvm.runtime.types.Type.TypeOverflowException;\n+\n+public class LLVMForeignConstructorCallNode extends LLVMForeignCallNode {\n+    private final Type clazzType;\n+    private final LLVMLanguage language;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4MzYxMw==", "bodyText": "You can use a @CachedContext(LLVMLanguage.class) context parameter to get the context in a more efficient way.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481983613", "createdAt": "2020-09-02T11:01:28Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +138,48 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n+                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n+        }\n+        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n+        Object[] newArguments = new Object[arguments.length + 1];\n+        newArguments[0] = receiver;\n+        for (int i = 0; i < arguments.length; i++) {\n+            newArguments[i + 1] = arguments[i];\n+        }\n+        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+\n+        Method method = clazz.findMethod(member, newArguments);\n+        if (method == null) {\n+            throw UnknownIdentifierException.create(member);\n+        }\n+        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4MzgyNg==", "bodyText": "You can use @CachedLibrary InteropLibrary interop to get a more efficient version of the interop library.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481983826", "createdAt": "2020-09-02T11:01:53Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +138,48 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n+                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n+        }\n+        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n+        Object[] newArguments = new Object[arguments.length + 1];\n+        newArguments[0] = receiver;\n+        for (int i = 0; i < arguments.length; i++) {\n+            newArguments[i + 1] = arguments[i];\n+        }\n+        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+\n+        Method method = clazz.findMethod(member, newArguments);\n+        if (method == null) {\n+            throw UnknownIdentifierException.create(member);\n+        }\n+        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());\n+        if (llvmFunction == null) {\n+            CompilerDirectives.transferToInterpreter();\n+            final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n+            final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n+            throw new LLVMLinkerException(msg);\n+        }\n+\n+        LLVMFunctionDescriptor fn = LLVMLanguage.getContext().createFunctionDescriptor(llvmFunction);\n+\n+        return InteropLibrary.getUncached().execute(fn, newArguments);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4NTU5NA==", "bodyText": "Also, e should probably do some caching here, since this is quite inefficient to do every time we call a method. If both clazz and member, and the argument array length are all the same, then llvmFunction should also be the same, so we can cache it. At compile time, we'd only have the comparisons, and then a direct call, instead of an expensive lookup and an indirect call.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481985594", "createdAt": "2020-09-02T11:05:33Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +138,48 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n+                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n+        }\n+        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n+        Object[] newArguments = new Object[arguments.length + 1];\n+        newArguments[0] = receiver;\n+        for (int i = 0; i < arguments.length; i++) {\n+            newArguments[i + 1] = arguments[i];\n+        }\n+        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+\n+        Method method = clazz.findMethod(member, newArguments);\n+        if (method == null) {\n+            throw UnknownIdentifierException.create(member);\n+        }\n+        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4NjM1Nw==", "bodyText": "I don't think we should create a new function descriptor every time we call the function. I think you actually want to use an LLVMAccessSymbolNode here to fetch the function pointer that points to this method.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481986357", "createdAt": "2020-09-02T11:07:10Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +138,48 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static Object invokeMember(LLVMPointerImpl receiver, String member, Object[] arguments)\n+                    throws UnsupportedMessageException, ArityException, UnknownIdentifierException, UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");\n+        }\n+        // change from receiver.foo(arguments) to interopLibrary.execute(foo, [receiver+arguments])\n+        Object[] newArguments = new Object[arguments.length + 1];\n+        newArguments[0] = receiver;\n+        for (int i = 0; i < arguments.length; i++) {\n+            newArguments[i + 1] = arguments[i];\n+        }\n+        LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) receiver.getExportType();\n+\n+        Method method = clazz.findMethod(member, newArguments);\n+        if (method == null) {\n+            throw UnknownIdentifierException.create(member);\n+        }\n+        LLVMFunction llvmFunction = LLVMLanguage.getContext().getGlobalScope().getFunction(method.getLinkageName());\n+        if (llvmFunction == null) {\n+            CompilerDirectives.transferToInterpreter();\n+            final String clazzName = clazz.toString().startsWith(\"class \") ? clazz.toString().substring(6) : clazz.toString();\n+            final String msg = String.format(\"No implementation of declared method %s::%s (%s) found\", clazzName, method.getName(), method.getLinkageName());\n+            throw new LLVMLinkerException(msg);\n+        }\n+\n+        LLVMFunctionDescriptor fn = LLVMLanguage.getContext().createFunctionDescriptor(llvmFunction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4Njc4MA==", "bodyText": "Should probably be type.getMethod(...).getName().", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481986780", "createdAt": "2020-09-02T11:08:08Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -232,6 +296,46 @@ Object readArrayElement(long idx,\n         }\n     }\n \n+    @ExportLibrary(InteropLibrary.class)\n+    public static final class ClassKeys implements TruffleObject {\n+        private final LLVMInteropType.Clazz type;\n+\n+        private ClassKeys(LLVMInteropType.Clazz type) {\n+            this.type = type;\n+        }\n+\n+        @ExportMessage\n+        boolean hasArrayElements() {\n+            return true;\n+        }\n+\n+        @ExportMessage\n+        long getArraySize() {\n+            return type.getMemberCount() + type.getMethodCount();\n+        }\n+\n+        @ExportMessage\n+        boolean isArrayElementReadable(long idx) {\n+            return Long.compareUnsigned(idx, getArraySize()) < 0;\n+        }\n+\n+        @ExportMessage\n+        Object readArrayElement(long idx,\n+                        @Cached BranchProfile exception) throws InvalidArrayIndexException {\n+            try {\n+                int index = (int) idx;\n+                if (index < type.getMemberCount()) {\n+                    return type.getMember(index).getName();\n+                } else {\n+                    return type.getMethod(index - type.getMemberCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4NzkzMw==", "bodyText": "Not sure I understand this test. You're passing a point to the constructor? Shouldn't the constructor have zero arguments, and return a Point?", "url": "https://github.com/oracle/graal/pull/2722#discussion_r481987933", "createdAt": "2020-09-02T11:10:32Z", "author": {"login": "rschatz"}, "path": "sulong/tests/com.oracle.truffle.llvm.tests/src/com/oracle/truffle/llvm/tests/interop/CxxMethodsTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+package com.oracle.truffle.llvm.tests.interop;\n+\n+import org.graalvm.polyglot.Value;\n+import org.junit.BeforeClass;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CxxMethodsTest extends InteropTestBase {\n+\n+    private static Value allocPoint;\n+    private static Value freePoint;\n+    private static Value allocXtendPoint;\n+    private static Value freeXtendPoint;\n+\n+    private static Value getY;\n+    private static Value setX;\n+    private static Value setY;\n+\n+    private static Value constructor;\n+\n+    private static Value squaredEuclideanDistance;\n+    private static Value swap;\n+\n+    private static Value testLibrary;\n+\n+    @BeforeClass\n+    public static void loadTestBitcode() {\n+        testLibrary = loadTestBitcodeValue(\"methodsTest.cpp\");\n+\n+        allocPoint = testLibrary.getMember(\"allocNativePoint\");\n+        freePoint = testLibrary.getMember(\"freeNativePoint\");\n+        allocXtendPoint = testLibrary.getMember(\"allocNativeXtendPoint\");\n+        freeXtendPoint = testLibrary.getMember(\"freeNativeXtendPoint\");\n+        getY = testLibrary.getMember(\"getY\");\n+        setX = testLibrary.getMember(\"setX\");\n+        setY = testLibrary.getMember(\"setY\");\n+        squaredEuclideanDistance = testLibrary.getMember(\"squaredEuclideanDistance\");\n+        constructor = testLibrary.getMember(\"Point\");\n+        swap = testLibrary.getMember(\"swap\");\n+    }\n+\n+    private static void checkPoint(Value point, int x, int y) {\n+        Assert.assertTrue(\"hasMembers\", point.hasMembers());\n+        Assert.assertFalse(\"hasArrayElements\", point.hasArrayElements());\n+\n+        Assert.assertTrue(\"hasMember(x)\", point.hasMember(\"x\"));\n+        Assert.assertTrue(\"hasMember(y)\", point.hasMember(\"y\"));\n+\n+        Assert.assertEquals(\"y\", y, point.getMember(\"y\").asInt());\n+        Assert.assertEquals(\"x\", x, point.getMember(\"x\").asInt());\n+    }\n+\n+    @Test\n+    public void testAllocPoint() {\n+        Value point = allocPoint.execute();\n+        try {\n+\n+            Assert.assertTrue(\"hasMember(x)\", point.hasMember(\"x\"));\n+            Assert.assertTrue(\"hasMember(y)\", point.hasMember(\"y\"));\n+\n+        } finally {\n+            freePoint.execute(point);\n+        }\n+    }\n+\n+    @Test\n+    public void testGettersAndSetters() {\n+        Value point = allocPoint.execute();\n+        try {\n+            point.invokeMember(\"setY\", 4);\n+            setX.execute(point, 30000);\n+            checkPoint(point, 30000, 4);\n+            checkPoint(point, point.invokeMember(\"getX\").asInt(), getY.execute(point).asInt());\n+\n+        } finally {\n+            freePoint.execute(point);\n+        }\n+    }\n+\n+    @Test\n+    public void testMemberFunction() {\n+        Value point = testLibrary.invokeMember(\"allocNativePoint\");\n+        Value point2 = allocPoint.execute();\n+        try {\n+            point.invokeMember(\"setX\", 3);\n+            Assert.assertEquals(\"getX()==3 after setX(3)\", 3, point.invokeMember(\"getX\").asInt());\n+            setY.execute(point, -4);\n+            setX.execute(point2, -6);\n+            testLibrary.invokeMember(\"setY\", point2, 8);\n+            checkPoint(point, 3, -4);\n+            checkPoint(point2, -6, 8);\n+            // swap point <-> point2\n+            swap.execute(point, point2);\n+            checkPoint(point2, 3, -4);\n+            checkPoint(point, -6, 8);\n+            // calculate distance\n+            Value distanceResult1 = squaredEuclideanDistance.execute(point, point2);\n+            Value distanceResult2 = squaredEuclideanDistance.execute(point2, point);\n+            Value distanceResult3 = point2.invokeMember(\"squaredEuclideanDistance\", point);\n+            Value distanceResult4 = point.invokeMember(\"squaredEuclideanDistance\", point2);\n+\n+            Assert.assertEquals(\"distance(p, p2)\", 0, Double.compare(225, distanceResult1.asDouble()));\n+            Assert.assertEquals(\"distance(p2, p)\", 0, Double.compare(225, distanceResult2.asDouble()));\n+            Assert.assertEquals(\"p.distance(p2)\", 0, Double.compare(225, distanceResult3.asDouble()));\n+            Assert.assertEquals(\"p2.distance(p)\", 0, Double.compare(225, distanceResult4.asDouble()));\n+\n+        } finally {\n+            testLibrary.invokeMember(\"freeNativePoint\", point);\n+            freePoint.execute(point2);\n+        }\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNonExistingMethod() {\n+        Value point = allocPoint.execute();\n+        try {\n+            point.invokeMember(\"methodWhichDoesNotExist\");\n+        } finally {\n+            testLibrary.invokeMember(\"freeNativePoint\", point);\n+        }\n+    }\n+\n+    @Test\n+    public void testOverloadedMethods() {\n+        Value xPoint = allocXtendPoint.execute();\n+        try {\n+            xPoint.invokeMember(\"setZ\", 1);\n+            Assert.assertEquals(\"getZ()\", 1, xPoint.invokeMember(\"getZ\").asInt());\n+            Assert.assertEquals(\"getZ(2)\", 3, xPoint.invokeMember(\"getZ\", 2).asInt());\n+        } finally {\n+            freeXtendPoint.execute(xPoint);\n+        }\n+    }\n+\n+    @Test\n+    public void testInheritedMethodsFromSuperclass() {\n+        Value xPoint = allocXtendPoint.execute();\n+        try {\n+            xPoint.invokeMember(\"setX\", 6);\n+            xPoint.invokeMember(\"setY\", 7);\n+            Assert.assertEquals(\"direct call: getX()\", 12, xPoint.invokeMember(\"getX\").asInt());\n+            Assert.assertEquals(\"superclass::getY()\", 7, xPoint.invokeMember(\"getY\").asInt());\n+        } finally {\n+            freeXtendPoint.execute(xPoint);\n+        }\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWrongArity() {\n+        Value point = allocPoint.execute();\n+        try {\n+            constructor.execute(point);\n+            point.invokeMember(\"setX\", 6, 9, 4);\n+        } finally {\n+            freePoint.execute(point);\n+        }\n+    }\n+\n+    @Test\n+    public void testConstructor() {\n+        Value point = allocPoint.execute();\n+        try {\n+            constructor.execute(point);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "486ea2dfc185f3d02ca7f394f98ec4770f4500c3"}, "originalPosition": 192}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "67b9b317711bae87b5b25f51fd0b9f7476cdcdff", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/67b9b317711bae87b5b25f51fd0b9f7476cdcdff", "committedDate": "2020-09-08T13:03:12Z", "message": "removing \"replaces\" attribute for @Specialization"}, "afterCommit": {"oid": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/b64390c26d9c1f9b97eee5d2dc2e11624f29fe09", "committedDate": "2020-09-08T13:06:39Z", "message": "removing \"replaces\" attribute for Specialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDE3MjQz", "url": "https://github.com/oracle/graal/pull/2722#pullrequestreview-501017243", "createdAt": "2020-10-02T10:15:48Z", "commit": {"oid": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxNTo0OFrOHbob3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxOTowOVrOHbohbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNjA5Mg==", "bodyText": "These @Cached values are all unused. I don't think they are necessary, since this is the generic fallback specialization that does the resolving on each call.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r498736092", "createdAt": "2020-10-02T10:15:48Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +142,84 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNjIwNA==", "bodyText": "Should replace doCached. It usually doesn't pay off to keep the cached versions after the inline cache overflows.\nAs a nice side effect, when this replaces doCached, the allowUncached = true arguments in doCached shouldn't be needed anymore.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r498736204", "createdAt": "2020-10-02T10:16:03Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +142,84 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNzUxNw==", "bodyText": "We shouldn't create a new function descriptor here. I wonder whether we need a variant of LLVMAccessSymbolNode that can take a dynamic symbol as argument... /cc @Palez", "url": "https://github.com/oracle/graal/pull/2722#discussion_r498737517", "createdAt": "2020-10-02T10:19:09Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +142,84 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\", allowUncached = true) LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\", allowUncached = true) Method method,\n+                        @Cached(value = \"arguments.length\", allowUncached = true) int argCount,\n+                        @Cached(value = \"method.getName()\", allowUncached = true) String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\", allowUncached = true) LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\", allowUncached = true) LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n+            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n+            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n+            Object newReceiver = context.createFunctionDescriptor(newLLVMFunction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b64390c26d9c1f9b97eee5d2dc2e11624f29fe09"}, "originalPosition": 130}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b664d2d5a7096ba792467a160026b3a32b417f99", "author": {"user": {"login": "pichristoph", "name": null}}, "url": "https://github.com/oracle/graal/commit/b664d2d5a7096ba792467a160026b3a32b417f99", "committedDate": "2020-10-05T08:21:45Z", "message": "Merge branch 'master' into feature/cppmethods3"}, "afterCommit": {"oid": "24f9f8293475ee130b0a80b7230a0a0810847aaa", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/24f9f8293475ee130b0a80b7230a0a0810847aaa", "committedDate": "2020-10-05T07:40:11Z", "message": "restructured 'invokeMember' message"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxODc1MDQy", "url": "https://github.com/oracle/graal/pull/2722#pullrequestreview-501875042", "createdAt": "2020-10-05T09:28:02Z", "commit": {"oid": "24f9f8293475ee130b0a80b7230a0a0810847aaa"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOToyODowM1rOHcUyjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOTozMToxMFrOHcU6pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2Mjc5Nw==", "bodyText": "I don't think this assertion is always correct. I'd just remove it.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r499462797", "createdAt": "2020-10-05T09:28:03Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/nodes/others/LLVMDynAccessSymbolNode.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates.\n+ *\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are\n+ * permitted provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of\n+ * conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and/or other materials provided\n+ * with the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written\n+ * permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.oracle.truffle.llvm.runtime.nodes.others;\n+\n+import com.oracle.truffle.api.CompilerAsserts;\n+import com.oracle.truffle.api.CompilerDirectives;\n+import com.oracle.truffle.api.dsl.CachedContext;\n+import com.oracle.truffle.api.dsl.Specialization;\n+import com.oracle.truffle.api.utilities.AssumedValue;\n+import com.oracle.truffle.llvm.runtime.LLVMContext;\n+import com.oracle.truffle.llvm.runtime.LLVMLanguage;\n+import com.oracle.truffle.llvm.runtime.LLVMSymbol;\n+import com.oracle.truffle.llvm.runtime.except.LLVMLinkerException;\n+import com.oracle.truffle.llvm.runtime.nodes.api.LLVMNode;\n+import com.oracle.truffle.llvm.runtime.pointer.LLVMPointer;\n+\n+public abstract class LLVMDynAccessSymbolNode extends LLVMNode {\n+\n+    public LLVMDynAccessSymbolNode() {\n+    }\n+\n+    public abstract LLVMPointer execute(LLVMSymbol symbol);\n+\n+    @Specialization\n+    LLVMPointer doAccess(LLVMSymbol symbol,\n+                    @CachedContext(LLVMLanguage.class) LLVMContext context) {\n+        CompilerAsserts.partialEvaluationConstant(symbol);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24f9f8293475ee130b0a80b7230a0a0810847aaa"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ2NDg3MA==", "bodyText": "allowUncached for nodes is wrong, that would create a new node for every call when used through an uncached library. Put the @GenerateUncached annotation on the LLVMDynAccessSymbolNode, then it should work without allowUncached = true. Also value = \"create()\" shouldn't be necessary, since that's the default (but not wrong either).", "url": "https://github.com/oracle/graal/pull/2722#discussion_r499464870", "createdAt": "2020-10-05T09:31:10Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -116,6 +143,79 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\") LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\") Method method,\n+                        @Cached(value = \"arguments.length\") int argCount,\n+                        @Cached(value = \"method.getName()\") String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\") LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\") LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        @Specialization(replaces = \"doCached\")\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"create()\", allowUncached = true) LLVMDynAccessSymbolNode dynAccessSymbolNode)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24f9f8293475ee130b0a80b7230a0a0810847aaa"}, "originalPosition": 120}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65de2f0ed19e240745fc3f8a424569402a453444", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/65de2f0ed19e240745fc3f8a424569402a453444", "committedDate": "2020-10-05T10:45:42Z", "message": "Add class type (to LLVM source types) and C++ method tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e47813aadf8f52829371fd4c3986bfed6ee5a717", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/e47813aadf8f52829371fd4c3986bfed6ee5a717", "committedDate": "2020-10-05T10:45:42Z", "message": "Update CxxMethodsTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e78074f41531ae40f6869bf7b889ecaa524c741f", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/e78074f41531ae40f6869bf7b889ecaa524c741f", "committedDate": "2020-10-05T10:45:42Z", "message": "Add class type to interop type structure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "070112fc7ae4f6b19d12029fb06e537fb6c70154", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/070112fc7ae4f6b19d12029fb06e537fb6c70154", "committedDate": "2020-10-05T10:45:42Z", "message": "make C++ method names accessible"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7543828c020bfba4155f0d8d2e478dfcf2867de", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/c7543828c020bfba4155f0d8d2e478dfcf2867de", "committedDate": "2020-10-05T10:50:11Z", "message": "enable C++ method calling via Sulong interoperability"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d104f1314a9a7cf4b0b2e82b2b7b5cab94846471", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/d104f1314a9a7cf4b0b2e82b2b7b5cab94846471", "committedDate": "2020-10-05T10:50:11Z", "message": "update C++/LLVM interop method calling and add tests for it"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01de5d8826026b2ee13784aaafb1ac7942ebbb3e", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/01de5d8826026b2ee13784aaafb1ac7942ebbb3e", "committedDate": "2020-10-05T10:50:11Z", "message": "enable method overloading w.r.t parameter count"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c1ba0267ad62420c24f433a59ea03d20cf294be", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/4c1ba0267ad62420c24f433a59ea03d20cf294be", "committedDate": "2020-10-05T10:50:11Z", "message": "enable calling inherited methods from superclasses"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c36a45170aaaadb40e89860c44a71f7c6d9dd5d9", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/c36a45170aaaadb40e89860c44a71f7c6d9dd5d9", "committedDate": "2020-10-05T10:50:11Z", "message": "Update tests for overloaded and inherited C++ methods"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ca4790e23563df31f7ae59b976309a7f07f8aa0a", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/ca4790e23563df31f7ae59b976309a7f07f8aa0a", "committedDate": "2020-10-05T10:39:59Z", "message": "adjust caching for invokeMember message"}, "afterCommit": {"oid": "3c33b4ad513bef2428c7c006dfeed51a5aab7a81", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/3c33b4ad513bef2428c7c006dfeed51a5aab7a81", "committedDate": "2020-10-05T11:08:01Z", "message": "remove unnecessary imports and warnings due to rebase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMDIyMTkz", "url": "https://github.com/oracle/graal/pull/2722#pullrequestreview-502022193", "createdAt": "2020-10-05T12:51:37Z", "commit": {"oid": "3c33b4ad513bef2428c7c006dfeed51a5aab7a81"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MjEzMjk3", "url": "https://github.com/oracle/graal/pull/2722#pullrequestreview-507213297", "createdAt": "2020-10-13T08:55:06Z", "commit": {"oid": "e9fec6d4dd4afdb16edbee01f67a6fdadb660b44"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwODo1NTowN1rOHgcYYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwODo1NTowN1rOHgcYYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc4MTQ3Mg==", "bodyText": "I think this is a wrong merge conflicting with e8b0489, which removed the forceInlining.", "url": "https://github.com/oracle/graal/pull/2722#discussion_r503781472", "createdAt": "2020-10-13T08:55:07Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/interop/LLVMForeignCallNode.java", "diffHunk": "@@ -188,19 +190,20 @@ public static PackForeignArgumentsNode create(FunctionType bitcodeFunctionType,\n     }\n \n     @CompilationFinal private ContextReference<LLVMContext> ctxRef;\n-    private final LLVMInteropType.Structured returnBaseType;\n+    protected final LLVMInteropType.Structured returnBaseType;\n \n     @Child LLVMGetStackFromThreadNode getStack;\n     @Child DirectCallNode callNode;\n     @Child LLVMDataEscapeNode prepareValueForEscape;\n     @Child PackForeignArgumentsNode packArguments;\n \n-    public LLVMForeignCallNode(LLVMLanguage language, LLVMFunctionDescriptor function, LLVMInteropType interopType, LLVMSourceFunctionType sourceType) {\n+    protected LLVMForeignCallNode(LLVMLanguage language, LLVMFunctionDescriptor function, LLVMInteropType interopType, LLVMSourceFunctionType sourceType, Structured returnBaseType, Type escapeType) {\n         super(language);\n-        this.returnBaseType = getReturnBaseType(interopType);\n+        this.returnBaseType = returnBaseType;\n         this.getStack = LLVMGetStackFromThreadNode.create();\n         this.callNode = DirectCallNode.create(getCallTarget(function));\n-        this.prepareValueForEscape = LLVMDataEscapeNode.create(function.getLLVMFunction().getType().getReturnType());\n+        this.callNode.forceInlining();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9fec6d4dd4afdb16edbee01f67a6fdadb660b44"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3MjE3NDk1", "url": "https://github.com/oracle/graal/pull/2722#pullrequestreview-507217495", "createdAt": "2020-10-13T08:59:36Z", "commit": {"oid": "e9fec6d4dd4afdb16edbee01f67a6fdadb660b44"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwODo1OTozNlrOHgclEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwODo1OTozNlrOHgclEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc4NDcyMQ==", "bodyText": "String concatenation is not safe on the fast path (internally this creates quite a lot of code). In this particular case, I'd just use a simple string (i.e. literally \"Receiver cannot be cast to LLVMInteropType.Clazz\", or maybe better \"Receiver type is not a class.\").", "url": "https://github.com/oracle/graal/pull/2722#discussion_r503784721", "createdAt": "2020-10-13T08:59:36Z", "author": {"login": "rschatz"}, "path": "sulong/projects/com.oracle.truffle.llvm.runtime/src/com/oracle/truffle/llvm/runtime/pointer/CommonPointerLibraries.java", "diffHunk": "@@ -119,6 +146,92 @@ static boolean isMemberModifiable(LLVMPointerImpl receiver, String ident,\n         }\n     }\n \n+    /**\n+     * @param receiver\n+     * @param ident\n+     * @see InteropLibrary#isMemberInsertable(Object, String)\n+     */\n+    @ExportMessage\n+    static boolean isMemberInvocable(LLVMPointerImpl receiver, String ident) {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (type instanceof LLVMInteropType.Clazz) {\n+            LLVMInteropType.Clazz clazz = (LLVMInteropType.Clazz) type;\n+            return clazz.findMethod(ident) != null;\n+        }\n+        return false;\n+    }\n+\n+    @ExportMessage\n+    static class InvokeMember {\n+        /**\n+         * @param member\n+         * @param context\n+         * @param clazz\n+         * @param method\n+         * @param argCount\n+         * @param methodName\n+         * @param llvmFunction\n+         * @see InteropLibrary#invokeMember(Object, String, Object[])\n+         */\n+        @Specialization(guards = {\"asClazz(receiver)==clazz\", \"member.equals(methodName)\", \"argCount==arguments.length\"})\n+        static Object doCached(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached(value = \"asClazz(receiver)\") LLVMInteropType.Clazz clazz,\n+                        @Cached(value = \"clazz.findMethodByArguments(receiver, member, arguments)\") Method method,\n+                        @Cached(value = \"arguments.length\") int argCount,\n+                        @Cached(value = \"method.getName()\") String methodName,\n+                        @Cached(value = \"getLLVMFunction(context, method, clazz, member)\") LLVMFunction llvmFunction,\n+                        @Cached(value = \"create(llvmFunction)\") LLVMAccessSymbolNode accessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            return interop.execute(accessSymbolNode.execute(), newArguments);\n+        }\n+\n+        @Specialization(replaces = \"doCached\")\n+        static Object doResolve(LLVMPointerImpl receiver, String member, Object[] arguments,\n+                        @CachedContext(LLVMLanguage.class) LLVMContext context, @CachedLibrary(limit = \"5\") InteropLibrary interop,\n+                        @Cached LLVMDynAccessSymbolNode dynAccessSymbolNode)\n+                        throws UnsupportedMessageException, ArityException, UnsupportedTypeException, UnknownIdentifierException {\n+            Object[] newArguments = addSelfObject(receiver, arguments);\n+            LLVMInteropType.Clazz newClazz = asClazz(receiver);\n+            Method newMethod = newClazz.findMethodByArguments(receiver, member, arguments);\n+            LLVMFunction newLLVMFunction = getLLVMFunction(context, newMethod, newClazz, member);\n+            Object newReceiver = dynAccessSymbolNode.execute(newLLVMFunction);\n+            return interop.execute(newReceiver, newArguments);\n+        }\n+    }\n+\n+    static LLVMInteropType.Clazz asClazz(LLVMPointerImpl receiver) throws UnsupportedTypeException {\n+        LLVMInteropType type = receiver.getExportType();\n+        if (!(type instanceof LLVMInteropType.Clazz)) {\n+            throw UnsupportedTypeException.create(new Object[]{receiver}, receiver + \" cannot be casted to LLVMInteropType.Clazz\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9fec6d4dd4afdb16edbee01f67a6fdadb660b44"}, "originalPosition": 147}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "062a150f4e8c7277b2e2a4c5589931ace1deb36c", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/062a150f4e8c7277b2e2a4c5589931ace1deb36c", "committedDate": "2020-10-13T11:42:45Z", "message": "Enable interop constructor calling and method/constructor arity checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7069abf73cc5f72e0ea765e53779224f546f6558", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/7069abf73cc5f72e0ea765e53779224f546f6558", "committedDate": "2020-10-13T11:44:05Z", "message": "fix checkstyle errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4351240bf8f0e3b2a85d12025f14c1c002027a69", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/4351240bf8f0e3b2a85d12025f14c1c002027a69", "committedDate": "2020-10-13T11:44:05Z", "message": "restructured LLVMSourceClassLikeType.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb1c33166f6e9265f2a4ac362d5c5b25c702c447", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/bb1c33166f6e9265f2a4ac362d5c5b25c702c447", "committedDate": "2020-10-13T11:44:05Z", "message": "add error message if declared method has no implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a62609eab6a6b923bf08ae6e86ef8df32cac718", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/7a62609eab6a6b923bf08ae6e86ef8df32cac718", "committedDate": "2020-10-13T11:44:05Z", "message": "include feedback: superclass of LLVMSourceClassLikeType; LLVMForeignCallNode; Caching"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90ba83c8488f27ce4a56346ab5d660d2d5dedb2c", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/90ba83c8488f27ce4a56346ab5d660d2d5dedb2c", "committedDate": "2020-10-13T11:44:05Z", "message": "removing \"replaces\" attribute for Specialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a8c6fec4539c782de0624aec269768a8e38b225", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/3a8c6fec4539c782de0624aec269768a8e38b225", "committedDate": "2020-10-13T11:44:05Z", "message": "restructured 'invokeMember' message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5d1aea5379d1ae1edae25510fb7009f516e4695", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/d5d1aea5379d1ae1edae25510fb7009f516e4695", "committedDate": "2020-10-13T11:44:05Z", "message": "adjust caching for invokeMember message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c99bed997da64b94347b36ca6fa0f21b6614be0", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/9c99bed997da64b94347b36ca6fa0f21b6614be0", "committedDate": "2020-10-13T11:44:05Z", "message": "apply API change due to rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11b21aa592e956bd1355735d905bb70b4cfdc36b", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/11b21aa592e956bd1355735d905bb70b4cfdc36b", "committedDate": "2020-10-13T11:44:05Z", "message": "remove unnecessary imports and warnings due to rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e48fbbff94e3ee3d424520b80e0d43385fb473d9", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/e48fbbff94e3ee3d424520b80e0d43385fb473d9", "committedDate": "2020-10-13T11:44:05Z", "message": "fix formatting issue in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "511e3731735758637aa999d65975c13f103f890d", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/511e3731735758637aa999d65975c13f103f890d", "committedDate": "2020-10-13T11:44:05Z", "message": "fix style issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edcf10bd1c3d851860e327ffaf3a6d76a49c0278", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/edcf10bd1c3d851860e327ffaf3a6d76a49c0278", "committedDate": "2020-10-13T11:44:05Z", "message": "remove non-fast-path operation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82fcbe8e2bc1ccec2a73474a6c631d5ecffca88d", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/82fcbe8e2bc1ccec2a73474a6c631d5ecffca88d", "committedDate": "2020-10-13T11:44:05Z", "message": "mark unused methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3a8b1f12722880f15727d9fed499141d799c6d1", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/d3a8b1f12722880f15727d9fed499141d799c6d1", "committedDate": "2020-10-13T11:44:05Z", "message": "remove 'class' notation for class names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f64a7ac68da4f31431db892a6d995c8e4bfd70e", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/8f64a7ac68da4f31431db892a6d995c8e4bfd70e", "committedDate": "2020-10-13T11:44:05Z", "message": "update test traces with method in scopes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80850dae5ac967b2cf2d7d0395019cd7e47a9dee", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/80850dae5ac967b2cf2d7d0395019cd7e47a9dee", "committedDate": "2020-10-13T11:44:05Z", "message": "fix copyright years"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa08592646749964c9c2bc9384bac9cf8506acd4", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/aa08592646749964c9c2bc9384bac9cf8506acd4", "committedDate": "2020-10-13T11:44:05Z", "message": "document unused parameters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cabd6619099eaf06c6338f4ae535722f519bd350", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/cabd6619099eaf06c6338f4ae535722f519bd350", "committedDate": "2020-10-13T11:44:06Z", "message": "Removed string concatenation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a411a86cd2270b3c0b0bc35e7d692421d1d6c9af", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/a411a86cd2270b3c0b0bc35e7d692421d1d6c9af", "committedDate": "2020-10-13T10:59:52Z", "message": "Removed string concatenation"}, "afterCommit": {"oid": "cabd6619099eaf06c6338f4ae535722f519bd350", "author": {"user": null}, "url": "https://github.com/oracle/graal/commit/cabd6619099eaf06c6338f4ae535722f519bd350", "committedDate": "2020-10-13T11:44:06Z", "message": "Removed string concatenation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1070, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}