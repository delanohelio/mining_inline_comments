{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4ODUzMTY2", "number": 2182, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowMDo1N1rOECFh3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowMzoxMlrOECFkzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjIzMTk2OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowMDo1N1rOGeU5Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo1ODozMlrOGeWu5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mjc0Ng==", "bodyText": "I think this is missing the mask of the lower bits in the shift amount. Here is a test:\ndiff --git a/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java b/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java\nindex 7212af4f80f..13ad08c91f8 100644\n--- a/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java\n+++ b/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java\n@@ -183,6 +183,16 @@ public class AArch64BitFieldTest extends AArch64MatchRuleTest {\n         testAndCheckLIR(\"signedB2LInsert\", 0xab3213efL);\n     }\n \n+    public long signedB2LInsertShAmtOverflow(long input) {\n+        byte b = (byte) input;\n+        return ((long) b) << 64;\n+    }\n+\n+    @Test\n+    public void testSignedB2LInsertShAmtOverflow() {\n+        testAndCheckLIR(\"signedB2LInsertShAmtOverflow\", 0xab3213efL);\n+    }\n+\n     // SBFIZ with S2L.\n     public long signedS2LInsert(long input) {\n         short s = (short) input;", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434452746", "createdAt": "2020-06-03T10:00:57Z", "author": {"login": "sanzinger"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "diffHunk": "@@ -233,38 +266,68 @@ public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {\n         return null;\n     }\n \n-    @MatchRule(\"(And (UnsignedRightShift=shift a Constant=b) Constant=c)\")\n-    @MatchRule(\"(LeftShift=shift (And a Constant=c) Constant=b)\")\n-    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {\n-        JavaKind srcKind = a.getStackKind();\n-        assert srcKind.isNumericInteger();\n-        AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());\n-        assert op != null;\n-        int distance = b.asJavaConstant().asInt();\n-        long mask = c.asJavaConstant().asLong();\n+    @MatchRule(\"(And (UnsignedRightShift=shift value Constant=a) Constant=b)\")\n+    @MatchRule(\"(LeftShift=shift (And value Constant=b) Constant=a)\")\n+    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = shift.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:\n-        // \"If the promoted type of the left-hand operand is int(long), then only the five(six)\n-        // lowest-order bits of the right-hand operand are used as the shift distance.\"\n-        distance = distance & (srcKind == JavaKind.Int ? 0x1f : 0x3f);\n+    @MatchRule(\"(LeftShift=shift (ZeroExtend=extend (And value Constant=b)) Constant=a)\")\n+    @MatchRule(\"(ZeroExtend=extend (And (UnsignedRightShift=shift value Constant=a) Constant=b))\")\n+    @MatchRule(\"(ZeroExtend=extend (LeftShift=shift (And value Constant=b) Constant=a))\")\n+    public ComplexMatchResult unsignedExtBitField(ZeroExtendNode extend, BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = extend.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // Constraint 1: Mask plus one should be a power-of-2 integer.\n-        if (!CodeUtil.isPowerOf2(mask + 1)) {\n-            return null;\n-        }\n-        int width = CodeUtil.log2(mask + 1);\n+    @MatchRule(\"(LeftShift=shift (SignExtend value) Constant)\")\n+    public ComplexMatchResult signedBitField(LeftShiftNode shift) {\n+        JavaKind kind = shift.getStackKind();\n+        assert kind.isNumericInteger();\n+\n+        SignExtendNode extend = (SignExtendNode) shift.getX();\n+        int srcBits = extend.getInputBits();\n+        int resultBits = extend.getResultBits();\n+        assert kind.getBitCount() == resultBits;\n+\n+        int lsb = shift.getY().asJavaConstant().asInt() & (resultBits - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MDk2OA==", "bodyText": "Left shift by 64 equals to 0. So this case can use a signed extended instruction\nsxtb        x0, w2", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434470968", "createdAt": "2020-06-03T10:34:48Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "diffHunk": "@@ -233,38 +266,68 @@ public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {\n         return null;\n     }\n \n-    @MatchRule(\"(And (UnsignedRightShift=shift a Constant=b) Constant=c)\")\n-    @MatchRule(\"(LeftShift=shift (And a Constant=c) Constant=b)\")\n-    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {\n-        JavaKind srcKind = a.getStackKind();\n-        assert srcKind.isNumericInteger();\n-        AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());\n-        assert op != null;\n-        int distance = b.asJavaConstant().asInt();\n-        long mask = c.asJavaConstant().asLong();\n+    @MatchRule(\"(And (UnsignedRightShift=shift value Constant=a) Constant=b)\")\n+    @MatchRule(\"(LeftShift=shift (And value Constant=b) Constant=a)\")\n+    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = shift.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:\n-        // \"If the promoted type of the left-hand operand is int(long), then only the five(six)\n-        // lowest-order bits of the right-hand operand are used as the shift distance.\"\n-        distance = distance & (srcKind == JavaKind.Int ? 0x1f : 0x3f);\n+    @MatchRule(\"(LeftShift=shift (ZeroExtend=extend (And value Constant=b)) Constant=a)\")\n+    @MatchRule(\"(ZeroExtend=extend (And (UnsignedRightShift=shift value Constant=a) Constant=b))\")\n+    @MatchRule(\"(ZeroExtend=extend (LeftShift=shift (And value Constant=b) Constant=a))\")\n+    public ComplexMatchResult unsignedExtBitField(ZeroExtendNode extend, BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = extend.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // Constraint 1: Mask plus one should be a power-of-2 integer.\n-        if (!CodeUtil.isPowerOf2(mask + 1)) {\n-            return null;\n-        }\n-        int width = CodeUtil.log2(mask + 1);\n+    @MatchRule(\"(LeftShift=shift (SignExtend value) Constant)\")\n+    public ComplexMatchResult signedBitField(LeftShiftNode shift) {\n+        JavaKind kind = shift.getStackKind();\n+        assert kind.isNumericInteger();\n+\n+        SignExtendNode extend = (SignExtendNode) shift.getX();\n+        int srcBits = extend.getInputBits();\n+        int resultBits = extend.getResultBits();\n+        assert kind.getBitCount() == resultBits;\n+\n+        int lsb = shift.getY().asJavaConstant().asInt() & (resultBits - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mjc0Ng=="}, "originalCommit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4MjkxNw==", "bodyText": "Ah. I see. I didn't pay too much attention to the output of the test. Yes this was false alarm. Everything looks good.", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434482917", "createdAt": "2020-06-03T10:58:32Z", "author": {"login": "sanzinger"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "diffHunk": "@@ -233,38 +266,68 @@ public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {\n         return null;\n     }\n \n-    @MatchRule(\"(And (UnsignedRightShift=shift a Constant=b) Constant=c)\")\n-    @MatchRule(\"(LeftShift=shift (And a Constant=c) Constant=b)\")\n-    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {\n-        JavaKind srcKind = a.getStackKind();\n-        assert srcKind.isNumericInteger();\n-        AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());\n-        assert op != null;\n-        int distance = b.asJavaConstant().asInt();\n-        long mask = c.asJavaConstant().asLong();\n+    @MatchRule(\"(And (UnsignedRightShift=shift value Constant=a) Constant=b)\")\n+    @MatchRule(\"(LeftShift=shift (And value Constant=b) Constant=a)\")\n+    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = shift.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:\n-        // \"If the promoted type of the left-hand operand is int(long), then only the five(six)\n-        // lowest-order bits of the right-hand operand are used as the shift distance.\"\n-        distance = distance & (srcKind == JavaKind.Int ? 0x1f : 0x3f);\n+    @MatchRule(\"(LeftShift=shift (ZeroExtend=extend (And value Constant=b)) Constant=a)\")\n+    @MatchRule(\"(ZeroExtend=extend (And (UnsignedRightShift=shift value Constant=a) Constant=b))\")\n+    @MatchRule(\"(ZeroExtend=extend (LeftShift=shift (And value Constant=b) Constant=a))\")\n+    public ComplexMatchResult unsignedExtBitField(ZeroExtendNode extend, BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = extend.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // Constraint 1: Mask plus one should be a power-of-2 integer.\n-        if (!CodeUtil.isPowerOf2(mask + 1)) {\n-            return null;\n-        }\n-        int width = CodeUtil.log2(mask + 1);\n+    @MatchRule(\"(LeftShift=shift (SignExtend value) Constant)\")\n+    public ComplexMatchResult signedBitField(LeftShiftNode shift) {\n+        JavaKind kind = shift.getStackKind();\n+        assert kind.isNumericInteger();\n+\n+        SignExtendNode extend = (SignExtendNode) shift.getX();\n+        int srcBits = extend.getInputBits();\n+        int resultBits = extend.getResultBits();\n+        assert kind.getBitCount() == resultBits;\n+\n+        int lsb = shift.getY().asJavaConstant().asInt() & (resultBits - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mjc0Ng=="}, "originalCommit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjIzOTQ4OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowMzoxMlrOGeU96A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDozNjo0MlrOGeWEbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mzk5Mg==", "bodyText": "This may be missing the masking of the lower bits as well. (Same as above in .signedBitField) Please doublecheck.", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434453992", "createdAt": "2020-06-03T10:03:12Z", "author": {"login": "sanzinger"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "diffHunk": "@@ -233,38 +266,68 @@ public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {\n         return null;\n     }\n \n-    @MatchRule(\"(And (UnsignedRightShift=shift a Constant=b) Constant=c)\")\n-    @MatchRule(\"(LeftShift=shift (And a Constant=c) Constant=b)\")\n-    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {\n-        JavaKind srcKind = a.getStackKind();\n-        assert srcKind.isNumericInteger();\n-        AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());\n-        assert op != null;\n-        int distance = b.asJavaConstant().asInt();\n-        long mask = c.asJavaConstant().asLong();\n+    @MatchRule(\"(And (UnsignedRightShift=shift value Constant=a) Constant=b)\")\n+    @MatchRule(\"(LeftShift=shift (And value Constant=b) Constant=a)\")\n+    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = shift.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:\n-        // \"If the promoted type of the left-hand operand is int(long), then only the five(six)\n-        // lowest-order bits of the right-hand operand are used as the shift distance.\"\n-        distance = distance & (srcKind == JavaKind.Int ? 0x1f : 0x3f);\n+    @MatchRule(\"(LeftShift=shift (ZeroExtend=extend (And value Constant=b)) Constant=a)\")\n+    @MatchRule(\"(ZeroExtend=extend (And (UnsignedRightShift=shift value Constant=a) Constant=b))\")\n+    @MatchRule(\"(ZeroExtend=extend (LeftShift=shift (And value Constant=b) Constant=a))\")\n+    public ComplexMatchResult unsignedExtBitField(ZeroExtendNode extend, BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = extend.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // Constraint 1: Mask plus one should be a power-of-2 integer.\n-        if (!CodeUtil.isPowerOf2(mask + 1)) {\n-            return null;\n-        }\n-        int width = CodeUtil.log2(mask + 1);\n+    @MatchRule(\"(LeftShift=shift (SignExtend value) Constant)\")\n+    public ComplexMatchResult signedBitField(LeftShiftNode shift) {\n+        JavaKind kind = shift.getStackKind();\n+        assert kind.isNumericInteger();\n+\n+        SignExtendNode extend = (SignExtendNode) shift.getX();\n+        int srcBits = extend.getInputBits();\n+        int resultBits = extend.getResultBits();\n+        assert kind.getBitCount() == resultBits;\n+\n+        int lsb = shift.getY().asJavaConstant().asInt() & (resultBits - 1);\n+        // Get the min value of the srcBits and (resultBits - lsb) as the bitfield width.\n+        int width = Math.min(srcBits, resultBits - lsb);\n+        assert width >= 1 && width <= resultBits - lsb;\n+\n+        ValueNode value = extend.getValue();\n+        return emitBitField(kind, BitFieldOpCode.SBFIZ, value, lsb, width);\n+    }\n+\n+    @MatchRule(\"(RightShift=rshift (LeftShift=lshift value Constant) Constant)\")\n+    @MatchRule(\"(UnsignedRightShift=rshift (LeftShift=lshift value Constant) Constant)\")\n+    public ComplexMatchResult bitFieldMove(BinaryNode rshift, LeftShiftNode lshift) {\n+        JavaKind srcKind = rshift.getStackKind();\n+        assert srcKind.isNumericInteger();\n         int srcBits = srcKind.getBitCount();\n-        // Constraint 2: Bit field width is less than 31(63) for int(long) as any bit field move\n-        // operations can be done by a single shift instruction if the width is 31(63).\n-        if (width >= srcBits - 1) {\n+        int lshiftNum = lshift.getY().asJavaConstant().asInt() & (srcBits - 1);\n+        int rshiftNum = rshift.getY().asJavaConstant().asInt() & (srcBits - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MjA0Ng==", "bodyText": "Actually I think  & (srcBits - 1) is not needed, since the compiler has handled it in the mid-end.", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434472046", "createdAt": "2020-06-03T10:36:42Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "diffHunk": "@@ -233,38 +266,68 @@ public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {\n         return null;\n     }\n \n-    @MatchRule(\"(And (UnsignedRightShift=shift a Constant=b) Constant=c)\")\n-    @MatchRule(\"(LeftShift=shift (And a Constant=c) Constant=b)\")\n-    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {\n-        JavaKind srcKind = a.getStackKind();\n-        assert srcKind.isNumericInteger();\n-        AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());\n-        assert op != null;\n-        int distance = b.asJavaConstant().asInt();\n-        long mask = c.asJavaConstant().asLong();\n+    @MatchRule(\"(And (UnsignedRightShift=shift value Constant=a) Constant=b)\")\n+    @MatchRule(\"(LeftShift=shift (And value Constant=b) Constant=a)\")\n+    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = shift.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:\n-        // \"If the promoted type of the left-hand operand is int(long), then only the five(six)\n-        // lowest-order bits of the right-hand operand are used as the shift distance.\"\n-        distance = distance & (srcKind == JavaKind.Int ? 0x1f : 0x3f);\n+    @MatchRule(\"(LeftShift=shift (ZeroExtend=extend (And value Constant=b)) Constant=a)\")\n+    @MatchRule(\"(ZeroExtend=extend (And (UnsignedRightShift=shift value Constant=a) Constant=b))\")\n+    @MatchRule(\"(ZeroExtend=extend (LeftShift=shift (And value Constant=b) Constant=a))\")\n+    public ComplexMatchResult unsignedExtBitField(ZeroExtendNode extend, BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = extend.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // Constraint 1: Mask plus one should be a power-of-2 integer.\n-        if (!CodeUtil.isPowerOf2(mask + 1)) {\n-            return null;\n-        }\n-        int width = CodeUtil.log2(mask + 1);\n+    @MatchRule(\"(LeftShift=shift (SignExtend value) Constant)\")\n+    public ComplexMatchResult signedBitField(LeftShiftNode shift) {\n+        JavaKind kind = shift.getStackKind();\n+        assert kind.isNumericInteger();\n+\n+        SignExtendNode extend = (SignExtendNode) shift.getX();\n+        int srcBits = extend.getInputBits();\n+        int resultBits = extend.getResultBits();\n+        assert kind.getBitCount() == resultBits;\n+\n+        int lsb = shift.getY().asJavaConstant().asInt() & (resultBits - 1);\n+        // Get the min value of the srcBits and (resultBits - lsb) as the bitfield width.\n+        int width = Math.min(srcBits, resultBits - lsb);\n+        assert width >= 1 && width <= resultBits - lsb;\n+\n+        ValueNode value = extend.getValue();\n+        return emitBitField(kind, BitFieldOpCode.SBFIZ, value, lsb, width);\n+    }\n+\n+    @MatchRule(\"(RightShift=rshift (LeftShift=lshift value Constant) Constant)\")\n+    @MatchRule(\"(UnsignedRightShift=rshift (LeftShift=lshift value Constant) Constant)\")\n+    public ComplexMatchResult bitFieldMove(BinaryNode rshift, LeftShiftNode lshift) {\n+        JavaKind srcKind = rshift.getStackKind();\n+        assert srcKind.isNumericInteger();\n         int srcBits = srcKind.getBitCount();\n-        // Constraint 2: Bit field width is less than 31(63) for int(long) as any bit field move\n-        // operations can be done by a single shift instruction if the width is 31(63).\n-        if (width >= srcBits - 1) {\n+        int lshiftNum = lshift.getY().asJavaConstant().asInt() & (srcBits - 1);\n+        int rshiftNum = rshift.getY().asJavaConstant().asInt() & (srcBits - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mzk5Mg=="}, "originalCommit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68"}, "originalPosition": 157}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 825, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}