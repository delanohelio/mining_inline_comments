{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4ODUzMTY2", "number": 2182, "title": "AArch64: Add match rules for bitfield move.", "bodyText": "This patch adds the following match rules to generate bitfield\nmove instruction on AArch64:\n\n(RightShift (LeftShift value a) b)         -> SBFX/SBFIZ\n(UnsignedRightShift (LeftShift value a) b) -> UBFX/UBFIZ\n(LeftShift (SignExtend value) a)           -> SBFIZ\n\nFor example:\n  lsl    w0, w1, #8\n  asr    w0, w0, #15\n\nis optimized to:\n  sbfx   w0, w1, #7, #1700 \n\nIt also adds the rules to integrate the ZeroExtend with unsigned\nbitfield move operation.\nFor example:\n  ubfiz  w0, w1, #5, #12\n  and    x0, x0, #0xffffffff\n\nis optimized to:\n  ubfiz  x0, x1, #5, #12\n\nChange-Id: I2b635d4895db0d5f4c30630176f336e9a226ccaf", "createdAt": "2020-02-24T07:56:29Z", "url": "https://github.com/oracle/graal/pull/2182", "merged": true, "mergeCommit": {"oid": "519f3dee68e2d4592a244cb586f480e1f8f6d128"}, "closed": true, "closedAt": "2020-06-05T20:03:26Z", "author": {"login": "XiaohongGong"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHYt5GAH2gAyMzc4ODUzMTY2OjViMWQ0ZTI4NjQ3NzM0ZWNhNDU2MjI2ZDVlZDJjMGZjNGRiOGRmNjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcn76XsgFqTQyNDMyODI4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/5b1d4e28647734eca456226d5ed2c0fc4db8df68", "committedDate": "2020-02-24T07:51:24Z", "message": "AArch64: Add match rules for bitfield move.\n\nThis patch adds the following match rules to generate bitfield\nmove instruction on AArch64:\n* (RightShift (LeftShift value a) b)         -> SBFX/SBFIZ\n* (UnsignedRightShift (LeftShift value a) b) -> UBFX/UBFIZ\n* (LeftShift (SignExtend value) a)           -> SBFIZ\nEg:\n  lsl    w0, w1, #8\n  asr    w0, w0, #15\nis optimized to:\n  sbfx   w0, w1, #7, #17\n\nIt also adds the rules to integrate the ZeroExtend with unsigned\nbitfield move operation.\nEg:\n  ubfiz  w0, w1, #5, #12\n  and    x0, x0, #0xffffffff\nis optimized to:\n  ubfiz  x0, x1, #5, #12\n\nChange-Id: I2b635d4895db0d5f4c30630176f336e9a226ccaf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDAyNDI1", "url": "https://github.com/oracle/graal/pull/2182#pullrequestreview-423402425", "createdAt": "2020-06-03T10:00:57Z", "commit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowMDo1N1rOGeU5Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowMzoxMlrOGeU96A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mjc0Ng==", "bodyText": "I think this is missing the mask of the lower bits in the shift amount. Here is a test:\ndiff --git a/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java b/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java\nindex 7212af4f80f..13ad08c91f8 100644\n--- a/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java\n+++ b/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java\n@@ -183,6 +183,16 @@ public class AArch64BitFieldTest extends AArch64MatchRuleTest {\n         testAndCheckLIR(\"signedB2LInsert\", 0xab3213efL);\n     }\n \n+    public long signedB2LInsertShAmtOverflow(long input) {\n+        byte b = (byte) input;\n+        return ((long) b) << 64;\n+    }\n+\n+    @Test\n+    public void testSignedB2LInsertShAmtOverflow() {\n+        testAndCheckLIR(\"signedB2LInsertShAmtOverflow\", 0xab3213efL);\n+    }\n+\n     // SBFIZ with S2L.\n     public long signedS2LInsert(long input) {\n         short s = (short) input;", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434452746", "createdAt": "2020-06-03T10:00:57Z", "author": {"login": "sanzinger"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "diffHunk": "@@ -233,38 +266,68 @@ public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {\n         return null;\n     }\n \n-    @MatchRule(\"(And (UnsignedRightShift=shift a Constant=b) Constant=c)\")\n-    @MatchRule(\"(LeftShift=shift (And a Constant=c) Constant=b)\")\n-    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {\n-        JavaKind srcKind = a.getStackKind();\n-        assert srcKind.isNumericInteger();\n-        AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());\n-        assert op != null;\n-        int distance = b.asJavaConstant().asInt();\n-        long mask = c.asJavaConstant().asLong();\n+    @MatchRule(\"(And (UnsignedRightShift=shift value Constant=a) Constant=b)\")\n+    @MatchRule(\"(LeftShift=shift (And value Constant=b) Constant=a)\")\n+    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = shift.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:\n-        // \"If the promoted type of the left-hand operand is int(long), then only the five(six)\n-        // lowest-order bits of the right-hand operand are used as the shift distance.\"\n-        distance = distance & (srcKind == JavaKind.Int ? 0x1f : 0x3f);\n+    @MatchRule(\"(LeftShift=shift (ZeroExtend=extend (And value Constant=b)) Constant=a)\")\n+    @MatchRule(\"(ZeroExtend=extend (And (UnsignedRightShift=shift value Constant=a) Constant=b))\")\n+    @MatchRule(\"(ZeroExtend=extend (LeftShift=shift (And value Constant=b) Constant=a))\")\n+    public ComplexMatchResult unsignedExtBitField(ZeroExtendNode extend, BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = extend.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // Constraint 1: Mask plus one should be a power-of-2 integer.\n-        if (!CodeUtil.isPowerOf2(mask + 1)) {\n-            return null;\n-        }\n-        int width = CodeUtil.log2(mask + 1);\n+    @MatchRule(\"(LeftShift=shift (SignExtend value) Constant)\")\n+    public ComplexMatchResult signedBitField(LeftShiftNode shift) {\n+        JavaKind kind = shift.getStackKind();\n+        assert kind.isNumericInteger();\n+\n+        SignExtendNode extend = (SignExtendNode) shift.getX();\n+        int srcBits = extend.getInputBits();\n+        int resultBits = extend.getResultBits();\n+        assert kind.getBitCount() == resultBits;\n+\n+        int lsb = shift.getY().asJavaConstant().asInt() & (resultBits - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mzk5Mg==", "bodyText": "This may be missing the masking of the lower bits as well. (Same as above in .signedBitField) Please doublecheck.", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434453992", "createdAt": "2020-06-03T10:03:12Z", "author": {"login": "sanzinger"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "diffHunk": "@@ -233,38 +266,68 @@ public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {\n         return null;\n     }\n \n-    @MatchRule(\"(And (UnsignedRightShift=shift a Constant=b) Constant=c)\")\n-    @MatchRule(\"(LeftShift=shift (And a Constant=c) Constant=b)\")\n-    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {\n-        JavaKind srcKind = a.getStackKind();\n-        assert srcKind.isNumericInteger();\n-        AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());\n-        assert op != null;\n-        int distance = b.asJavaConstant().asInt();\n-        long mask = c.asJavaConstant().asLong();\n+    @MatchRule(\"(And (UnsignedRightShift=shift value Constant=a) Constant=b)\")\n+    @MatchRule(\"(LeftShift=shift (And value Constant=b) Constant=a)\")\n+    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = shift.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:\n-        // \"If the promoted type of the left-hand operand is int(long), then only the five(six)\n-        // lowest-order bits of the right-hand operand are used as the shift distance.\"\n-        distance = distance & (srcKind == JavaKind.Int ? 0x1f : 0x3f);\n+    @MatchRule(\"(LeftShift=shift (ZeroExtend=extend (And value Constant=b)) Constant=a)\")\n+    @MatchRule(\"(ZeroExtend=extend (And (UnsignedRightShift=shift value Constant=a) Constant=b))\")\n+    @MatchRule(\"(ZeroExtend=extend (LeftShift=shift (And value Constant=b) Constant=a))\")\n+    public ComplexMatchResult unsignedExtBitField(ZeroExtendNode extend, BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = extend.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // Constraint 1: Mask plus one should be a power-of-2 integer.\n-        if (!CodeUtil.isPowerOf2(mask + 1)) {\n-            return null;\n-        }\n-        int width = CodeUtil.log2(mask + 1);\n+    @MatchRule(\"(LeftShift=shift (SignExtend value) Constant)\")\n+    public ComplexMatchResult signedBitField(LeftShiftNode shift) {\n+        JavaKind kind = shift.getStackKind();\n+        assert kind.isNumericInteger();\n+\n+        SignExtendNode extend = (SignExtendNode) shift.getX();\n+        int srcBits = extend.getInputBits();\n+        int resultBits = extend.getResultBits();\n+        assert kind.getBitCount() == resultBits;\n+\n+        int lsb = shift.getY().asJavaConstant().asInt() & (resultBits - 1);\n+        // Get the min value of the srcBits and (resultBits - lsb) as the bitfield width.\n+        int width = Math.min(srcBits, resultBits - lsb);\n+        assert width >= 1 && width <= resultBits - lsb;\n+\n+        ValueNode value = extend.getValue();\n+        return emitBitField(kind, BitFieldOpCode.SBFIZ, value, lsb, width);\n+    }\n+\n+    @MatchRule(\"(RightShift=rshift (LeftShift=lshift value Constant) Constant)\")\n+    @MatchRule(\"(UnsignedRightShift=rshift (LeftShift=lshift value Constant) Constant)\")\n+    public ComplexMatchResult bitFieldMove(BinaryNode rshift, LeftShiftNode lshift) {\n+        JavaKind srcKind = rshift.getStackKind();\n+        assert srcKind.isNumericInteger();\n         int srcBits = srcKind.getBitCount();\n-        // Constraint 2: Bit field width is less than 31(63) for int(long) as any bit field move\n-        // operations can be done by a single shift instruction if the width is 31(63).\n-        if (width >= srcBits - 1) {\n+        int lshiftNum = lshift.getY().asJavaConstant().asInt() & (srcBits - 1);\n+        int rshiftNum = rshift.getY().asJavaConstant().asInt() & (srcBits - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzI4Mjg3", "url": "https://github.com/oracle/graal/pull/2182#pullrequestreview-424328287", "createdAt": "2020-06-04T10:57:17Z", "commit": {"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1097, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}