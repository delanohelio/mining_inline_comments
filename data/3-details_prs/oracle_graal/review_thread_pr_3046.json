{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyNjQ0NzU2", "number": 3046, "reviewThreads": {"totalCount": 41, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowMDo0OVrOFIIgSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxMToyNTozMlrOFYVcwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDcyMjY1OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowMDo0OVrOIJ4x2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowMDo0OVrOIJ4x2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzODM2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            kows how to dereference it to locate the object field\n          \n          \n            \n            knows how to dereference it to locate the object field", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547238362", "createdAt": "2020-12-22T12:00:49Z", "author": {"login": "zakkak"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+kows how to dereference it to locate the object field", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDcyNjc0OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowMjoxNVrOIJ40SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowMjoxNVrOIJ40SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzODk4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            However, this transformation won't work correctly in the secodn case\n          \n          \n            \n            However, this transformation won't work correctly in the second case", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547238985", "createdAt": "2020-12-22T12:02:15Z", "author": {"login": "zakkak"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+kows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx\n+```\n+\n+The raw address in the register is the same as the oop value stored\n+in the field.\n+\n+By contrast, when isolates are enabled oop references stored in static\n+or instance fields are actually relative addresses, offsets from a\n+dedicated heap base register (r14 on x86_64, r29 on AArch64), rather\n+than direct addresses.  However, when an oop gets loaded during\n+execution it is almost always immediately converted to a direct\n+address by adding the offset to the heap base register value. The\n+DWARF info encoded into the image tells gdb to rebase object pointers\n+whenever it tries to dereference them to access the underlying object\n+data.\n+\n+This still means gdb will do the right thing when it accesses an\n+object via a static field. When processing the field expression above\n+that prints the default unit name gdb will automatically rebase the\n+`Units` oop stored in field `DEFAULT_UNIT` by adding it to the heap\n+base register. It will then fetch and rebase the oop stored in its\n+`print_name` field to access the contents of the `String`.\n+\n+However, this transformation won't work correctly in the secodn case", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDczNjY4OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowNTo0NFrOIJ46Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowNTo0NFrOIJ46Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MDQ4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            the hub field that are sometimesmay sometimes get set by the runtime\n          \n          \n            \n            the hub field that may sometimes get set by the runtime", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547240486", "createdAt": "2020-12-22T12:05:44Z", "author": {"login": "zakkak"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,347 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in\n+the hub field that are sometimesmay sometimes get set by the runtime", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDc0MDc0OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowNjo1NVrOIJ48bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowNjo1NVrOIJ48bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MTA2OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (he last one is for\n          \n          \n            \n            one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (the last one is for", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547241068", "createdAt": "2020-12-22T12:06:55Z", "author": {"login": "zakkak"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,347 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in\n+the hub field that are sometimesmay sometimes get set by the runtime\n+during program operation.\n+\n+Attempting to print the hub name for an invalid reference will fail\n+safe, printing an error message.\n+\n+```\n+(gdb) p/x (_objhdr *)$rdx\n+$5 = 0x2\n+(gdb) hubname $rdx\n+Cannot access memory at address 0x2\n+```\n+\n+Array type layouts are modelled with a class. The class inherits\n+fields from an array header struct specific to the array element type,\n+one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (he last one is for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDc0NzgxOnYy", "diffSide": "RIGHT", "path": "substratevm/mx.substratevm/mx_substratevm.py", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjowOToyOFrOIJ5Adw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNjoyNDo1N1rOIX-w9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MjEwMw==", "bodyText": "Would it make sense to have tests with isolates enabled as well?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547242103", "createdAt": "2020-12-22T12:09:28Z", "author": {"login": "zakkak"}, "path": "substratevm/mx.substratevm/mx_substratevm.py", "diffHunk": "@@ -734,6 +734,7 @@ def _debuginfotest(native_image, path, build_only, args):\n                          '-cp', classpath('com.oracle.svm.test'),\n                          '-Dgraal.LogFile=graal.log',\n                          '-g',\n+                         '-H:-SpawnIsolates',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxMjM2NQ==", "bodyText": "That's a good idea but probably best left to a follow-up issue.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551212365", "createdAt": "2021-01-04T09:50:11Z", "author": {"login": "adinn"}, "path": "substratevm/mx.substratevm/mx_substratevm.py", "diffHunk": "@@ -734,6 +734,7 @@ def _debuginfotest(native_image, path, build_only, args):\n                          '-cp', classpath('com.oracle.svm.test'),\n                          '-Dgraal.LogFile=graal.log',\n                          '-g',\n+                         '-H:-SpawnIsolates',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MjEwMw=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTg3OTM0Mw==", "bodyText": "@adinn at https://github.com/oracle/graal/pull/3046/files#diff-eab1ebfe7b30eac56f68f32f6eff8466a51b176a60fcd6b0309d974f48579057L744 please\nuse os.environ.get('GDB_BIN', 'gdb') instead of hardcoding 'gdb' in mx.run.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r561879343", "createdAt": "2021-01-21T13:27:55Z", "author": {"login": "olpaw"}, "path": "substratevm/mx.substratevm/mx_substratevm.py", "diffHunk": "@@ -734,6 +734,7 @@ def _debuginfotest(native_image, path, build_only, args):\n                          '-cp', classpath('com.oracle.svm.test'),\n                          '-Dgraal.LogFile=graal.log',\n                          '-g',\n+                         '-H:-SpawnIsolates',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MjEwMw=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAxNjUwMQ==", "bodyText": "Done.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562016501", "createdAt": "2021-01-21T16:24:57Z", "author": {"login": "adinn"}, "path": "substratevm/mx.substratevm/mx_substratevm.py", "diffHunk": "@@ -734,6 +734,7 @@ def _debuginfotest(native_image, path, build_only, args):\n                          '-cp', classpath('com.oracle.svm.test'),\n                          '-Dgraal.LogFile=graal.log',\n                          '-g',\n+                         '-H:-SpawnIsolates',", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0MjEwMw=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDc2MTE4OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ArrayTypeEntry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoxNDo0MlrOIJ5IhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoxNDo0MlrOIJ5IhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NDE2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    elementType = debugInfoBase.lookupTypeEntry(elementTypeName);\n          \n          \n            \n                    this.elementType = debugInfoBase.lookupTypeEntry(elementTypeName);", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547244164", "createdAt": "2020-12-22T12:14:42Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ArrayTypeEntry.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debugentry;\n+\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugArrayTypeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfo.DebugTypeKind;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+public class ArrayTypeEntry extends TypeEntry {\n+    private TypeEntry elementType;\n+    private int headerSize;\n+    private int lengthOffset;\n+\n+    public ArrayTypeEntry(String typeName, int size) {\n+        super(typeName, size);\n+    }\n+\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.ARRAY;\n+    }\n+\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        DebugArrayTypeInfo debugArrayTypeInfo = (DebugArrayTypeInfo) debugTypeInfo;\n+        String elementTypeName = TypeEntry.canonicalize(debugArrayTypeInfo.elementType());\n+        elementType = debugInfoBase.lookupTypeEntry(elementTypeName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDc2NzU4OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoxNzowNFrOIJ5MSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1Njo0OFrOINribQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTEyOA==", "bodyText": "Wouldn't it be safer to use a different name? e.g. primaryFileEntry", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547245128", "createdAt": "2020-12-22T12:17:04Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -133,10 +122,14 @@ public void addPrimary(Range primary, List<DebugFrameSizeChange> frameSizeInfos,\n                 /* deopt targets should all come after normal methods */\n                 assert includesDeoptTarget == false;\n             }\n+            @SuppressWarnings(\"hiding\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNTcyNQ==", "bodyText": "yes", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551215725", "createdAt": "2021-01-04T09:56:48Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -133,10 +122,14 @@ public void addPrimary(Range primary, List<DebugFrameSizeChange> frameSizeInfos,\n                 /* deopt targets should all come after normal methods */\n                 assert includesDeoptTarget == false;\n             }\n+            @SuppressWarnings(\"hiding\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTEyOA=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDc3Mjc1OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoxODo1NlrOIJ5PWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDozMTo0NFrOINsqMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTkxMg==", "bodyText": "As above, I would prevent the hiding (especially here where the SuppressWarnings annotation is \"hidden\" in the method signature) by using a different name, e.g. entry in this case.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547245912", "createdAt": "2020-12-22T12:18:56Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -148,13 +141,18 @@ public void addSubRange(Range subrange, FileEntry subFileEntry) {\n          */\n         assert primaryEntry != null;\n         assert primaryEntry.getClassEntry() == this;\n-        primaryEntry.addSubRange(subrange, subFileEntry);\n+        primaryEntry.addSubRange(subrange);\n+        FileEntry subFileEntry = subrange.getFileEntry();\n         if (subFileEntry != null) {\n-            if (localFilesIndex.get(subFileEntry) == null) {\n-                localFiles.add(subFileEntry);\n-                localFilesIndex.put(subFileEntry, localFiles.size());\n-            }\n-            DirEntry dirEntry = subFileEntry.getDirEntry();\n+            indexFileEntry(subFileEntry);\n+        }\n+    }\n+\n+    private void indexFileEntry(@SuppressWarnings(\"hiding\") FileEntry fileEntry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDA5Ng==", "bodyText": "Yes, I renamed this to localFileEntry and also changed the method name to indexLocalFileEntry", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551234096", "createdAt": "2021-01-04T10:31:44Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -148,13 +141,18 @@ public void addSubRange(Range subrange, FileEntry subFileEntry) {\n          */\n         assert primaryEntry != null;\n         assert primaryEntry.getClassEntry() == this;\n-        primaryEntry.addSubRange(subrange, subFileEntry);\n+        primaryEntry.addSubRange(subrange);\n+        FileEntry subFileEntry = subrange.getFileEntry();\n         if (subFileEntry != null) {\n-            if (localFilesIndex.get(subFileEntry) == null) {\n-                localFiles.add(subFileEntry);\n-                localFilesIndex.put(subFileEntry, localFiles.size());\n-            }\n-            DirEntry dirEntry = subFileEntry.getDirEntry();\n+            indexFileEntry(subFileEntry);\n+        }\n+    }\n+\n+    private void indexFileEntry(@SuppressWarnings(\"hiding\") FileEntry fileEntry) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NTkxMg=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDc4MjI1OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoyMjoxNlrOIJ5U3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQwOTo1ODowOFrOINrlEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NzMyNQ==", "bodyText": "nitpick: I would move this right after the constructor.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547247325", "createdAt": "2020-12-22T12:22:16Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNjQwMQ==", "bodyText": "yeah that's better", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551216401", "createdAt": "2021-01-04T09:58:08Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0NzMyNQ=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDc4NzkxOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoyNDowM1rOIJ5YHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDozNjowMlrOINszGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0ODE1OA==", "bodyText": "Another hiding :)", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547248158", "createdAt": "2020-12-22T12:24:03Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n+        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n+        /* Add details of super and interface classes */\n+        String superName = debugInstanceTypeInfo.superName();\n+        if (superName != null) {\n+            superName = TypeEntry.canonicalize(superName);\n+        }\n+        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n+        if (superName != null) {\n+            this.superClass = debugInfoBase.lookupClassEntry(superName);\n+        }\n+        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n+        /* Add details of fields and field types */\n+        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n+        /* Add details of methods and method types */\n+        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n     }\n \n-    public String getClassName() {\n-        return className;\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n     }\n \n-    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n-        return primaryEntries;\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a\n+        // substitution\n+        @SuppressWarnings(\"hiding\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 302}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNjM3Nw==", "bodyText": "renamed to methodFileEntry", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551236377", "createdAt": "2021-01-04T10:36:02Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n+        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n+        /* Add details of super and interface classes */\n+        String superName = debugInstanceTypeInfo.superName();\n+        if (superName != null) {\n+            superName = TypeEntry.canonicalize(superName);\n+        }\n+        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n+        if (superName != null) {\n+            this.superClass = debugInfoBase.lookupClassEntry(superName);\n+        }\n+        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n+        /* Add details of fields and field types */\n+        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n+        /* Add details of methods and method types */\n+        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n     }\n \n-    public String getClassName() {\n-        return className;\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n     }\n \n-    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n-        return primaryEntries;\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a\n+        // substitution\n+        @SuppressWarnings(\"hiding\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0ODE1OA=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDc5NDczOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjoyNjoxNFrOIJ5cLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDowMDo0M1rOINrqjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0OTE5Nw==", "bodyText": "Please don't hide fileEntry especially in this method where both this.fileEntry and fileEntry are being used.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547249197", "createdAt": "2020-12-22T12:26:14Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n+        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n+        /* Add details of super and interface classes */\n+        String superName = debugInstanceTypeInfo.superName();\n+        if (superName != null) {\n+            superName = TypeEntry.canonicalize(superName);\n+        }\n+        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n+        if (superName != null) {\n+            this.superClass = debugInfoBase.lookupClassEntry(superName);\n+        }\n+        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n+        /* Add details of fields and field types */\n+        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n+        /* Add details of methods and method types */\n+        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n     }\n \n-    public String getClassName() {\n-        return className;\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n     }\n \n-    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n-        return primaryEntries;\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a\n+        // substitution\n+        @SuppressWarnings(\"hiding\")\n+        FileEntry fileEntry = debugInfoBase.ensureFileEntry(fileName, filePath, cachePath);\n+        methods.add(new MethodEntry(fileEntry, methodName, this, resultType, paramTypeArray, paramNameArray, modifiers));\n     }\n \n-    public Object primaryIndexFor(Range primaryRange) {\n-        return primaryIndex.get(primaryRange);\n-    }\n+    private static String formatParams(List<String> paramTypes, List<String> paramNames) {\n+        if (paramNames.size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder builder = new StringBuilder();\n+        String separator = \"\";\n+        for (int i = 0; i < paramNames.size(); i++) {\n+            builder.append(separator);\n+            builder.append(paramTypes.get(i));\n+            String paramName = paramNames.get(i);\n+            if (paramName.length() > 0) {\n+                builder.append(' ');\n+                builder.append(paramName);\n+            }\n+            separator = \", \";\n+        }\n \n-    public LinkedList<DirEntry> getLocalDirs() {\n-        return localDirs;\n+        return builder.toString();\n     }\n \n-    public LinkedList<FileEntry> getLocalFiles() {\n-        return localFiles;\n+    public boolean isPrimary() {\n+        return primaryEntries.size() != 0;\n     }\n \n-    public boolean includesDeoptTarget() {\n-        return includesDeoptTarget;\n+    public ClassEntry getSuperClass() {\n+        return superClass;\n     }\n \n-    public String getCachePath() {\n-        if (fileEntry != null) {\n-            return fileEntry.getCachePath();\n-        } else {\n-            return \"\";\n+    public Range makePrimaryRange(String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, @SuppressWarnings(\"hiding\") FileEntry fileEntry, int lo,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 349}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxNzgwNA==", "bodyText": "ok", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551217804", "createdAt": "2021-01-04T10:00:43Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -200,89 +198,151 @@ String getDirName() {\n         }\n     }\n \n-    public void setCUIndex(int cuIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert cuIndex >= 0;\n-        assert this.cuIndex == -1;\n-        this.cuIndex = cuIndex;\n-    }\n-\n-    public int getCUIndex() {\n-        // Should have been set before being read.\n-        assert cuIndex >= 0;\n-        return cuIndex;\n-    }\n-\n-    public void setDeoptCUIndex(int deoptCUIndex) {\n-        // Should only get set once to a non-negative value.\n-        assert deoptCUIndex >= 0;\n-        assert this.deoptCUIndex == -1;\n-        this.deoptCUIndex = deoptCUIndex;\n+    public FileEntry getFileEntry() {\n+        return fileEntry;\n     }\n \n-    public int getDeoptCUIndex() {\n-        // Should have been set before being read.\n-        assert deoptCUIndex >= 0;\n-        return deoptCUIndex;\n+    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n+        return primaryEntries;\n     }\n \n-    public int getLineIndex() {\n-        return lineIndex;\n+    @SuppressWarnings(\"unused\")\n+    public Object primaryIndexFor(Range primaryRange) {\n+        return primaryIndex.get(primaryRange);\n     }\n \n-    public void setLineIndex(int lineIndex) {\n-        this.lineIndex = lineIndex;\n+    public LinkedList<DirEntry> getLocalDirs() {\n+        return localDirs;\n     }\n \n-    public void setLinePrologueSize(int linePrologueSize) {\n-        this.linePrologueSize = linePrologueSize;\n+    public LinkedList<FileEntry> getLocalFiles() {\n+        return localFiles;\n     }\n \n-    public int getLinePrologueSize() {\n-        return linePrologueSize;\n+    public boolean includesDeoptTarget() {\n+        return includesDeoptTarget;\n     }\n \n-    public int getTotalSize() {\n-        return totalSize;\n+    public String getCachePath() {\n+        if (fileEntry != null) {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n     }\n \n-    public void setTotalSize(int totalSize) {\n-        this.totalSize = totalSize;\n+    @Override\n+    public DebugTypeKind typeKind() {\n+        return DebugTypeKind.INSTANCE;\n     }\n \n-    public FileEntry getFileEntry() {\n-        return fileEntry;\n+    @Override\n+    public void addDebugInfo(DebugInfoBase debugInfoBase, DebugTypeInfo debugTypeInfo, DebugContext debugContext) {\n+        assert TypeEntry.canonicalize(debugTypeInfo.typeName()).equals(typeName);\n+        DebugInstanceTypeInfo debugInstanceTypeInfo = (DebugInstanceTypeInfo) debugTypeInfo;\n+        /* Add details of super and interface classes */\n+        String superName = debugInstanceTypeInfo.superName();\n+        if (superName != null) {\n+            superName = TypeEntry.canonicalize(superName);\n+        }\n+        debugContext.log(\"typename %s adding super %s\\n\", typeName, superName);\n+        if (superName != null) {\n+            this.superClass = debugInfoBase.lookupClassEntry(superName);\n+        }\n+        debugInstanceTypeInfo.interfaces().forEach(interfaceName -> processInterface(interfaceName, debugInfoBase, debugContext));\n+        /* Add details of fields and field types */\n+        debugInstanceTypeInfo.fieldInfoProvider().forEach(debugFieldInfo -> this.processField(debugFieldInfo, debugInfoBase, debugContext));\n+        /* Add details of methods and method types */\n+        debugInstanceTypeInfo.methodInfoProvider().forEach(methodFieldInfo -> this.processMethod(methodFieldInfo, debugInfoBase, debugContext));\n     }\n \n-    public String getClassName() {\n-        return className;\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n     }\n \n-    public LinkedList<PrimaryEntry> getPrimaryEntries() {\n-        return primaryEntries;\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a\n+        // substitution\n+        @SuppressWarnings(\"hiding\")\n+        FileEntry fileEntry = debugInfoBase.ensureFileEntry(fileName, filePath, cachePath);\n+        methods.add(new MethodEntry(fileEntry, methodName, this, resultType, paramTypeArray, paramNameArray, modifiers));\n     }\n \n-    public Object primaryIndexFor(Range primaryRange) {\n-        return primaryIndex.get(primaryRange);\n-    }\n+    private static String formatParams(List<String> paramTypes, List<String> paramNames) {\n+        if (paramNames.size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder builder = new StringBuilder();\n+        String separator = \"\";\n+        for (int i = 0; i < paramNames.size(); i++) {\n+            builder.append(separator);\n+            builder.append(paramTypes.get(i));\n+            String paramName = paramNames.get(i);\n+            if (paramName.length() > 0) {\n+                builder.append(' ');\n+                builder.append(paramName);\n+            }\n+            separator = \", \";\n+        }\n \n-    public LinkedList<DirEntry> getLocalDirs() {\n-        return localDirs;\n+        return builder.toString();\n     }\n \n-    public LinkedList<FileEntry> getLocalFiles() {\n-        return localFiles;\n+    public boolean isPrimary() {\n+        return primaryEntries.size() != 0;\n     }\n \n-    public boolean includesDeoptTarget() {\n-        return includesDeoptTarget;\n+    public ClassEntry getSuperClass() {\n+        return superClass;\n     }\n \n-    public String getCachePath() {\n-        if (fileEntry != null) {\n-            return fileEntry.getCachePath();\n-        } else {\n-            return \"\";\n+    public Range makePrimaryRange(String methodName, String symbolName, String paramSignature, String returnTypeName, StringTable stringTable, @SuppressWarnings(\"hiding\") FileEntry fileEntry, int lo,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI0OTE5Nw=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 349}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDgyMTEzOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjozNTozNVrOIJ5rqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDozMTo1NFrOINsqiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzE2MQ==", "bodyText": "Is there any reason to not use this.dirEntry directly?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547253161", "createdAt": "2020-12-22T12:35:35Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -48,11 +50,23 @@ public String getFileName() {\n     }\n \n     public String getPathName() {\n-        return getDirEntry().getPathString();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNDE4NA==", "bodyText": "no", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551234184", "createdAt": "2021-01-04T10:31:54Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -48,11 +50,23 @@ public String getFileName() {\n     }\n \n     public String getPathName() {\n-        return getDirEntry().getPathString();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzE2MQ=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDgyMjAxOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjozNTo1NFrOIJ5sKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDowMjoyMlrOINrtrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzI4OA==", "bodyText": "Is there any reason to not use this.dirEntry directly?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547253288", "createdAt": "2020-12-22T12:35:54Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -48,11 +50,23 @@ public String getFileName() {\n     }\n \n     public String getPathName() {\n-        return getDirEntry().getPathString();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {\n+            return \"\";\n+        } else {\n+            return dirEntry.getPathString();\n+        }\n     }\n \n     public String getFullName() {\n-        return getDirEntry() != null ? getDirEntry().getPath().resolve(getFileName()).toString() : getFileName();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxODYwNQ==", "bodyText": "No :-)", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551218605", "createdAt": "2021-01-04T10:02:22Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/FileEntry.java", "diffHunk": "@@ -48,11 +50,23 @@ public String getFileName() {\n     }\n \n     public String getPathName() {\n-        return getDirEntry().getPathString();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {\n+            return \"\";\n+        } else {\n+            return dirEntry.getPathString();\n+        }\n     }\n \n     public String getFullName() {\n-        return getDirEntry() != null ? getDirEntry().getPath().resolve(getFileName()).toString() : getFileName();\n+        @SuppressWarnings(\"hiding\")\n+        DirEntry dirEntry = getDirEntry();\n+        if (dirEntry == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1MzI4OA=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDg2NTcwOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjo0OTo1NVrOIJ6FaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDozNDoyMlrOINsviA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1OTc1Mw==", "bodyText": "Shouldn't this be not reachable?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547259753", "createdAt": "2020-12-22T12:49:55Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -38,34 +38,158 @@\n  * underlying object file so that the latter can insert appropriate debug info.\n  */\n public interface DebugInfoProvider {\n-    /**\n-     * Access details of a specific type.\n-     */\n-    interface DebugTypeInfo {\n-    }\n+    boolean useHeapBase();\n+\n+    int oopShiftBitCount();\n+\n+    int oopFlagBitsMask();\n+\n+    int oopReferenceByteCount();\n \n     /**\n-     * Access details of a specific compiled method.\n+     * An interface implemented by items that can be located in a file.\n      */\n-    interface DebugCodeInfo {\n-        void debugContext(Consumer<DebugContext> action);\n-\n+    interface DebugFileInfo {\n         /**\n-         * @return the name of the file containing a compiled method excluding any path.\n+         * @return the name of the file containing a file element excluding any path.\n          */\n         String fileName();\n \n         /**\n-         * @return a relative path to the file containing a compiled method derived from its package\n-         *         name or null if the method is in the empty package.\n+         * @return a relative path to the file containing a file element derived from its package\n+         *         name or {@code null} if the element is in the empty package.\n          */\n         Path filePath();\n \n         /**\n-         * @return a relative path to the source cache containing the sources of a compiled method\n-         *         or {@code null} if sources are not available.\n+         * @return a relative path to the source cache containing the cached source file of a file\n+         *         element or {@code null} if sources are not available.\n          */\n         Path cachePath();\n+    }\n+\n+    interface DebugTypeInfo extends DebugFileInfo {\n+        enum DebugTypeKind {\n+            PRIMITIVE,\n+            ENUM,\n+            INSTANCE,\n+            INTERFACE,\n+            ARRAY,\n+            HEADER;\n+\n+            @Override\n+            public String toString() {\n+                switch (this) {\n+                    case PRIMITIVE:\n+                        return \"primitive\";\n+                    case ENUM:\n+                        return \"enum\";\n+                    case INSTANCE:\n+                        return \"instance\";\n+                    case INTERFACE:\n+                        return \"interface\";\n+                    case ARRAY:\n+                        return \"array\";\n+                    case HEADER:\n+                        return \"header\";\n+                    default:\n+                        return \"???\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNTQ2NA==", "bodyText": "Yes, but tell that to my IDE :-)", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551235464", "createdAt": "2021-01-04T10:34:22Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -38,34 +38,158 @@\n  * underlying object file so that the latter can insert appropriate debug info.\n  */\n public interface DebugInfoProvider {\n-    /**\n-     * Access details of a specific type.\n-     */\n-    interface DebugTypeInfo {\n-    }\n+    boolean useHeapBase();\n+\n+    int oopShiftBitCount();\n+\n+    int oopFlagBitsMask();\n+\n+    int oopReferenceByteCount();\n \n     /**\n-     * Access details of a specific compiled method.\n+     * An interface implemented by items that can be located in a file.\n      */\n-    interface DebugCodeInfo {\n-        void debugContext(Consumer<DebugContext> action);\n-\n+    interface DebugFileInfo {\n         /**\n-         * @return the name of the file containing a compiled method excluding any path.\n+         * @return the name of the file containing a file element excluding any path.\n          */\n         String fileName();\n \n         /**\n-         * @return a relative path to the file containing a compiled method derived from its package\n-         *         name or null if the method is in the empty package.\n+         * @return a relative path to the file containing a file element derived from its package\n+         *         name or {@code null} if the element is in the empty package.\n          */\n         Path filePath();\n \n         /**\n-         * @return a relative path to the source cache containing the sources of a compiled method\n-         *         or {@code null} if sources are not available.\n+         * @return a relative path to the source cache containing the cached source file of a file\n+         *         element or {@code null} if sources are not available.\n          */\n         Path cachePath();\n+    }\n+\n+    interface DebugTypeInfo extends DebugFileInfo {\n+        enum DebugTypeKind {\n+            PRIMITIVE,\n+            ENUM,\n+            INSTANCE,\n+            INTERFACE,\n+            ARRAY,\n+            HEADER;\n+\n+            @Override\n+            public String toString() {\n+                switch (this) {\n+                    case PRIMITIVE:\n+                        return \"primitive\";\n+                    case ENUM:\n+                        return \"enum\";\n+                    case INSTANCE:\n+                        return \"instance\";\n+                    case INTERFACE:\n+                        return \"interface\";\n+                    case ARRAY:\n+                        return \"array\";\n+                    case HEADER:\n+                        return \"header\";\n+                    default:\n+                        return \"???\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI1OTc1Mw=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDg4Njk4OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMjo1Njo1NFrOIJ6RzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDowMzozN1rOINrv1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MjkyNA==", "bodyText": "This comment looks like there is something missing here (it is not followed by any command).\nIt should be placed above writeBuiltInUnit if I am not mistaken.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547262924", "createdAt": "2020-12-22T12:56:54Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -61,133 +133,1009 @@ public String getSectionName() {\n         return DW_INFO_SECTION_NAME;\n     }\n \n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        // order all content decisions after all size decisions by\n+        // making info section content depend on abbrev section size\n+        String abbrevSectionName = dwarfSections.getAbbrevSectionImpl().getSectionName();\n+        ELFObjectFile.ELFSection abbrevSection = (ELFObjectFile.ELFSection) getElement().getOwner().elementForName(abbrevSectionName);\n+        LayoutDecision sizeDecision = decisions.get(abbrevSection).getDecision(LayoutDecision.Kind.SIZE);\n+        deps.add(BuildDependency.createOrGet(ourContent, sizeDecision));\n+        return deps;\n+    }\n+\n     @Override\n     public void createContent() {\n-        /*\n-         * We need a single level 0 DIE for each compilation unit (CU). Each CU's Level 0 DIE is\n-         * preceded by a fixed header and terminated by a null DIE:\n-         *\n-         * <ul>\n-         *\n-         * <li><code>uint32 length ......... excluding this length field</code>\n-         *\n-         * <li><code>uint16 dwarf_version .. always 2 ??</code>\n-         *\n-         * <li><code>uint32 abbrev offset .. always 0 ??</code>\n-         *\n-         * <li><code>uint8 address_size .... always 8</code>\n-         *\n-         * <li><code>DIE* .................. sequence of top-level and nested child entries</code>\n-         *\n-         * <li><code>null_DIE .............. == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * A DIE is a recursively defined structure. it starts with a code for the associated abbrev\n-         * entry followed by a series of attribute values, as determined by the entry, terminated by\n-         * a null value and followed by zero or more child DIEs (zero iff has_children ==\n-         * no_children).\n-         *\n-         * <ul>\n-         *\n-         * <li><code>LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of\n-         * DIE</code>\n-         *\n-         * <li><code>attribute_value* ......... value sequence as determined by abbrev entry</code>\n-         *\n-         * <li><code>DIE* ..................... sequence of child DIEs (if appropriate)</code>\n-         * <li><code>\n-         *\n-         * <li><code>null_value ............... == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * Note that a null_DIE looks like:\n-         *\n-         * <ul>\n-         *\n-         * <li><code>LEB128 abbrev_code ....... == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * i.e. it also looks like a null_value.\n-         */\n+        assert !contentByteArrayCreated();\n \n         byte[] buffer = null;\n-        int pos = 0;\n+        int len = generateContent(null, buffer);\n \n-        /* CUs for normal methods */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            int lengthPos = pos;\n-            pos = writeCUHeader(buffer, pos);\n-            assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-            pos = writeCU(null, classEntry, false, buffer, pos);\n-            /*\n-             * No need to backpatch length at lengthPos.\n-             */\n-        }\n-        /* CUs for deopt targets */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            if (classEntry.includesDeoptTarget()) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(null, classEntry, true, buffer, pos);\n-                /*\n-                 * No need to backpatch length at lengthPos.\n-                 */\n-            }\n-        }\n-        buffer = new byte[pos];\n+        buffer = new byte[len];\n         super.setContent(buffer);\n     }\n \n     @Override\n     public void writeContent(DebugContext context) {\n+        assert contentByteArrayCreated();\n+\n         byte[] buffer = getContent();\n         int size = buffer.length;\n         int pos = 0;\n \n         enableLog(context, pos);\n-\n         log(context, \"  [0x%08x] DEBUG_INFO\", pos);\n         log(context, \"  [0x%08x] size = 0x%08x\", pos, size);\n-        /* write CUs for normal methods */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            /*\n-             * Save the offset of this file's CU so it can be used when writing the aranges section.\n-             */\n-            classEntry.setCUIndex(pos);\n-            int lengthPos = pos;\n-            pos = writeCUHeader(buffer, pos);\n-            log(context, \"  [0x%08x] Compilation Unit\", pos, size);\n-            assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-            pos = writeCU(context, classEntry, false, buffer, pos);\n-            /*\n-             * Backpatch length at lengthPos (excluding length field).\n-             */\n-            patchLength(lengthPos, buffer, pos);\n+\n+        pos = generateContent(context, buffer);\n+        assert pos == size;\n+    }\n+\n+    byte computeEncoding(int flags, int bitCount) {\n+        assert bitCount > 0;\n+        if ((flags & FLAG_NUMERIC) != 0) {\n+            if (((flags & FLAG_INTEGRAL) != 0)) {\n+                if ((flags & FLAG_SIGNED) != 0) {\n+                    switch (bitCount) {\n+                        case 8:\n+                            return DW_ATE_signed_char;\n+                        default:\n+                            assert bitCount == 16 || bitCount == 32 || bitCount == 64;\n+                            return DW_ATE_signed;\n+                    }\n+                } else {\n+                    assert bitCount == 16;\n+                    return DW_ATE_unsigned; // should be UTF???\n+                }\n+            } else {\n+                assert bitCount == 32 || bitCount == 64;\n+                return DW_ATE_float;\n+            }\n+        } else {\n+            assert bitCount == 1;\n+            return DW_ATE_boolean;\n         }\n-        /* write CUs for deopt targets */\n+    }\n+\n+    public int generateContent(DebugContext context, byte[] buffer) {\n+        int pos = 0;\n+        pos = writeBuiltInUnit(context, buffer, pos);\n+\n+        // write entries for all the types known to the generator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIxOTE1OQ==", "bodyText": "Yes it should.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551219159", "createdAt": "2021-01-04T10:03:37Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -61,133 +133,1009 @@ public String getSectionName() {\n         return DW_INFO_SECTION_NAME;\n     }\n \n+    @Override\n+    public Set<BuildDependency> getDependencies(Map<ObjectFile.Element, LayoutDecisionMap> decisions) {\n+        Set<BuildDependency> deps = super.getDependencies(decisions);\n+        LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+        // order all content decisions after all size decisions by\n+        // making info section content depend on abbrev section size\n+        String abbrevSectionName = dwarfSections.getAbbrevSectionImpl().getSectionName();\n+        ELFObjectFile.ELFSection abbrevSection = (ELFObjectFile.ELFSection) getElement().getOwner().elementForName(abbrevSectionName);\n+        LayoutDecision sizeDecision = decisions.get(abbrevSection).getDecision(LayoutDecision.Kind.SIZE);\n+        deps.add(BuildDependency.createOrGet(ourContent, sizeDecision));\n+        return deps;\n+    }\n+\n     @Override\n     public void createContent() {\n-        /*\n-         * We need a single level 0 DIE for each compilation unit (CU). Each CU's Level 0 DIE is\n-         * preceded by a fixed header and terminated by a null DIE:\n-         *\n-         * <ul>\n-         *\n-         * <li><code>uint32 length ......... excluding this length field</code>\n-         *\n-         * <li><code>uint16 dwarf_version .. always 2 ??</code>\n-         *\n-         * <li><code>uint32 abbrev offset .. always 0 ??</code>\n-         *\n-         * <li><code>uint8 address_size .... always 8</code>\n-         *\n-         * <li><code>DIE* .................. sequence of top-level and nested child entries</code>\n-         *\n-         * <li><code>null_DIE .............. == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * A DIE is a recursively defined structure. it starts with a code for the associated abbrev\n-         * entry followed by a series of attribute values, as determined by the entry, terminated by\n-         * a null value and followed by zero or more child DIEs (zero iff has_children ==\n-         * no_children).\n-         *\n-         * <ul>\n-         *\n-         * <li><code>LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of\n-         * DIE</code>\n-         *\n-         * <li><code>attribute_value* ......... value sequence as determined by abbrev entry</code>\n-         *\n-         * <li><code>DIE* ..................... sequence of child DIEs (if appropriate)</code>\n-         * <li><code>\n-         *\n-         * <li><code>null_value ............... == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * Note that a null_DIE looks like:\n-         *\n-         * <ul>\n-         *\n-         * <li><code>LEB128 abbrev_code ....... == 0</code>\n-         *\n-         * </ul>\n-         *\n-         * i.e. it also looks like a null_value.\n-         */\n+        assert !contentByteArrayCreated();\n \n         byte[] buffer = null;\n-        int pos = 0;\n+        int len = generateContent(null, buffer);\n \n-        /* CUs for normal methods */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            int lengthPos = pos;\n-            pos = writeCUHeader(buffer, pos);\n-            assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-            pos = writeCU(null, classEntry, false, buffer, pos);\n-            /*\n-             * No need to backpatch length at lengthPos.\n-             */\n-        }\n-        /* CUs for deopt targets */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            if (classEntry.includesDeoptTarget()) {\n-                int lengthPos = pos;\n-                pos = writeCUHeader(buffer, pos);\n-                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-                pos = writeCU(null, classEntry, true, buffer, pos);\n-                /*\n-                 * No need to backpatch length at lengthPos.\n-                 */\n-            }\n-        }\n-        buffer = new byte[pos];\n+        buffer = new byte[len];\n         super.setContent(buffer);\n     }\n \n     @Override\n     public void writeContent(DebugContext context) {\n+        assert contentByteArrayCreated();\n+\n         byte[] buffer = getContent();\n         int size = buffer.length;\n         int pos = 0;\n \n         enableLog(context, pos);\n-\n         log(context, \"  [0x%08x] DEBUG_INFO\", pos);\n         log(context, \"  [0x%08x] size = 0x%08x\", pos, size);\n-        /* write CUs for normal methods */\n-        for (ClassEntry classEntry : getPrimaryClasses()) {\n-            /*\n-             * Save the offset of this file's CU so it can be used when writing the aranges section.\n-             */\n-            classEntry.setCUIndex(pos);\n-            int lengthPos = pos;\n-            pos = writeCUHeader(buffer, pos);\n-            log(context, \"  [0x%08x] Compilation Unit\", pos, size);\n-            assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n-            pos = writeCU(context, classEntry, false, buffer, pos);\n-            /*\n-             * Backpatch length at lengthPos (excluding length field).\n-             */\n-            patchLength(lengthPos, buffer, pos);\n+\n+        pos = generateContent(context, buffer);\n+        assert pos == size;\n+    }\n+\n+    byte computeEncoding(int flags, int bitCount) {\n+        assert bitCount > 0;\n+        if ((flags & FLAG_NUMERIC) != 0) {\n+            if (((flags & FLAG_INTEGRAL) != 0)) {\n+                if ((flags & FLAG_SIGNED) != 0) {\n+                    switch (bitCount) {\n+                        case 8:\n+                            return DW_ATE_signed_char;\n+                        default:\n+                            assert bitCount == 16 || bitCount == 32 || bitCount == 64;\n+                            return DW_ATE_signed;\n+                    }\n+                } else {\n+                    assert bitCount == 16;\n+                    return DW_ATE_unsigned; // should be UTF???\n+                }\n+            } else {\n+                assert bitCount == 32 || bitCount == 64;\n+                return DW_ATE_float;\n+            }\n+        } else {\n+            assert bitCount == 1;\n+            return DW_ATE_boolean;\n         }\n-        /* write CUs for deopt targets */\n+    }\n+\n+    public int generateContent(DebugContext context, byte[] buffer) {\n+        int pos = 0;\n+        pos = writeBuiltInUnit(context, buffer, pos);\n+\n+        // write entries for all the types known to the generator", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MjkyNA=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDg5OTU4OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMzowMDo1OFrOIJ6ZJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDoxMjo0MVrOINsCJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDgwNA==", "bodyText": "Shouldn't we rename this to DW_VERSION instead? Is there any chance to use different dwarf versions in different places?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547264804", "createdAt": "2020-12-22T13:00:58Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -196,7 +1144,7 @@ private int writeCUHeader(byte[] buffer, int p) {\n             /* CU length. */\n             pos += putInt(0, scratch, 0);\n             /* DWARF version. */\n-            pos += putShort(DW_VERSION_2, scratch, 0);\n+            pos += putShort(DW_VERSION_4, scratch, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 1214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIyMzg0Nw==", "bodyText": "I am already doing that. The aranges and line sections are still written as DW_VERSION_2.  n.b. it does not cause a problem for gdb.\nStill, you are right that it would be better to write all sections using a single preferred dwarf version. However, before changing anything we will need to carefully check the spec to see if updating the version of those two sections to 4 also requires changes to their format. This is probably best left for a follow-up issue.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551223847", "createdAt": "2021-01-04T10:12:41Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -196,7 +1144,7 @@ private int writeCUHeader(byte[] buffer, int p) {\n             /* CU length. */\n             pos += putInt(0, scratch, 0);\n             /* DWARF version. */\n-            pos += putShort(DW_VERSION_2, scratch, 0);\n+            pos += putShort(DW_VERSION_4, scratch, 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDgwNA=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 1214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDkxODczOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMzowNzoxOVrOIJ6kbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDoyNjowMVrOINseFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NzY5Mw==", "bodyText": "Consider extracting a new method ResolvedJavaType getJavaType(ResolvedJavaType, boolean) to reduce code duplication (i.e. keep all the instanceof checks in one place)", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547267693", "createdAt": "2020-12-22T13:07:19Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -81,46 +156,132 @@\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return Stream.empty();\n+        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n     }\n \n-    /**\n-     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+    static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();\n+\n+    /*\n+     * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n+     * getSourceFilename to the wrapped class so for consistency we need to do type names and path\n+     * lookup relative to the doubly unwrapped HostedType.\n+     *\n+     * However, note that the result of the unwrap on the AnalysisType may be a SubstitutionType\n+     * which wraps both an original type and the annotated type that substitutes it. Unwrapping\n+     * normally returns the AnnotatedType which we need to use to resolve the file name. However, we\n+     * need to use the original to name the owning type to ensure that names found in method param\n+     * and return types resolve correctly.\n      */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final ResolvedJavaType javaType;\n-        private final CompilationResult compilation;\n+    protected static ResolvedJavaType getJavaType(HostedType hostedType, boolean wantOriginal) {\n+        ResolvedJavaType javaType;\n+        if (wantOriginal) {\n+            // check for wholesale replacement of the original class\n+            javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n+            if (javaType instanceof SubstitutionType) {\n+                return ((SubstitutionType) javaType).getOriginal();\n+            } else if (javaType instanceof CustomSubstitutionType<?, ?>) {\n+                return ((CustomSubstitutionType<?, ?>) javaType).getOriginal();\n+            } else if (javaType instanceof LambdaSubstitutionType) {\n+                return ((LambdaSubstitutionType) javaType).getOriginal();\n+            } else if (javaType instanceof InjectedFieldsType) {\n+                return ((InjectedFieldsType) javaType).getOriginal();\n+            } else {\n+                return javaType;\n+            }\n+        }\n+        return hostedType.getWrapped().getWrapped();\n+    }\n+\n+    protected static ResolvedJavaType getJavaType(HostedMethod hostedMethod, boolean wantOriginal) {\n+        if (wantOriginal) {\n+            // check for wholesale replacement of the original class\n+            HostedType hostedType = hostedMethod.getDeclaringClass();\n+            ResolvedJavaType javaType = hostedType.getWrapped().getWrappedWithoutResolve();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzMDk5Ng==", "bodyText": "Done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551230996", "createdAt": "2021-01-04T10:26:01Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -81,46 +156,132 @@\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return Stream.empty();\n+        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n     }\n \n-    /**\n-     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+    static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();\n+\n+    /*\n+     * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n+     * getSourceFilename to the wrapped class so for consistency we need to do type names and path\n+     * lookup relative to the doubly unwrapped HostedType.\n+     *\n+     * However, note that the result of the unwrap on the AnalysisType may be a SubstitutionType\n+     * which wraps both an original type and the annotated type that substitutes it. Unwrapping\n+     * normally returns the AnnotatedType which we need to use to resolve the file name. However, we\n+     * need to use the original to name the owning type to ensure that names found in method param\n+     * and return types resolve correctly.\n      */\n-    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n-        private final HostedMethod method;\n-        private final ResolvedJavaType javaType;\n-        private final CompilationResult compilation;\n+    protected static ResolvedJavaType getJavaType(HostedType hostedType, boolean wantOriginal) {\n+        ResolvedJavaType javaType;\n+        if (wantOriginal) {\n+            // check for wholesale replacement of the original class\n+            javaType = hostedType.getWrapped().getWrappedWithoutResolve();\n+            if (javaType instanceof SubstitutionType) {\n+                return ((SubstitutionType) javaType).getOriginal();\n+            } else if (javaType instanceof CustomSubstitutionType<?, ?>) {\n+                return ((CustomSubstitutionType<?, ?>) javaType).getOriginal();\n+            } else if (javaType instanceof LambdaSubstitutionType) {\n+                return ((LambdaSubstitutionType) javaType).getOriginal();\n+            } else if (javaType instanceof InjectedFieldsType) {\n+                return ((InjectedFieldsType) javaType).getOriginal();\n+            } else {\n+                return javaType;\n+            }\n+        }\n+        return hostedType.getWrapped().getWrapped();\n+    }\n+\n+    protected static ResolvedJavaType getJavaType(HostedMethod hostedMethod, boolean wantOriginal) {\n+        if (wantOriginal) {\n+            // check for wholesale replacement of the original class\n+            HostedType hostedType = hostedMethod.getDeclaringClass();\n+            ResolvedJavaType javaType = hostedType.getWrapped().getWrappedWithoutResolve();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NzY5Mw=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MDk0NjQ4OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQxMzoxNjowN1rOIJ60Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxMDoyNjo0N1rOINsf1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTc3OA==", "bodyText": "Redundant?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r547271778", "createdAt": "2020-12-22T13:16:07Z", "author": {"login": "zakkak"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -149,45 +310,593 @@ public Path filePath() {\n         public Path cachePath() {\n             return cachePath;\n         }\n+    }\n+\n+    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n+        protected final HostedType hostedType;\n+\n+        @SuppressWarnings(\"try\")\n+        protected NativeImageDebugTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+            this.hostedType = hostedType;\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n+            return getJavaType(hostedType, true).toJavaName();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return toJavaName(hostedType);\n+        }\n+\n+        @Override\n+        public int size() {\n+            if (hostedType instanceof HostedInstanceClass) {\n+                // We know the actual instance size in bytes.\n+                return ((HostedInstanceClass) hostedType).getInstanceSize();\n+            } else if (hostedType instanceof HostedArrayClass) {\n+                // Use the size of header common to all arrays of this type.\n+                return OBJECTLAYOUT.getArrayBaseOffset(hostedType.getComponentType().getStorageKind());\n+            } else if (hostedType instanceof HostedInterface) {\n+                // Use the size of the header common to all implementors.\n+                return OBJECTLAYOUT.getFirstFieldOffset();\n+            } else {\n+                // Use the number of bytes needed needed to store the value.\n+                assert hostedType instanceof HostedPrimitiveType;\n+                JavaKind javaKind = hostedType.getStorageKind();\n+                return (javaKind == JavaKind.Void ? 0 : javaKind.getByteCount());\n+            }\n+        }\n+    }\n+\n+    private class NativeImageHeaderTypeInfo implements DebugHeaderTypeInfo {\n+        String typeName;\n+        int size;\n+        List<DebugFieldInfo> fieldInfos;\n+\n+        NativeImageHeaderTypeInfo(String typeName, int size) {\n+            this.typeName = typeName;\n+            this.size = size;\n+            this.fieldInfos = new LinkedList<>();\n+        }\n+\n+        void addField(String name, String valueType, int offset, @SuppressWarnings(\"hiding\") int size) {\n+            NativeImageDebugHeaderFieldInfo fieldinfo = new NativeImageDebugHeaderFieldInfo(name, typeName, valueType, offset, size);\n+            fieldInfos.add(fieldinfo);\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return typeName;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.HEADER;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Path filePath() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Path cachePath() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public Stream<DebugFieldInfo> fieldInfoProvider() {\n+            return fieldInfos.stream();\n+        }\n+\n+        private class NativeImageDebugHeaderFieldInfo implements DebugFieldInfo {\n+            private final String name;\n+            private final String ownerType;\n+            private final String valueType;\n+            private final int offset;\n+            private final int size;\n+            private final int modifiers;\n+\n+            NativeImageDebugHeaderFieldInfo(String name, String ownerType, String valueType, int offset, int size) {\n+                this.name = name;\n+                this.ownerType = ownerType;\n+                this.valueType = valueType;\n+                this.offset = offset;\n+                this.size = size;\n+                this.modifiers = Modifier.PUBLIC;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return name;\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return ownerType;\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                return valueType;\n+            }\n+\n+            @Override\n+            public int offset() {\n+                return offset;\n+            }\n+\n+            @Override\n+            public int size() {\n+                return size;\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return modifiers;\n+            }\n+\n+            @Override\n+            public String fileName() {\n+                return \"\";\n+            }\n+\n+            @Override\n+            public Path filePath() {\n+                return null;\n+            }\n+\n+            @Override\n+            public Path cachePath() {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private Stream<DebugTypeInfo> computeHeaderTypeInfo() {\n+        List<DebugTypeInfo> infos = new LinkedList<>();\n+        int hubOffset = OBJECTLAYOUT.getHubOffset();\n+        int referenceSize = OBJECTLAYOUT.getReferenceSize();\n+        int hubFieldSize = referenceSize;\n+        String hubTypeName = \"java.lang.Class\";\n+        int arrayLengthOffset = OBJECTLAYOUT.getArrayLengthOffset();\n+        int arrayLengthSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n+        int idHashOffset = OBJECTLAYOUT.getIdentityHashCodeOffset();\n+        int idHashSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n+        int objHeaderSize = OBJECTLAYOUT.getFirstFieldOffset();\n+        // we need array headers for all Java kinds\n+\n+        NativeImageHeaderTypeInfo objHeader = new NativeImageHeaderTypeInfo(\"_objhdr\", objHeaderSize);\n+        objHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n+        if (idHashOffset > 0) {\n+            objHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n+        }\n+        infos.add(objHeader);\n+\n+        // create a header for each\n+        for (JavaKind arrayKind : ARRAY_KINDS) {\n+            String name = \"_arrhdr\" + arrayKind.getTypeChar();\n+            int headerSize = OBJECTLAYOUT.getArrayBaseOffset(arrayKind);\n+            NativeImageHeaderTypeInfo arrHeader = new NativeImageHeaderTypeInfo(name, headerSize);\n+            arrHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n+            if (idHashOffset > 0) {\n+                arrHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n+            }\n+            arrHeader.addField(\"len\", \"int\", arrayLengthOffset, arrayLengthSize);\n+            infos.add(arrHeader);\n+        }\n+        return infos.stream();\n+    }\n+\n+    private class NativeImageDebugEnumTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugEnumTypeInfo {\n+\n+        NativeImageDebugEnumTypeInfo(HostedInstanceClass enumClass) {\n+            super(enumClass);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.ENUM;\n+        }\n+    }\n+\n+    private class NativeImageDebugInstanceTypeInfo extends NativeImageDebugTypeInfo implements DebugInstanceTypeInfo {\n+        NativeImageDebugInstanceTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.INSTANCE;\n+        }\n+\n+        @Override\n+        public int headerSize() {\n+            return OBJECTLAYOUT.getFirstFieldOffset();\n+        }\n+\n+        @Override\n+        public Stream<DebugFieldInfo> fieldInfoProvider() {\n+            Stream<DebugFieldInfo> instanceFieldsStream = Arrays.stream(hostedType.getInstanceFields(false)).map(this::createDebugFieldInfo);\n+            if (hostedType instanceof HostedInstanceClass && hostedType.getStaticFields().length > 0) {\n+                Stream<DebugFieldInfo> staticFieldsStream = Arrays.stream(hostedType.getStaticFields()).map(this::createDebugStaticFieldInfo);\n+                return Stream.concat(instanceFieldsStream, staticFieldsStream);\n+            } else {\n+                return instanceFieldsStream;\n+            }\n+        }\n+\n+        @Override\n+        public Stream<DebugMethodInfo> methodInfoProvider() {\n+            return Arrays.stream(hostedType.getAllDeclaredMethods()).map(this::createDebugMethodInfo);\n+        }\n+\n+        @Override\n+        public String superName() {\n+            HostedClass superClass = hostedType.getSuperclass();\n+            /*\n+             * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n+             * getSourceFilename to the wrapped class so for consistency we need to do the path\n+             * lookup relative to the doubly unwrapped HostedType.\n+             */\n+            if (superClass != null) {\n+                return getJavaType(superClass, true).toJavaName();\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Stream<String> interfaces() {\n+            return Arrays.stream(hostedType.getInterfaces()).map(this::toJavaName);\n+        }\n+\n+        protected NativeImageDebugFieldInfo createDebugFieldInfo(HostedField field) {\n+            return new NativeImageDebugFieldInfo(field);\n+        }\n+\n+        protected NativeImageDebugFieldInfo createDebugStaticFieldInfo(ResolvedJavaField field) {\n+            return new NativeImageDebugFieldInfo((HostedField) field);\n+        }\n+\n+        protected NativeImageDebugMethodInfo createDebugMethodInfo(HostedMethod method) {\n+            return new NativeImageDebugMethodInfo(method);\n+        }\n+\n+        protected class NativeImageDebugFieldInfo extends NativeImageDebugFileInfo implements DebugFieldInfo {\n+            private final HostedField field;\n+\n+            NativeImageDebugFieldInfo(HostedField field) {\n+                super(field);\n+                this.field = field;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return field.getName();\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return typeName();\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                HostedType valueType = field.getType();\n+                return toJavaName(valueType);\n+            }\n+\n+            @Override\n+            public int offset() {\n+                int offset = field.getLocation();\n+                // for static fields we need to add in the appropriate partition base\n+                // but only if we have a real offset\n+                if (isStatic() && offset >= 0) {\n+                    if (isPrimitive()) {\n+                        offset += primitiveStartOffset;\n+                    } else {\n+                        offset += referenceStartOffset;\n+                    }\n+                }\n+                return offset;\n+            }\n+\n+            @Override\n+            public int size() {\n+                return OBJECTLAYOUT.sizeInBytes(field.getType().getStorageKind());\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return field.getModifiers();\n+            }\n+\n+            private boolean isStatic() {\n+                return Modifier.isStatic(modifiers());\n+            }\n+\n+            private boolean isPrimitive() {\n+                return field.getType().getStorageKind().isPrimitive();\n+            }\n+        }\n+\n+        protected class NativeImageDebugMethodInfo extends NativeImageDebugFileInfo implements DebugMethodInfo {\n+            private final HostedMethod hostedMethod;\n+\n+            NativeImageDebugMethodInfo(HostedMethod hostedMethod) {\n+                super(hostedMethod);\n+                this.hostedMethod = hostedMethod;\n+            }\n+\n+            @Override\n+            public String name() {\n+                String name = hostedMethod.format(\"%n\");\n+                if (\"<init>\".equals(name)) {\n+                    ResolvedJavaMethod unwrapped = hostedMethod.getWrapped().getWrapped();\n+                    if (unwrapped instanceof SubstitutionMethod) {\n+                        unwrapped = ((SubstitutionMethod) unwrapped).getOriginal();\n+                    }\n+                    name = unwrapped.format(\"%h\");\n+                    if (name.indexOf('$') >= 0) {\n+                        name = name.substring(name.lastIndexOf('$') + 1);\n+                    }\n+                }\n+                return name;\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return typeName();\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                return hostedMethod.getSignature().getReturnType(null).toJavaName();\n+            }\n+\n+            @Override\n+            public List<String> paramTypes() {\n+                LinkedList<String> paramTypes = new LinkedList<>();\n+                Signature signature = hostedMethod.getSignature();\n+                for (int i = 0; i < signature.getParameterCount(false); i++) {\n+                    paramTypes.add(signature.getParameterType(i, null).toJavaName());\n+                }\n+                return paramTypes;\n+            }\n+\n+            @Override\n+            public List<String> paramNames() {\n+                // can only provide blank names for now\n+                LinkedList<String> paramNames = new LinkedList<>();\n+                Signature signature = hostedMethod.getSignature();\n+                for (int i = 0; i < signature.getParameterCount(false); i++) {\n+                    paramNames.add(\"\");\n+                }\n+                return paramNames;\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return hostedMethod.getModifiers();\n+            }\n+        }\n+    }\n+\n+    private class NativeImageDebugInterfaceTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugInterfaceTypeInfo {\n+\n+        NativeImageDebugInterfaceTypeInfo(HostedInterface interfaceClass) {\n+            super(interfaceClass);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.INTERFACE;\n+        }\n+    }\n+\n+    private class NativeImageDebugArrayTypeInfo extends NativeImageDebugTypeInfo implements DebugArrayTypeInfo {\n+        HostedArrayClass arrayClass;\n+\n+        NativeImageDebugArrayTypeInfo(HostedArrayClass arrayClass) {\n+            super(arrayClass);\n+            this.arrayClass = arrayClass;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.ARRAY;\n+        }\n+\n+        @Override\n+        public int headerSize() {\n+            return OBJECTLAYOUT.getArrayBaseOffset(arrayClass.getComponentType().getStorageKind());\n+        }\n+\n+        @Override\n+        public int lengthOffset() {\n+            return OBJECTLAYOUT.getArrayLengthOffset();\n+        }\n+\n+        @Override\n+        public String elementType() {\n+            HostedType elementType = arrayClass.getComponentType();\n+            return toJavaName(elementType);\n+        }\n+    }\n+\n+    private class NativeImageDebugPrimitiveTypeInfo extends NativeImageDebugTypeInfo implements DebugPrimitiveTypeInfo {\n+        private final HostedPrimitiveType primitiveType;\n+\n+        NativeImageDebugPrimitiveTypeInfo(HostedPrimitiveType primitiveType) {\n+            super(primitiveType);\n+            this.primitiveType = primitiveType;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.PRIMITIVE;\n+        }\n+\n+        @Override\n+        public int bitCount() {\n+            JavaKind javaKind = primitiveType.getStorageKind();\n+            return (javaKind == JavaKind.Void ? 0 : javaKind.getBitCount());\n+        }\n+\n+        @Override\n+        public char typeChar() {\n+            return primitiveType.getStorageKind().getTypeChar();\n+        }\n+\n+        @Override\n+        public int flags() {\n+            char typeChar = primitiveType.getStorageKind().getTypeChar();\n+            switch (typeChar) {\n+                case 'B':\n+                case 'S':\n+                case 'I':\n+                case 'J': {\n+                    return FLAG_NUMERIC | FLAG_INTEGRAL | FLAG_SIGNED;\n+                }\n+                case 'C': {\n+                    return FLAG_NUMERIC | FLAG_INTEGRAL;\n+                }\n+                case 'F':\n+                case 'D': {\n+                    return FLAG_NUMERIC;\n+                }\n+                default: {\n+                    assert typeChar == 'V' || typeChar == 'Z';\n+                    return 0;\n+                }\n+            }\n+        }\n+    }\n+\n+    private NativeImageDebugTypeInfo createDebugTypeInfo(HostedType hostedType) {\n+        if (hostedType.isEnum()) {\n+            return new NativeImageDebugEnumTypeInfo((HostedInstanceClass) hostedType);\n+        } else if (hostedType.isInstanceClass()) {\n+            return new NativeImageDebugInstanceTypeInfo(hostedType);\n+        } else if (hostedType.isInterface()) {\n+            return new NativeImageDebugInterfaceTypeInfo((HostedInterface) hostedType);\n+        } else if (hostedType.isArray()) {\n+            return new NativeImageDebugArrayTypeInfo((HostedArrayClass) hostedType);\n+        } else if (hostedType.isPrimitive()) {\n+            return new NativeImageDebugPrimitiveTypeInfo((HostedPrimitiveType) hostedType);\n+        } else {\n+            throw new RuntimeException(\"Unknown type kind \" + hostedType.getName());\n+        }\n+    }\n+\n+    /**\n+     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo extends NativeImageDebugFileInfo implements DebugCodeInfo {\n+        private final HostedMethod hostedMethod;\n+        private final CompilationResult compilation;\n+\n+        @SuppressWarnings(\"try\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 816}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzMTQ0Nw==", "bodyText": "yes", "url": "https://github.com/oracle/graal/pull/3046#discussion_r551231447", "createdAt": "2021-01-04T10:26:47Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -149,45 +310,593 @@ public Path filePath() {\n         public Path cachePath() {\n             return cachePath;\n         }\n+    }\n+\n+    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n+        protected final HostedType hostedType;\n+\n+        @SuppressWarnings(\"try\")\n+        protected NativeImageDebugTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+            this.hostedType = hostedType;\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n+            return getJavaType(hostedType, true).toJavaName();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return toJavaName(hostedType);\n+        }\n+\n+        @Override\n+        public int size() {\n+            if (hostedType instanceof HostedInstanceClass) {\n+                // We know the actual instance size in bytes.\n+                return ((HostedInstanceClass) hostedType).getInstanceSize();\n+            } else if (hostedType instanceof HostedArrayClass) {\n+                // Use the size of header common to all arrays of this type.\n+                return OBJECTLAYOUT.getArrayBaseOffset(hostedType.getComponentType().getStorageKind());\n+            } else if (hostedType instanceof HostedInterface) {\n+                // Use the size of the header common to all implementors.\n+                return OBJECTLAYOUT.getFirstFieldOffset();\n+            } else {\n+                // Use the number of bytes needed needed to store the value.\n+                assert hostedType instanceof HostedPrimitiveType;\n+                JavaKind javaKind = hostedType.getStorageKind();\n+                return (javaKind == JavaKind.Void ? 0 : javaKind.getByteCount());\n+            }\n+        }\n+    }\n+\n+    private class NativeImageHeaderTypeInfo implements DebugHeaderTypeInfo {\n+        String typeName;\n+        int size;\n+        List<DebugFieldInfo> fieldInfos;\n+\n+        NativeImageHeaderTypeInfo(String typeName, int size) {\n+            this.typeName = typeName;\n+            this.size = size;\n+            this.fieldInfos = new LinkedList<>();\n+        }\n+\n+        void addField(String name, String valueType, int offset, @SuppressWarnings(\"hiding\") int size) {\n+            NativeImageDebugHeaderFieldInfo fieldinfo = new NativeImageDebugHeaderFieldInfo(name, typeName, valueType, offset, size);\n+            fieldInfos.add(fieldinfo);\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return typeName;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.HEADER;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            return \"\";\n+        }\n+\n+        @Override\n+        public Path filePath() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Path cachePath() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public Stream<DebugFieldInfo> fieldInfoProvider() {\n+            return fieldInfos.stream();\n+        }\n+\n+        private class NativeImageDebugHeaderFieldInfo implements DebugFieldInfo {\n+            private final String name;\n+            private final String ownerType;\n+            private final String valueType;\n+            private final int offset;\n+            private final int size;\n+            private final int modifiers;\n+\n+            NativeImageDebugHeaderFieldInfo(String name, String ownerType, String valueType, int offset, int size) {\n+                this.name = name;\n+                this.ownerType = ownerType;\n+                this.valueType = valueType;\n+                this.offset = offset;\n+                this.size = size;\n+                this.modifiers = Modifier.PUBLIC;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return name;\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return ownerType;\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                return valueType;\n+            }\n+\n+            @Override\n+            public int offset() {\n+                return offset;\n+            }\n+\n+            @Override\n+            public int size() {\n+                return size;\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return modifiers;\n+            }\n+\n+            @Override\n+            public String fileName() {\n+                return \"\";\n+            }\n+\n+            @Override\n+            public Path filePath() {\n+                return null;\n+            }\n+\n+            @Override\n+            public Path cachePath() {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private Stream<DebugTypeInfo> computeHeaderTypeInfo() {\n+        List<DebugTypeInfo> infos = new LinkedList<>();\n+        int hubOffset = OBJECTLAYOUT.getHubOffset();\n+        int referenceSize = OBJECTLAYOUT.getReferenceSize();\n+        int hubFieldSize = referenceSize;\n+        String hubTypeName = \"java.lang.Class\";\n+        int arrayLengthOffset = OBJECTLAYOUT.getArrayLengthOffset();\n+        int arrayLengthSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n+        int idHashOffset = OBJECTLAYOUT.getIdentityHashCodeOffset();\n+        int idHashSize = OBJECTLAYOUT.sizeInBytes(JavaKind.Int);\n+        int objHeaderSize = OBJECTLAYOUT.getFirstFieldOffset();\n+        // we need array headers for all Java kinds\n+\n+        NativeImageHeaderTypeInfo objHeader = new NativeImageHeaderTypeInfo(\"_objhdr\", objHeaderSize);\n+        objHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n+        if (idHashOffset > 0) {\n+            objHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n+        }\n+        infos.add(objHeader);\n+\n+        // create a header for each\n+        for (JavaKind arrayKind : ARRAY_KINDS) {\n+            String name = \"_arrhdr\" + arrayKind.getTypeChar();\n+            int headerSize = OBJECTLAYOUT.getArrayBaseOffset(arrayKind);\n+            NativeImageHeaderTypeInfo arrHeader = new NativeImageHeaderTypeInfo(name, headerSize);\n+            arrHeader.addField(\"hub\", hubTypeName, hubOffset, hubFieldSize);\n+            if (idHashOffset > 0) {\n+                arrHeader.addField(\"idHash\", \"int\", idHashOffset, idHashSize);\n+            }\n+            arrHeader.addField(\"len\", \"int\", arrayLengthOffset, arrayLengthSize);\n+            infos.add(arrHeader);\n+        }\n+        return infos.stream();\n+    }\n+\n+    private class NativeImageDebugEnumTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugEnumTypeInfo {\n+\n+        NativeImageDebugEnumTypeInfo(HostedInstanceClass enumClass) {\n+            super(enumClass);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.ENUM;\n+        }\n+    }\n+\n+    private class NativeImageDebugInstanceTypeInfo extends NativeImageDebugTypeInfo implements DebugInstanceTypeInfo {\n+        NativeImageDebugInstanceTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.INSTANCE;\n+        }\n+\n+        @Override\n+        public int headerSize() {\n+            return OBJECTLAYOUT.getFirstFieldOffset();\n+        }\n+\n+        @Override\n+        public Stream<DebugFieldInfo> fieldInfoProvider() {\n+            Stream<DebugFieldInfo> instanceFieldsStream = Arrays.stream(hostedType.getInstanceFields(false)).map(this::createDebugFieldInfo);\n+            if (hostedType instanceof HostedInstanceClass && hostedType.getStaticFields().length > 0) {\n+                Stream<DebugFieldInfo> staticFieldsStream = Arrays.stream(hostedType.getStaticFields()).map(this::createDebugStaticFieldInfo);\n+                return Stream.concat(instanceFieldsStream, staticFieldsStream);\n+            } else {\n+                return instanceFieldsStream;\n+            }\n+        }\n+\n+        @Override\n+        public Stream<DebugMethodInfo> methodInfoProvider() {\n+            return Arrays.stream(hostedType.getAllDeclaredMethods()).map(this::createDebugMethodInfo);\n+        }\n+\n+        @Override\n+        public String superName() {\n+            HostedClass superClass = hostedType.getSuperclass();\n+            /*\n+             * HostedType wraps an AnalysisType and both HostedType and AnalysisType punt calls to\n+             * getSourceFilename to the wrapped class so for consistency we need to do the path\n+             * lookup relative to the doubly unwrapped HostedType.\n+             */\n+            if (superClass != null) {\n+                return getJavaType(superClass, true).toJavaName();\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Stream<String> interfaces() {\n+            return Arrays.stream(hostedType.getInterfaces()).map(this::toJavaName);\n+        }\n+\n+        protected NativeImageDebugFieldInfo createDebugFieldInfo(HostedField field) {\n+            return new NativeImageDebugFieldInfo(field);\n+        }\n+\n+        protected NativeImageDebugFieldInfo createDebugStaticFieldInfo(ResolvedJavaField field) {\n+            return new NativeImageDebugFieldInfo((HostedField) field);\n+        }\n+\n+        protected NativeImageDebugMethodInfo createDebugMethodInfo(HostedMethod method) {\n+            return new NativeImageDebugMethodInfo(method);\n+        }\n+\n+        protected class NativeImageDebugFieldInfo extends NativeImageDebugFileInfo implements DebugFieldInfo {\n+            private final HostedField field;\n+\n+            NativeImageDebugFieldInfo(HostedField field) {\n+                super(field);\n+                this.field = field;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return field.getName();\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return typeName();\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                HostedType valueType = field.getType();\n+                return toJavaName(valueType);\n+            }\n+\n+            @Override\n+            public int offset() {\n+                int offset = field.getLocation();\n+                // for static fields we need to add in the appropriate partition base\n+                // but only if we have a real offset\n+                if (isStatic() && offset >= 0) {\n+                    if (isPrimitive()) {\n+                        offset += primitiveStartOffset;\n+                    } else {\n+                        offset += referenceStartOffset;\n+                    }\n+                }\n+                return offset;\n+            }\n+\n+            @Override\n+            public int size() {\n+                return OBJECTLAYOUT.sizeInBytes(field.getType().getStorageKind());\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return field.getModifiers();\n+            }\n+\n+            private boolean isStatic() {\n+                return Modifier.isStatic(modifiers());\n+            }\n+\n+            private boolean isPrimitive() {\n+                return field.getType().getStorageKind().isPrimitive();\n+            }\n+        }\n+\n+        protected class NativeImageDebugMethodInfo extends NativeImageDebugFileInfo implements DebugMethodInfo {\n+            private final HostedMethod hostedMethod;\n+\n+            NativeImageDebugMethodInfo(HostedMethod hostedMethod) {\n+                super(hostedMethod);\n+                this.hostedMethod = hostedMethod;\n+            }\n+\n+            @Override\n+            public String name() {\n+                String name = hostedMethod.format(\"%n\");\n+                if (\"<init>\".equals(name)) {\n+                    ResolvedJavaMethod unwrapped = hostedMethod.getWrapped().getWrapped();\n+                    if (unwrapped instanceof SubstitutionMethod) {\n+                        unwrapped = ((SubstitutionMethod) unwrapped).getOriginal();\n+                    }\n+                    name = unwrapped.format(\"%h\");\n+                    if (name.indexOf('$') >= 0) {\n+                        name = name.substring(name.lastIndexOf('$') + 1);\n+                    }\n+                }\n+                return name;\n+            }\n+\n+            @Override\n+            public String ownerType() {\n+                return typeName();\n+            }\n+\n+            @Override\n+            public String valueType() {\n+                return hostedMethod.getSignature().getReturnType(null).toJavaName();\n+            }\n+\n+            @Override\n+            public List<String> paramTypes() {\n+                LinkedList<String> paramTypes = new LinkedList<>();\n+                Signature signature = hostedMethod.getSignature();\n+                for (int i = 0; i < signature.getParameterCount(false); i++) {\n+                    paramTypes.add(signature.getParameterType(i, null).toJavaName());\n+                }\n+                return paramTypes;\n+            }\n+\n+            @Override\n+            public List<String> paramNames() {\n+                // can only provide blank names for now\n+                LinkedList<String> paramNames = new LinkedList<>();\n+                Signature signature = hostedMethod.getSignature();\n+                for (int i = 0; i < signature.getParameterCount(false); i++) {\n+                    paramNames.add(\"\");\n+                }\n+                return paramNames;\n+            }\n+\n+            @Override\n+            public int modifiers() {\n+                return hostedMethod.getModifiers();\n+            }\n+        }\n+    }\n+\n+    private class NativeImageDebugInterfaceTypeInfo extends NativeImageDebugInstanceTypeInfo implements DebugInterfaceTypeInfo {\n+\n+        NativeImageDebugInterfaceTypeInfo(HostedInterface interfaceClass) {\n+            super(interfaceClass);\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.INTERFACE;\n+        }\n+    }\n+\n+    private class NativeImageDebugArrayTypeInfo extends NativeImageDebugTypeInfo implements DebugArrayTypeInfo {\n+        HostedArrayClass arrayClass;\n+\n+        NativeImageDebugArrayTypeInfo(HostedArrayClass arrayClass) {\n+            super(arrayClass);\n+            this.arrayClass = arrayClass;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.ARRAY;\n+        }\n+\n+        @Override\n+        public int headerSize() {\n+            return OBJECTLAYOUT.getArrayBaseOffset(arrayClass.getComponentType().getStorageKind());\n+        }\n+\n+        @Override\n+        public int lengthOffset() {\n+            return OBJECTLAYOUT.getArrayLengthOffset();\n+        }\n+\n+        @Override\n+        public String elementType() {\n+            HostedType elementType = arrayClass.getComponentType();\n+            return toJavaName(elementType);\n+        }\n+    }\n+\n+    private class NativeImageDebugPrimitiveTypeInfo extends NativeImageDebugTypeInfo implements DebugPrimitiveTypeInfo {\n+        private final HostedPrimitiveType primitiveType;\n+\n+        NativeImageDebugPrimitiveTypeInfo(HostedPrimitiveType primitiveType) {\n+            super(primitiveType);\n+            this.primitiveType = primitiveType;\n+        }\n+\n+        @Override\n+        public DebugTypeKind typeKind() {\n+            return DebugTypeKind.PRIMITIVE;\n+        }\n+\n+        @Override\n+        public int bitCount() {\n+            JavaKind javaKind = primitiveType.getStorageKind();\n+            return (javaKind == JavaKind.Void ? 0 : javaKind.getBitCount());\n+        }\n+\n+        @Override\n+        public char typeChar() {\n+            return primitiveType.getStorageKind().getTypeChar();\n+        }\n+\n+        @Override\n+        public int flags() {\n+            char typeChar = primitiveType.getStorageKind().getTypeChar();\n+            switch (typeChar) {\n+                case 'B':\n+                case 'S':\n+                case 'I':\n+                case 'J': {\n+                    return FLAG_NUMERIC | FLAG_INTEGRAL | FLAG_SIGNED;\n+                }\n+                case 'C': {\n+                    return FLAG_NUMERIC | FLAG_INTEGRAL;\n+                }\n+                case 'F':\n+                case 'D': {\n+                    return FLAG_NUMERIC;\n+                }\n+                default: {\n+                    assert typeChar == 'V' || typeChar == 'Z';\n+                    return 0;\n+                }\n+            }\n+        }\n+    }\n+\n+    private NativeImageDebugTypeInfo createDebugTypeInfo(HostedType hostedType) {\n+        if (hostedType.isEnum()) {\n+            return new NativeImageDebugEnumTypeInfo((HostedInstanceClass) hostedType);\n+        } else if (hostedType.isInstanceClass()) {\n+            return new NativeImageDebugInstanceTypeInfo(hostedType);\n+        } else if (hostedType.isInterface()) {\n+            return new NativeImageDebugInterfaceTypeInfo((HostedInterface) hostedType);\n+        } else if (hostedType.isArray()) {\n+            return new NativeImageDebugArrayTypeInfo((HostedArrayClass) hostedType);\n+        } else if (hostedType.isPrimitive()) {\n+            return new NativeImageDebugPrimitiveTypeInfo((HostedPrimitiveType) hostedType);\n+        } else {\n+            throw new RuntimeException(\"Unknown type kind \" + hostedType.getName());\n+        }\n+    }\n+\n+    /**\n+     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo extends NativeImageDebugFileInfo implements DebugCodeInfo {\n+        private final HostedMethod hostedMethod;\n+        private final CompilationResult compilation;\n+\n+        @SuppressWarnings(\"try\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3MTc3OA=="}, "originalCommit": {"oid": "f665d9b9b3dd24e03e6d6c9d5182311b5e4138e9"}, "originalPosition": 816}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzODEwMDEzOnYy", "diffSide": "RIGHT", "path": "substratevm/mx.substratevm/testhello.py", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxMzoxNjo1OFrOIX178g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxNjoxNzoxNVrOIX-YuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTg3MTg1OA==", "bodyText": "s/warning/Warning", "url": "https://github.com/oracle/graal/pull/3046#discussion_r561871858", "createdAt": "2021-01-21T13:16:58Z", "author": {"login": "olpaw"}, "path": "substratevm/mx.substratevm/testhello.py", "diffHunk": "@@ -130,11 +130,30 @@ def test():\n     package_file_pattern = '[a-zA-Z0-9_/]+\\\\.java'\n     varname_pattern = '[a-zA-Z0-9_]+'\n     wildcard_pattern = '.*'\n+    # obtain the gdb version\n+    # n.b. we can only test printing in gdb 10.1 upwards\n+    exec_string=execute(\"show version\")\n+    checker = Checker('show version',\n+                      r\"GNU gdb %s (%s)\\.(%s)%s\"%(wildcard_pattern, digits_pattern, digits_pattern, wildcard_pattern))\n+    matches = checker.check(exec_string, skip_fails=False)\n+    # n.b. can only get back here with one match\n+    match = matches[0]\n+    major = int(match.group(1))\n+    # may need this if 8.x and 9.x get patched\n+    # minor = int(match.group(2))\n+    # printing object data requires gdb 10+\n+    can_print_data = major > 9\n+\n+    if not can_print_data:\n+        print(\"warning: cannot test printing of objects!\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "637d66a875578c991bb171fe720f41b32601d289"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAxMDI5Nw==", "bodyText": "Fixed.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562010297", "createdAt": "2021-01-21T16:17:15Z", "author": {"login": "adinn"}, "path": "substratevm/mx.substratevm/testhello.py", "diffHunk": "@@ -130,11 +130,30 @@ def test():\n     package_file_pattern = '[a-zA-Z0-9_/]+\\\\.java'\n     varname_pattern = '[a-zA-Z0-9_]+'\n     wildcard_pattern = '.*'\n+    # obtain the gdb version\n+    # n.b. we can only test printing in gdb 10.1 upwards\n+    exec_string=execute(\"show version\")\n+    checker = Checker('show version',\n+                      r\"GNU gdb %s (%s)\\.(%s)%s\"%(wildcard_pattern, digits_pattern, digits_pattern, wildcard_pattern))\n+    matches = checker.check(exec_string, skip_fails=False)\n+    # n.b. can only get back here with one match\n+    match = matches[0]\n+    major = int(match.group(1))\n+    # may need this if 8.x and 9.x get patched\n+    # minor = int(match.group(2))\n+    # printing object data requires gdb 10+\n+    can_print_data = major > 9\n+\n+    if not can_print_data:\n+        print(\"warning: cannot test printing of objects!\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTg3MTg1OA=="}, "originalCommit": {"oid": "637d66a875578c991bb171fe720f41b32601d289"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUzODI4MzczOnYy", "diffSide": "RIGHT", "path": "substratevm/mx.substratevm/testhello.py", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQxMzo1Nzo0MVrOIX3phw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODowMzoyOFrOIYvMYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTg5OTkxMQ==", "bodyText": "When I run mx debuginfotest locally on 637d66a with gdb\nGNU gdb (GDB) Fedora 10.1-2.fc33\n\ngdb aborts when executing line 182:\ngdb) list\n67\t        Greeter greeter = Greeter.greeter(args);\n\n(gdb) backtrace\n#0  hello.Hello::main(java.lang.String[] *) () at hello/Hello.java:67\n#1  0x000000000041cef5 in com.oracle.svm.core.code.IsolateEnterStub::JavaMainWrapper_run_5087f5482cc9a6abc971913ece43acb471d2631b(int, org.graalvm.nativeimage.c.type.CCharPointerPointer *) () at com/oracle/svm/core/JavaMainWrapper.java:146\n\n(gdb) print /x *(('java.lang.String[]' *)$rdi)\ngdb.error: Location address is not set.\n\nDo I need another version of gdb (I thought I read that 10.1 should be good)?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r561899911", "createdAt": "2021-01-21T13:57:41Z", "author": {"login": "olpaw"}, "path": "substratevm/mx.substratevm/testhello.py", "diffHunk": "@@ -149,36 +168,75 @@ def test():\n     checker.check(exec_string, skip_fails=False)\n \n     # run a backtrace\n-    # expect \"#0  hello.Hello.main(java.lang.String[]).* at hello.Hello.java:67\"\n+    # expect \"#0  hello.Hello.main(java.lang.String[] *).* at hello.Hello.java:67\"\n     # expect \"#1  0x[0-9a-f]+ in com.oracle.svm.core.code.IsolateEnterStub.JavaMainWrapper_run_.* at [a-z/]+/JavaMainWrapper.java:[0-9]+\"\n     exec_string = execute(\"backtrace\")\n-    checker = Checker(\"backtrace hello.Hello.main\",\n-                      [r\"#0%shello\\.Hello\\.main\\(java\\.lang\\.String\\[\\]\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n-                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub\\.JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n+    checker = Checker(\"backtrace hello.Hello::main\",\n+                      [r\"#0%shello\\.Hello::main\\(java\\.lang\\.String\\[\\] \\*\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n+                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub::JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n                        ])\n     checker.check(exec_string, skip_fails=False)\n \n+    if can_print_data:\n+        # print the contents of the arguments array which will be in rdi\n+        exec_string = execute(\"print /x *(('java.lang.String[]' *)$rdi)\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "637d66a875578c991bb171fe720f41b32601d289"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAwOTU2MQ==", "bodyText": "Hmm, yes  10.1 is supposed to avoid this problem. I'll take a look at this once I fix the script as you recommended earlier.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562009561", "createdAt": "2021-01-21T16:16:20Z", "author": {"login": "adinn"}, "path": "substratevm/mx.substratevm/testhello.py", "diffHunk": "@@ -149,36 +168,75 @@ def test():\n     checker.check(exec_string, skip_fails=False)\n \n     # run a backtrace\n-    # expect \"#0  hello.Hello.main(java.lang.String[]).* at hello.Hello.java:67\"\n+    # expect \"#0  hello.Hello.main(java.lang.String[] *).* at hello.Hello.java:67\"\n     # expect \"#1  0x[0-9a-f]+ in com.oracle.svm.core.code.IsolateEnterStub.JavaMainWrapper_run_.* at [a-z/]+/JavaMainWrapper.java:[0-9]+\"\n     exec_string = execute(\"backtrace\")\n-    checker = Checker(\"backtrace hello.Hello.main\",\n-                      [r\"#0%shello\\.Hello\\.main\\(java\\.lang\\.String\\[\\]\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n-                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub\\.JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n+    checker = Checker(\"backtrace hello.Hello::main\",\n+                      [r\"#0%shello\\.Hello::main\\(java\\.lang\\.String\\[\\] \\*\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n+                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub::JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n                        ])\n     checker.check(exec_string, skip_fails=False)\n \n+    if can_print_data:\n+        # print the contents of the arguments array which will be in rdi\n+        exec_string = execute(\"print /x *(('java.lang.String[]' *)$rdi)\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTg5OTkxMQ=="}, "originalCommit": {"oid": "637d66a875578c991bb171fe720f41b32601d289"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA3ODI5NA==", "bodyText": "Well, that's disappointing. This appears to be a problem with the fedora build of gdb 10.1. When I run with a gdb 10.1 built from the vanilla gnu sources this error does not happen.\nI think I know where this is going wrong (there is a patch in fedora's c-valprint.c that looks decidedly dodgy) but I need to check using a debuggable gdb build based on the fedora code. I'll post an update as soon as I can find what is wrong.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562078294", "createdAt": "2021-01-21T17:47:58Z", "author": {"login": "adinn"}, "path": "substratevm/mx.substratevm/testhello.py", "diffHunk": "@@ -149,36 +168,75 @@ def test():\n     checker.check(exec_string, skip_fails=False)\n \n     # run a backtrace\n-    # expect \"#0  hello.Hello.main(java.lang.String[]).* at hello.Hello.java:67\"\n+    # expect \"#0  hello.Hello.main(java.lang.String[] *).* at hello.Hello.java:67\"\n     # expect \"#1  0x[0-9a-f]+ in com.oracle.svm.core.code.IsolateEnterStub.JavaMainWrapper_run_.* at [a-z/]+/JavaMainWrapper.java:[0-9]+\"\n     exec_string = execute(\"backtrace\")\n-    checker = Checker(\"backtrace hello.Hello.main\",\n-                      [r\"#0%shello\\.Hello\\.main\\(java\\.lang\\.String\\[\\]\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n-                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub\\.JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n+    checker = Checker(\"backtrace hello.Hello::main\",\n+                      [r\"#0%shello\\.Hello::main\\(java\\.lang\\.String\\[\\] \\*\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n+                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub::JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n                        ])\n     checker.check(exec_string, skip_fails=False)\n \n+    if can_print_data:\n+        # print the contents of the arguments array which will be in rdi\n+        exec_string = execute(\"print /x *(('java.lang.String[]' *)$rdi)\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTg5OTkxMQ=="}, "originalCommit": {"oid": "637d66a875578c991bb171fe720f41b32601d289"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc2MjIyMQ==", "bodyText": "I confirmed the problem is indeed a patch applied to valops.c which I have reported to Red Hat's gdb team. I'm not really clear what the patch is meant to achieve but it actually looks incoherent. The inserted code tests a pointer value to see if there is a data_location on target type for the pointer and special cases that situation to fetch the address by calling a routine that looks for a data_location on the type of the pointer value (i.e. the pointer type, not the target). That doesn't look at all right.\nI'll let you know what the gdb team come up with. n.b. I have asked them if they can ensure any fix to this gets pushed back to RHEL and fedora 32 if that is needed.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562762221", "createdAt": "2021-01-22T16:46:42Z", "author": {"login": "adinn"}, "path": "substratevm/mx.substratevm/testhello.py", "diffHunk": "@@ -149,36 +168,75 @@ def test():\n     checker.check(exec_string, skip_fails=False)\n \n     # run a backtrace\n-    # expect \"#0  hello.Hello.main(java.lang.String[]).* at hello.Hello.java:67\"\n+    # expect \"#0  hello.Hello.main(java.lang.String[] *).* at hello.Hello.java:67\"\n     # expect \"#1  0x[0-9a-f]+ in com.oracle.svm.core.code.IsolateEnterStub.JavaMainWrapper_run_.* at [a-z/]+/JavaMainWrapper.java:[0-9]+\"\n     exec_string = execute(\"backtrace\")\n-    checker = Checker(\"backtrace hello.Hello.main\",\n-                      [r\"#0%shello\\.Hello\\.main\\(java\\.lang\\.String\\[\\]\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n-                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub\\.JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n+    checker = Checker(\"backtrace hello.Hello::main\",\n+                      [r\"#0%shello\\.Hello::main\\(java\\.lang\\.String\\[\\] \\*\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n+                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub::JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n                        ])\n     checker.check(exec_string, skip_fails=False)\n \n+    if can_print_data:\n+        # print the contents of the arguments array which will be in rdi\n+        exec_string = execute(\"print /x *(('java.lang.String[]' *)$rdi)\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTg5OTkxMQ=="}, "originalCommit": {"oid": "637d66a875578c991bb171fe720f41b32601d289"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwOTk1NA==", "bodyText": "Awesome! Thanks for getting this fixed.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562809954", "createdAt": "2021-01-22T18:03:28Z", "author": {"login": "olpaw"}, "path": "substratevm/mx.substratevm/testhello.py", "diffHunk": "@@ -149,36 +168,75 @@ def test():\n     checker.check(exec_string, skip_fails=False)\n \n     # run a backtrace\n-    # expect \"#0  hello.Hello.main(java.lang.String[]).* at hello.Hello.java:67\"\n+    # expect \"#0  hello.Hello.main(java.lang.String[] *).* at hello.Hello.java:67\"\n     # expect \"#1  0x[0-9a-f]+ in com.oracle.svm.core.code.IsolateEnterStub.JavaMainWrapper_run_.* at [a-z/]+/JavaMainWrapper.java:[0-9]+\"\n     exec_string = execute(\"backtrace\")\n-    checker = Checker(\"backtrace hello.Hello.main\",\n-                      [r\"#0%shello\\.Hello\\.main\\(java\\.lang\\.String\\[\\]\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n-                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub\\.JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n+    checker = Checker(\"backtrace hello.Hello::main\",\n+                      [r\"#0%shello\\.Hello::main\\(java\\.lang\\.String\\[\\] \\*\\)%s at hello/Hello\\.java:67\"%(spaces_pattern, wildcard_pattern),\n+                       r\"#1%s%s in com\\.oracle\\.svm\\.core\\.code\\.IsolateEnterStub::JavaMainWrapper_run_%s at %sJavaMainWrapper\\.java:[0-9]+\"%(spaces_pattern, address_pattern, wildcard_pattern, package_pattern)\n                        ])\n     checker.check(exec_string, skip_fails=False)\n \n+    if can_print_data:\n+        # print the contents of the arguments array which will be in rdi\n+        exec_string = execute(\"print /x *(('java.lang.String[]' *)$rdi)\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTg5OTkxMQ=="}, "originalCommit": {"oid": "637d66a875578c991bb171fe720f41b32601d289"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MjI3MDQwOnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwOTo0NzowMlrOIYc8Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMTozNDowNVrOIYgqig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxMDk0Nw==", "bodyText": "Static field access like this one should be tested in testhello.py", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562510947", "createdAt": "2021-01-22T09:47:02Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU3MTkxNA==", "bodyText": "Yes, good point. I'll add a check to the test.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562571914", "createdAt": "2021-01-22T11:34:05Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxMDk0Nw=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MjMyNjg2OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMDowMDo0NlrOIYdeMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxMDowMzowM1rOIZfQBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxOTYwMQ==", "bodyText": "Interesting ... this approach is different than what we came up in EE debuginfo. There the dwarf-type for java.lang.String is a DW_TAG_pointer_type that points to a DW_TAG_structure_type. This allows us to encode the different deref-semantics when compressed pointers are used into the dwarf-types (i.e. we have java.lang.String and a  _z_.java.lang.String in case a location points to a String via compressed refs).\nHow are you going to solve that problem with your approach?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562519601", "createdAt": "2021-01-22T10:00:46Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+knows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUzMjY1Mw==", "bodyText": "Ahh I just saw the special special access for compressed refs is specified as dwarf expression in the DW_TAG_structure_type in field DW_AT_data_location (and not in DW_TAG_pointer_type). That means you can use the same approach. E.g for  _z_.java.lang.String we have:\nDW_TAG_pointer_type\n  DW_AT_type                  <0x002b5dd2>\n  DW_AT_byte_size             0x00000004\nDW_TAG_structure_type\n  DW_AT_name                  _z_.java.lang.String\n  DW_AT_byte_size             0x00000018\n  DW_AT_data_location         0x970effffffff000000001a12302928050033247e0022 \n  DW_AT_sibling               <0x002b5e24>\n  DW_TAG_member\n    DW_AT_name                  __hub__\n    DW_AT_type                  <0x002d64e0>\n    DW_AT_data_member_location  DW_OP_plus_uconst 0\n  DW_TAG_member\n    DW_AT_name                  value\n  ...\n\nwhere DW_AT_data_location holds the dwarf-expression-program that specifies the compressed refs access.\nCompare that to java.lang.String where we have:\nDW_TAG_pointer_type\n  DW_AT_type                  <0x002b5e2a>\n  DW_AT_byte_size             0x00000008\nDW_TAG_structure_type\n  DW_AT_name                  java.lang.String\n  DW_AT_byte_size             0x00000018\n  DW_AT_sibling               <0x002b5e6e>\n  DW_TAG_member\n    DW_AT_name                  __hub__\n    DW_AT_type                  <0x002d64e0>\n    DW_AT_data_member_location  DW_OP_plus_uconst 0\n  DW_TAG_member\n  ...", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562532653", "createdAt": "2021-01-22T10:22:27Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+knows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxOTYwMQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUzNjY5Ng==", "bodyText": "Btw, do you know a tool that can disassemble the contents of DW_AT_data_location fields?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562536696", "createdAt": "2021-01-22T10:28:53Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+knows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxOTYwMQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc1ODMxNg==", "bodyText": "First off, to answer the second question, objdump should decode data_location expressions when you dump the info section.\n$ objdump --dwarf=info hello\n. . . \n <0><b>: Abbrev Number: 1 (DW_TAG_compile_unit)\n    <c>   DW_AT_language    : 11\t(Java)\n . . .\n <1><52>: Abbrev Number: 7 (DW_TAG_structure_type)\n    <53>   DW_AT_name        : (indirect string, offset: 0x23af3): _objhdr\n    <57>   DW_AT_byte_size   : 12\n    <58>   DW_AT_data_location: 4 byte block: 97 37 20 1a \t(DW_OP_push_object_address; DW_OP_lit7; DW_OP_not; DW_OP_and)\n. . .\n\nOk, now for the pointer interpretation problem. I have thought about trying something similar to your solution but but I think there may be a problem with it. It's a tad complex so I hope you'll bear with me while I try to explain it in detail.\nThe root of the problem is actually the somewhat odd way DWARF supports re-interpretation of addresses using the data_location property. It expects that property to be located in the definition of the structure being pointed to not in the definition of the pointer that references the structure. That means that if you want to be able to distinguish, say, narrow pointers to struct Foo from direct pointers to struct Foo you actually need to have two equivalent definitions of the underlying layout type e.g. Struct Foo and struct _z_Foo, differing only in the presence or absence of the data_location.  In your case it comes down to having two names for pointers to two anonymous but equivalent structs and using those named pointer types strategically to label the relevant data locations, method arguments etc.\nOf course, a narrow pointer and a direct pointer both actually point at the same type of object. However, because both anonymous structs have the same named fields any path expression that works for one struct works exactly the same for the other. So, the fact that two different types may be used to identify the same memory layout is transparent to whoever is driving gdb.\nYour solution also doubles the amount of of DWARF info needed to define both the structs and their data members but that's maybe not too big a deal.\nNow, in my code the names are attached to the struct types, not the pointer types. So, the equivalent trick would be to have two structs with two different names, define anonymous pointer types for each struct and and then use them strategically in the same way as you do to type pointer data. One reaso for using that naming model is that my code is not using structs, it is using classes which need to have name. Also, classes with different names are different types. Well, structs with different names are also different types.  Does that matter? There are several points where I think it does.\nApart from the base compilation unit that declares primitive an header types all other compilation units map 1-1 to an instance class or interface. Info records for members, i.e. instance fields, methods and static fields are declared within the scope of the method's owning class. Declarations (strictly specifications)are embedded as children of the class_type DIE. The latter two types of declaration have accompanying method definitions (essentially the method address ranges) and static field definitions (essentially address locations) embedded as level 1 siblings of the class_type DIE.\nProviding a second class definition to carry the data_location attribute needed, say, to allow a narrow pointer to be translated would appear to require doubling all those elements. A consequence of this is that there would be more than one method definition associated with an address range and more than one data definition associated with a static field address. That's a problem because it means more than one DIE is associated with a given address range. gdb expects DIEs to be presented in ascending address order with no overlap.\nNote that it would not be possible to get round this by putting the declarations in each of the two classes and have each equivalent declaration reference reference the equivalent definition record. Declarations and definitions must be cross-linked 1-1 in each direction.\nIs there a way around this? Well, it might be possible to omit the method and static field declarations from the copy, only making it structurally equivalent to the direct pointer target. However, that means the two type are to present differently to the user (at the very least command ptype would produce different output).\nAnother option is to use structs and not embed method and static field details in classes. That's perhaps ok in the short term. However, in the longer term I think it would really be better if the debugger knew that Java objects were objects and had associated behaviours. So, I'd really like to avoid switching from classes to structs and decoupling the methods and static fields if I can avoid it.\nOne thing I still have to try is to define a narrow class type as a vacuous wrapper type that inherits from the direct pointer class with only one extra attribute i.e. the data_location field. I'm hoping we could use this as the base target for a narrow pointer type. I did try this some months back and it failed but that was when I was grappling with the bugs in the data_location processing. I'll retry this solution now that they are fixed and see if that can be used to enable us to declare the two alternative pointer types.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562758316", "createdAt": "2021-01-22T16:40:35Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+knows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxOTYwMQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwMzY0Mw==", "bodyText": "Wow, just to make this a bit more salient ...  I noticed that symbol 'java.util.Scanner'::linePattern is ambiguos because it idenitfies a static field and a method of class scanner.\n(gdb) info var java.util.Scanner::linePattern\nAll variables matching regular expression \"java.util.Scanner::linePattern\":\n\nFile java/util/Scanner.java:\n    java.util.regex.Pattern *java.util.Scanner::linePattern;\n(gdb)  p * 'java.util.Scanner'::linePattern\n$16 = {java.util.regex.Pattern *(void)} 0x5f87d0 <java.util.Scanner::linePattern(void)>\n\nptype 'java.util.Scanner'\ntype = class java.util.Scanner : public java.lang.Object {\n  private:\n    int position;\n    . . .\n    static java.util.regex.Pattern *linePattern;\n    . . .\n    static java.util.regex.Pattern * linePattern(void);\n    . . .\n\nHowever, I then tried this and it shows that gdb really does know a lot about methods:\n(gdb) p * 'java.util.Scanner'::linePattern()\n$17 = {\n  <java.lang.Object> = {\n    <_objhdr> = {\n      hub = 0x952c60,\n      idHash = 157063191\n    }, <No data fields>}, \n  members of java.util.regex.Pattern:\n  flags = 0,\n  pattern = 0xa2c110,\n  . . .\n\nSo, a bit more info about calling conventions and we might be able to call methods direct from gdb!", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562803643", "createdAt": "2021-01-22T17:53:53Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+knows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxOTYwMQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU4NTk1MA==", "bodyText": "One thing I still have to try is to define a narrow class type as a vacuous wrapper type that inherits from the direct pointer class with only one extra attribute i.e. the data_location field. I'm hoping we could use this as the base target for a narrow pointer type. I did try this some months back and it failed but that was when I was grappling with the bugs in the data_location processing. I'll retry this solution now that they are fixed and see if that can be used to enable us to declare the two alternative pointer types.\n\nIf that does not work maybe folding the data_location field in by declaring the type of each location that uses a compressed ref as a DW_TAG_union_type consisting of the regular DW_TAG_class_type plus a DW_TAG_class_type that only contains the DW_AT_data_location.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563585950", "createdAt": "2021-01-25T09:46:27Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+knows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxOTYwMQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU4NjUzNA==", "bodyText": "objdump --dwarf=info hello\n\nThanks for the info!", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563586534", "createdAt": "2021-01-25T09:47:22Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+knows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxOTYwMQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU5NjEyOA==", "bodyText": "Another option is to use structs and not embed method and static field details in classes. That's perhaps ok in the short term. However, in the longer term I think it would really be better if the debugger knew that Java objects were objects and had associated behaviours. So, I'd really like to avoid switching from classes to structs and decoupling the methods and static fields if I can avoid it.\n\nOnce you settled on the dwarf type presentation for Java types you should not change it anymore if possible. Users might get upset if the way to access data changes from one release to the next. Also native-image specific debugging plugins for IDEs might pop into existence that start to rely on stable patterns on how to access certain kind data structures when debugging native-images. I.e. we should be really sure that the chosen type representation will work with compressed refs.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563596128", "createdAt": "2021-01-25T10:01:19Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+knows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxOTYwMQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU5NzMxNg==", "bodyText": "So, a bit more info about calling conventions and we might be able to call methods direct from gdb!\n\nSounds plausible. At least for methods that only require primitive type arguments.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563597316", "createdAt": "2021-01-25T10:03:03Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,12 +80,83 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n+## Debugging with Isolates\n+\n+Note that it is currently recommended to disable use of Isolates by\n+passing flag `-H:-UseIsolates` on the command line when debug info\n+generation is enabled. Enabling of Isolates affects the way that oops\n+(object references) are encoded. In turn that means the debug info\n+generator has to provide gdb with information about how to translate\n+an encoded oop to the address in memory where the object data is\n+stored. This sometimes requires care when asking gdb to process\n+encoded oops vs decoded raw addresses.\n+\n+When isolates are disabled oops are essentially raw addresses pointing\n+directly at the object contents. This is the same whether the oop is\n+stored in a static/instance field or has been loaded into a register.\n+\n+When an oop is stored in a static or instance field gdb knows the type\n+of the value stored in the field and knows how to dereference it to\n+locate the object contents. For example, assume we have a `Units` type\n+that details the scale used for a blueprint drawing and that the\n+`Units` instance has a `String` field called `print_name`. Assume also\n+we have a static field `DEFAULT_UNIT` that holds the standard `Units`\n+instance. The following command will print the name for the default\n+units.\n+\n+```\n+(gdb) print *com.acme.Blueprint::DEFAULT_UNIT->print_name\n+```\n+\n+gdb knows the type of the oop stored in `Blueprint::DEFAULT_UNIT` and\n+knows how to dereference it to locate the object field\n+values. Likewise, it knows that the `print_name` field is a `String`\n+it will translate the oop stored in that field to an address where the\n+String contents are stored and it will print the values of the\n+`String` instance fields one by one.\n+\n+If, say, an oop referring to the `print_name` String has been loaded\n+into $rdx it is still possible to print it using a straightforward\n+cast to the pointer type that gdb associates with oop references.\n+\n+```\n+(gdb) print/x *('java.lang.String' *)$rdx", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjUxOTYwMQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MjYyMzcyOnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMToyMTo0MVrOIYgSVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzoyMzoxOFrOIYtrqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU2NTcxOA==", "bodyText": "s/caled/called", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562565718", "createdAt": "2021-01-22T11:21:41Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc4NTE5NA==", "bodyText": "done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562785194", "createdAt": "2021-01-22T17:23:18Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU2NTcxOA=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MjYyNTc0OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMToyMjoxNlrOIYgTgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzoyMzozMVrOIYtsJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU2NjAxOA==", "bodyText": "s/obejct/object", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562566018", "createdAt": "2021-01-22T11:22:16Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc4NTMxNw==", "bodyText": "done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562785317", "createdAt": "2021-01-22T17:23:31Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU2NjAxOA=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MjgxNDIzOnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMjoyMDo1OVrOIYiE0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzozNDozN1rOIYuGww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU5NTAyNQ==", "bodyText": "With proper implementation the manual masking of the flag bits should not be necessary. It is possible to implement the masking of the three bits in the dwarf-type of the hub object. The __hub__ member in the above examples https://github.com/oracle/graal/pull/3046/files#r562532653 is of type <0x002d64e0>. Here is the definition of this dwarf-type:\n< 1><0x002d64e0>    DW_TAG_pointer_type\n                      DW_AT_type                  <0x002d64e6>\n                      DW_AT_byte_size             0x00000004\n< 1><0x002d64e6>    DW_TAG_structure_type\n                      DW_AT_name                  _z_.java.lang.Class\n                      DW_AT_byte_size             0x00000078\n                      DW_AT_data_location         0x9733250effffffff000000001a12302928050033247e0022\n                      DW_AT_sibling               <0x002d668a>\n< 2><0x002d6509>      DW_TAG_member\n                        DW_AT_name                  __hub__\n                        DW_AT_type                  <0x002d64e0>\n                        DW_AT_data_member_location  DW_OP_plus_uconst 0\n< 2><0x002d6515>      DW_TAG_member\n\nAs you can see here we have for DW_AT_data_location a different dwarf-expression program\n0x9733250effffffff000000001a12302928050033247e0022. The reason is that here it also takes the masking of the lowest 3 bits into account.\nYou should be able to use the same approach so that users do not need to know about the masking when they deref the hub field.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562595025", "createdAt": "2021-01-22T12:20:59Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc4NzU4Mw==", "bodyText": "Yes, this version of the hubname command is a hangover from an earlier version when I was omitting data_location attributes in the case where -H:-SpawnIsolates was specified. In the current version the mask should not be needed.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562787583", "createdAt": "2021-01-22T17:26:58Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU5NTAyNQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc5MTk3Ng==", "bodyText": "The command can actually be simplified to this\ncommand hubname\n  x/s ((_objhdr *)($arg0))->hub->name->value->data\nend", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562791976", "createdAt": "2021-01-22T17:34:18Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU5NTAyNQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc5MjEzMQ==", "bodyText": "Done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562792131", "createdAt": "2021-01-22T17:34:37Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU5NTAyNQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MjgzNTY2OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMjoyODowOFrOIYiRtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzozODo1OVrOIYuRPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU5ODMyNg==", "bodyText": "Wow. This is nice.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562598326", "createdAt": "2021-01-22T12:28:08Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in\n+the hub field that may sometimes get set by the runtime during program operation.\n+\n+Attempting to print the hub name for an invalid reference will fail\n+safe, printing an error message.\n+\n+```\n+(gdb) p/x (_objhdr *)$rdx\n+$5 = 0x2\n+(gdb) hubname $rdx\n+Cannot access memory at address 0x2\n+```\n+\n+Array type layouts are modelled with a class. The class inherits\n+fields from an array header struct specific to the array element type,\n+one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (the last one is for\n+object arrays). Inherited fields include the hub, array length, idHash\n+to round up the header size to a boundary suitable for the array\n+element type. The array class (layout) type includes only one field, a\n+C++ array of length zero whose element type is a primtiive type or\n+Java referece type.\n+\n+```\n+(gdb) ptype 'java.lang.String[]'\n+type = struct java.lang.String[] : public _arrhdrA {\n+    java.lang.String *data[0];\n+}\n+```\n+\n+Notice that the type of the values stored in the data array is\n+`java.lang.String *` i.e. the C++ array stores Java references\n+i.e. addresss as far as the C++ model is concerned.\n+\n+The array header structs are all extensions of the basic _objhdr type\n+which means that arrays and objects can both be safely cast to oops.\n+\n+```\n+(gdb) ptype _arrhdrA\n+type = struct _arrhdrA {\n+    java.lang.Class *hub;\n+    int len;\n+    int idHash;\n+}\n+```\n+\n+Interfaces layouts are modelled as union types whose members are the\n+layouts for all the classes which implement the interfacse.\n+\n+```\n+(gdb) ptype 'java.lang.CharSequence'\n+type = union _java.lang.CharSequence {\n+    _java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;\n+    _java.lang.StringBuffer _java.lang.StringBuffer;\n+    _java.lang.StringBuilder _java.lang.StringBuilder;\n+    _java.lang.String _java.lang.String;\n+    _java.nio.CharBuffer _java.nio.CharBuffer;\n+}\n+```\n+\n+Given a reference typed to an interface it can be resolved to the\n+relevant class type by viewing it through the relevant union element.\n+\n+If we take the first String in the args array we can ask gdb to cast\n+it to interface CharSequence\n+```\n+(gdb) print (('java.lang.String[]' *)$rdi)->data[0]\n+$6 = (java.lang.String) 0x7ffff7c01060\n+(gdb) print ('java.lang.CharSequence')$6", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc5NDgxMw==", "bodyText": "Yes, isn't it. I vaguely waved at this idea in my Linux Plumbers Conference talk when I was sketching out a Java -> C type mapping a a prior step to translating to DWARF. It's actually quite a neat way of looking at interfaces -- but only in a closed world!\nI was really impressed  because someone in the audience immediately added that rider before I could :-)", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562794813", "createdAt": "2021-01-22T17:38:59Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in\n+the hub field that may sometimes get set by the runtime during program operation.\n+\n+Attempting to print the hub name for an invalid reference will fail\n+safe, printing an error message.\n+\n+```\n+(gdb) p/x (_objhdr *)$rdx\n+$5 = 0x2\n+(gdb) hubname $rdx\n+Cannot access memory at address 0x2\n+```\n+\n+Array type layouts are modelled with a class. The class inherits\n+fields from an array header struct specific to the array element type,\n+one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (the last one is for\n+object arrays). Inherited fields include the hub, array length, idHash\n+to round up the header size to a boundary suitable for the array\n+element type. The array class (layout) type includes only one field, a\n+C++ array of length zero whose element type is a primtiive type or\n+Java referece type.\n+\n+```\n+(gdb) ptype 'java.lang.String[]'\n+type = struct java.lang.String[] : public _arrhdrA {\n+    java.lang.String *data[0];\n+}\n+```\n+\n+Notice that the type of the values stored in the data array is\n+`java.lang.String *` i.e. the C++ array stores Java references\n+i.e. addresss as far as the C++ model is concerned.\n+\n+The array header structs are all extensions of the basic _objhdr type\n+which means that arrays and objects can both be safely cast to oops.\n+\n+```\n+(gdb) ptype _arrhdrA\n+type = struct _arrhdrA {\n+    java.lang.Class *hub;\n+    int len;\n+    int idHash;\n+}\n+```\n+\n+Interfaces layouts are modelled as union types whose members are the\n+layouts for all the classes which implement the interfacse.\n+\n+```\n+(gdb) ptype 'java.lang.CharSequence'\n+type = union _java.lang.CharSequence {\n+    _java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;\n+    _java.lang.StringBuffer _java.lang.StringBuffer;\n+    _java.lang.StringBuilder _java.lang.StringBuilder;\n+    _java.lang.String _java.lang.String;\n+    _java.nio.CharBuffer _java.nio.CharBuffer;\n+}\n+```\n+\n+Given a reference typed to an interface it can be resolved to the\n+relevant class type by viewing it through the relevant union element.\n+\n+If we take the first String in the args array we can ask gdb to cast\n+it to interface CharSequence\n+```\n+(gdb) print (('java.lang.String[]' *)$rdi)->data[0]\n+$6 = (java.lang.String) 0x7ffff7c01060\n+(gdb) print ('java.lang.CharSequence')$6", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU5ODMyNg=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 326}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0Mjg0NzA4OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMjozMTo0NlrOIYiYqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMjozMTo0NlrOIYiYqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwMDEwNw==", "bodyText": "This should also be mention below ## Currently Implemented Features. I.e. add ## Currently missing Features that mentions the missing location info generation.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562600107", "createdAt": "2021-01-22T12:31:46Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in\n+the hub field that may sometimes get set by the runtime during program operation.\n+\n+Attempting to print the hub name for an invalid reference will fail\n+safe, printing an error message.\n+\n+```\n+(gdb) p/x (_objhdr *)$rdx\n+$5 = 0x2\n+(gdb) hubname $rdx\n+Cannot access memory at address 0x2\n+```\n+\n+Array type layouts are modelled with a class. The class inherits\n+fields from an array header struct specific to the array element type,\n+one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (the last one is for\n+object arrays). Inherited fields include the hub, array length, idHash\n+to round up the header size to a boundary suitable for the array\n+element type. The array class (layout) type includes only one field, a\n+C++ array of length zero whose element type is a primtiive type or\n+Java referece type.\n+\n+```\n+(gdb) ptype 'java.lang.String[]'\n+type = struct java.lang.String[] : public _arrhdrA {\n+    java.lang.String *data[0];\n+}\n+```\n+\n+Notice that the type of the values stored in the data array is\n+`java.lang.String *` i.e. the C++ array stores Java references\n+i.e. addresss as far as the C++ model is concerned.\n+\n+The array header structs are all extensions of the basic _objhdr type\n+which means that arrays and objects can both be safely cast to oops.\n+\n+```\n+(gdb) ptype _arrhdrA\n+type = struct _arrhdrA {\n+    java.lang.Class *hub;\n+    int len;\n+    int idHash;\n+}\n+```\n+\n+Interfaces layouts are modelled as union types whose members are the\n+layouts for all the classes which implement the interfacse.\n+\n+```\n+(gdb) ptype 'java.lang.CharSequence'\n+type = union _java.lang.CharSequence {\n+    _java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;\n+    _java.lang.StringBuffer _java.lang.StringBuffer;\n+    _java.lang.StringBuilder _java.lang.StringBuilder;\n+    _java.lang.String _java.lang.String;\n+    _java.nio.CharBuffer _java.nio.CharBuffer;\n+}\n+```\n+\n+Given a reference typed to an interface it can be resolved to the\n+relevant class type by viewing it through the relevant union element.\n+\n+If we take the first String in the args array we can ask gdb to cast\n+it to interface CharSequence\n+```\n+(gdb) print (('java.lang.String[]' *)$rdi)->data[0]\n+$6 = (java.lang.String) 0x7ffff7c01060\n+(gdb) print ('java.lang.CharSequence')$6\n+$7 = (java.lang.CharSequence) 0x7ffff7c01060\n+```\n+\n+The hubname command can be used to identify the actual type of the\n+object that implements this interface and that type name can be used\n+to select the union element used to print the object.\n+\n+```\n+(gdb) hubname $7\n+0x7d96d8:\t\"java.lang.String\\270\", <incomplete sequence \\344\\220>\n+(gdb) print $7->'_java.lang.String'\n+$18 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The current debug info model does not include the location info needed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0Mjg1MzI5OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMjozMzo1NlrOIYiceA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzozOTo0MlrOIYuS6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwMTA4MA==", "bodyText": "Nice advantage of using :: as separator. Makes it dead simple to grep for method names.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562601080", "createdAt": "2021-01-22T12:33:56Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in\n+the hub field that may sometimes get set by the runtime during program operation.\n+\n+Attempting to print the hub name for an invalid reference will fail\n+safe, printing an error message.\n+\n+```\n+(gdb) p/x (_objhdr *)$rdx\n+$5 = 0x2\n+(gdb) hubname $rdx\n+Cannot access memory at address 0x2\n+```\n+\n+Array type layouts are modelled with a class. The class inherits\n+fields from an array header struct specific to the array element type,\n+one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (the last one is for\n+object arrays). Inherited fields include the hub, array length, idHash\n+to round up the header size to a boundary suitable for the array\n+element type. The array class (layout) type includes only one field, a\n+C++ array of length zero whose element type is a primtiive type or\n+Java referece type.\n+\n+```\n+(gdb) ptype 'java.lang.String[]'\n+type = struct java.lang.String[] : public _arrhdrA {\n+    java.lang.String *data[0];\n+}\n+```\n+\n+Notice that the type of the values stored in the data array is\n+`java.lang.String *` i.e. the C++ array stores Java references\n+i.e. addresss as far as the C++ model is concerned.\n+\n+The array header structs are all extensions of the basic _objhdr type\n+which means that arrays and objects can both be safely cast to oops.\n+\n+```\n+(gdb) ptype _arrhdrA\n+type = struct _arrhdrA {\n+    java.lang.Class *hub;\n+    int len;\n+    int idHash;\n+}\n+```\n+\n+Interfaces layouts are modelled as union types whose members are the\n+layouts for all the classes which implement the interfacse.\n+\n+```\n+(gdb) ptype 'java.lang.CharSequence'\n+type = union _java.lang.CharSequence {\n+    _java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;\n+    _java.lang.StringBuffer _java.lang.StringBuffer;\n+    _java.lang.StringBuilder _java.lang.StringBuilder;\n+    _java.lang.String _java.lang.String;\n+    _java.nio.CharBuffer _java.nio.CharBuffer;\n+}\n+```\n+\n+Given a reference typed to an interface it can be resolved to the\n+relevant class type by viewing it through the relevant union element.\n+\n+If we take the first String in the args array we can ask gdb to cast\n+it to interface CharSequence\n+```\n+(gdb) print (('java.lang.String[]' *)$rdi)->data[0]\n+$6 = (java.lang.String) 0x7ffff7c01060\n+(gdb) print ('java.lang.CharSequence')$6\n+$7 = (java.lang.CharSequence) 0x7ffff7c01060\n+```\n+\n+The hubname command can be used to identify the actual type of the\n+object that implements this interface and that type name can be used\n+to select the union element used to print the object.\n+\n+```\n+(gdb) hubname $7\n+0x7d96d8:\t\"java.lang.String\\270\", <incomplete sequence \\344\\220>\n+(gdb) print $7->'_java.lang.String'\n+$18 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The current debug info model does not include the location info needed\n+to allow symbolic names for local vars and parameter vars to be\n+resolved to primitive values or object references. However, the\n+debugger does understand method names and static field names.\n+\n+The following command places a breakpoint on the main entry point for\n+class `Hello`. Note that since GDB thinks this is a C++ method it uses\n+the `::` separator to separate the method name from the class name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc5NTI0Mg==", "bodyText": "Yes, Java probably has too many dots for its own good :-) Other than that the syntax is perf... oh wait!", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562795242", "createdAt": "2021-01-22T17:39:42Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in\n+the hub field that may sometimes get set by the runtime during program operation.\n+\n+Attempting to print the hub name for an invalid reference will fail\n+safe, printing an error message.\n+\n+```\n+(gdb) p/x (_objhdr *)$rdx\n+$5 = 0x2\n+(gdb) hubname $rdx\n+Cannot access memory at address 0x2\n+```\n+\n+Array type layouts are modelled with a class. The class inherits\n+fields from an array header struct specific to the array element type,\n+one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (the last one is for\n+object arrays). Inherited fields include the hub, array length, idHash\n+to round up the header size to a boundary suitable for the array\n+element type. The array class (layout) type includes only one field, a\n+C++ array of length zero whose element type is a primtiive type or\n+Java referece type.\n+\n+```\n+(gdb) ptype 'java.lang.String[]'\n+type = struct java.lang.String[] : public _arrhdrA {\n+    java.lang.String *data[0];\n+}\n+```\n+\n+Notice that the type of the values stored in the data array is\n+`java.lang.String *` i.e. the C++ array stores Java references\n+i.e. addresss as far as the C++ model is concerned.\n+\n+The array header structs are all extensions of the basic _objhdr type\n+which means that arrays and objects can both be safely cast to oops.\n+\n+```\n+(gdb) ptype _arrhdrA\n+type = struct _arrhdrA {\n+    java.lang.Class *hub;\n+    int len;\n+    int idHash;\n+}\n+```\n+\n+Interfaces layouts are modelled as union types whose members are the\n+layouts for all the classes which implement the interfacse.\n+\n+```\n+(gdb) ptype 'java.lang.CharSequence'\n+type = union _java.lang.CharSequence {\n+    _java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;\n+    _java.lang.StringBuffer _java.lang.StringBuffer;\n+    _java.lang.StringBuilder _java.lang.StringBuilder;\n+    _java.lang.String _java.lang.String;\n+    _java.nio.CharBuffer _java.nio.CharBuffer;\n+}\n+```\n+\n+Given a reference typed to an interface it can be resolved to the\n+relevant class type by viewing it through the relevant union element.\n+\n+If we take the first String in the args array we can ask gdb to cast\n+it to interface CharSequence\n+```\n+(gdb) print (('java.lang.String[]' *)$rdi)->data[0]\n+$6 = (java.lang.String) 0x7ffff7c01060\n+(gdb) print ('java.lang.CharSequence')$6\n+$7 = (java.lang.CharSequence) 0x7ffff7c01060\n+```\n+\n+The hubname command can be used to identify the actual type of the\n+object that implements this interface and that type name can be used\n+to select the union element used to print the object.\n+\n+```\n+(gdb) hubname $7\n+0x7d96d8:\t\"java.lang.String\\270\", <incomplete sequence \\344\\220>\n+(gdb) print $7->'_java.lang.String'\n+$18 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The current debug info model does not include the location info needed\n+to allow symbolic names for local vars and parameter vars to be\n+resolved to primitive values or object references. However, the\n+debugger does understand method names and static field names.\n+\n+The following command places a breakpoint on the main entry point for\n+class `Hello`. Note that since GDB thinks this is a C++ method it uses\n+the `::` separator to separate the method name from the class name.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwMTA4MA=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0Mjg2NzA4OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMjozODowMFrOIYikoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzo0MToxNFrOIYuWhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwMzE2OQ==", "bodyText": "Impressive!", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562603169", "createdAt": "2021-01-22T12:38:00Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in\n+the hub field that may sometimes get set by the runtime during program operation.\n+\n+Attempting to print the hub name for an invalid reference will fail\n+safe, printing an error message.\n+\n+```\n+(gdb) p/x (_objhdr *)$rdx\n+$5 = 0x2\n+(gdb) hubname $rdx\n+Cannot access memory at address 0x2\n+```\n+\n+Array type layouts are modelled with a class. The class inherits\n+fields from an array header struct specific to the array element type,\n+one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (the last one is for\n+object arrays). Inherited fields include the hub, array length, idHash\n+to round up the header size to a boundary suitable for the array\n+element type. The array class (layout) type includes only one field, a\n+C++ array of length zero whose element type is a primtiive type or\n+Java referece type.\n+\n+```\n+(gdb) ptype 'java.lang.String[]'\n+type = struct java.lang.String[] : public _arrhdrA {\n+    java.lang.String *data[0];\n+}\n+```\n+\n+Notice that the type of the values stored in the data array is\n+`java.lang.String *` i.e. the C++ array stores Java references\n+i.e. addresss as far as the C++ model is concerned.\n+\n+The array header structs are all extensions of the basic _objhdr type\n+which means that arrays and objects can both be safely cast to oops.\n+\n+```\n+(gdb) ptype _arrhdrA\n+type = struct _arrhdrA {\n+    java.lang.Class *hub;\n+    int len;\n+    int idHash;\n+}\n+```\n+\n+Interfaces layouts are modelled as union types whose members are the\n+layouts for all the classes which implement the interfacse.\n+\n+```\n+(gdb) ptype 'java.lang.CharSequence'\n+type = union _java.lang.CharSequence {\n+    _java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;\n+    _java.lang.StringBuffer _java.lang.StringBuffer;\n+    _java.lang.StringBuilder _java.lang.StringBuilder;\n+    _java.lang.String _java.lang.String;\n+    _java.nio.CharBuffer _java.nio.CharBuffer;\n+}\n+```\n+\n+Given a reference typed to an interface it can be resolved to the\n+relevant class type by viewing it through the relevant union element.\n+\n+If we take the first String in the args array we can ask gdb to cast\n+it to interface CharSequence\n+```\n+(gdb) print (('java.lang.String[]' *)$rdi)->data[0]\n+$6 = (java.lang.String) 0x7ffff7c01060\n+(gdb) print ('java.lang.CharSequence')$6\n+$7 = (java.lang.CharSequence) 0x7ffff7c01060\n+```\n+\n+The hubname command can be used to identify the actual type of the\n+object that implements this interface and that type name can be used\n+to select the union element used to print the object.\n+\n+```\n+(gdb) hubname $7\n+0x7d96d8:\t\"java.lang.String\\270\", <incomplete sequence \\344\\220>\n+(gdb) print $7->'_java.lang.String'\n+$18 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The current debug info model does not include the location info needed\n+to allow symbolic names for local vars and parameter vars to be\n+resolved to primitive values or object references. However, the\n+debugger does understand method names and static field names.\n+\n+The following command places a breakpoint on the main entry point for\n+class `Hello`. Note that since GDB thinks this is a C++ method it uses\n+the `::` separator to separate the method name from the class name.\n+\n+```\n+(gdb) info func ::main\n+All functions matching regular expression \"::main\":\n+\n+File Hello.java:\n+\tvoid Hello::main(java.lang.String[] *);\n+(gdb) x/4i Hello::main\n+=> 0x4065a0 <Hello::main(java.lang.String[] *)>:\tsub    $0x8,%rsp\n+   0x4065a4 <Hello::main(java.lang.String[] *)+4>:\tcmp    0x8(%r15),%rsp\n+   0x4065a8 <Hello::main(java.lang.String[] *)+8>:\tjbe    0x4065fd <Hello::main(java.lang.String[] *)+93>\n+   0x4065ae <Hello::main(java.lang.String[] *)+14>:\tcallq  0x406050 <Hello$Greeter::greeter(java.lang.String[] *)>\n+(gdb) b Hello::main\n+Breakpoint 1 at 0x4065a0: file Hello.java, line 43.\n+```\n+\n+ An example of a static field containing Object data is provided by\n+ the static field `powerCache` in class `BigInteger`\n+\n+```\n+(gdb) ptype 'java.math.BigInteger'\n+type = class _java.math.BigInteger : public _java.lang.Number {\n+  public:\n+    int [] mag;\n+    int signum;\n+  private:\n+    int bitLengthPlusOne;\n+    int lowestSetBitPlusTwo;\n+    int firstNonzeroIntNumPlusTwo;\n+    static java.math.BigInteger[][] powerCache;\n+    . . .\n+  public:\n+    void BigInteger(byte [] *);\n+    void BigInteger(java.lang.String *, int);\n+    . . .    \n+}\n+(gdb) info var powerCache\n+All variables matching regular expression \"powerCache\":\n+\n+File java/math/BigInteger.java:\n+\tjava.math.BigInteger[][] *java.math.BigInteger::powerCache;\n+```\n+\n+The static variable name can be used to refer to the value stored in\n+this field. Note also that the address operator can be used identify\n+the location (address) of the field in the heap.\n+\n+```\n+(gdb) p '_java.math.BigInteger'::powerCache\n+$9 = (java.math.BigInteger[][] *) 0xa6fd98\n+(gdb) p &'java.math.BigInteger'::powerCache\n+$10 = (java.math.BigInteger[][] **) 0xa6fbd8\n+```\n+\n+gdb dereferences through symbolic names for static fields to access\n+the primitive value or object stored in the field\n+\n+```\n+(gdb) p *'java.math.BigInteger'::powerCache\n+$11 = {\n+  <_arrhdrA> = {\n+    hub = 0x9ab3d0,\n+    len = 37,\n+    idHash = 489620191\n+  },\n+  members of _java.math.BigInteger[][]:\n+  data = 0xa6fda8\n+}\n+(gdb) p 'java.math.BigInteger'::powerCache->data[0]@4\n+$12 = {0x0, 0x0, 0xc09378, 0xc09360}\n+(gdb) p *'java.math.BigInteger'::powerCache->data[2]\n+$13 = {\n+  <_arrhdrA> = {\n+    hub = 0x919898,\n+    len = 1,\n+    idHash = 1796421813\n+  },\n+  members of java.math.BigInteger[]:\n+  data = 0xc09388\n+}\n+(gdb) p *'java.math.BigInteger'::powerCache->data[2]->data[0]\n+$14 = {\n+  <java.lang.Number> = {\n+    <java.lang.Object> = {\n+      <_objhdr> = {\n+        hub = 0x919bc8\n+      }, <No data fields>}, <No data fields>}, \n+  members of java.math.BigInteger:\n+  mag = 0xa5b030,\n+  signum = 1,\n+  bitLengthPlusOne = 0,\n+  lowestSetBitPlusTwo = 0,\n+  firstNonzeroIntNumPlusTwo = 0\n+}\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 452}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc5NjE2Nw==", "bodyText": "Thank you :-)", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562796167", "createdAt": "2021-01-22T17:41:14Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -90,12 +165,346 @@ The currently implemented features include:\n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Special considerations for debugging Java from GDB\n+\n+GDB does not currently include support for debugging of Java programs.\n+In consequence, debug capability has been implemented by generating debug\n+info that models the Java program as an equivalent C++ program. Java\n+class, array and interface references are actually pointers to records\n+that contain the relevant field/array data. In the corresponding C++\n+model the Java name is used to label the underlying C++ (class/struct)\n+layout types and Java references appear as pointers.\n+\n+So, for example in the DWARF debug info model `java.lang.String`\n+identifies a C++ class. This class layout type declares the expected\n+fields like `hash` of type `int` and `value` of type `byte[]` and\n+methods like `String(byte[])`, `charAt(int)`, etc. However, the copy\n+constructor which appears in Java as `String(String)` appears in gdb\n+with the signature `String(java.lang.String *)`.\n+\n+The C++ layout class inherits fields and methods from class (layout)\n+type java.lang.Object using C++ public inheritance. The latter in turn\n+inherits standard oop header fields from a special struct class named\n+_objhdr which includes a single field caled `hub` whose type is\n+`java.lang.Class *` i.e. it is a pointer to the obejct's class.\n+\n+The ptype command can be used to print details of a specific type. Note\n+that the java type name must be specified in quotes because to escape the\n+embedded `.` characters.\n+\n+```\n+(gdb) ptype 'java.lang.String'\n+type = class java.lang.String : public java.lang.Object {\n+  private:\n+    byte [] *value;\n+    int hash;\n+    byte coder;\n+\n+  public:\n+    void String(byte [] *);\n+    void String(char [] *);\n+    void String(byte [] *, java.lang.String *);\n+    . . .\n+    char charAt(int);\n+    . . .\n+    java.lang.String * concat(java.lang.String *);\n+    . . .\n+}\n+```\n+\n+The print command can be used to print the contents of a referenced object\n+field by field. Note how a cast is used to convert a raw memory address to\n+a reference for a specific Java type.\n+\n+```\n+(gdb) print *('java.lang.String' *) 0x7ffff7c01060\n+$1 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The hub field in the object header is actually a reference of Java type\n+`java.lang.Class`. Note that the field is typed by gdb using a pointer\n+to the underlying C++ class (layout) type.\n+\n+```\n+(gdb) ptype _objhdr\n+type = struct _objhdr {\n+    java.lang.Class *hub;\n+}\n+```\n+\n+Given an address that might be an object reference it is possible to\n+verify that case and identify the object's type by printing the\n+contents of the String referenced from the hub's name field.  First\n+the value is cast to an object reference. Then a path expression is\n+used to dereference through the the hub field and the hub's name field\n+to the `byte[]` value array located in the name String.\n+\n+```\n+(gdb) print/x ((_objhdr *)$rdi)\n+$2 = 0x7ffff7c01028\n+(gdb) print *$2->hub->name->value\n+$3 = {\n+  <_arrhdrB> = {\n+    hub = 0x90e4b8,\n+    len = 19,\n+    idHash = 3759493\n+  }, \n+  members of byte []:\n+  data = 0x904798 \"[Ljava.lang.String;\"\n+}\n+```\n+\n+The value in register rdx is obviously a reference to a String array.\n+Casting it to this type shows it has length 1.\n+\n+```\n+(gdb) print *('java.lang.String[]' *)$rdi\n+$4 = {\n+  <_arrhdrA> = {\n+    hub = 0x906a78,\n+    len = 2,\n+    idHash = 0\n+  }, \n+  members of java.lang.String[]:\n+  data = 0x7ffff7c01038\n+}\n+```\n+\n+A simpler command which allows just the name of the hub object to be\n+printed is as follows:\n+\n+```\n+(gdb) x/s $2->hub->name->value->data\n+798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Indeed it is useful to define a gdb command `hubname` to execute this\n+operation on an arbitrary input argument\n+\n+```\n+command hubname\n+  x/s (('java.lang.Class' *)((long)((('java.lang.Object' *)($arg0))->hub) & ~0x7L))->name->value->data\n+end\n+\n+(gdb) hubname $2\n+0x904798:\t\"[Ljava.lang.String;\"\n+```\n+\n+Notice that the `hubname` command also masks out the low 3 flag bits in\n+the hub field that may sometimes get set by the runtime during program operation.\n+\n+Attempting to print the hub name for an invalid reference will fail\n+safe, printing an error message.\n+\n+```\n+(gdb) p/x (_objhdr *)$rdx\n+$5 = 0x2\n+(gdb) hubname $rdx\n+Cannot access memory at address 0x2\n+```\n+\n+Array type layouts are modelled with a class. The class inherits\n+fields from an array header struct specific to the array element type,\n+one of _arrhdrZ _arrhdrB, _arrhdrS, ... _arrhdrA (the last one is for\n+object arrays). Inherited fields include the hub, array length, idHash\n+to round up the header size to a boundary suitable for the array\n+element type. The array class (layout) type includes only one field, a\n+C++ array of length zero whose element type is a primtiive type or\n+Java referece type.\n+\n+```\n+(gdb) ptype 'java.lang.String[]'\n+type = struct java.lang.String[] : public _arrhdrA {\n+    java.lang.String *data[0];\n+}\n+```\n+\n+Notice that the type of the values stored in the data array is\n+`java.lang.String *` i.e. the C++ array stores Java references\n+i.e. addresss as far as the C++ model is concerned.\n+\n+The array header structs are all extensions of the basic _objhdr type\n+which means that arrays and objects can both be safely cast to oops.\n+\n+```\n+(gdb) ptype _arrhdrA\n+type = struct _arrhdrA {\n+    java.lang.Class *hub;\n+    int len;\n+    int idHash;\n+}\n+```\n+\n+Interfaces layouts are modelled as union types whose members are the\n+layouts for all the classes which implement the interfacse.\n+\n+```\n+(gdb) ptype 'java.lang.CharSequence'\n+type = union _java.lang.CharSequence {\n+    _java.lang.AbstractStringBuilder _java.lang.AbstractStringBuilder;\n+    _java.lang.StringBuffer _java.lang.StringBuffer;\n+    _java.lang.StringBuilder _java.lang.StringBuilder;\n+    _java.lang.String _java.lang.String;\n+    _java.nio.CharBuffer _java.nio.CharBuffer;\n+}\n+```\n+\n+Given a reference typed to an interface it can be resolved to the\n+relevant class type by viewing it through the relevant union element.\n+\n+If we take the first String in the args array we can ask gdb to cast\n+it to interface CharSequence\n+```\n+(gdb) print (('java.lang.String[]' *)$rdi)->data[0]\n+$6 = (java.lang.String) 0x7ffff7c01060\n+(gdb) print ('java.lang.CharSequence')$6\n+$7 = (java.lang.CharSequence) 0x7ffff7c01060\n+```\n+\n+The hubname command can be used to identify the actual type of the\n+object that implements this interface and that type name can be used\n+to select the union element used to print the object.\n+\n+```\n+(gdb) hubname $7\n+0x7d96d8:\t\"java.lang.String\\270\", <incomplete sequence \\344\\220>\n+(gdb) print $7->'_java.lang.String'\n+$18 = {\n+  <java.lang.Object> = {\n+    <_objhdr> = {\n+      hub = 0x90cb58\n+    }, <No data fields>}, \n+  members of java.lang.String:\n+  value = 0x7ffff7c011a0,\n+  hash = 0,\n+  coder = 0 '\\000'\n+}\n+```\n+\n+The current debug info model does not include the location info needed\n+to allow symbolic names for local vars and parameter vars to be\n+resolved to primitive values or object references. However, the\n+debugger does understand method names and static field names.\n+\n+The following command places a breakpoint on the main entry point for\n+class `Hello`. Note that since GDB thinks this is a C++ method it uses\n+the `::` separator to separate the method name from the class name.\n+\n+```\n+(gdb) info func ::main\n+All functions matching regular expression \"::main\":\n+\n+File Hello.java:\n+\tvoid Hello::main(java.lang.String[] *);\n+(gdb) x/4i Hello::main\n+=> 0x4065a0 <Hello::main(java.lang.String[] *)>:\tsub    $0x8,%rsp\n+   0x4065a4 <Hello::main(java.lang.String[] *)+4>:\tcmp    0x8(%r15),%rsp\n+   0x4065a8 <Hello::main(java.lang.String[] *)+8>:\tjbe    0x4065fd <Hello::main(java.lang.String[] *)+93>\n+   0x4065ae <Hello::main(java.lang.String[] *)+14>:\tcallq  0x406050 <Hello$Greeter::greeter(java.lang.String[] *)>\n+(gdb) b Hello::main\n+Breakpoint 1 at 0x4065a0: file Hello.java, line 43.\n+```\n+\n+ An example of a static field containing Object data is provided by\n+ the static field `powerCache` in class `BigInteger`\n+\n+```\n+(gdb) ptype 'java.math.BigInteger'\n+type = class _java.math.BigInteger : public _java.lang.Number {\n+  public:\n+    int [] mag;\n+    int signum;\n+  private:\n+    int bitLengthPlusOne;\n+    int lowestSetBitPlusTwo;\n+    int firstNonzeroIntNumPlusTwo;\n+    static java.math.BigInteger[][] powerCache;\n+    . . .\n+  public:\n+    void BigInteger(byte [] *);\n+    void BigInteger(java.lang.String *, int);\n+    . . .    \n+}\n+(gdb) info var powerCache\n+All variables matching regular expression \"powerCache\":\n+\n+File java/math/BigInteger.java:\n+\tjava.math.BigInteger[][] *java.math.BigInteger::powerCache;\n+```\n+\n+The static variable name can be used to refer to the value stored in\n+this field. Note also that the address operator can be used identify\n+the location (address) of the field in the heap.\n+\n+```\n+(gdb) p '_java.math.BigInteger'::powerCache\n+$9 = (java.math.BigInteger[][] *) 0xa6fd98\n+(gdb) p &'java.math.BigInteger'::powerCache\n+$10 = (java.math.BigInteger[][] **) 0xa6fbd8\n+```\n+\n+gdb dereferences through symbolic names for static fields to access\n+the primitive value or object stored in the field\n+\n+```\n+(gdb) p *'java.math.BigInteger'::powerCache\n+$11 = {\n+  <_arrhdrA> = {\n+    hub = 0x9ab3d0,\n+    len = 37,\n+    idHash = 489620191\n+  },\n+  members of _java.math.BigInteger[][]:\n+  data = 0xa6fda8\n+}\n+(gdb) p 'java.math.BigInteger'::powerCache->data[0]@4\n+$12 = {0x0, 0x0, 0xc09378, 0xc09360}\n+(gdb) p *'java.math.BigInteger'::powerCache->data[2]\n+$13 = {\n+  <_arrhdrA> = {\n+    hub = 0x919898,\n+    len = 1,\n+    idHash = 1796421813\n+  },\n+  members of java.math.BigInteger[]:\n+  data = 0xc09388\n+}\n+(gdb) p *'java.math.BigInteger'::powerCache->data[2]->data[0]\n+$14 = {\n+  <java.lang.Number> = {\n+    <java.lang.Object> = {\n+      <_objhdr> = {\n+        hub = 0x919bc8\n+      }, <No data fields>}, <No data fields>}, \n+  members of java.math.BigInteger:\n+  mag = 0xa5b030,\n+  signum = 1,\n+  bitLengthPlusOne = 0,\n+  lowestSetBitPlusTwo = 0,\n+  firstNonzeroIntNumPlusTwo = 0\n+}\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwMzE2OQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 452}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MjkzODg5OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMjo1OToxMFrOIYjPSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxMjowODozMFrOIZj9Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNDA4OQ==", "bodyText": "// comments should be avoided. mx eclipseformat can behave badly when code gets refactored that uses // comments. Use /* my single line comment */ instead.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562614089", "createdAt": "2021-01-22T12:59:10Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -149,45 +304,594 @@ public Path filePath() {\n         public Path cachePath() {\n             return cachePath;\n         }\n+    }\n+\n+    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n+        protected final HostedType hostedType;\n+\n+        @SuppressWarnings(\"try\")\n+        protected NativeImageDebugTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+            this.hostedType = hostedType;\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n+            return getJavaType(hostedType, true).toJavaName();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return toJavaName(hostedType);\n+        }\n+\n+        @Override\n+        public int size() {\n+            if (hostedType instanceof HostedInstanceClass) {\n+                // We know the actual instance size in bytes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3NDQ1NQ==", "bodyText": "Done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563674455", "createdAt": "2021-01-25T12:08:30Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -149,45 +304,594 @@ public Path filePath() {\n         public Path cachePath() {\n             return cachePath;\n         }\n+    }\n+\n+    private abstract class NativeImageDebugTypeInfo extends NativeImageDebugFileInfo implements DebugTypeInfo {\n+        protected final HostedType hostedType;\n+\n+        @SuppressWarnings(\"try\")\n+        protected NativeImageDebugTypeInfo(HostedType hostedType) {\n+            super(hostedType);\n+            this.hostedType = hostedType;\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        @Override\n+        public void debugContext(Consumer<DebugContext> action) {\n+            try (DebugContext.Scope s = debugContext.scope(\"DebugTypeInfo\", typeName())) {\n+                action.accept(debugContext);\n+            } catch (Throwable e) {\n+                throw debugContext.handle(e);\n+            }\n+        }\n+\n+        public String toJavaName(@SuppressWarnings(\"hiding\") HostedType hostedType) {\n+            return getJavaType(hostedType, true).toJavaName();\n+        }\n+\n+        @Override\n+        public String typeName() {\n+            return toJavaName(hostedType);\n+        }\n+\n+        @Override\n+        public int size() {\n+            if (hostedType instanceof HostedInstanceClass) {\n+                // We know the actual instance size in bytes.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNDA4OQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0Mjk2MTM0OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMzowNjowMlrOIYjcxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQwOTo1NDoxNlrOIZe3zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNzU0Mg==", "bodyText": "You could use:\n            while (targetMethod instanceof WrappedJavaMethod) {\n                targetMethod = ((WrappedJavaMethod) targetMethod).getWrapped();\n            }", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562617542", "createdAt": "2021-01-22T13:06:02Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -291,7 +1000,36 @@ public String className() {\n \n         @Override\n         public String methodName() {\n-            return method.format(\"%n\");\n+            ResolvedJavaMethod targetMethod = method;\n+            if (targetMethod instanceof HostedMethod) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 909}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzU5MTExOQ==", "bodyText": "Done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563591119", "createdAt": "2021-01-25T09:54:16Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -291,7 +1000,36 @@ public String className() {\n \n         @Override\n         public String methodName() {\n-            return method.format(\"%n\");\n+            ResolvedJavaMethod targetMethod = method;\n+            if (targetMethod instanceof HostedMethod) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYxNzU0Mg=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 909}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MzA1NjgwOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMzozMjoyN1rOIYkWow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxMjowMzo1MVrOIZjy_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjM1NQ==", "bodyText": "Start all those comments with uppercase", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562632355", "createdAt": "2021-01-22T13:32:27Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -118,37 +139,87 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n+        /*\n+         * track whether we need to use a heap base regsiter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MTgwNQ==", "bodyText": "Done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563671805", "createdAt": "2021-01-25T12:03:51Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -118,37 +139,87 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n+        /*\n+         * track whether we need to use a heap base regsiter", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjM1NQ=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MzA1ODQ1OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMzozMzowMVrOIYkXrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxMjowMzo1OVrOIZjzSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjYyMA==", "bodyText": "/* Create all the types */ + use the same format elsewhere below.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562632620", "createdAt": "2021-01-22T13:33:01Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -118,37 +139,87 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n+        /*\n+         * track whether we need to use a heap base regsiter\n+         */\n+        useHeapBase = debugInfoProvider.useHeapBase();\n+\n+        /*\n+         * save mask for low order flag bits\n+         */\n+        oopFlagBitsMask = debugInfoProvider.oopFlagBitsMask();\n+        // flag bits be bewteen 1 and 32 for us to emit as DW_OP_lit<n>\n+        assert oopFlagBitsMask > 0 && oopFlagBitsMask < 32;\n+        // mask must be contiguous from bit 0\n+        assert ((oopFlagBitsMask + 1) & oopFlagBitsMask) == 0;\n+\n+        /*\n+         * save amount we need to shift references by when loading from an object field\n+         */\n+        oopShiftBitCount = debugInfoProvider.oopShiftBitCount();\n+\n+        /*\n+         * save number of bytes in a reference field\n+         */\n+        oopReferenceByteCount = debugInfoProvider.oopReferenceByteCount();\n+\n         /*\n          * Ensure we have a null string in the string section.\n          */\n         stringTable.uniqueDebugString(\"\");\n \n+        // create all the types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MTg4MQ==", "bodyText": "Done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563671881", "createdAt": "2021-01-25T12:03:59Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -118,37 +139,87 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          * (DebugTypeInfo debugTypeInfo : typeInfoProvider) { install types }\n          */\n \n+        /*\n+         * track whether we need to use a heap base regsiter\n+         */\n+        useHeapBase = debugInfoProvider.useHeapBase();\n+\n+        /*\n+         * save mask for low order flag bits\n+         */\n+        oopFlagBitsMask = debugInfoProvider.oopFlagBitsMask();\n+        // flag bits be bewteen 1 and 32 for us to emit as DW_OP_lit<n>\n+        assert oopFlagBitsMask > 0 && oopFlagBitsMask < 32;\n+        // mask must be contiguous from bit 0\n+        assert ((oopFlagBitsMask + 1) & oopFlagBitsMask) == 0;\n+\n+        /*\n+         * save amount we need to shift references by when loading from an object field\n+         */\n+        oopShiftBitCount = debugInfoProvider.oopShiftBitCount();\n+\n+        /*\n+         * save number of bytes in a reference field\n+         */\n+        oopReferenceByteCount = debugInfoProvider.oopReferenceByteCount();\n+\n         /*\n          * Ensure we have a null string in the string section.\n          */\n         stringTable.uniqueDebugString(\"\");\n \n+        // create all the types", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYzMjYyMA=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MzEwODE5OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMzo0NTo0NVrOIYk01w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxMDoyMTowOFrOIZf_Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0MDA4Nw==", "bodyText": "I'd much prefer if the code below uses e.g. DwarfDebugInfo.DW_ABBREV_CODE_field_declaration1 instead of DW_ABBREV_CODE_field_declaration1 so that we do not need all these static imports.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562640087", "createdAt": "2021-01-22T13:45:45Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -26,27 +26,99 @@\n \n package com.oracle.objectfile.elf.dwarf;\n \n+import com.oracle.objectfile.BuildDependency;\n import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ArrayTypeEntry;\n import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.FieldEntry;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.HeaderTypeEntry;\n+import com.oracle.objectfile.debugentry.InterfaceClassEntry;\n import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.PrimitiveTypeEntry;\n import com.oracle.objectfile.debugentry.Range;\n+import com.oracle.objectfile.debugentry.StructureTypeEntry;\n+import com.oracle.objectfile.debugentry.TypeEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n import org.graalvm.compiler.debug.DebugContext;\n \n+import java.lang.reflect.Modifier;\n import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Set;\n \n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_1;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_2;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_subprogram;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_SECTION_NAME;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_INTEGRAL;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_NUMERIC;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_SIGNED;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_array_data_type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzYwOTQzOQ==", "bodyText": "Yes, that sounds like a better way to do it. I have actually applied the same transform to all the other files in this package that were using static imports.\nDone.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563609439", "createdAt": "2021-01-25T10:21:08Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -26,27 +26,99 @@\n \n package com.oracle.objectfile.elf.dwarf;\n \n+import com.oracle.objectfile.BuildDependency;\n import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ArrayTypeEntry;\n import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.debugentry.FieldEntry;\n+import com.oracle.objectfile.debugentry.FileEntry;\n+import com.oracle.objectfile.debugentry.HeaderTypeEntry;\n+import com.oracle.objectfile.debugentry.InterfaceClassEntry;\n import com.oracle.objectfile.debugentry.PrimaryEntry;\n+import com.oracle.objectfile.debugentry.PrimitiveTypeEntry;\n import com.oracle.objectfile.debugentry.Range;\n+import com.oracle.objectfile.debugentry.StructureTypeEntry;\n+import com.oracle.objectfile.debugentry.TypeEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n import org.graalvm.compiler.debug.DebugContext;\n \n+import java.lang.reflect.Modifier;\n import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Set;\n \n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_1;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_compile_unit_2;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_subprogram;\n-import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_SECTION_NAME;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_INTEGRAL;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_NUMERIC;\n+import static com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugPrimitiveTypeInfo.FLAG_SIGNED;\n+import static com.oracle.objectfile.elf.dwarf.DwarfDebugInfo.DW_ABBREV_CODE_array_data_type;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0MDA4Nw=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MzE0MDg1OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMzo1Mjo1OVrOIYlHkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMzo1Mjo1OVrOIYlHkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0NDg4MQ==", "bodyText": "Aha there it is!\nIf you also have such code why is the explicit & ~0x7L necessary in the example in DebugInfo.md?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562644881", "createdAt": "2021-01-22T13:52:59Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1221,93 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DW_ACCESS_private;\n+        } else {\n+            // package private -- make it public for now\n+            access = DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeOopRelocationExpression(byte[] buffer, int p) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 1308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MzIwMDQyOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNDowODoyNVrOIYlskA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxMjowNzoxMVrOIZj6LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY1NDM1Mg==", "bodyText": "Use the\n            /*-\n             *\n             *\n             */\n\nmethod, then eclipseformat will not reformat your comment content. (Note the - after /*)", "url": "https://github.com/oracle/graal/pull/3046#discussion_r562654352", "createdAt": "2021-01-22T14:08:25Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1221,93 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DW_ACCESS_private;\n+        } else {\n+            // package private -- make it public for now\n+            access = DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeOopRelocationExpression(byte[] buffer, int p) {\n+        int pos = p;\n+        if (dwarfSections.useHeapBase()) {\n+            // oop is 32 bit signed offset, possibly shifted by CompressEncoding.getShift()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 1311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzY3MzY0NQ==", "bodyText": "Yes, thanks for the tip.\nDone.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r563673645", "createdAt": "2021-01-25T12:07:11Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1221,93 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DW_ACCESS_private;\n+        } else {\n+            // package private -- make it public for now\n+            access = DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeOopRelocationExpression(byte[] buffer, int p) {\n+        int pos = p;\n+        if (dwarfSections.useHeapBase()) {\n+            // oop is 32 bit signed offset, possibly shifted by CompressEncoding.getShift()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY1NDM1Mg=="}, "originalCommit": {"oid": "17f20a05967e0b3d0ded6da7b31f66153bab3e8b"}, "originalPosition": 1311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMDE4NTk3OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQwOTo1MDoxMVrOIiNOlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxMTowNToxNVrOIjEFaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjczOTIyMQ==", "bodyText": "Now that we have all this info in the JavaDoc of com.oracle.svm.core.heap.ReferenceAccess please refer to it here instead of replicating.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572739221", "createdAt": "2021-02-09T09:50:11Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1326,207 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_private;\n+        } else {\n+            /* Actually package private -- make it public for now. */\n+            access = DwarfDebugInfo.DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeIndirectOopConversionExpression(boolean isHub, byte[] buffer, int p) {\n+        int pos = p;\n+        /*\n+         * The conversion rules are different depending on whether they apply to the hub class or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 1440}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzYzNzk5Mg==", "bodyText": "Done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573637992", "createdAt": "2021-02-10T11:05:15Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfInfoSectionImpl.java", "diffHunk": "@@ -326,10 +1326,207 @@ public int writeAttrString(String value, byte[] buffer, int p) {\n         }\n     }\n \n+    public int writeAttrAccessibility(int modifiers, byte[] buffer, int p) {\n+        byte access;\n+        if (Modifier.isPublic(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_public;\n+        } else if (Modifier.isProtected(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_protected;\n+        } else if (Modifier.isPrivate(modifiers)) {\n+            access = DwarfDebugInfo.DW_ACCESS_private;\n+        } else {\n+            /* Actually package private -- make it public for now. */\n+            access = DwarfDebugInfo.DW_ACCESS_public;\n+        }\n+        return writeAttrData1(access, buffer, p);\n+    }\n+\n+    public int writeIndirectOopConversionExpression(boolean isHub, byte[] buffer, int p) {\n+        int pos = p;\n+        /*\n+         * The conversion rules are different depending on whether they apply to the hub class or", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjczOTIyMQ=="}, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 1440}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMDI2NTAxOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxMDowNzowMVrOIiN94g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxMjozMzoxN1rOIjHTQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc1MTMzMA==", "bodyText": "Never store ImageSingletons in static fields.\nImageSingleton values are only valid for a single native-image compilation. If more than one image gets built within the same JVM instance the OBJECTLAYOUT value of the first build will be reused for the second build. In this particular instance you can replace the static field with a static method ...\nstatic ObjectLayout getObjectLayout() {\nreturn ConfigurationValues.getObjectLayout();\n}\n... if using ConfigurationValues.getObjectLayout() directly feels too verbose.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572751330", "createdAt": "2021-02-09T10:07:01Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -81,46 +160,126 @@\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return Stream.empty();\n+        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n     }\n \n-    /**\n-     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+    static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0MDAyNw==", "bodyText": "Done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573640027", "createdAt": "2021-02-10T11:08:10Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -81,46 +160,126 @@\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return Stream.empty();\n+        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n     }\n \n-    /**\n-     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+    static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc1MTMzMA=="}, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY5MDY4OQ==", "bodyText": "Hmm ... Did you forget to push the related commit/s ?", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573690689", "createdAt": "2021-02-10T12:33:17Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeImageDebugInfoProvider.java", "diffHunk": "@@ -81,46 +160,126 @@\n \n     @Override\n     public Stream<DebugDataInfo> dataInfoProvider() {\n-        return Stream.empty();\n+        return heap.getObjects().stream().filter(this::acceptObjectInfo).map(this::createDebugDataInfo);\n     }\n \n-    /**\n-     * Implementation of the DebugCodeInfo API interface that allows code info to be passed to an\n-     * ObjectFile when generation of debug info is enabled.\n+    static ObjectLayout OBJECTLAYOUT = ConfigurationValues.getObjectLayout();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc1MTMzMA=="}, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMDU0NjU3OnYy", "diffSide": "RIGHT", "path": "substratevm/DebugInfo.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxMTowODowN1rOIiQp_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxMTowOTowMVrOIjEPfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc5NTM4OA==", "bodyText": "s/boudn/bound", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572795388", "createdAt": "2021-02-09T11:08:07Z", "author": {"login": "olpaw"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,26 +80,401 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n-\n ## Currently Implemented Features\n \n The currently implemented features include:\n \n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Currently Missing Features\n+\n+  - reference by name to values boudn to parameter and local vars", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0MDU3NQ==", "bodyText": "Done", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573640575", "createdAt": "2021-02-10T11:09:01Z", "author": {"login": "adinn"}, "path": "substratevm/DebugInfo.md", "diffHunk": "@@ -76,26 +80,401 @@ created during population of the cache.\n Note that in all the examples above the `DebugInfoSourceSearchPath`\n options are actually redundant. In the first case, the classpath\n entries for _apps/hello/classes_ and _apps/greeter/classes_ will be used\n-to derive the default search roots `apps/hello/src` and\n+to derive the default search roots _apps/hello/src_ and\n _apps/greeter/src_. In the second case, the classpath entries for\n _apps/target/hello.jar_ and _apps/target/greeter.jar_ will be used to\n derive the default search roots _apps/target/hello-sources.jar_ and\n _apps/target/greeter-sources.jar_.\n \n-\n ## Currently Implemented Features\n \n The currently implemented features include:\n \n   - break points configured by file and line, or by method name\n   - single stepping by line including both into and over function calls\n   - stack backtraces (not including frames detailing inlined code)\n+  - printing of primitive values\n+  - structured (field by field) printing of Java objects\n+  - casting/printing objects at different levels of generality\n+  - access through object networks via path expressions\n+  - reference by name to methods and static field data\n \n Note that single stepping within a compiled method includes file and\n line number info for inlined code, including inlined GraalVM methods.\n So, GDB may switch files even though you are still in the same\n compiled method.\n \n+### Currently Missing Features\n+\n+  - reference by name to values boudn to parameter and local vars", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mjc5NTM4OA=="}, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMDYxMTU2OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxMToyNDoyNFrOIiRRiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxMToxNzo1MlrOIjEkwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNTUxMw==", "bodyText": "/* ... */", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572805513", "createdAt": "2021-02-09T11:24:24Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -280,9 +250,110 @@ public boolean includesDeoptTarget() {\n \n     public String getCachePath() {\n         if (fileEntry != null) {\n-            return fileEntry.getCachePath();\n-        } else {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n+    }\n+\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0NjAxNg==", "bodyText": "Done. The only remaining // comments are to exclude generation of speculative/currently unavailable field declarations for abbrev record in DwarfAbbrevSectionImpl.java. I really want to leave those as they are place-holders for possible future upgrades.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573646016", "createdAt": "2021-02-10T11:17:52Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/ClassEntry.java", "diffHunk": "@@ -280,9 +250,110 @@ public boolean includesDeoptTarget() {\n \n     public String getCachePath() {\n         if (fileEntry != null) {\n-            return fileEntry.getCachePath();\n-        } else {\n+            Path cachePath = fileEntry.getCachePath();\n+            if (cachePath != null) {\n+                return cachePath.toString();\n+            }\n+        }\n+        return \"\";\n+    }\n+\n+    private void processInterface(String interfaceName, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        debugContext.log(\"typename %s adding interface %s\\n\", typeName, interfaceName);\n+        ClassEntry entry = debugInfoBase.lookupClassEntry(TypeEntry.canonicalize(interfaceName));\n+        assert entry instanceof InterfaceClassEntry;\n+        InterfaceClassEntry interfaceClassEntry = (InterfaceClassEntry) entry;\n+        interfaces.add(interfaceClassEntry);\n+        interfaceClassEntry.addImplementor(this, debugContext);\n+    }\n+\n+    protected void processMethod(DebugMethodInfo debugMethodInfo, DebugInfoBase debugInfoBase, DebugContext debugContext) {\n+        String methodName = debugInfoBase.uniqueDebugString(debugMethodInfo.name());\n+        String resultTypeName = TypeEntry.canonicalize(debugMethodInfo.valueType());\n+        int modifiers = debugMethodInfo.modifiers();\n+        List<String> paramTypes = debugMethodInfo.paramTypes();\n+        List<String> paramNames = debugMethodInfo.paramNames();\n+        assert paramTypes.size() == paramNames.size();\n+        int paramCount = paramTypes.size();\n+        debugContext.log(\"typename %s adding %s method %s %s(%s)\\n\",\n+                        typeName, memberModifiers(modifiers), resultTypeName, methodName, formatParams(paramTypes, paramNames));\n+        TypeEntry resultType = debugInfoBase.lookupTypeEntry(resultTypeName);\n+        TypeEntry[] paramTypeArray = new TypeEntry[paramCount];\n+        String[] paramNameArray = new String[paramCount];\n+        int idx = 0;\n+        for (String paramTypeName : paramTypes) {\n+            TypeEntry paramType = debugInfoBase.lookupTypeEntry(TypeEntry.canonicalize(paramTypeName));\n+            paramTypeArray[idx++] = paramType;\n+        }\n+        paramNameArray = paramNames.toArray(paramNameArray);\n+        String fileName = debugMethodInfo.fileName();\n+        Path filePath = debugMethodInfo.filePath();\n+        Path cachePath = debugMethodInfo.cachePath();\n+        // n.b. the method file may differ from the owning class file when the method is a", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNTUxMw=="}, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 323}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzYxMDYxNTY4OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxMToyNTozMlrOIiRUJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxMToyMDo0OFrOIjEsFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNjE4MA==", "bodyText": "Sometimes your comments still start with lowercase ...", "url": "https://github.com/oracle/graal/pull/3046#discussion_r572806180", "createdAt": "2021-02-09T11:25:32Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -119,36 +160,95 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          */\n \n         /*\n-         * Ensure we have a null string in the string section.\n+         * track whether we need to use a heap base regsiter\n+         */\n+        useHeapBase = debugInfoProvider.useHeapBase();\n+\n+        /*\n+         * save count of low order tag bits that may appear in references\n          */\n+        int oopTagsMask = debugInfoProvider.oopTagsMask();\n+\n+        /* tag bits must be between 1 and 32 for us to emit as DW_OP_lit<n> */\n+        assert oopTagsMask > 0 && oopTagsMask < 32;\n+        /* mask must be contiguous from bit 0 */\n+        assert ((oopTagsMask + 1) & oopTagsMask) == 0;\n+\n+        oopTagsCount = Integer.bitCount(oopTagsMask);\n+\n+        /* Save amount we need to shift references by when loading from an object field. */\n+        oopCompressShift = debugInfoProvider.oopCompressShift();\n+\n+        /* shift bit count must be either 0 or 3 */\n+        assert (oopCompressShift == 0 || oopCompressShift == 3);\n+\n+        /* Save number of bytes in a reference field. */\n+        oopReferenceSize = debugInfoProvider.oopReferenceSize();\n+\n+        /* Save alignment of a reference */\n+        oopAlignment = debugInfoProvider.oopAlignment();\n+\n+        /* Save alignment of a reference */\n+        oopAlignShift = Integer.bitCount(oopAlignment - 1);\n+\n+        /* reference alignment must be 8 bytes */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzY0Nzg5NA==", "bodyText": "Yeah, sorry for that. I keep forgetting about this. I think I have found all such cases and corrected them.", "url": "https://github.com/oracle/graal/pull/3046#discussion_r573647894", "createdAt": "2021-02-10T11:20:48Z", "author": {"login": "adinn"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/DebugInfoBase.java", "diffHunk": "@@ -119,36 +160,95 @@ public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n          */\n \n         /*\n-         * Ensure we have a null string in the string section.\n+         * track whether we need to use a heap base regsiter\n+         */\n+        useHeapBase = debugInfoProvider.useHeapBase();\n+\n+        /*\n+         * save count of low order tag bits that may appear in references\n          */\n+        int oopTagsMask = debugInfoProvider.oopTagsMask();\n+\n+        /* tag bits must be between 1 and 32 for us to emit as DW_OP_lit<n> */\n+        assert oopTagsMask > 0 && oopTagsMask < 32;\n+        /* mask must be contiguous from bit 0 */\n+        assert ((oopTagsMask + 1) & oopTagsMask) == 0;\n+\n+        oopTagsCount = Integer.bitCount(oopTagsMask);\n+\n+        /* Save amount we need to shift references by when loading from an object field. */\n+        oopCompressShift = debugInfoProvider.oopCompressShift();\n+\n+        /* shift bit count must be either 0 or 3 */\n+        assert (oopCompressShift == 0 || oopCompressShift == 3);\n+\n+        /* Save number of bytes in a reference field. */\n+        oopReferenceSize = debugInfoProvider.oopReferenceSize();\n+\n+        /* Save alignment of a reference */\n+        oopAlignment = debugInfoProvider.oopAlignment();\n+\n+        /* Save alignment of a reference */\n+        oopAlignShift = Integer.bitCount(oopAlignment - 1);\n+\n+        /* reference alignment must be 8 bytes */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjgwNjE4MA=="}, "originalCommit": {"oid": "2ef088d7122ed0b7f654bbe07c219344d89cc599"}, "originalPosition": 109}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 736, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}