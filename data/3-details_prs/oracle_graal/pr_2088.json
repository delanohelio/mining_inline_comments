{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1Nzg3Mzc5", "number": 2088, "title": "Debug info prototype", "bodyText": "This PR is for an initial prototype for the native image debug info implementation. It is really intended for discussion rather than to be pulled into the main repo. However, it does actually implement support for gdb on Linux/x86_64 (see DEBUGINFO.md for details of how to generate and use debug info and what features are supported).\nThe patch contains 3 main commits of which the second is the actual code that generates the DWARF debug records. The first patch defines a set of Graal-neutral interfaces defining an API that allow the Native Image Generator to communicate the necessary details of compiled code to an object file. The third patch modifies the Native Image Generator to drive generation of debug info using that API.\nWork on a Windows implementation is progressing and should be able to rely on employing the same Graal-neutral interface API. AArch64 support still needs testing (it will probably require only a little bit of tweaking to get stack backtraces working).\nI'd be very grateful for feedback on all aspects of the implementation but clearly the most important things to look at form the point of view of the rest of the project are patches 1 and 3.\nn.b. the interface API includes place holders for notifying details of types and heap data elements to the debug generator. Fleshing out this API and implementing associated debug info generation is the next task in hand.", "createdAt": "2020-01-22T10:51:13Z", "url": "https://github.com/oracle/graal/pull/2088", "merged": true, "mergeCommit": {"oid": "2a2077a8095d72b1473965163ec9e94401716982"}, "closed": true, "closedAt": "2020-04-06T20:00:56Z", "author": {"login": "adinn"}, "timelineItems": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9HRSwAFqTM0NzE3MTM3OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVAy6TAFqTM4ODM4ODcxNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTcxMzc4", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-347171378", "createdAt": "2020-01-23T09:52:31Z", "commit": {"oid": "7138edc94f05596cf2d70d158f317cad5abb5178"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTo1MjozMlrOFg4S9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwOTo1MjozMlrOFg4S9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMTEwOA==", "bodyText": "Can you please convert all these C++ style comments to proper javadoc.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r370021108", "createdAt": "2020-01-23T09:52:32Z", "author": {"login": "dougxc"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.util.List;\n+\n+// class defining interfaces used to allow a native image", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7138edc94f05596cf2d70d158f317cad5abb5178"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDY4NDA5", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350068409", "createdAt": "2020-01-29T12:27:34Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjoyNzozNFrOFjGqdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjoyNzozNFrOFjGqdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1MzY1Mw==", "bodyText": "No point in assigning to an unused local. Just use newUserDefinedSection( ..... I know the names of these methods are stupid.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372353653", "createdAt": "2020-01-29T12:27:34Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java", "diffHunk": "@@ -1155,4 +1157,46 @@ public SymbolTable getSymbolTable() {\n     protected int getMinimumFileSize() {\n         return 0;\n     }\n+\n+    @Override\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        DwarfSections dwarfSections = new DwarfSections(getMachine());\n+        // we need an implementation for each section\n+        DwarfSections.DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n+        DwarfSections.DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n+        DwarfSections.DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n+        DwarfSections.DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n+        DwarfSections.DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n+        DwarfSections.DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n+        // now we can create the section elements with empty content\n+        @SuppressWarnings(\"unused\")\n+        ELFSection strSection = (ELFSection) newUserDefinedSection(elfStrSectionImpl.getSectionName(), elfStrSectionImpl);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDc0MDk3", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350074097", "createdAt": "2020-01-29T12:38:05Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozODowNlrOFjG7rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjozODowNlrOFjG7rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ==", "bodyText": "I did not see the code where your elf.darf entities get transformed into their binary representations. Do I miss something or is this simply not ready yet?", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372358061", "createdAt": "2020-01-29T12:38:06Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * details of a specific address range in a compiled method\n+ * either a primary range identifying a whole method\n+ * or a sub-range identifying a sequence of\n+ * instructions that belong to an inlined method\n+ */\n+\n+public class Range {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDc1MjA5", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350075209", "createdAt": "2020-01-29T12:40:12Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo0MDoxMlrOFjG-8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo0MDoxMlrOFjG-8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODg5Ng==", "bodyText": "We would want to have a hosted option. e.g GenerateDebugInfo that would ensure TrackNodeSourcePosition is enabled whenever GenerateDebugInfo > 0", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372358896", "createdAt": "2020-01-29T12:40:12Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -458,6 +473,12 @@ public void build(DebugContext debug, ImageHeapLayouter layouter) {\n             cGlobals.writeData(rwDataBuffer, (offset, symbolName) -> defineDataSymbol(symbolName, rwDataSection, offset + RWDATA_CGLOBALS_PARTITION_OFFSET));\n             defineDataSymbol(CGlobalDataInfo.CGLOBALDATA_BASE_SYMBOL_NAME, rwDataSection, RWDATA_CGLOBALS_PARTITION_OFFSET);\n \n+            // if we have constructed any debug info then\n+            // give the object file a chance to install it\n+            if (GraalOptions.TrackNodeSourcePosition.getValue(HostedOptionValues.singleton())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDg0OTky", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350084992", "createdAt": "2020-01-29T12:57:22Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo1NzoyMlrOFjHcJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMjo1NzoyMlrOFjHcJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2NjM3Mg==", "bodyText": "We have org.graalvm.compiler.debug.DebugContext for logging. See e.g. com.oracle.svm.hosted.ResourcesFeature#scanDirectory", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372366372", "createdAt": "2020-01-29T12:57:22Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 489}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDg5MTEy", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350089112", "createdAt": "2020-01-29T13:04:32Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzowNDozMlrOFjHo2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzowNDozMlrOFjHo2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2OTYyNQ==", "bodyText": "afaics you only ever add to this list without every using it afterwards", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372369625", "createdAt": "2020-01-29T13:04:32Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 232}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDkwNzc5", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350090779", "createdAt": "2020-01-29T13:07:35Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzowNzozNVrOFjHt0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzowNzozNVrOFjHt0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MDg5Nw==", "bodyText": "Maybe Charset.forName(\"US-ASCII\").newEncoder().canEncode ?", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372370897", "createdAt": "2020-01-29T13:07:35Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 582}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDkyNDkw", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350092490", "createdAt": "2020-01-29T13:10:31Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoxMDozMVrOFjHzNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoxMDozMVrOFjHzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MjI3OQ==", "bodyText": "CUDOs for documenting the binary representations. Please use\n/*\n * This style for code comments wherever possible.\n *\n */", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372372279", "createdAt": "2020-01-29T13:10:31Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 810}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDkzNzg2", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350093786", "createdAt": "2020-01-29T13:12:45Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoxMjo0NVrOFjH3Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoxMjo0NVrOFjH3Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MzI1NQ==", "bodyText": "This file would profit from getting partitioned into multiple source files.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372373255", "createdAt": "2020-01-29T13:12:45Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDk0OTE3", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350094917", "createdAt": "2020-01-29T13:14:38Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoxNDozOFrOFjH6RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoxNDozOFrOFjH6RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NDA4NA==", "bodyText": "Nah ... instead add HostedOption GenerateDebugInfo and whenever it is > 0 make sure TrackNodeSourcePosition gets set.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372374084", "createdAt": "2020-01-29T13:14:38Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,127 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+TrackNodeSourcePosition to the native image command line.\n+\n+  mx native-image -H:+TrackNodeSourcePosition Hello.java", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMDk5MzEx", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350099311", "createdAt": "2020-01-29T13:21:54Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyMTo1NFrOFjIH5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyMTo1NFrOFjIH5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NzU3NA==", "bodyText": "Instead of having a bash script that will get very complicated over time as part of building debuginfo produce a sources folder next to the binary (subdir of Path HostedOption) where you collect all the source files that the generated debuginfo refers to. This way the debugger only needs to know about a single source dir. Also keep in mind that in the Java ecosystem jar-files often have their corresponding zip or jar file that contain the sources. In Java its easy to aggregate all these files from source bundles into a single common directory location.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372377574", "createdAt": "2020-01-29T13:21:54Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,127 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+TrackNodeSourcePosition to the native image command line.\n+\n+  mx native-image -H:+TrackNodeSourcePosition Hello.java\n+\n+The resulting image should contain code (method) debug symbols.\n+\n+What is currently implemented\n+-----------------------------\n+\n+The currently implemented features include:\n+\n+  - break points configured by file and line or by method name\n+  - single stepping by line including both into and over function calls\n+  - stack backtraces (not including frames detailing inlined code)\n+\n+Note that single stepping within a compiled method includes file and\n+line number info for inlined code, including inlined Graal methods.\n+So, gdb may switch files even though you are still in the same\n+compiled method.\n+\n+Identifying the location of source code\n+---------------------------------------\n+\n+In order for gdb to be able to locate the source files for your app\n+methods, Graal methods and JDK runtime methods you need to provide gdb\n+with a list of source root dirs a 'set directories' command:\n+\n+    (gdb) set directories /home/adinn/hello/src:/home/adinn/graal/sdk/src/org/graalvm.word/src:/home/adinn/graal/sdk/src/org.graalvm.options/src:...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTAxMzMz", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350101333", "createdAt": "2020-01-29T13:25:12Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyNToxMlrOFjIN5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyNToxMlrOFjIN5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3OTEwOQ==", "bodyText": "dwarfdump is also nice for debugging/verification", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372379109", "createdAt": "2020-01-29T13:25:12Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,127 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+TrackNodeSourcePosition to the native image command line.\n+\n+  mx native-image -H:+TrackNodeSourcePosition Hello.java\n+\n+The resulting image should contain code (method) debug symbols.\n+\n+What is currently implemented\n+-----------------------------\n+\n+The currently implemented features include:\n+\n+  - break points configured by file and line or by method name\n+  - single stepping by line including both into and over function calls\n+  - stack backtraces (not including frames detailing inlined code)\n+\n+Note that single stepping within a compiled method includes file and\n+line number info for inlined code, including inlined Graal methods.\n+So, gdb may switch files even though you are still in the same\n+compiled method.\n+\n+Identifying the location of source code\n+---------------------------------------\n+\n+In order for gdb to be able to locate the source files for your app\n+methods, Graal methods and JDK runtime methods you need to provide gdb\n+with a list of source root dirs a 'set directories' command:\n+\n+    (gdb) set directories /home/adinn/hello/src:/home/adinn/graal/sdk/src/org/graalvm.word/src:/home/adinn/graal/sdk/src/org.graalvm.options/src:...\n+\n+The argument is a comma separated list of source roots. It needs to\n+identify:\n+\n+  - sources for your app\n+  - sources under the Graal sdk, compiler, substratevm and truffle trees\n+  - sources in the JDK src.zip file\n+\n+Needless to say the list for Graal is long and complex. Also, the JDK\n+sources are in a zip file and gdb does not understand zip sources. So\n+you need to extract the JDK sources as a preparatory step,\n+\n+You can use shell script write_gdbsourcepath (added to Graal dir\n+substratevm) to auto-generate settings for the GRaal and JDK sources.\n+\n+    $ bash write_gdbsourcepath\n+\n+It creates a local file .gdbsourcepath which sets the relevant\n+directories. Before running it you can set two env vars to tell it\n+where to locate the source trees it needs to include:\n+\n+  - GRAAL_JAVA_SRC_ROOT should point to the dir into which you have\n+  unzipped the src.zip from your Graal JDK release\n+  - GRAAL_SRC_ROOT should point to the dir in which your Graal git\n+  tree checkout is located\n+\n+Note that the script ignores test source dirs and jdk dirs that do not\n+match the release level of the JDK (i.e. if you use jdk8 it will ony\n+include jdk8 src dirs). The script runs the java command available via\n+JAVA_HOME to idenitfy which JDK is in use).\n+\n+If you run the script from the substratevm dir of your Graal git repo\n+checkout the script will default GRAAL_SRC_ROOT to the parent dir.\n+\n+If JAVA_HOME is set the script will default GRAAL_JAVA_SRC_ROOT to\n+$JAVA_HOME/src\n+\n+Checking debug info\n+-------------------\n+\n+The objdump command can be used to display the dbeug info embedded\n+into a native image. The following commands (which all assume the\n+target binary is called hello) can be used to display all currentyl\n+generated content:\n+\n+    $ objdump --dwarf=info hello > info", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTAzMTQ1", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350103145", "createdAt": "2020-01-29T13:28:01Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyODowMlrOFjITPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzoyODowMlrOFjITPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDQ3Ng==", "bodyText": "Why not use Path for path-like entities?", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372380476", "createdAt": "2020-01-29T13:28:02Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DirEntry.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * track the directory associated with one or\n+ * more source files.\n+ */\n+public class DirEntry {\n+    private String path;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTA0NzE1", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350104715", "createdAt": "2020-01-29T13:30:35Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozMDozNVrOFjIYEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozMDozNVrOFjIYEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg==", "bodyText": "Use Path here an you get Platform portability for free.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372381712", "createdAt": "2020-01-29T13:30:35Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 416}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTA2MjQ3", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350106247", "createdAt": "2020-01-29T13:32:56Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozMjo1NlrOFjIcvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozMjo1NlrOFjIcvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MjkxMA==", "bodyText": "Should be a static class. Others likely as well. Event better split out into several source files", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372382910", "createdAt": "2020-01-29T13:32:56Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 437}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTA4OTEw", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350108910", "createdAt": "2020-01-29T13:36:54Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozNjo1NFrOFjIkwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozNjo1NFrOFjIkwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NDk2MQ==", "bodyText": "That is the right place to switch from Path to String objects.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372384961", "createdAt": "2020-01-29T13:36:54Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+             ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 2225}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTA5NzMy", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350109732", "createdAt": "2020-01-29T13:38:12Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozODoxMlrOFjInXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozODoxMlrOFjInXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ==", "bodyText": "Strings ...", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372385631", "createdAt": "2020-01-29T13:38:12Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/FileEntry.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * track debug info associated with a Java source file.\n+ */\n+public class FileEntry {\n+    // the name of the associated file including path\n+    private String fileName;\n+    // the name of the associated file excluding path\n+    private String baseName;\n+    // the directory entry associated with this file entry\n+    DirEntry dirEntry;\n+\n+    public FileEntry(String fileName, String baseName, DirEntry dirEntry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTEwNTUx", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350110551", "createdAt": "2020-01-29T13:39:26Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozOToyNlrOFjIptw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzozOToyNlrOFjIptw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NjIzMQ==", "bodyText": "Always start JavaDoc with capital letter.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372386231", "createdAt": "2020-01-29T13:39:26Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/PrimaryEntry.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * track debug info associated with a primary method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTEzMzQ0", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350113344", "createdAt": "2020-01-29T13:43:27Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo0MzoyN1rOFjIyOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo0MzoyN1rOFjIyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4ODQwOA==", "bodyText": "afaics this is the only thing used atm, right?", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372388408", "createdAt": "2020-01-29T13:43:27Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTE1ODQw", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350115840", "createdAt": "2020-01-29T13:47:11Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo0NzoxMVrOFjI5pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxMzo0NzoxMVrOFjI5pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ==", "bodyText": "In Java 11 the module base-name is also part of the full file path with the src.zip. e.g.\nsrc.zip contains /java.base/java/util/Set.class", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372390309", "createdAt": "2020-01-29T13:47:11Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTM3NjI5", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350137629", "createdAt": "2020-01-29T14:17:29Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNDoxNzoyOVrOFjJ5tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNDoxNzoyOVrOFjJ5tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA==", "bodyText": "Sometimes the source file isn't actually a .java file.  Is there any way to get access to the source name that was specified in the original .class file?  Or is this code only used when there is no debug info available?", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372406708", "createdAt": "2020-01-29T14:17:29Z", "author": {"login": "dmlloyd"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();\n+            String name = declaringClass.getSourceFileName();\n+            if (name != null) {\n+                // the file name will not include any path\n+                // use the package to create a path prefix\n+                Package pkg = declaringClass.getJavaClass().getPackage();\n+                if (pkg != null) {\n+                    String prefix = pkg.getName();\n+                    prefix = prefix.replace('.', '/');\n+                    name = prefix + \"/\" + name;\n+                }\n+            } else {\n+                // build file name from the class name which includes the package\n+                name = className();\n+                // try to map inner classes back to their parent class's file\n+                int idx = name.indexOf('$');\n+                if (idx == 0) {\n+                    // name is $XXX so cannot associate with a file\n+                    return \"\";\n+                }\n+                if (idx > 0) {\n+                    // name is XXX$YYY so use outer class to derive file name\n+                    name = name.substring(0, idx);\n+                }\n+                name = name.replace('.', '/') + \".java\";\n+            }\n+            return name;\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public String paramNames() {\n+            return method.format(\"%P\");\n+        }\n+\n+        @Override\n+        public String returnTypeName() {\n+            return method.format(\"%R\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return method.getCodeAddressOffset();\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(0);\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n+            if (fileName().length() == 0) {\n+                return () -> new Iterator<DebugLineInfo>() {\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public DebugLineInfo next() {\n+                        return null;\n+                    }\n+                };\n+            }\n+            return () -> new Iterator<DebugLineInfo>() {\n+                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return sourceIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugLineInfo next() {\n+                    return new NativeImageDebugLineInfo(sourceIterator.next());\n+                }\n+            };\n+        }\n+\n+        public int getFrameSize() {\n+            return compilation.getTotalFrameSize();\n+        }\n+\n+        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n+            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n+            for (Mark mark : compilation.getMarks()) {\n+                // we only need to observe stack increment or decrement points\n+                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n+                    // can ignore these\n+                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n+                    // can ignore these\n+                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n+                }\n+            }\n+            return frameSizeChanges;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugLineInfo API interface\n+     * that allows line number info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugLineInfo implements DebugLineInfo {\n+        private final int bci;\n+        private final ResolvedJavaMethod method;\n+        private final int lo;\n+        private final int hi;\n+\n+        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n+            NodeSourcePosition position = sourceMapping.getSourcePosition();\n+            int bci = position.getBCI();\n+            this.bci = (bci >= 0 ? bci : 0);\n+            this.method = position.getMethod();\n+            this.lo = sourceMapping.getStartOffset();\n+            this.hi = sourceMapping.getEndOffset();\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            String name = className();\n+            int idx = name.indexOf('$');\n+            if (idx == 0) {\n+                // name is $XXX so cannot associate with a file\n+                return \"\";\n+            }\n+            if (idx > 0) {\n+                // name is XXX$YYY so use outer class to derive file name\n+                name = name.substring(0, idx);\n+            }\n+            return name.replace('.', '/') + \".java\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 303}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTY3MDAz", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350167003", "createdAt": "2020-01-29T14:54:03Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNDo1NDowM1rOFjLRkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNDo1NDowM1rOFjLRkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ==", "bodyText": "How about something more modern than Iterable. E.g. like:\n@Override\npublic Stream<DebugCodeInfo> codeInfoProvider() {\n    return compilations.entrySet().stream().map(NativeImageDebugCodeInfo::new);\n}", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372429201", "createdAt": "2020-01-29T14:54:03Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMTcxNTgw", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-350171580", "createdAt": "2020-01-29T14:59:28Z", "commit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNDo1OToyOFrOFjLfHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNDo1OToyOFrOFjLfHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA==", "bodyText": "Does DWARF have a fixed endianness, or should it be using the ELFDATA value to determine this?", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372432668", "createdAt": "2020-01-29T14:59:28Z", "author": {"login": "dmlloyd"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c884f8fdf3885c5aef077d2af031f4b763b57f"}, "originalPosition": 505}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTA5Nzc2", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-364909776", "createdAt": "2020-02-26T13:48:19Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzo0ODoyMFrOFusHXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDoyNTozM1rOFutfWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwMTU5OQ==", "bodyText": "s/pplication/Application", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384501599", "createdAt": "2020-02-26T13:48:20Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwMjMzMw==", "bodyText": "s/whcih/which", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384502333", "createdAt": "2020-02-26T13:49:32Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzY4Mg==", "bodyText": "Finally, the current directory in which the native image program is being run is also considered as a candidate.\n\nThat is (and should be) only true if -cp (or one of its variants) is not used as native-image argument. Our classpath-handling mirrors that of the java command in this regard:\nhttps://docs.oracle.com/javase/8/docs/technotes/tools/unix/classpath.html#A1100592\n...The default class path is the current directory. Setting the CLASSPATH variable or using the -classpath command-line option overrides that default...", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384507682", "createdAt": "2020-02-26T13:58:49Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the\n+native image program is being run is also considered as a candidate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxOTY2OA==", "bodyText": "That's cumbersome. Since you already have the infrastructure to copy sources from zip-files or directories for your automatic lookup strategy adding a hosted option (e.g. DebugInfoSourceSearchPath) that allows user to add additional lookup roots would be the most natural way to allow users to supplement source lookup.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384519668", "createdAt": "2020-02-26T14:18:26Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the\n+native image program is being run is also considered as a candidate.\n+\n+These lookup strategies are only provisional and may need extending in\n+future. Note however that it is possible to make missing sources\n+available by other means. One option is to unzip extra app source jars\n+or copying extra app source trees into the cache. Another is to\n+configure extra source search paths (see below).\n+\n+Configuring source paths in gdb\n+-------------------------------\n \n-    (gdb) set directories /home/adinn/hello/src:/home/adinn/graal/sdk/src/org/graalvm.word/src:/home/adinn/graal/sdk/src/org.graalvm.options/src:...\n-\n-The argument is a comma separated list of source roots. It needs to\n-identify:\n+In order for gdb to be able to locate the source files for your app\n+classes, Graal classes and JDK runtime classes you need to provide gdb\n+with a list of source root dirs using the 'set directories' command:\n \n-  - sources for your app\n-  - sources under the Graal sdk, compiler, substratevm and truffle trees\n-  - sources in the JDK src.zip file\n+    (gdb) set directories /path/to/sources/jdk:/path/to/sources/graal:/path/to/sources/src\n \n-Needless to say the list for Graal is long and complex. Also, the JDK\n-sources are in a zip file and gdb does not understand zip sources. So\n-you need to extract the JDK sources as a preparatory step,\n+Directory .../sources/jdk should contain source files for all JDK runtime\n+classes referenced from debug records.\n \n-You can use shell script write_gdbsourcepath (added to Graal dir\n-substratevm) to auto-generate settings for the GRaal and JDK sources.\n+Directory .../sources/graal should contain source files for all GraalVM\n+classes referenced from debug records. Note that the current\n+implementation does not yet find some sources for the GraalVM JIT\n+compiler in the org.graalvm.compiler* package subspace.\n \n-    $ bash write_gdbsourcepath\n+Directory .../sources/src should contain source files for all\n+application classes referenced from debug records, assuming they can\n+be located using the lookup strategy described above.\n \n-It creates a local file .gdbsourcepath which sets the relevant\n-directories. Before running it you can set two env vars to tell it\n-where to locate the source trees it needs to include:\n+You can supplement the files cached in sources/src by unzipping\n+application source jars or copying application source trees into the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyNDEyMA==", "bodyText": "typo: fomrat", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384524120", "createdAt": "2020-02-26T14:25:33Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the\n+native image program is being run is also considered as a candidate.\n+\n+These lookup strategies are only provisional and may need extending in\n+future. Note however that it is possible to make missing sources\n+available by other means. One option is to unzip extra app source jars\n+or copying extra app source trees into the cache. Another is to\n+configure extra source search paths (see below).\n+\n+Configuring source paths in gdb\n+-------------------------------\n \n-    (gdb) set directories /home/adinn/hello/src:/home/adinn/graal/sdk/src/org/graalvm.word/src:/home/adinn/graal/sdk/src/org.graalvm.options/src:...\n-\n-The argument is a comma separated list of source roots. It needs to\n-identify:\n+In order for gdb to be able to locate the source files for your app\n+classes, Graal classes and JDK runtime classes you need to provide gdb\n+with a list of source root dirs using the 'set directories' command:\n \n-  - sources for your app\n-  - sources under the Graal sdk, compiler, substratevm and truffle trees\n-  - sources in the JDK src.zip file\n+    (gdb) set directories /path/to/sources/jdk:/path/to/sources/graal:/path/to/sources/src\n \n-Needless to say the list for Graal is long and complex. Also, the JDK\n-sources are in a zip file and gdb does not understand zip sources. So\n-you need to extract the JDK sources as a preparatory step,\n+Directory .../sources/jdk should contain source files for all JDK runtime\n+classes referenced from debug records.\n \n-You can use shell script write_gdbsourcepath (added to Graal dir\n-substratevm) to auto-generate settings for the GRaal and JDK sources.\n+Directory .../sources/graal should contain source files for all GraalVM\n+classes referenced from debug records. Note that the current\n+implementation does not yet find some sources for the GraalVM JIT\n+compiler in the org.graalvm.compiler* package subspace.\n \n-    $ bash write_gdbsourcepath\n+Directory .../sources/src should contain source files for all\n+application classes referenced from debug records, assuming they can\n+be located using the lookup strategy described above.\n \n-It creates a local file .gdbsourcepath which sets the relevant\n-directories. Before running it you can set two env vars to tell it\n-where to locate the source trees it needs to include:\n+You can supplement the files cached in sources/src by unzipping\n+application source jars or copying application source trees into the\n+cache. You need to ensure that any new subdirectory you add to\n+sources/src corresponds to the top level package for the classes whose\n+sources are being included.\n \n-  - GRAAL_JAVA_SRC_ROOT should point to the dir into which you have\n-  unzipped the src.zip from your Graal JDK release\n-  - GRAAL_SRC_ROOT should point to the dir in which your Graal git\n-  tree checkout is located\n+You can also add extra directories to the search path. Note that gdb\n+does not understand zip fomrat file systems so any extra entries you", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 148}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTQ1NzQw", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-364945740", "createdAt": "2020-02-26T14:32:49Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDozMjo0OVrOFutx_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDozMjo0OVrOFutx_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyODg5Mw==", "bodyText": "Typo", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384528893", "createdAt": "2020-02-26T14:32:49Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringTable.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+/**\n+ * Allows incoming strings to be reduced to unique (up\n+ * to equals) instances and supports marking of strings\n+ * which need to be written to the debug_str section\n+ * and retrieval of the location offset after writing.\n+ */\n+public class StringTable implements Iterable<StringEntry> {\n+\n+    private final HashMap<String, StringEntry> table;\n+\n+    public StringTable() {\n+        this.table = new HashMap<>();\n+    }\n+\n+    /**\n+     * Wnsures a unique instance of a string exists in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTQ2NzIx", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-364946721", "createdAt": "2020-02-26T14:33:57Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDozMzo1N1rOFut0qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDozMzo1N1rOFut0qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyOTU3Nw==", "bodyText": "I still see many of these comments starting with lowercase letters", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384529577", "createdAt": "2020-02-26T14:33:57Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringEntry.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * Used to retain a unique (up to equals) copy of a\n+ * String. Also flag swhether the String needs to be\n+ * located in the debug_string section and, if so,\n+ * tracks the offset at which it gets written.\n+ */\n+public class StringEntry {\n+    private String string;\n+    private int offset;\n+    private boolean addToStrSection;\n+\n+    StringEntry(String string) {\n+        this.string = string;\n+        this.offset = -1;\n+    }\n+\n+    public String getString() {\n+        return string;\n+    }\n+\n+    public int getOffset() {\n+        /*\n+         * offset must be set before this can be fetched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTQ4MzQx", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-364948341", "createdAt": "2020-02-26T14:35:54Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDozNTo1NFrOFut5sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDozNTo1NFrOFut5sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzMDg2Ng==", "bodyText": "GenerateDebugInfo is HostedOptionKey<Integer> which does not support the -H:+GenerateDebugInfo syntax.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384530866", "createdAt": "2020-02-26T14:35:54Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,207 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+GenerateDebugInfo to the native image command line.\n+\n+    $ javac Hello.java\n+    $ mx native-image -H:+GenerateDebugInfo Hello", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTU2ODg3", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-364956887", "createdAt": "2020-02-26T14:45:42Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo0NTo0M1rOFuuS6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNDo0NTo0M1rOFuuS6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzNzMyMA==", "bodyText": "Windows support is still under development.\n\nIt would be useful to also see the development of the Windows support happening in this same repo.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384537320", "createdAt": "2020-02-26T14:45:43Z", "author": {"login": "olpaw"}, "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,207 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+GenerateDebugInfo to the native image command line.\n+\n+    $ javac Hello.java\n+    $ mx native-image -H:+GenerateDebugInfo Hello\n+\n+The resulting image should contain code (method) debug records in a\n+format gdb understands (VS support is still under development).\n+\n+The flag also enables caching of sources for JDK runtime classes,\n+GraalVM classes and application classes which can be located during\n+native image generation. The cache is created under local subdirectory\n+sources and can be used to configure source file search path roots for\n+the debugger. Files in the cache are located in a directory hierarchy\n+that matches the file path information included in the native image\n+debug records\n+\n+\n+What is currently implemented\n+-----------------------------\n+\n+The currently implemented features include:\n+\n+  - break points configured by file and line or by method name\n+  - single stepping by line including both into and over function calls\n+  - stack backtraces (not including frames detailing inlined code)\n+\n+Note that single stepping within a compiled method includes file and\n+line number info for inlined code, including inlined Graal methods.\n+So, gdb may switch files even though you are still in the same\n+compiled method.\n+\n+Identifying the location of source code\n+---------------------------------------\n+\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the\n+native image program is being run is also considered as a candidate.\n+\n+These lookup strategies are only provisional and may need extending in\n+future. Note however that it is possible to make missing sources\n+available by other means. One option is to unzip extra app source jars\n+or copying extra app source trees into the cache. Another is to\n+configure extra source search paths (see below).\n+\n+Configuring source paths in gdb\n+-------------------------------\n+\n+In order for gdb to be able to locate the source files for your app\n+classes, Graal classes and JDK runtime classes you need to provide gdb\n+with a list of source root dirs using the 'set directories' command:\n+\n+    (gdb) set directories /path/to/sources/jdk:/path/to/sources/graal:/path/to/sources/src\n+\n+Directory .../sources/jdk should contain source files for all JDK runtime\n+classes referenced from debug records.\n+\n+Directory .../sources/graal should contain source files for all GraalVM\n+classes referenced from debug records. Note that the current\n+implementation does not yet find some sources for the GraalVM JIT\n+compiler in the org.graalvm.compiler* package subspace.\n+\n+Directory .../sources/src should contain source files for all\n+application classes referenced from debug records, assuming they can\n+be located using the lookup strategy described above.\n+\n+You can supplement the files cached in sources/src by unzipping\n+application source jars or copying application source trees into the\n+cache. You need to ensure that any new subdirectory you add to\n+sources/src corresponds to the top level package for the classes whose\n+sources are being included.\n+\n+You can also add extra directories to the search path. Note that gdb\n+does not understand zip fomrat file systems so any extra entries you\n+add must identify a directory tree containing the relevant\n+sources. Once again. top leel entries in the directory added to the\n+search path must correspond to the top level package for the classes\n+whose sources are being included.\n+\n+Configuring source paths in VS\n+------------------------------\n+\n+TO BE ADDED\n+\n+Checking debug info on Linux\n+----------------------------\n+\n+n.b. this is only of interest to those who want to understand how the\n+debug info implemetation works or want to trouble shoot problems\n+encountered during debugging that might relate to the debug info\n+encoding.\n+\n+The objdump command can be used to display the dbeug info embedded\n+into a native image. The following commands (which all assume the\n+target binary is called hello) can be used to display all currentyl\n+generated content:\n+\n+    $ objdump --dwarf=info hello > info\n+    $ objdump --dwarf=abbrev hello > abbrev\n+    $ objdump --dwarf=ranges hello > ranges\n+    $ objdump --dwarf=decodedline hello > decodedline\n+    $ objdump --dwarf=rawline hello > rawline\n+    $ objdump --dwarf=str hello > str\n+    $ objdump --dwarf=frames hello > frames\n+\n+The *info* section includes details of all compiled Java methods.\n+\n+The *abbrev* sectio defines the layout of records in the info section\n+that describe Java files (compilation units) and methods.\n+\n+The *ranges* section details the start and end addresses of method\n+code segments\n+\n+The *decodedline* section maps subsegments of method code range\n+segments to files and line numbers. This mapping includes entries\n+for files and line numbers for inlined methods.\n+\n+The *rawline* segment provides deatails of how the line table is\n+generated using DWARF state machine instuctions that encode file,\n+line and address transitions.\n+\n+The *str* section provides a lookup table for strings referenced\n+from records in the info section\n+\n+The *frames* section lists transition points in compiled methods\n+where a (fixed size) stack frame is pushed or popped, allowing\n+the debugger to identify each frame's current and previous stack\n+pointers and it's return address.\n+\n+Note that some of the content embedded in the debug records is\n+generated by the C compiler and belongs to code that is either in\n+libraries or the C lib bootstrap code that is bundled in with the\n+Java method code.\n+\n+Currently supported targets\n+---------------------------\n+\n+The prototype is currently implemented only for gdb on Linux.\n+\n+  - Linux/x86_64 suppoort has been tested and should work\n+    correctly.\n+\n+  - Linux/AArch64 support is present but has not yet been fully\n+    verified (break points should work ok but stack backtraces\n+    may be incorrect).\n+\n+Windows support is still under development.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTc0Mjcy", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-364974272", "createdAt": "2020-02-26T15:05:11Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTowNToxMVrOFuvH8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTowNToxMVrOFuvH8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDg5OQ==", "bodyText": "dead code", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384550899", "createdAt": "2020-02-26T15:05:11Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 173}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTc0Mzc2", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-364974376", "createdAt": "2020-02-26T15:05:19Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTowNToxOVrOFuvIQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTowNToxOVrOFuvIQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDk3Nw==", "bodyText": "dead code", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384550977", "createdAt": "2020-02-26T15:05:19Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 179}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTc0NDg3", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-364974487", "createdAt": "2020-02-26T15:05:27Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTowNToyN1rOFuvIoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTowNToyN1rOFuvIoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MTA3Mg==", "bodyText": "dead code", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384551072", "createdAt": "2020-02-26T15:05:27Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 185}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTg4OTc2", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-364988976", "createdAt": "2020-02-26T15:21:52Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToyMTo1MlrOFuv1Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNToyMTo1MlrOFuv1Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA==", "bodyText": "How about\npublic enum SourceCacheType {\n    JDK(\"jdk\"),\n    GRAALVM(\"graal\"),\n    APPLICATION(\"src\");\n\n    final Path subdir;\n\n    SourceCacheType(String subdir) {\n        this.subdir = Paths.get(subdir);\n    }\n}\ninstead of those protected static final fields ?", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384562450", "createdAt": "2020-02-26T15:21:52Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {\n+\n+    /*\n+     * properties needed to locate relevant JDK and app source roots\n+     */\n+    protected static final String JAVA_CLASSPATH_PROP = \"java.class.path\";\n+    protected static final String JAVA_HOME_PROP = \"java.home\";\n+    protected static final String JAVA_SPEC_VERSION_PROP = \"java.specification.version\";\n+    /**\n+     * A list of root directories which may contain source files\n+     * from which this cache can be populated\n+     */\n+    protected List<Path> srcRoots;\n+\n+    /**\n+     * Create a source cache with a specific base type.\n+     * @param key a String identifying the subdir under\n+     * which sources should be cached which should also\n+     * match the type of content being cached\n+     */\n+    protected SourceCache(String key) {\n+        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR, key);\n+        srcRoots = new ArrayList<>();\n+\n+    }\n+\n+    /**\n+     * A local directory serving as the root for all\n+     * source trees maintained by the different\n+     * available source caches.\n+     */\n+    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n+    /**\n+     * The top level path relative to the root directory\n+     * under which files belonging to this specific cache\n+     * are located.\n+     */\n+    private Path basePath;\n+    /**\n+     * JDK runtime code sources are cached using this key as a\n+     * leading path prefix with a module name as a sub-path\n+     * prefix when we have a modular JDK.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be jdk/java/lang/Throwable.java on jdk8 or\n+     * jdk/java.base/java/lang/Throwable.java on jdk11\n+     */\n+    protected static final String JDK_CACHE_KEY = \"jdk\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDExMzk4", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-365011398", "createdAt": "2020-02-26T15:46:25Z", "commit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTo0NjoyNVrOFuw5-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNTo0NjoyNVrOFuw5-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MDA4OA==", "bodyText": "adding\nabstract SourceCacheType getType();\n\ncould probably be handy at some point.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384580088", "createdAt": "2020-02-26T15:46:25Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93dbfe57b94099877ef6a333795780f1897e3de8"}, "originalPosition": 50}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8a9a7b7a12816d5afdff0da0e42a7a9d1e2e2b9", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/c8a9a7b7a12816d5afdff0da0e42a7a9d1e2e2b9", "committedDate": "2020-03-10T11:21:12Z", "message": "more format changes and fix some small errors in graal cache"}, "afterCommit": {"oid": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "committedDate": "2020-03-10T14:47:11Z", "message": "more format changes and fix some small errors in graal cache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "68e5ed439bb1eb946528635cd0bbb9cb0d9d06fa", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/68e5ed439bb1eb946528635cd0bbb9cb0d9d06fa", "committedDate": "2020-03-17T14:50:56Z", "message": "support tracing of DWARF debug info modelling and generation to file using a debugContext provided via either the DebugInfoProvider API or via the ObjectFile"}, "afterCommit": {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "committedDate": "2020-03-17T15:13:14Z", "message": "support tracing of DWARF debug info modelling and generation to file using a debugContext provided via either the DebugInfoProvider API or via the ObjectFile"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3Nzg3ODgz", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-377787883", "createdAt": "2020-03-19T14:43:33Z", "commit": {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNDo0MzozM1rOF4xvGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNDo0MzozM1rOF4xvGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA==", "bodyText": "If the return value is not used anywhere use java.util.function.Consumer instead Function of to avoid pointless code such as\n    // doesn't actually matter what we return\n    return true;", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395079448", "createdAt": "2020-03-19T14:43:33Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java", "diffHunk": "@@ -1725,4 +1741,49 @@ public final SymbolTable getOrCreateSymbolTable() {\n             return createSymbolTable();\n         }\n     }\n+\n+    /**\n+     * Temporary storage for a debug context installed in a nested scope under a call.\n+     * to {@link #withDebugContext}\n+     */\n+    private DebugContext debugContext = null;\n+\n+    /**\n+     * Allows a function to be executed with a specific debug context in a named subscope bound to\n+     * the object file and accessible to code invoked during the lifetime of the function. Invoked\n+     * code may obtain access to the debug context using method {@link #debugContext}.\n+     * @param context a context to be bound toin the object file for the duration of the function\n+     *        execution.\n+     * @param scopeName a name to be used to define a subscope current while the function is being\n+     *        executed.\n+     * @param t a value to be injected into the function that performs the action.\n+     * @param function a function to be executed while the context is bound to the object file.\n+     */\n+    @SuppressWarnings(\"try\")\n+    public <T, R> R withDebugContext(DebugContext context,  String scopeName, T t, Function<T, R> function) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3ODEwOTk3", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-377810997", "createdAt": "2020-03-19T15:07:02Z", "commit": {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTowNzowM1rOF4y1qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTowNzowM1rOF4y1qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw==", "bodyText": "Since we will also have Windows debug info generation it might be better to use\nreturn \"debug.dwarf.\" + getSectionName();\n\nhere so that we can have\nreturn \"debug.pdb.\" + getSectionName();\n\nfor Windows.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395097513", "createdAt": "2020-03-19T15:07:03Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;\n+\n+    public DwarfSectionImpl(DwarfSections dwarfSections) {\n+        this.dwarfSections = dwarfSections;\n+    }\n+\n+    /**\n+     * creates the target byte[] array used to define the section contents.\n+     *\n+     * the main task of this method is to precompute the size of the debug section. given the\n+     * complexity of the data layouts that invariably requires performing a dummy write of the\n+     * contents, inserting bytes into a small, scratch buffer only when absolutely necessary.\n+     * subclasses may also cache some information for use when writing the contents.\n+     */\n+    public abstract void createContent();\n+\n+    /**\n+     * populates the byte[] array used to contain the section contents.\n+     *\n+     * in most cases this task reruns the operations performed under createContent but this time\n+     * actually writing data to the target byte[].\n+     */\n+    public abstract void writeContent(DebugContext debugContext);\n+\n+    @Override\n+    public boolean isLoadable() {\n+        /*\n+         * even though we're a progbits section impl we're not actually loadable\n+         */\n+        return false;\n+    }\n+\n+    public String debugSectionLogName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3ODM4NzI3", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-377838727", "createdAt": "2020-03-19T15:35:22Z", "commit": {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTozNToyM1rOF40JyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxNTozNToyM1rOF40JyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExOTA0OA==", "bodyText": "Is this a write-only field?", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395119048", "createdAt": "2020-03-19T15:35:23Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "faa1990076749dab51198a641850311309a643bc", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/faa1990076749dab51198a641850311309a643bc", "committedDate": "2020-03-20T11:38:46Z", "message": "use dwarf prefix +  section name as context key for messages generated at section write"}, "afterCommit": {"oid": "648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "committedDate": "2020-03-20T12:00:30Z", "message": "Checkstyle adjustments for copyright header"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7102ebc3e993fd2cf8a2623906a37cc2b499c8e3", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/7102ebc3e993fd2cf8a2623906a37cc2b499c8e3", "committedDate": "2020-03-20T13:17:07Z", "message": "avoid repeated dot in scope name"}, "afterCommit": {"oid": "536baf5fca1685afe4205fc2bca846568ab5043b", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/536baf5fca1685afe4205fc2bca846568ab5043b", "committedDate": "2020-03-20T16:16:57Z", "message": "avoid repeated dot in scope name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzOTExMzQ0", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-383911344", "createdAt": "2020-03-30T14:28:07Z", "commit": {"oid": "b17a12e2847085772f41ef3e9762d957865bcd05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNDoyODowN1rOF9sdyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNDoyODowN1rOF9sdyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzNTk3OA==", "bodyText": "@adinn, I think I already mentioned it, it's rather unusual in our codebase to start comments with lowercase.", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400235978", "createdAt": "2020-03-30T14:28:07Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debugentry;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * Details of a specific address range in a compiled method either a primary range identifying a\n+ * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n+ * method.\n+ */\n+\n+public class Range {\n+    private String fileName;\n+    private Path filePath;\n+    private String className;\n+    private String methodName;\n+    private String paramNames;\n+    private String returnTypeName;\n+    private String fullMethodName;\n+    private int lo;\n+    private int hi;\n+    private int line;\n+    /*\n+     * this is null for a primary range", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b17a12e2847085772f41ef3e9762d957865bcd05"}, "originalPosition": 50}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa343bc6e54b2114c3551019590363adadc28ed7", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/aa343bc6e54b2114c3551019590363adadc28ed7", "committedDate": "2020-03-31T08:25:08Z", "message": "add test of debuginfo generation to gate tests"}, "afterCommit": {"oid": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/0a0b19984f6a90726dbff59cd65e05e260de6d81", "committedDate": "2020-03-31T11:25:21Z", "message": "Add test of debuginfo generation to gate tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NjU1MzUz", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-384655353", "createdAt": "2020-03-31T11:51:31Z", "commit": {"oid": "0a0b19984f6a90726dbff59cd65e05e260de6d81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo1MTozMVrOF-R-RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMTo1MTozMVrOF-R-RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MDUwMA==", "bodyText": "You should use '-H:GenerateDebugInfo=1' also for\n\njavac_image(...)\nFirst helloworld(...) build (non-shared library build of hello world image)\ncinterfacetutorial(...)\n\nOtherwise it's pointless to build those images in GraalTags.helloworld_debug", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400850500", "createdAt": "2020-03-31T11:51:31Z", "author": {"login": "olpaw"}, "path": "substratevm/mx.substratevm/mx_substratevm.py", "diffHunk": "@@ -468,6 +468,19 @@ def svm_gate_body(args, tasks):\n                 cinterfacetutorial([])\n                 clinittest([])\n \n+        with Task('image demos debuginfo', tasks, tags=[GraalTags.helloworld_debug]) as t:\n+            if t:\n+                if svm_java8():", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a0b19984f6a90726dbff59cd65e05e260de6d81"}, "originalPosition": 6}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "26e0cd958249164d1a13d23e4deb430e57a5e527", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/26e0cd958249164d1a13d23e4deb430e57a5e527", "committedDate": "2020-03-31T12:33:10Z", "message": "Code cleanups"}, "afterCommit": {"oid": "b4680c224c85730ac0221155bab5881b98ea5bc1", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/b4680c224c85730ac0221155bab5881b98ea5bc1", "committedDate": "2020-03-31T13:30:27Z", "message": "Code cleanups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ace863810b8292744b1bd7a6fbe981f7641fdc3", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/3ace863810b8292744b1bd7a6fbe981f7641fdc3", "committedDate": "2020-03-31T13:42:27Z", "message": "text cleanups"}, "afterCommit": {"oid": "51c8f8f55d012aa5f073a608de6b66931c419c00", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/51c8f8f55d012aa5f073a608de6b66931c419c00", "committedDate": "2020-03-31T13:46:17Z", "message": "Code cleanups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dec7407b113d5a9e82b08a63d32f7bfd5020abd6", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/dec7407b113d5a9e82b08a63d32f7bfd5020abd6", "committedDate": "2020-04-01T09:34:42Z", "message": "use unique name for debuginfo gate test"}, "afterCommit": {"oid": "dc16efa8528c7fb20a3bee0671214eee15edecff", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/dc16efa8528c7fb20a3bee0671214eee15edecff", "committedDate": "2020-04-01T09:41:07Z", "message": "use unique name for debuginfo gate test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab1cb427a768786f0e6a70ae58e907861d8969de", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/ab1cb427a768786f0e6a70ae58e907861d8969de", "committedDate": "2020-04-03T10:55:26Z", "message": "Implement basic debuginfo generation for ELF objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84516d367c30a9493ceab8b96043512a45442536", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/84516d367c30a9493ceab8b96043512a45442536", "committedDate": "2020-04-03T10:55:26Z", "message": "Add option GenerateDebugInfo=<level>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25c7101fcc02d41865ef60545b6177ee7842dbef", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/25c7101fcc02d41865ef60545b6177ee7842dbef", "committedDate": "2020-04-03T10:55:26Z", "message": "Use Path expressions for directories and file names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "committedDate": "2020-04-03T10:55:26Z", "message": "Implement source file cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "committedDate": "2020-04-03T10:55:26Z", "message": "Modify debug info API to use streams instead of iterators"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "259171c5618e71769cbc7610e0ffc136d7d77562", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/259171c5618e71769cbc7610e0ffc136d7d77562", "committedDate": "2020-04-03T10:55:26Z", "message": "Added option DebugInfoSourceSearchPath=<path>\n\nTweak SourceCacheType enum\n\nClean up SourceCache initialization\n\nMemoize source cache checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b0aec7af896b5b20a0cbee931cf963906187669", "author": {"user": {"login": "olpaw", "name": "Paul Woegerer"}}, "url": "https://github.com/oracle/graal/commit/4b0aec7af896b5b20a0cbee931cf963906187669", "committedDate": "2020-04-03T10:55:26Z", "message": "Support hierarchical logging"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dc16efa8528c7fb20a3bee0671214eee15edecff", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/dc16efa8528c7fb20a3bee0671214eee15edecff", "committedDate": "2020-04-01T09:41:07Z", "message": "use unique name for debuginfo gate test"}, "afterCommit": {"oid": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "committedDate": "2020-04-03T10:55:26Z", "message": "Add test of debuginfo generation to gate tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4c876066b1122091bcaf68d869f94961d751724", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/e4c876066b1122091bcaf68d869f94961d751724", "committedDate": "2020-04-06T09:44:26Z", "message": "Abstract generic code for modelling debug info from DwarfSections into DebugInfoBase\n\nRename subclass DwarfSections to DwarfDebugInfo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/261045f807bdc6649c56fdbe8f93cd54b52e96a5", "committedDate": "2020-04-06T09:45:25Z", "message": "Add test of debuginfo generation to gate tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "committedDate": "2020-04-03T10:55:26Z", "message": "Add test of debuginfo generation to gate tests"}, "afterCommit": {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5", "author": {"user": {"login": "adinn", "name": "Andrew Dinn"}}, "url": "https://github.com/oracle/graal/commit/261045f807bdc6649c56fdbe8f93cd54b52e96a5", "committedDate": "2020-04-06T09:45:25Z", "message": "Add test of debuginfo generation to gate tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Mzg2MzI1", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-388386325", "createdAt": "2020-04-06T15:51:29Z", "commit": {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Mzg4NzE2", "url": "https://github.com/oracle/graal/pull/2088#pullrequestreview-388388716", "createdAt": "2020-04-06T15:54:06Z", "commit": {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1187, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}