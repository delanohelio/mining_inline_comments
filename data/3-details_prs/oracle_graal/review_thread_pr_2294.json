{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0Mjg2MjE1", "number": 2294, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzozOTozOVrOD0w16g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzozOTozOVrOD0w16g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NjUyNzc4OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/classinitialization/ClassInitializationFeature.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzozOTozOVrOGJ2-8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTowMzo1MlrOGiGQiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5MTIxNg==", "bodyText": "Is there an action we could suggest to the user that gets this error?\nAlso, should we re-throw if AllowIncompleteClasspath is enabled? Maybe we should just ignore in that case and return false?", "url": "https://github.com/oracle/graal/pull/2294#discussion_r412991216", "createdAt": "2020-04-22T13:39:39Z", "author": {"login": "vjovanov"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/classinitialization/ClassInitializationFeature.java", "diffHunk": "@@ -368,17 +369,22 @@ static boolean declaresDefaultMethods(ResolvedJavaType type) {\n             /* Only interfaces can declare default methods. */\n             return false;\n         }\n-        /*\n-         * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n-         * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n-         */\n-        for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n-            if (method.isDefault()) {\n-                assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n-                return true;\n+\n+        try {\n+            /*\n+             * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n+             * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n+             */\n+            for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n+                if (method.isDefault()) {\n+                    assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n+                    return true;\n+                }\n             }\n+            return false;\n+        } catch (NoClassDefFoundError e) {\n+            throw new GraalError(e, \"Unable to resolve all classes in class: %s\", type.toClassName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d180cefc8df92444cf383698b86ea06fc0722a0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NjA5NA==", "bodyText": "@vjovanov was the intention here to return false when AllowIncompleteClasspath is enabled? This got merged with the condition flipped:\nif (!NativeImageOptions.AllowIncompleteClasspath.getValue()) {\n       return false;\n}\n\nEither way  returning false (assume that the interface does not have default methods) doesn't seem like a good idea. What are the implications of this on the class initialization logic that depends on it?", "url": "https://github.com/oracle/graal/pull/2294#discussion_r436146094", "createdAt": "2020-06-05T20:21:24Z", "author": {"login": "cstancu"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/classinitialization/ClassInitializationFeature.java", "diffHunk": "@@ -368,17 +369,22 @@ static boolean declaresDefaultMethods(ResolvedJavaType type) {\n             /* Only interfaces can declare default methods. */\n             return false;\n         }\n-        /*\n-         * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n-         * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n-         */\n-        for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n-            if (method.isDefault()) {\n-                assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n-                return true;\n+\n+        try {\n+            /*\n+             * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n+             * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n+             */\n+            for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n+                if (method.isDefault()) {\n+                    assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n+                    return true;\n+                }\n             }\n+            return false;\n+        } catch (NoClassDefFoundError e) {\n+            throw new GraalError(e, \"Unable to resolve all classes in class: %s\", type.toClassName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5MTIxNg=="}, "originalCommit": {"oid": "3d180cefc8df92444cf383698b86ea06fc0722a0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMjk0NQ==", "bodyText": "@cstancu I was just looking at this and noticed the same thing. Indeed it seems the condition is flipped.\n@vjovanov @cstancu Shall we keep the check for AllowIncompleteClasspath assuming it's fixed to be:\nif (NativeImageOptions.AllowIncompleteClasspath.getValue()) {\n       return false;\n}", "url": "https://github.com/oracle/graal/pull/2294#discussion_r437422945", "createdAt": "2020-06-09T13:37:36Z", "author": {"login": "galderz"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/classinitialization/ClassInitializationFeature.java", "diffHunk": "@@ -368,17 +369,22 @@ static boolean declaresDefaultMethods(ResolvedJavaType type) {\n             /* Only interfaces can declare default methods. */\n             return false;\n         }\n-        /*\n-         * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n-         * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n-         */\n-        for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n-            if (method.isDefault()) {\n-                assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n-                return true;\n+\n+        try {\n+            /*\n+             * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n+             * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n+             */\n+            for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n+                if (method.isDefault()) {\n+                    assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n+                    return true;\n+                }\n             }\n+            return false;\n+        } catch (NoClassDefFoundError e) {\n+            throw new GraalError(e, \"Unable to resolve all classes in class: %s\", type.toClassName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5MTIxNg=="}, "originalCommit": {"oid": "3d180cefc8df92444cf383698b86ea06fc0722a0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MzY4NA==", "bodyText": "I've created #2556 to fix this.", "url": "https://github.com/oracle/graal/pull/2294#discussion_r437443684", "createdAt": "2020-06-09T13:58:12Z", "author": {"login": "galderz"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/classinitialization/ClassInitializationFeature.java", "diffHunk": "@@ -368,17 +369,22 @@ static boolean declaresDefaultMethods(ResolvedJavaType type) {\n             /* Only interfaces can declare default methods. */\n             return false;\n         }\n-        /*\n-         * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n-         * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n-         */\n-        for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n-            if (method.isDefault()) {\n-                assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n-                return true;\n+\n+        try {\n+            /*\n+             * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n+             * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n+             */\n+            for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n+                if (method.isDefault()) {\n+                    assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n+                    return true;\n+                }\n             }\n+            return false;\n+        } catch (NoClassDefFoundError e) {\n+            throw new GraalError(e, \"Unable to resolve all classes in class: %s\", type.toClassName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5MTIxNg=="}, "originalCommit": {"oid": "3d180cefc8df92444cf383698b86ea06fc0722a0"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwNzMwNQ==", "bodyText": "The proper fix is to take care of this in JVMCI. See https://bugs.openjdk.java.net/browse/JDK-8247246. It's actually a one-line fix, just need to remove linking the class from ResolvedJavaType.getDeclaredMethod(). There is no reason for the class to be linked to get the JVMCI representation of a class's methods. I will revert this PR once all that is integrated into JVMCI.", "url": "https://github.com/oracle/graal/pull/2294#discussion_r438407305", "createdAt": "2020-06-10T21:03:52Z", "author": {"login": "cstancu"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/classinitialization/ClassInitializationFeature.java", "diffHunk": "@@ -368,17 +369,22 @@ static boolean declaresDefaultMethods(ResolvedJavaType type) {\n             /* Only interfaces can declare default methods. */\n             return false;\n         }\n-        /*\n-         * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n-         * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n-         */\n-        for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n-            if (method.isDefault()) {\n-                assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n-                return true;\n+\n+        try {\n+            /*\n+             * We call getDeclaredMethods() directly on the wrapped type. We avoid calling it on the\n+             * AnalysisType because it resolves all the methods in the AnalysisUniverse.\n+             */\n+            for (ResolvedJavaMethod method : Inflation.toWrappedType(type).getDeclaredMethods()) {\n+                if (method.isDefault()) {\n+                    assert !Modifier.isStatic(method.getModifiers()) : \"Default method that is static?\";\n+                    return true;\n+                }\n             }\n+            return false;\n+        } catch (NoClassDefFoundError e) {\n+            throw new GraalError(e, \"Unable to resolve all classes in class: %s\", type.toClassName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5MTIxNg=="}, "originalCommit": {"oid": "3d180cefc8df92444cf383698b86ea06fc0722a0"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 845, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}