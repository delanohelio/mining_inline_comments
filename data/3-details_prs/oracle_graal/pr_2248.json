{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2NTA1NTQ1", "number": 2248, "title": "AArch64: Eliminate redundant constant load instructions.", "bodyText": "This patch fixes issue: #2216\nUnused constant load won't be deleted after match rules. As a result, it might generate redundant \"mov/orr\" instructions if the constants cannot be inlined to codes.\nFor example, the original codes:\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will never be used. To fix it, this patch inserts a phase applied to LIRInstructions. It's used to eliminate the unused constant load ops before code generation. Although it is limited to constant load ops currently, it can also be extended to remove other kinds of unused instructions if needed in future.\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "createdAt": "2020-03-11T06:22:11Z", "url": "https://github.com/oracle/graal/pull/2248", "merged": true, "mergeCommit": {"oid": "5875c7ff7fce960c2a364a276b4197dee132f1d3"}, "closed": true, "closedAt": "2020-06-16T17:13:00Z", "author": {"login": "XiaohongGong"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMh0aEgBqjMxMTc1Nzc1MzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqHmCXgFqTQyODYwNjQwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "67d311786544e31ef46c4ca8218ccbf10e5635d6", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/67d311786544e31ef46c4ca8218ccbf10e5635d6", "committedDate": "2020-03-11T06:19:38Z", "message": "Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}, "afterCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/7adcdcc955c09479552bdd15e5be295c4c3f10d3", "committedDate": "2020-03-11T07:15:46Z", "message": "Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNzcwNDE1", "url": "https://github.com/oracle/graal/pull/2248#pullrequestreview-372770415", "createdAt": "2020-03-11T13:46:05Z", "commit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMzo0NjowNlrOF03iyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNDowMDoxN1rOF04Jdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4MDI5Ng==", "bodyText": "minor: remove this.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390980296", "createdAt": "2020-03-11T13:46:06Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4MDU2Mw==", "bodyText": "minor: remove this.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390980563", "createdAt": "2020-03-11T13:46:28Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4Mzk1Ng==", "bodyText": "I might be wrong, but IIRC all LIR phases should be able to deal with nulls in the instruction list. Deleting them manually should not be necessary.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390983956", "createdAt": "2020-03-11T13:51:26Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));\n+                    }\n+                }\n+            };\n+\n+            int opId = 0;\n+            for (LIRInstruction inst : lir.getLIRforBlock(block)) {\n+                inst.setId(opId++);\n+                inst.visitEachOutput(defConsumer);\n+                inst.visitEachInput(useConsumer);\n+                inst.visitEachAlive(useConsumer);\n+                inst.visitEachTemp(useConsumer);\n+                inst.visitEachState(useConsumer);\n+            }\n+        }\n+\n+        /**\n+         * Currently we only find the unused constant load instructions that can be safely removed.\n+         * If there are any other kinds of eligible instructions, please extend the condition here.\n+         */\n+        private static boolean isEligibleOp(LIRInstruction inst) {\n+            return inst.isLoadConstantOp();\n+        }\n+\n+        /**\n+         * Remove unused instructions for a {@code block}.\n+         */\n+        private void removeUnusedInBlock(AbstractBlockBase<?> block) {\n+            boolean hasDead = false;\n+            ArrayList<LIRInstruction> instructions = lir.getLIRforBlock(block);\n+            for (LIRInstruction instruction : instructions) {\n+                if (instruction == null) {\n+                    hasDead = true;\n+                } else {\n+                    instruction.setId(-1);\n+                }\n+            }\n+\n+            // delete unused instructions\n+            if (hasDead) {\n+                instructions.removeAll(Collections.singleton(null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5MDE5OQ==", "bodyText": "At some point we tried to avoid allocating lambdas. I'd replace d -> (!d.instruction.equals(inst)) with a static method (e.g. RedundantInstructionElimination::filterDefEntry).", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390990199", "createdAt": "2020-03-11T14:00:17Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3"}, "originalPosition": 109}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/7adcdcc955c09479552bdd15e5be295c4c3f10d3", "committedDate": "2020-03-11T07:15:46Z", "message": "Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}, "afterCommit": {"oid": "62c299285e8874b620448f786eb538a431287e75", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/62c299285e8874b620448f786eb538a431287e75", "committedDate": "2020-03-12T09:08:20Z", "message": "Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "62c299285e8874b620448f786eb538a431287e75", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/62c299285e8874b620448f786eb538a431287e75", "committedDate": "2020-03-12T09:08:20Z", "message": "Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}, "afterCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/f02e6639b83dacbc0c0658d008fee87f0d4cb19b", "committedDate": "2020-03-13T03:19:04Z", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNjk5NDQw", "url": "https://github.com/oracle/graal/pull/2248#pullrequestreview-420699440", "createdAt": "2020-05-29T07:03:11Z", "commit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzowMzoxMVrOGcRDNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzoxNjo0OVrOGcRZig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5MjY2Mw==", "bodyText": "I'd rewrite this to\n        for (T e : content) {\n            if (e != null) {\n                return false;\n            }\n        }\n        return true;\nNot a blocker, though.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432292663", "createdAt": "2020-05-29T07:03:11Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/VariableMap.java", "diffHunk": "@@ -87,4 +85,38 @@ public void filter(Predicate<T> predicate) {\n         }\n     }\n \n+    public boolean isEmpty() {\n+        if (content.isEmpty()) {\n+            return true;\n+        }\n+\n+        boolean empty = true;\n+        for (T e : content) {\n+            if (e != null) {\n+                empty = false;\n+                break;\n+            }\n+        }\n+        return empty;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw==", "bodyText": "Since we are in SSA form, there can be only one instruction defining a variable. Thus, I think the code can be changed to unUsedDefs.remove((asVariable(value)).", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432297453", "createdAt": "2020-05-29T07:14:44Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5ODM3OA==", "bodyText": "We usually use LIRValueUtil.asVariable(value) instead of a direct cast, often with a static import so the code would change to unUsedDefs.put(asVariable(value)), def);. But it is a question of style preference and not a blocker.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432298378", "createdAt": "2020-05-29T07:16:49Z", "author": {"login": "zapster"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b"}, "originalPosition": 103}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/f02e6639b83dacbc0c0658d008fee87f0d4cb19b", "committedDate": "2020-03-13T03:19:04Z", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}, "afterCommit": {"oid": "0990ae5c05e253ded8ff837273fcab9012852215", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/0990ae5c05e253ded8ff837273fcab9012852215", "committedDate": "2020-06-01T07:16:40Z", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0990ae5c05e253ded8ff837273fcab9012852215", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/0990ae5c05e253ded8ff837273fcab9012852215", "committedDate": "2020-06-01T07:16:40Z", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}, "afterCommit": {"oid": "b5c1d01a298771b7484296ceff60a729aee2b6ab", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/b5c1d01a298771b7484296ceff60a729aee2b6ab", "committedDate": "2020-06-01T07:32:44Z", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b5c1d01a298771b7484296ceff60a729aee2b6ab", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/b5c1d01a298771b7484296ceff60a729aee2b6ab", "committedDate": "2020-06-01T07:32:44Z", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}, "afterCommit": {"oid": "5c5f7c7f5bcce49c1eab663b30b096cd6e3fe591", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/5c5f7c7f5bcce49c1eab663b30b096cd6e3fe591", "committedDate": "2020-06-02T07:14:04Z", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c5f7c7f5bcce49c1eab663b30b096cd6e3fe591", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/5c5f7c7f5bcce49c1eab663b30b096cd6e3fe591", "committedDate": "2020-06-02T07:14:04Z", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}, "afterCommit": {"oid": "126f62c924d8b155b9549c13ae220542eeae20cd", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/126f62c924d8b155b9549c13ae220542eeae20cd", "committedDate": "2020-06-05T06:57:09Z", "message": "Make sharable nodes be consumable by matched rules\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not consumed by the matched rules\nsince ConstantNode is sharable.\n\nTo fix it, this patch adds the modifications to the matching codes:\n  1) Adds the \"consumable\" flag for matching. It is used to decide\nwhether a node can be consumed by a matched rule.\n  2) Adds the class \"SharedMatchValue\". It is used as the operand for\na sharable and consumable node, if the node is swallowed by the matched\nrules. It doesn't emit any codes.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NTQzMDY1", "url": "https://github.com/oracle/graal/pull/2248#pullrequestreview-426543065", "createdAt": "2020-06-08T19:10:23Z", "commit": {"oid": "126f62c924d8b155b9549c13ae220542eeae20cd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToxMDoyM1rOGgsaaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxOToxMDoyM1rOGgsaaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNTI3NQ==", "bodyText": "Why is this necessary?  I don't think this is safe is the return operand is a virtual register.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r436935275", "createdAt": "2020-06-08T19:10:23Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -171,6 +174,10 @@ protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeVal\n     @Override\n     public Value operand(Node node) {\n         Value operand = getOperand(node);\n+        if (node instanceof ValueNode && operand instanceof SharedMatchValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "126f62c924d8b155b9549c13ae220542eeae20cd"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5875c7ff7fce960c2a364a276b4197dee132f1d3", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/5875c7ff7fce960c2a364a276b4197dee132f1d3", "committedDate": "2020-06-10T09:33:00Z", "message": "Make sharable nodes be consumable by matched rules\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not consumed by the matched rules\nsince ConstantNode is sharable.\n\nTo fix it, this patch adds the modifications to the matching codes:\n  1) Adds the \"consumable\" flag for matching. It is used to decide\nwhether a node can be consumed by a matched rule.\n  2) Adds the class \"SharedMatchValue\". It is used as the operand for\na sharable and consumable node, if the node is swallowed by the matched\nrules. It doesn't emit any codes.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "126f62c924d8b155b9549c13ae220542eeae20cd", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/126f62c924d8b155b9549c13ae220542eeae20cd", "committedDate": "2020-06-05T06:57:09Z", "message": "Make sharable nodes be consumable by matched rules\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not consumed by the matched rules\nsince ConstantNode is sharable.\n\nTo fix it, this patch adds the modifications to the matching codes:\n  1) Adds the \"consumable\" flag for matching. It is used to decide\nwhether a node can be consumed by a matched rule.\n  2) Adds the class \"SharedMatchValue\". It is used as the operand for\na sharable and consumable node, if the node is swallowed by the matched\nrules. It doesn't emit any codes.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}, "afterCommit": {"oid": "5875c7ff7fce960c2a364a276b4197dee132f1d3", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/5875c7ff7fce960c2a364a276b4197dee132f1d3", "committedDate": "2020-06-10T09:33:00Z", "message": "Make sharable nodes be consumable by matched rules\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not consumed by the matched rules\nsince ConstantNode is sharable.\n\nTo fix it, this patch adds the modifications to the matching codes:\n  1) Adds the \"consumable\" flag for matching. It is used to decide\nwhether a node can be consumed by a matched rule.\n  2) Adds the class \"SharedMatchValue\". It is used as the operand for\na sharable and consumable node, if the node is swallowed by the matched\nrules. It doesn't emit any codes.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NjA2NDAw", "url": "https://github.com/oracle/graal/pull/2248#pullrequestreview-428606400", "createdAt": "2020-06-11T05:41:46Z", "commit": {"oid": "5875c7ff7fce960c2a364a276b4197dee132f1d3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNTo0MTo0N1rOGiPNfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwNTo0MTo0N1rOGiPNfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU1Mzk4Mw==", "bodyText": "You know I don't really thing we need SharedMatchValue.  If we're going to maintain a side table we can just as easily store an Integer to track the count.  Then when it's equal to getUsageCount() we can store INTERIOR_MATCH into nodeOperands.  I could make that change if you're amenable to it.", "url": "https://github.com/oracle/graal/pull/2248#discussion_r438553983", "createdAt": "2020-06-11T05:41:47Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -226,6 +229,19 @@ public void setMatchResult(Node x, Value operand) {\n         nodeOperands.set(x, operand);\n     }\n \n+    public void setSharedMatchResult(Node node) {\n+        assert nodeOperands != null && nodeOperands.get(node) == null : \"operand cannot be set twice\";\n+        SharedMatchValue matchValue = sharedMatchValues.get(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5875c7ff7fce960c2a364a276b4197dee132f1d3"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1112, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}