{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1ODA2NDg1", "number": 2364, "title": "Apply trapping nullcheck to the uncompressed target for compressed po\u2026", "bodyText": "\u2026inter.\nTrapping nullcheck might generate two uncompress instructions for the same compressed oop in Graal. One is inserted by the backend when it emits nullcheck. If the pointer is a compressed object, it should be uncompressed before the nullcheck is emitted. And another one is generated by the normal uncompressing operation. These two instructions are duplicated with each other.\nThe generated codes on AArch64 like:\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for the nullcheck, and let the value numbering remove the duplicated one if possible. Since the address lowering of AMD64 can handle the uncompressing computation for address, the created uncompression node is wrapped to an address node and the nullcheck is finally applied on the address.\nWith the modification, the codes above could be optimized to:\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb", "createdAt": "2020-04-20T03:46:29Z", "url": "https://github.com/oracle/graal/pull/2364", "merged": true, "mergeCommit": {"oid": "3031e6128fef60e65f98f6a6caf0264320f4a669"}, "closed": true, "closedAt": "2020-11-17T23:40:32Z", "author": {"login": "XiaohongGong"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaGRxGgFqTM5ODA4MDkyMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZyEtEABqjM5NjU5NDUxMzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MDgwOTIz", "url": "https://github.com/oracle/graal/pull/2364#pullrequestreview-398080923", "createdAt": "2020-04-22T11:06:57Z", "commit": {"oid": "32032617a8714f69968d002d225834e8783b9010"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMTowNjo1N1rOGJwoPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMTowNjo1N1rOGJwoPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg4NzEwMw==", "bodyText": "Couldn't there be multiple uncompress usages?", "url": "https://github.com/oracle/graal/pull/2364#discussion_r412887103", "createdAt": "2020-04-22T11:06:57Z", "author": {"login": "dougxc"}, "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/UseTrappingNullChecksPhase.java", "diffHunk": "@@ -287,4 +292,22 @@ private static void replaceWithTrappingNullCheck(AbstractDeoptimizeNode deopt, I\n         GraphUtil.killCFG(trappingContinuation);\n         GraphUtil.tryKillUnused(isNullNode);\n     }\n+\n+    private static NullCheckNode tryUseUncompressedNullCheck(ValueNode value, IsNullNode isNullNode) {\n+        assert isNullNode.getValue().equals(value);\n+        CompressionNode uncompressed = null;\n+        for (Node usage : value.usages()) {\n+            if (usage instanceof CompressionNode) {\n+                if (((CompressionNode) usage).getOp() == CompressionNode.CompressionOp.Uncompress) {\n+                    assert ((CompressionNode) usage).getValue().equals(value);\n+                    uncompressed = (CompressionNode) usage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32032617a8714f69968d002d225834e8783b9010"}, "originalPosition": 35}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32032617a8714f69968d002d225834e8783b9010", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/32032617a8714f69968d002d225834e8783b9010", "committedDate": "2020-04-20T03:43:31Z", "message": "Apply trapping nullcheck to the uncompressed target for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for the\nsame compressed oop in Graal. One is inserted by the backend when it\nemits nullcheck. If the pointer is a compressed object, it should be\nuncompressed before the nullcheck is emitted. And another one is\ngenerated by the normal uncompressing operation. These two instructions\nare duplicated with each other.\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to apply the nullcheck to the uncompressed\nresult if it exists instead of to the compressed pointer when generating\nthe trapping nullcheck.\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb"}, "afterCommit": {"oid": "4b391ad1661e44c7cbf64d4d00934ac7c8cb39e0", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/4b391ad1661e44c7cbf64d4d00934ac7c8cb39e0", "committedDate": "2020-04-23T10:31:32Z", "message": "Apply trapping nullcheck to the uncompressed target for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for the\nsame compressed oop in Graal. One is inserted by the backend when it\nemits nullcheck. If the pointer is a compressed object, it should be\nuncompressed before the nullcheck is emitted. And another one is\ngenerated by the normal uncompressing operation. These two instructions\nare duplicated with each other.\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to apply the nullcheck to the uncompressed\nresult if it exists instead of to the compressed pointer when generating\nthe trapping nullcheck.\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b391ad1661e44c7cbf64d4d00934ac7c8cb39e0", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/4b391ad1661e44c7cbf64d4d00934ac7c8cb39e0", "committedDate": "2020-04-23T10:31:32Z", "message": "Apply trapping nullcheck to the uncompressed target for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for the\nsame compressed oop in Graal. One is inserted by the backend when it\nemits nullcheck. If the pointer is a compressed object, it should be\nuncompressed before the nullcheck is emitted. And another one is\ngenerated by the normal uncompressing operation. These two instructions\nare duplicated with each other.\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to apply the nullcheck to the uncompressed\nresult if it exists instead of to the compressed pointer when generating\nthe trapping nullcheck.\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb"}, "afterCommit": {"oid": "e5b9f3f6a81704a862120dc6a4f78922865759f5", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/e5b9f3f6a81704a862120dc6a4f78922865759f5", "committedDate": "2020-05-09T07:07:59Z", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5b9f3f6a81704a862120dc6a4f78922865759f5", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/e5b9f3f6a81704a862120dc6a4f78922865759f5", "committedDate": "2020-05-09T07:07:59Z", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb"}, "afterCommit": {"oid": "f49b7cd54cd012c49c52136a63724346c259a313", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/f49b7cd54cd012c49c52136a63724346c259a313", "committedDate": "2020-05-13T04:18:55Z", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68dd33ded8cd60c1fa0f80f2ab7286695d6d40fd", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/68dd33ded8cd60c1fa0f80f2ab7286695d6d40fd", "committedDate": "2020-11-06T07:44:50Z", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f49b7cd54cd012c49c52136a63724346c259a313", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/f49b7cd54cd012c49c52136a63724346c259a313", "committedDate": "2020-05-13T04:18:55Z", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]\n\nChange-Id: Iabfe47bbf984ed11c42555f84bdd0ccf2a5bdddb"}, "afterCommit": {"oid": "68dd33ded8cd60c1fa0f80f2ab7286695d6d40fd", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/68dd33ded8cd60c1fa0f80f2ab7286695d6d40fd", "committedDate": "2020-11-06T07:44:50Z", "message": "Apply trapping nullcheck to uncompressed object for compressed pointer.\n\nTrapping nullcheck might generate two uncompress instructions for\nthe same compressed oop on AArch64. One is inserted by the backend\nwhen it emits nullcheck. If the object is a compressed pointer, it\nis uncompressed before the nullcheck is emitted. And another one is\ngenerated by the uncompression node used for memory access. These\ntwo instructions are duplicated with each other.\n\nThe generated codes on AArch64 like:\n\n  ldr   w0, [x0,#112]\n  lsl   x2, x0, #3      ; uncompressing (first)\n  ldr   xzr, [x2]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  lsl   x0, x0, #3      ; uncompressing (second)\n  str   w1, [x0,#12]\n\nA simple way to avoid this is to creat a new uncompression node for\nthe nullcheck, and let the value numbering remove the duplicated one\nif possible. Since the address lowering of AMD64 can handle the\nuncompressing computation for address, the created uncompression node\nis wrapped to an address node and the nullcheck is finally applied on\nthe address.\n\nWith the modification, the codes above could be optimized to:\n\n  ldr   w0, [x0,#112]\n  lsl   x0, x0, #3      ; uncompressing\n  ldr   xzr, [x0]       ; implicit exception: deoptimizes\n  ......                ; fixed operations\n  str   w1, [x0,#12]"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1149, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}