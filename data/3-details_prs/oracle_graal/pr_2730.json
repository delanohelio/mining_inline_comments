{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyMDAzNDcz", "number": 2730, "title": "Support JDK serialization/deserialization features", "bodyText": "JDK's serialization/deserialization features are implemented by java.io.java.io.ObjectInputStream.readObject and java.io.ObjectOutputStream.writeObject APIs which are not supported by native image. This patch supports  these two APIs in native image.\nFeatures:\n\nSupport serialization API Ljava/io/ObjectOutputStream;#writeObject(Ljava/lang/Object;)V\nSupport deserialization API Ljava/io/ObjectInputStream;#readObject()Ljava/lang/Object;\nAdd a new configuration file serialization-config.json to provide serialization/deserialization target class information for\nnative-image at build time. The agent can intercept serialization/deserialization calls to store the serialization/deserialization target class information to the configuration file automatically.\nThis patch doesn't depend on the previously committed dynamic class loading feature #2442\nUnsupported multiple class loader usage will be reported at build time. For example, there are two classes with the same name \"com.alibaba.test.serialze.Data\", but one extends com.alibaba.test.serialize.DummyBase and another doesn't.  When they are loaded and serialized by different classloaders. the following error will be reported at build time:\n\nJUnit is now supported. All tests in the attached tests.zip are JUnit tests.\n\nTests:\nTests are here:\ntests.zip\nThere are 4 tests in  tests.zip for this patch. Unzip the file and run each  shell script started with \"test\" to see the result.\n\ntestCustomizedClassSerialize.sh: This test serializes and deserializes a customized class.\ntestDeserializeStream.sh: this test deserializes a float array\ntestSerializeArrayList.sh: this test serializes and deserializes an ArrayList class\ntestDeserializeMultiClassloader.sh: this test serializes and deserializes two different classes with the same name by different classloaders. This test is expected to fail.", "createdAt": "2020-08-03T07:31:41Z", "url": "https://github.com/oracle/graal/pull/2730", "merged": true, "mergeCommit": {"oid": "c4fb66ce6f44c55764bbe759c94ee2b34985d37e"}, "closed": true, "closedAt": "2020-12-05T04:30:24Z", "author": {"login": "ziyilin"}, "timelineItems": {"totalCount": 63, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc74uGVgBqjM2MjQwNTcxNzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdinO2tgFqTU0NDI0NDYyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "08580b8b1293ccf1b1e822a7e3bdf8636636e009", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/08580b8b1293ccf1b1e822a7e3bdf8636636e009", "committedDate": "2020-08-03T06:39:45Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "d8da62b3f893b6b8717bdd661b10bf0c669262a2", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/d8da62b3f893b6b8717bdd661b10bf0c669262a2", "committedDate": "2020-08-05T10:32:13Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MTM3NDM3", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-466137437", "createdAt": "2020-08-12T17:44:10Z", "commit": {"oid": "d8da62b3f893b6b8717bdd661b10bf0c669262a2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzo0NDoxMFrOG_r5AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQxNzo1OToxNlrOG_sbpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzMjU3Ng==", "bodyText": "This seems to target JDK 8 because these classes have since been moved to jdk.internal.reflect. Have you tested these changes using JDK 11?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r469432576", "createdAt": "2020-08-12T17:44:10Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -1218,6 +1338,9 @@ public static void onUnload() {\n                     brk(\"java/lang/reflect/Proxy\", \"newProxyInstance\",\n                                     \"(Ljava/lang/ClassLoader;[Ljava/lang/Class;Ljava/lang/reflect/InvocationHandler;)Ljava/lang/Object;\", BreakpointInterceptor::newProxyInstance),\n \n+                    brk(\"sun/reflect/MethodAccessorGenerator\", \"generateSerializationConstructor\",\n+                                    \"(Ljava/lang/Class;[Ljava/lang/Class;[Ljava/lang/Class;ILjava/lang/Class;)Lsun/reflect/SerializationConstructorAccessorImpl;\",\n+                                    BreakpointInterceptor::generateSerializationConstructor),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8da62b3f893b6b8717bdd661b10bf0c669262a2"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQzNDk4Nw==", "bodyText": "Wouldn't this yield something like [I or [[[J for primitive arrays? I believe in order to stay consistent, this should also result in int[] or long[][][].", "url": "https://github.com/oracle/graal/pull/2730#discussion_r469434987", "createdAt": "2020-08-12T17:48:18Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/TypeConfiguration.java", "diffHunk": "@@ -63,7 +63,12 @@ public ConfigurationType getOrCreateType(String qualifiedForNameString) {\n         }\n         if (n > 0) { // transform to Java source syntax\n             StringBuilder sb = new StringBuilder(s.length() + n);\n-            sb.append(s, n + 1, s.length() - 1); // cut off leading '[' and 'L' and trailing ';'\n+            if (s.charAt(n) == 'L' && s.charAt(s.length() - 1) == ';') {\n+                sb.append(s, n + 1, s.length() - 1); // cut off leading '[' and 'L' and trailing ';'\n+            } else {\n+                // Primitive Array\n+                return types.computeIfAbsent(s, ConfigurationType::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8da62b3f893b6b8717bdd661b10bf0c669262a2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ0MDczNg==", "bodyText": "Given that native-image does not support anything between JDK 8 and 11, the existing class JDK11OrLater should be sufficient.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r469440736", "createdAt": "2020-08-12T17:57:58Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/JDK9OrLater.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ */\n+package com.oracle.svm.core.jdk;\n+\n+import org.graalvm.compiler.serviceprovider.JavaVersionUtil;\n+\n+import java.util.function.BooleanSupplier;\n+\n+public class JDK9OrLater implements BooleanSupplier {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8da62b3f893b6b8717bdd661b10bf0c669262a2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ0MTQ0Nw==", "bodyText": "minor: accessorDefinitions (+f)", "url": "https://github.com/oracle/graal/pull/2730#discussion_r469441447", "createdAt": "2020-08-12T17:59:16Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.VMError;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport<T> implements SerializationRegistry<T> {\n+    //Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Object> cachedSerializationConstructorAccessors;\n+\n+    /* This map is used to track multiple classloader usage\n+     * Map of serialization target class and a list of class T that stores the parameters to\n+     * generate its SerializationConstructorAccessor class and other relevant information.\n+     *  Each T entity represents one generation. One target class usually has only one generation,\n+     * multiple-generations is a suggestion of multiple classloader usage.\n+     */\n+    private Map<String, List<T>> accessorDeinitions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8da62b3f893b6b8717bdd661b10bf0c669262a2"}, "originalPosition": 24}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d8da62b3f893b6b8717bdd661b10bf0c669262a2", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/d8da62b3f893b6b8717bdd661b10bf0c669262a2", "committedDate": "2020-08-05T10:32:13Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "committedDate": "2020-08-18T03:17:27Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjIzMjI4", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-469623228", "createdAt": "2020-08-18T16:25:33Z", "commit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjoyNTozNFrOHCcVxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjoyNTozNFrOHCcVxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyMzUyNg==", "bodyText": "Needs to be adjusted for JDK 11. Locally I changed Package_jdk_internal_reflect to expose this method so it can be called here:\n    public static String getQualifiedName() {\n        if (JavaVersionUtil.JAVA_SPEC <= 8) {\n            return \"sun.reflect\";\n        } else {\n            return \"jdk.internal.reflect\";\n        }\n    }", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472323526", "createdAt": "2020-08-18T16:25:34Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/FallbackFeature.java", "diffHunk": "@@ -167,7 +168,11 @@ public FallbackFeature() {\n             addCheck(Proxy.class.getMethod(\"newProxyInstance\", ClassLoader.class, Class[].class, InvocationHandler.class), this::collectProxyInvokes);\n \n             addCheck(System.class.getMethod(\"loadLibrary\", String.class), this::collectJNIInvokes);\n-        } catch (NoSuchMethodException e) {\n+\n+            Class<?> generatorClass = Class.forName(\"sun.reflect.MethodAccessorGenerator\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjI1NDkx", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-469625491", "createdAt": "2020-08-18T16:28:18Z", "commit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjoyODoxOFrOHCccqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjoyODoxOFrOHCccqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyNTI5MA==", "bodyText": "This file can be deleted once JDK 11 support is in place.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472325290", "createdAt": "2020-08-18T16:28:18Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_jdk_internal_reflect_AccessorGenerator.java", "diffHunk": "@@ -28,11 +28,6 @@\n import com.oracle.svm.core.annotate.TargetClass;\n \n @Delete\n-@TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"AccessorGenerator\")\n-public final class Target_jdk_internal_reflect_AccessorGenerator {\n-}\n-\n-@Delete\n-@TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"MethodAccessorGenerator\")\n+@TargetClass(className = \"jdk.internal.reflect.MethodAccessorGenerator\", onlyWith = JDK11OrLater.class)\n final class Target_jdk_internal_reflect_MethodAccessorGenerator {\n }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjI2MzI1", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-469626325", "createdAt": "2020-08-18T16:29:22Z", "commit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjoyOToyM1rOHCcfgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjoyOToyM1rOHCcfgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMyNjAxNg==", "bodyText": "Use @TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"MethodAccessorGenerator\") and @TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"SerializationConstructorAccessorImpl\"), then these should work for both JDK 8 and 11. Rename classes to jdk_internal_reflect_* for consistency.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472326016", "createdAt": "2020-08-18T16:29:23Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/serialize/Target_sun_reflect_MethodAccessorGenerator.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright (c) 2019, 2019, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.jdk.serialize;\n+\n+import com.oracle.svm.core.annotate.Substitute;\n+import com.oracle.svm.core.annotate.TargetClass;\n+import com.oracle.svm.core.jdk.JDK8OrEarlier;\n+import org.graalvm.nativeimage.ImageSingletons;\n+\n+@TargetClass(className = \"sun.reflect.MethodAccessorGenerator\", onlyWith = JDK8OrEarlier.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjM3MjY1", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-469637265", "createdAt": "2020-08-18T16:43:03Z", "commit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjo0MzowM1rOHCdCBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjo0MzowM1rOHCdCBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNDg1NQ==", "bodyText": "It would be cleaner to pass along the field information gathered below in the serialization event above, or in separate serialization events, rather than faking reflection accesses. The TypeConfiguration for reflection can be passed to the SerializationProcessor constructor, which would then be able to register the fields and classes accordingly.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472334855", "createdAt": "2020-08-18T16:43:03Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -913,6 +918,119 @@ private static String asInternalSignature(Object paramTypesArray) {\n         return null;\n     }\n \n+    @SuppressWarnings(\"unused\")\n+    private static boolean generateSerializationConstructor(JNIEnvironment jni, Breakpoint bp) {\n+        JNIObjectHandle self = getObjectArgument(0);\n+        JNIObjectHandle serializeTargetClass = getObjectArgument(1);\n+        String serializeTargetClassName = getClassNameOrNull(jni, serializeTargetClass);\n+        JNIObjectHandle parameterTypes = getObjectArgument(2);\n+        Object parameterTypeNames = getClassArrayNames(jni, parameterTypes);\n+        JNIObjectHandle checkedExceptions = getObjectArgument(3);\n+        Object checkedExceptionNames = getClassArrayNames(jni, checkedExceptions);\n+        int modifiers = getIntArgument(4);\n+        JNIObjectHandle targetConstructorClass = getObjectArgument(5);\n+        String targetConstructorClassName = getClassNameOrNull(jni, targetConstructorClass);\n+        boolean allowed = (serializationAccessVerifier == null ||\n+                        serializationAccessVerifier.verifyGenerateSerializationConstructor(jni, serializeTargetClassName, parameterTypeNames,\n+                                        checkedExceptionNames, modifiers, targetConstructorClassName));\n+        Object result = false;\n+        if (allowed) {\n+            JNIValue args = StackValue.get(6, JNIValue.class);\n+            args.addressOf(0).setObject(self);\n+            args.addressOf(1).setObject(serializeTargetClass);\n+            args.addressOf(2).setObject(parameterTypes);\n+            args.addressOf(3).setObject(checkedExceptions);\n+            args.addressOf(4).setInt(modifiers);\n+            args.addressOf(5).setObject(targetConstructorClass);\n+            result = nullHandle().notEqual(jniFunctions().getCallObjectMethodA().invoke(jni, bp.clazz, bp.method, args));\n+            if (clearException(jni)) {\n+                result = false;\n+            }\n+        }\n+        JNIObjectHandle callerClass = getDirectCallerClass();\n+        if (traceWriter != null) {\n+            traceWriter.traceCall(\"serialization\",\n+                            \"generateSerializationConstructor\",\n+                            null,\n+                            null,\n+                            null,\n+                            result,\n+                            serializeTargetClassName, parameterTypeNames,\n+                            checkedExceptionNames, modifiers, targetConstructorClassName);\n+            JNIFunctionPointerTypes.CallIntMethodFunctionPointer noArgRetIntCall = jniFunctions().getCallIntMethod();\n+            int privateStaticFinalMask = Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL;\n+            int staticFinalMask = Modifier.STATIC | Modifier.FINAL;\n+\n+            // call serializationTargetClass.getDeclaredFields();\n+            JNIObjectHandle javaLangClass = agent.handles().findClass(jni, \"java/lang/Class\");\n+            JNIMethodId getDeclaredFieldsMI = agent.handles().getMethodId(jni, javaLangClass, \"getDeclaredFields\",\n+                            \"()[Ljava/lang/reflect/Field;\", false);\n+            JNIFunctionPointerTypes.CallObjectMethod0FunctionPointer noArgRetObjectCall = jniFunctions().getCallObjectMethod();\n+            JNIObjectHandle fieldsJArray = noArgRetObjectCall.invoke(jni, serializeTargetClass, getDeclaredFieldsMI);\n+\n+            // Prepare JNIMethodIds for later calls\n+            JNIObjectHandle javaLangReflectField = agent.handles().findClass(jni, \"java/lang/reflect/Field\");\n+            JNIMethodId getFieldNameId = agent.handles().getMethodId(jni, javaLangReflectField, \"getName\", \"()Ljava/lang/String;\", false);\n+            JNIMethodId getFieldModifiersId = agent.handles().getMethodId(jni, javaLangReflectField, \"getModifiers\", \"()I\", false);\n+            JNIMethodId getFieldTypeId = agent.handles().getMethodId(jni, javaLangReflectField, \"getType\", \"()Ljava/lang/Class;\", false);\n+            // Add serialize and deserialize fields into reflection configs\n+            // Check each field", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjQ1NjIz", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-469645623", "createdAt": "2020-08-18T16:53:44Z", "commit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjo1Mzo0NFrOHCdbPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjo1Mzo0NFrOHCdbPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM0MTMwOA==", "bodyText": "This check will also need to look at the caller to determine if it should be ignored (shouldApproveWithoutChecks). The verifiers are part of the agent's restriction mode (as opposed to its tracing mode), I can take care of this part if you prefer.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472341308", "createdAt": "2020-08-18T16:53:44Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/restrict/SerializationAccessVerifier.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent.restrict;\n+\n+import com.oracle.svm.configure.config.SerializationConfiguration;\n+import com.oracle.svm.configure.trace.AccessAdvisor;\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+\n+public class SerializationAccessVerifier extends AbstractAccessVerifier {\n+    private final SerializationConfiguration configuration;\n+\n+    public SerializationAccessVerifier(SerializationConfiguration configuration, AccessAdvisor advisor) {\n+        super(advisor);\n+        this.configuration = configuration;\n+    }\n+\n+    public boolean verifyGenerateSerializationConstructor(JNIEnvironment env, String serializationTargetClass, Object parameterTypes, Object checkedExceptions,\n+                    int modifiers, String targetConstructorClass) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjUyMDE3", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-469652017", "createdAt": "2020-08-18T17:01:58Z", "commit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzowMTo1OVrOHCdvlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzowMTo1OVrOHCdvlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM0NjUxNw==", "bodyText": "Should be possible to replace with JavaKind.fromPrimitiveOrVoidTypeChar(s.chartAt(n)).getJavaName() with a check that n == s.length() - 1.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r472346517", "createdAt": "2020-08-18T17:01:59Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/TypeConfiguration.java", "diffHunk": "@@ -63,7 +64,44 @@ public ConfigurationType getOrCreateType(String qualifiedForNameString) {\n         }\n         if (n > 0) { // transform to Java source syntax\n             StringBuilder sb = new StringBuilder(s.length() + n);\n-            sb.append(s, n + 1, s.length() - 1); // cut off leading '[' and 'L' and trailing ';'\n+            if (s.charAt(n) == 'L' && s.charAt(s.length() - 1) == ';') {\n+                sb.append(s, n + 1, s.length() - 1); // cut off leading '[' and 'L' and trailing ';'\n+            } else {\n+                // Primitive Array\n+                String primitiveType = s.substring(n, s.length());\n+                switch (primitiveType) {\n+                    case \"I\":\n+                        s = \"int\";\n+                        break;\n+                    case \"F\":\n+                        s = \"float\";\n+                        break;\n+                    case \"J\":\n+                        s = \"long\";\n+                        break;\n+                    case \"D\":\n+                        s = \"double\";\n+                        break;\n+                    case \"Z\":\n+                        s = \"boolean\";\n+                        break;\n+                    case \"B\":\n+                        s = \"byte\";\n+                        break;\n+                    case \"S\":\n+                        s = \"short\";\n+                        break;\n+                    case \"C\":\n+                        s = \"char\";\n+                        break;\n+                    case \"V\":\n+                        s = \"void\";\n+                        break;\n+                    default:\n+                        throw new JSONParserException(\"Unrecognized primitive type \" + primitiveType);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb"}, "originalPosition": 48}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b7d56d17924e224e2f11db2b3cc3a76d58a1b0cb", "committedDate": "2020-08-18T03:17:27Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "c6b5fe700fec84f703dc751bdc25a0ebe2b9aa14", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/c6b5fe700fec84f703dc751bdc25a0ebe2b9aa14", "committedDate": "2020-08-19T08:48:06Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c6b5fe700fec84f703dc751bdc25a0ebe2b9aa14", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/c6b5fe700fec84f703dc751bdc25a0ebe2b9aa14", "committedDate": "2020-08-19T08:48:06Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "5df952635dfee8e53ee01e1acf6532706c8462d5", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/5df952635dfee8e53ee01e1acf6532706c8462d5", "committedDate": "2020-08-19T09:56:53Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5df952635dfee8e53ee01e1acf6532706c8462d5", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/5df952635dfee8e53ee01e1acf6532706c8462d5", "committedDate": "2020-08-19T09:56:53Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "committedDate": "2020-08-19T11:23:15Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNzE2MTIy", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-470716122", "createdAt": "2020-08-19T18:06:17Z", "commit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODowNjoxN1rOHDTZXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODowNjoxN1rOHDTZXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIyNTU2NA==", "bodyText": "Why the check for String[], isn't it a bug if this is not the case? It should probably be done in the caller and parameters here should have already type String[].", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473225564", "createdAt": "2020-08-19T18:06:17Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/restrict/SerializationAccessVerifier.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent.restrict;\n+\n+import com.oracle.svm.configure.config.SerializationConfiguration;\n+import com.oracle.svm.configure.trace.AccessAdvisor;\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+\n+public class SerializationAccessVerifier extends AbstractAccessVerifier {\n+    private final SerializationConfiguration configuration;\n+\n+    public SerializationAccessVerifier(SerializationConfiguration configuration, AccessAdvisor advisor) {\n+        super(advisor);\n+        this.configuration = configuration;\n+    }\n+\n+    public boolean verifyGenerateSerializationConstructor(JNIEnvironment env, String serializationTargetClass, Object parameterTypes, Object checkedExceptions,\n+                                                          int modifiers, String targetConstructorClass, JNIObjectHandle queriedClass, JNIObjectHandle callerClass) {\n+        if (shouldApproveWithoutChecks(env, queriedClass, callerClass)) {\n+            return true;\n+        }\n+        return (parameterTypes instanceof String[] && checkedExceptions instanceof String[] &&\n+                        configuration.contains(serializationTargetClass, (String[]) parameterTypes, (String[]) checkedExceptions, modifiers, targetConstructorClass));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNzE5MzA5", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-470719309", "createdAt": "2020-08-19T18:11:08Z", "commit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODoxMTowOFrOHDTjDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODoxMTowOFrOHDTjDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIyODA0NQ==", "bodyText": "Couldn't you make SerializationKey create its flattenString in JSON format and have it implement JsonPrintable and simply call it here?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473228045", "createdAt": "2020-08-19T18:11:08Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/SerializationConfiguration.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.configure.config;\n+\n+import com.oracle.svm.configure.json.JsonPrintable;\n+import com.oracle.svm.configure.json.JsonWriter;\n+import com.oracle.svm.core.configure.SerializationKey;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationConfiguration implements JsonPrintable {\n+\n+    private final ConcurrentHashMap.KeySetView<SerializationKey<String>, Boolean> serializations = ConcurrentHashMap.newKeySet();\n+\n+    public void add(String serializationTargetClass, String[] parameterTypes, String[] checkedExceptions, int modifiers, String targetConstructorClass) {\n+        SerializationKey<String> key = new SerializationKey<>(serializationTargetClass, parameterTypes, checkedExceptions, modifiers, targetConstructorClass);\n+        add(key);\n+    }\n+\n+    public void add(SerializationKey<String> key) {\n+        serializations.add(key);\n+    }\n+\n+    public boolean contains(String serializationTargetClass, String[] parameterTypes, String[] checkedExceptions, int modifiers, String targetConstructorClass) {\n+        SerializationKey<String> key = new SerializationKey<>(serializationTargetClass, parameterTypes, checkedExceptions, modifiers, targetConstructorClass);\n+        return serializations.contains(key);\n+    }\n+\n+    @Override\n+    public void printJson(JsonWriter writer) throws IOException {\n+        writer.append('[').indent();\n+        String prefix = \"\";\n+        for (SerializationKey<String> skey : serializations) {\n+            writer.append(prefix).newline().append('{');\n+            writer.newline();\n+            String typePrefix = \"\";\n+            writer.quote(\"name\").append(\":\").quote(skey.getSerializationTargetClass()).append(\",\").newline();\n+            writer.quote(\"parameterTypes\").append(\":\").append('[');\n+            for (String parameterType : skey.getParameterTypes()) {\n+                writer.append(typePrefix).quote(parameterType);\n+                typePrefix = \",\";\n+            }\n+            writer.append(']').append(\",\").newline();\n+\n+            typePrefix = \"\";\n+            writer.quote(\"checkedExceptions\").append(\":\").append('[');\n+            for (String checkedException : skey.getCheckedExceptions()) {\n+                writer.append(typePrefix).quote(checkedException);\n+                typePrefix = \",\";\n+            }\n+            writer.append(']').append(\",\").newline();\n+\n+            writer.quote(\"modifiers\").append(':').append(Integer.toString(skey.getModifiers())).append(\",\").newline();\n+            writer.quote(\"targetConstructorClass\").append(':').quote(skey.getTargetConstructorClass()).newline();\n+            writer.append('}');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNzIxODQx", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-470721841", "createdAt": "2020-08-19T18:14:51Z", "commit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODoxNDo1MVrOHDTqsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODoxNDo1MVrOHDTqsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDAwMg==", "bodyText": "Why are these necessary? These rules should cause reflective accesses from the various stream classes to end up in the reflection configuration, but these should be considered implementation details of serialization/deserialization on native-image and we would already register accessible fields separately.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473230002", "createdAt": "2020-08-19T18:14:51Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/trace/AccessAdvisor.java", "diffHunk": "@@ -78,6 +78,11 @@\n \n         internalCallerFilter.addOrGetChildren(\"org.graalvm.compiler.**\", RuleNode.Inclusion.Exclude);\n         internalCallerFilter.addOrGetChildren(\"org.graalvm.libgraal.**\", RuleNode.Inclusion.Exclude);\n+\n+        // For serializations\n+        internalCallerFilter.addOrGetChildren(\"java.io.ObjectInputStream\", RuleNode.Inclusion.Include);\n+        internalCallerFilter.addOrGetChildren(\"java.io.ObjectOutputStream\", RuleNode.Inclusion.Include);\n+        internalCallerFilter.addOrGetChildren(\"java.io.ObjectStreamClass\", RuleNode.Inclusion.Include);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNzIyMjE4", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-470722218", "createdAt": "2020-08-19T18:15:25Z", "commit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODoxNToyNVrOHDTr9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODoxNToyNVrOHDTr9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzIzMDMyNQ==", "bodyText": "Is this still needed now that the fake reflection events are gone?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473230325", "createdAt": "2020-08-19T18:15:25Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/trace/ReflectionProcessor.java", "diffHunk": "@@ -145,7 +145,8 @@ public void processEntry(Map<String, ?> entry) {\n                 memberKind = ConfigurationMemberKind.DECLARED;\n                 // fall through\n             case \"getField\": {\n-                configuration.getOrCreateType(clazzOrDeclaringClass).addField(singleElement(args), memberKind, false, unsafeAccess);\n+                configuration.getOrCreateType(clazzOrDeclaringClass).addField(singleElement(args), memberKind, entry.containsKey(\"allowWrite\") ? (Boolean) entry.get(\"allowWrite\") : false,\n+                                entry.containsKey(\"unsafeAccess\") ? (Boolean) entry.get(\"unsafeAccess\") : unsafeAccess);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNzQ4Mjk5", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-470748299", "createdAt": "2020-08-19T18:53:54Z", "commit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODo1Mzo1NFrOHDU7Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxODo1Mzo1NFrOHDU7Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1MDY2Mg==", "bodyText": "I think this information can be easily merged into ClassInitializationInfo above by creating another constant like INITIALIZED_INFO_SINGLETON, for example NO_INITIALIZER_INFO_SINGLETON. This way, not every DynamicHub needs to have this extra field.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r473250662", "createdAt": "2020-08-19T18:53:54Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "diffHunk": "@@ -266,6 +266,12 @@\n      */\n     private ClassInitializationInfo classInitializationInfo;\n \n+    /**\n+     * Indicates if this class originally has a <clinit> method. It is used for serialization\n+     * support.\n+     */\n+    private boolean hasCLinit;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579"}, "originalPosition": 8}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b2c20b2cd20a41d8c400ca6ae709a1d0669c4579", "committedDate": "2020-08-19T11:23:15Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "9ba52977628ed9ecd107dda93ae3b15f80d591ac", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/9ba52977628ed9ecd107dda93ae3b15f80d591ac", "committedDate": "2020-08-20T09:22:14Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ba52977628ed9ecd107dda93ae3b15f80d591ac", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/9ba52977628ed9ecd107dda93ae3b15f80d591ac", "committedDate": "2020-08-20T09:22:14Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "bdf3f6d2f515516065394168fb28bebe174c6a10", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/bdf3f6d2f515516065394168fb28bebe174c6a10", "committedDate": "2020-08-20T12:37:15Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bdf3f6d2f515516065394168fb28bebe174c6a10", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/bdf3f6d2f515516065394168fb28bebe174c6a10", "committedDate": "2020-08-20T12:37:15Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "b83c4e0fa7cb44a96700d5cad4f5dfa978caf63b", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b83c4e0fa7cb44a96700d5cad4f5dfa978caf63b", "committedDate": "2020-08-20T12:53:48Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b83c4e0fa7cb44a96700d5cad4f5dfa978caf63b", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b83c4e0fa7cb44a96700d5cad4f5dfa978caf63b", "committedDate": "2020-08-20T12:53:48Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "13c898bda3da7dd8b16564f7ab37f2459737f9f1", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/13c898bda3da7dd8b16564f7ab37f2459737f9f1", "committedDate": "2020-08-21T09:32:31Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODQ0ODIy", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-473844822", "createdAt": "2020-08-24T20:48:05Z", "commit": {"oid": "13c898bda3da7dd8b16564f7ab37f2459737f9f1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMDo0ODowNVrOHF1tBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMDo0ODowNVrOHF1tBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4NDgwNw==", "bodyText": "Do all fields, constructors and methods really need to be registered? It seems to me that only those that are singled out in the ObjectStreamClass(Class<?>) constructor are really relevant. But that might be irrelevant with the approach of populating a collection of ObjectStreamClass at build time.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r475884807", "createdAt": "2020-08-24T20:48:05Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, srtParameterTypes, srtCheckedExceptions, modifiers, strTargetConstructorClass) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            Class<?>[] parameterTypes = Arrays.stream(srtParameterTypes).map(parameterType -> resolveClass(parameterType, imageClassLoader)).toArray(Class[]::new);\n+            Class<?>[] checkedExceptions = Arrays.stream(srtCheckedExceptions).map(parameterType -> resolveClass(parameterType, imageClassLoader)).toArray(Class[]::new);\n+            Class<?> targetConstructor = strTargetConstructorClass.length() == 0 ? null : resolveClass(strTargetConstructorClass, imageClassLoader);\n+            if (targetConstructor != null) {\n+                serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, parameterTypes, checkedExceptions, modifiers, targetConstructor);\n+            }\n+            addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        String exceptionsMsg = serializationSupport.collectMultiDefinitions();\n+        // Checkstyle: stop\n+        if (exceptionsMsg.length() > 0) {\n+            System.out.println(exceptionsMsg);\n+            if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(\"Unsupported dynamic features\", null,\n+                                \"To allow continuing compilation with above unsupported features, set \" +\n+                                                SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\"));\n+            } else {\n+                System.out.println(\"Compilation will continue because \" + SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\") +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            reflectionData.register(targetConstructor.getDeclaredConstructors());\n+        }\n+        reflectionData.register(serializationTargetClass);\n+        for (Field f : serializationTargetClass.getDeclaredFields()) {\n+            int modifiers = f.getModifiers();\n+            boolean allowWrite = false;\n+            boolean allowUnsafeAccess = false;\n+            if (!(Modifier.isFinal(modifiers) && Modifier.isStatic(modifiers))) {\n+                allowWrite = Modifier.isFinal(f.getModifiers());\n+                allowUnsafeAccess = !Modifier.isStatic(f.getModifiers());\n+            }\n+            reflectionData.register(allowWrite, allowUnsafeAccess, f);\n+        }\n+        reflectionData.register(serializationTargetClass.getDeclaredMethods());\n+        reflectionData.register(serializationTargetClass.getDeclaredConstructors());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c898bda3da7dd8b16564f7ab37f2459737f9f1"}, "originalPosition": 103}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "13c898bda3da7dd8b16564f7ab37f2459737f9f1", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/13c898bda3da7dd8b16564f7ab37f2459737f9f1", "committedDate": "2020-08-21T09:32:31Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "38b16049e35fa97bdaec7463865525a56e89a678", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/38b16049e35fa97bdaec7463865525a56e89a678", "committedDate": "2020-08-26T14:44:47Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "38b16049e35fa97bdaec7463865525a56e89a678", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/38b16049e35fa97bdaec7463865525a56e89a678", "committedDate": "2020-08-26T14:44:47Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "f0d49c2393a59a516efc213449368fc3a367209f", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/f0d49c2393a59a516efc213449368fc3a367209f", "committedDate": "2020-08-27T03:40:17Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2Mzk2NzU3", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-476396757", "createdAt": "2020-08-27T05:33:12Z", "commit": {"oid": "f0d49c2393a59a516efc213449368fc3a367209f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNTozMzoxMlrOHH_avw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNTozMzoxMlrOHH_avw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE0MTExOQ==", "bodyText": "Should it present License lines here?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r478141119", "createdAt": "2020-08-27T05:33:12Z", "author": {"login": "mingjliu9"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.oracle.svm.reflect.serialize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0d49c2393a59a516efc213449368fc3a367209f"}, "originalPosition": 1}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f0d49c2393a59a516efc213449368fc3a367209f", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/f0d49c2393a59a516efc213449368fc3a367209f", "committedDate": "2020-08-27T03:40:17Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "c4b118335f579e16f358eb32fa42afb34e536da7", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/c4b118335f579e16f358eb32fa42afb34e536da7", "committedDate": "2020-08-27T05:54:48Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4b118335f579e16f358eb32fa42afb34e536da7", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/c4b118335f579e16f358eb32fa42afb34e536da7", "committedDate": "2020-08-27T05:54:48Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b4c3dee22257d87c46be18eb6980f1ff2f294f16", "committedDate": "2020-09-07T05:44:38Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4NzQ3NjA0", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-488747604", "createdAt": "2020-09-15T14:31:08Z", "commit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNDozMTowOFrOHSE0lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTo0Mjo1NlrOHSR3ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcxNTQxNA==", "bodyText": "This method seems to be no longer needed.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488715414", "createdAt": "2020-09-15T14:31:08Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/ConfigurationParser.java", "diffHunk": "@@ -71,4 +71,22 @@ protected static boolean asBoolean(Object value, String propertyName) {\n         }\n         throw new JSONParserException(\"Invalid boolean value '\" + value + \"' for element '\" + propertyName + \"'\");\n     }\n+\n+    protected static int asInteger(Object value, String propertyName) {\n+        if (value instanceof Integer) {\n+            return (int) value;\n+        }\n+        throw new JSONParserException(\"Invalid int value '\" + value + \"' for element '\" + propertyName + \"'\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcxNjcyNQ==", "bodyText": "This description is outdated now.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488716725", "createdAt": "2020-09-15T14:32:39Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/doc-files/SerializationConfigurationFilesHelp.txt", "diffHunk": "@@ -0,0 +1,19 @@\n+One or several (comma-separated) paths to JSON files that specify lists of serialization configurations that define Java SerializationConstructorAccessor classes.\n+The structure is an array of elements specifying the parameters of method\n+\n+    sun.reflect.MethodAccessorGenerator.generateSerializationConstructor(Class<?> declaringClass,\n+                                     Class<?>[] parameterTypes,\n+                                     Class<?>[] checkedExceptions,\n+                                     int modifiers,\n+                                     Class<?> targetConstructorClass)\n+\n+Example:\n+\n+    [\n+        {\"name\":\"java.lang.ArrayList\",\n+         \"parameterTypes\":[],\n+         \"checkedExceptions\":[],\n+         \"modifiers\":\"4\",\n+         \"targetConstructorClass\":\"AbstractList\"\n+        }\n+    ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcxODcyMw==", "bodyText": "This test should compare the checksum as well.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488718723", "createdAt": "2020-09-15T14:35:09Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/restrict/SerializationAccessVerifier.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.agent.restrict;\n+\n+import com.oracle.svm.configure.config.SerializationConfiguration;\n+import com.oracle.svm.configure.trace.AccessAdvisor;\n+import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n+import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+\n+public class SerializationAccessVerifier extends AbstractAccessVerifier {\n+    private final SerializationConfiguration configuration;\n+\n+    public SerializationAccessVerifier(SerializationConfiguration configuration, AccessAdvisor advisor) {\n+        super(advisor);\n+        this.configuration = configuration;\n+    }\n+\n+    public boolean verifyObjectStreamClassConstructor(JNIEnvironment env, String serializationTargetClass, JNIObjectHandle queriedClass, JNIObjectHandle callerClass) {\n+        if (shouldApproveWithoutChecks(env, queriedClass, callerClass)) {\n+            return true;\n+        }\n+        return configuration.contains(serializationTargetClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODcyOTc5OA==", "bodyText": "Please revert so that RuntimeReflectionSupport is registered only here and use the API class RuntimeReflection to register members for reflective access elsewhere.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488729798", "createdAt": "2020-09-15T14:49:22Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/hosted/ReflectionFeature.java", "diffHunk": "@@ -62,8 +62,12 @@ public void duringSetup(DuringSetupAccess a) {\n         access.registerSubstitutionProcessor(subst);\n         ImageSingletons.add(ReflectionSubstitution.class, subst);\n \n-        reflectionData = new ReflectionDataBuilder(access);\n-        ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODczMDg4OQ==", "bodyText": "Please use RuntimeReflection to register classes and members for reflection and not ReflectionDataBuilder directly. You will have an initialization race with ReflectionFeature, but you can delay parsing serialization configuration until beforeAnalysis.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488730889", "createdAt": "2020-09-15T14:50:47Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODczMjAyNA==", "bodyText": "Features are initialized only once, so you can unconditionally register SerializationRegistry here.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488732024", "createdAt": "2020-09-15T14:52:17Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NTA1NQ==", "bodyText": "So a checksum in the configuration is really just the hash code of the name of the declaring class of the generated serialization constructor, right? What kind of guarantees do the checks during the image build provide based on this? From my experiments, I remember that the declaring class of a generated serialization constructor is just a superclass of the target class, like Object, so I would expect that hash codes would be the same for different class loaders. Why not use computeDefaultSUID as discussed earlier?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488775055", "createdAt": "2020-09-15T15:49:18Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -913,6 +918,52 @@ private static String asInternalSignature(Object paramTypesArray) {\n         return null;\n     }\n \n+    private static boolean objectStreamClassConstructor(JNIEnvironment jni, Breakpoint bp) {\n+        JNIObjectHandle callerClass = getDirectCallerClass();\n+        JNIObjectHandle self = getObjectArgument(0);\n+        JNIObjectHandle serializeTargetClass = getObjectArgument(1);\n+        String serializeTargetClassName = getClassNameOrNull(jni, serializeTargetClass);\n+        long checksum = 0;\n+\n+        JNIObjectHandle objectStreamClassInstance = newObjectL(jni, bp.clazz, bp.method, serializeTargetClass);\n+        Object result = nullHandle().notEqual(objectStreamClassInstance);\n+        if (clearException(jni)) {\n+            result = false;\n+        }\n+        if (result.equals(true)) {\n+            JNIObjectHandle cons = getObjectField(jni, bp.clazz, objectStreamClassInstance, \"cons\", \"Ljava/lang/reflect/Constructor;\");\n+            String targetConstructorClassName = \"\";\n+            if (nullHandle().notEqual(cons)) {\n+                JNIObjectHandle constructorClazz = jniFunctions().getGetObjectClass().invoke(jni, cons);\n+                try (CCharPointerHolder getDeclaringClassNameHolder = toCString(\"getDeclaringClass\");\n+                                CCharPointerHolder getDeclaringClassSigHolder = toCString(\"()Ljava/lang/Class;\");) {\n+                    JNIMethodId getDeclaringClassMId = jniFunctions().getGetMethodID().invoke(jni, constructorClazz, getDeclaringClassNameHolder.get(), getDeclaringClassSigHolder.get());\n+                    targetConstructorClassName = getClassNameOrNull(jni, callObjectMethod(jni, cons, getDeclaringClassMId));\n+                    checksum = targetConstructorClassName.hashCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNzUyNg==", "bodyText": "hasInitializer should be sufficient. This is unrelated to the JDK too (it could be any class) and we don't need to mention serializationVersionUID here.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488827526", "createdAt": "2020-09-15T17:11:02Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/classinitialization/ClassInitializationInfo.java", "diffHunk": "@@ -124,18 +130,37 @@\n      */\n     private Condition initCondition;\n \n+    /**\n+     * Indicates if the class has a {@code <clinit>} method in its original JDK version, no matter\n+     * if it should be initialized at native image's build time or run time . It is used for\n+     * calculating serializationUID when it was not set.\n+     */\n+    private boolean hasOriginalInitializer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgyNzgwMg==", "bodyText": "Please name hasInitializer, no trouble if it has the same name as the field.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488827802", "createdAt": "2020-09-15T17:11:35Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/classinitialization/ClassInitializationInfo.java", "diffHunk": "@@ -124,18 +130,37 @@\n      */\n     private Condition initCondition;\n \n+    /**\n+     * Indicates if the class has a {@code <clinit>} method in its original JDK version, no matter\n+     * if it should be initialized at native image's build time or run time . It is used for\n+     * calculating serializationUID when it was not set.\n+     */\n+    private boolean hasOriginalInitializer;\n+\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    private ClassInitializationInfo(InitState initState, boolean hasOriginalInitializer) {\n+        this(initState);\n+        this.hasOriginalInitializer = hasOriginalInitializer;\n+    }\n+\n     @Platforms(Platform.HOSTED_ONLY.class)\n     private ClassInitializationInfo(InitState initState) {\n         this.classInitializer = null;\n         this.initState = initState;\n         this.initLock = initState == InitState.FullyInitialized ? null : new ReentrantLock();\n+        this.hasOriginalInitializer = true;\n     }\n \n     @Platforms(Platform.HOSTED_ONLY.class)\n     public ClassInitializationInfo(CFunctionPointer classInitializer) {\n         this.classInitializer = classInitializer == null || classInitializer.isNull() ? null : new ClassInitializerFunctionPointerHolder(classInitializer);\n         this.initState = InitState.Linked;\n         this.initLock = new ReentrantLock();\n+        this.hasOriginalInitializer = true;\n+    }\n+\n+    public boolean isHasOriginalInitializer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNjIyNQ==", "bodyText": "These can be final.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488836225", "createdAt": "2020-09-15T17:23:33Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/SerializationKey.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.configure;\n+\n+public class SerializationKey {\n+    private String serializationTargetClass;\n+    private Long checksum;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNzUwNg==", "bodyText": "This should be Target_jdk_internal_reflect_SerializationConstructorAccessorImpl.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488837506", "createdAt": "2020-09-15T17:24:45Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/Target_jdk_internal_reflect_AccessorGenerator.java", "diffHunk": "@@ -24,15 +24,28 @@\n  */\n package com.oracle.svm.core.jdk;\n \n-import com.oracle.svm.core.annotate.Delete;\n+import com.oracle.svm.core.annotate.Substitute;\n import com.oracle.svm.core.annotate.TargetClass;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import org.graalvm.nativeimage.ImageSingletons;\n \n-@Delete\n @TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"AccessorGenerator\")\n public final class Target_jdk_internal_reflect_AccessorGenerator {\n }\n \n-@Delete\n @TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"MethodAccessorGenerator\")\n final class Target_jdk_internal_reflect_MethodAccessorGenerator {\n+    @Substitute\n+    public Target_SerializationConstructorAccessorImpl generateSerializationConstructor(Class<?> declaringClass,\n+                    Class<?>[] parameterTypes,\n+                    Class<?>[] checkedExceptions,\n+                    int modifiers,\n+                    Class<?> targetConstructorClass) {\n+        SerializationRegistry serializationRegistry = ImageSingletons.lookup(SerializationRegistry.class);\n+        return (Target_SerializationConstructorAccessorImpl) serializationRegistry.getSerializationConstructorAccessorClass(declaringClass, targetConstructorClass.getName());\n+    }\n+}\n+\n+@TargetClass(classNameProvider = Package_jdk_internal_reflect.class, className = \"SerializationConstructorAccessorImpl\")\n+final class Target_SerializationConstructorAccessorImpl {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMTMwMA==", "bodyText": "Class MethodAccessorGenerator is an implementation detail of object serialization, so the location from where it is used will not be very helpful to users. I think it would be more helpful to check for ObjectInputStream.readObject, .readUnshared, and ObjectOutputStream.writeObject, .writeUnshared (and maybe their String variants).", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488901300", "createdAt": "2020-09-15T19:04:52Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/FallbackFeature.java", "diffHunk": "@@ -167,7 +169,11 @@ public FallbackFeature() {\n             addCheck(Proxy.class.getMethod(\"newProxyInstance\", ClassLoader.class, Class[].class, InvocationHandler.class), this::collectProxyInvokes);\n \n             addCheck(System.class.getMethod(\"loadLibrary\", String.class), this::collectJNIInvokes);\n-        } catch (NoSuchMethodException e) {\n+\n+            Class<?> generatorClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".MethodAccessorGenerator\");\n+            Method generateMethod = generatorClass.getMethod(\"generateSerializationConstructor\", Class.class, Class[].class, Class[].class, int.class, Class.class);\n+            addCheck(generateMethod, this::collectSerializationInvokes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMjgwNw==", "bodyText": "Most of the declarations in this file are probably no longer needed, please back them out for a smaller patch.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488902807", "createdAt": "2020-09-15T19:07:34Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.jni/src/com/oracle/svm/jni/nativeapi/JNIFunctionPointerTypes.java", "diffHunk": "@@ -212,6 +217,31 @@\n         CCharPointer invoke(JNIEnvironment env, JNIObjectHandle byteArray, CCharPointer elements, int mode);\n     }\n \n+    public interface CallObjectMethod0FunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        JNIObjectHandle invoke(JNIEnvironment env, JNIObjectHandle objOrClass, JNIMethodId methodID);\n+    }\n+\n+    public interface CallIntMethodFunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        int invoke(JNIEnvironment env, JNIObjectHandle objOrClass, JNIMethodId methodID);\n+    }\n+\n+    public interface GetObjectFieldFunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        JNIObjectHandle invoke(JNIEnvironment env, JNIObjectHandle obj, JNIFieldId fieldId);\n+    }\n+\n+    public interface CallStaticLongMethodAFunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        long invoke(JNIEnvironment env, JNIObjectHandle clazz, JNIMethodId methodID, JNIValue args);\n+    }\n+\n+    public interface CallStaticObjectMethodAFunctionPointer extends CFunctionPointer {\n+        @InvokeCFunctionPointer\n+        JNIObjectHandle invoke(JNIEnvironment env, JNIObjectHandle clazz, JNIMethodId methodID, JNIValue args);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNDEzMA==", "bodyText": "This should be consistent with the other methods and not throw an exception. It could be solved by passing in a CIntPointer from the caller and returning a boolean whether it was successful. Also, the variable should not be called handlePtr since it does not contain a handle.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488904130", "createdAt": "2020-09-15T19:10:00Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.jvmtiagentbase/src/com/oracle/svm/jvmtiagentbase/Support.java", "diffHunk": "@@ -182,6 +182,15 @@ public static JNIObjectHandle getObjectArgument(int slot) {\n         return handlePtr.read();\n     }\n \n+    public static int getIntArgument(int slot) {\n+        CIntPointer handlePtr = StackValue.get(CIntPointer.class);\n+        JvmtiError error = jvmtiFunctions().GetLocalInt().invoke(jvmtiEnv(), nullHandle(), 0, slot, handlePtr);\n+        if (error != JvmtiError.JVMTI_ERROR_NONE) {\n+            throw new RuntimeException(error.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNTM2Ng==", "bodyText": "Please use ReflectionUtil.newInstance, which also takes care of the module system, and ReflectionUtil.lookupMethod for below.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488905366", "createdAt": "2020-09-15T19:12:23Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/serialize/SerializationRegistry.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.jdk.serialize;\n+\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public interface SerializationRegistry {\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long checksum);\n+\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    void reportErrors(FeatureAccess access);\n+\n+    Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass);\n+\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    static Object createSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Class<?>[] parameterTypes, Class<?>[] checkedExceptions,\n+                    int modifiers, Class<?> targetConstructorClass) {\n+        try {\n+            Class<?> generatorClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".MethodAccessorGenerator\");\n+            Constructor<?> c = generatorClass.getDeclaredConstructor();\n+            c.setAccessible(true);\n+            Object generator = c.newInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzEwOQ==", "bodyText": "Typo: registerAllFieds", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488907109", "createdAt": "2020-09-15T19:15:35Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            try {\n+                reflectionData.register(targetConstructor.getDeclaredConstructor());\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                reflectionData.register(serializationTargetClass.getDeclaredConstructor((Class<?>[]) null));\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        reflectionData.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFieds = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMTczMQ==", "bodyText": "Are the hosted-only methods really needed in this interface? Seems like the serialization code can just use the implementation class directly, and only the runtime methods need to be declared here.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488911731", "createdAt": "2020-09-15T19:22:45Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/serialize/SerializationRegistry.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.jdk.serialize;\n+\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public interface SerializationRegistry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjU5OQ==", "bodyText": "I'm not sure if we need such an option, we should just support that the checksum is not present in a configuration file, and then not do any checks.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488912599", "createdAt": "2020-09-15T19:23:52Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjg4MQ==", "bodyText": "Please use ReflectionUtil below.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488912881", "createdAt": "2020-09-15T19:24:14Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNDg2MQ==", "bodyText": "Why is field/method access not required when serialVersionUID is present?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488914861", "createdAt": "2020-09-15T19:26:32Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            try {\n+                reflectionData.register(targetConstructor.getDeclaredConstructor());\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                reflectionData.register(serializationTargetClass.getDeclaredConstructor((Class<?>[]) null));\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        reflectionData.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFieds = false;\n+        try {\n+            serializationTargetClass.getDeclaredField(\"serialVersionUID\");\n+        } catch (NoSuchFieldException e) {\n+            registerAllMethods = true;\n+            registerAllFieds = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNjQ3Nw==", "bodyText": "registerAllMethods == true should have a short-cut path rather than going through all cases for each method below.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488916477", "createdAt": "2020-09-15T19:28:24Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            try {\n+                reflectionData.register(targetConstructor.getDeclaredConstructor());\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                reflectionData.register(serializationTargetClass.getDeclaredConstructor((Class<?>[]) null));\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        reflectionData.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFieds = false;\n+        try {\n+            serializationTargetClass.getDeclaredField(\"serialVersionUID\");\n+        } catch (NoSuchFieldException e) {\n+            registerAllMethods = true;\n+            registerAllFieds = true;\n+            reflectionData.register(serializationTargetClass.getDeclaredConstructors());\n+        }\n+\n+        registerMethods(reflectionData, serializationTargetClass, registerAllMethods);\n+        registerFields(reflectionData, serializationTargetClass, registerAllFieds);\n+    }\n+\n+    private static void registerMethods(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, boolean registerAllMethods) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxODcxNw==", "bodyText": "Please rewrite using ReflectionUtil and avoid such catch-all constructs.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488918717", "createdAt": "2020-09-15T19:30:58Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void duringSetup(DuringSetupAccess a) {\n+        FeatureImpl.DuringSetupAccessImpl access = (FeatureImpl.DuringSetupAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport;\n+        if (ImageSingletons.contains(SerializationRegistry.class)) {\n+            serializationSupport = (SerializationSupport) ImageSingletons.lookup(SerializationRegistry.class);\n+        } else {\n+            serializationSupport = new SerializationSupport();\n+            ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+        }\n+\n+        ReflectionDataBuilder reflectionData;\n+        if (ImageSingletons.contains(RuntimeReflectionSupport.class)) {\n+            reflectionData = (ReflectionDataBuilder) ImageSingletons.lookup(RuntimeReflectionSupport.class);\n+        } else {\n+            reflectionData = new ReflectionDataBuilder(access);\n+            ImageSingletons.add(RuntimeReflectionSupport.class, reflectionData);\n+        }\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, imageClassLoader);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(reflectionData, serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, Class<?> targetConstructor) {\n+        if (targetConstructor != null) {\n+            try {\n+                reflectionData.register(targetConstructor.getDeclaredConstructor());\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                reflectionData.register(serializationTargetClass.getDeclaredConstructor((Class<?>[]) null));\n+            } catch (NoSuchMethodException e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        reflectionData.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFieds = false;\n+        try {\n+            serializationTargetClass.getDeclaredField(\"serialVersionUID\");\n+        } catch (NoSuchFieldException e) {\n+            registerAllMethods = true;\n+            registerAllFieds = true;\n+            reflectionData.register(serializationTargetClass.getDeclaredConstructors());\n+        }\n+\n+        registerMethods(reflectionData, serializationTargetClass, registerAllMethods);\n+        registerFields(reflectionData, serializationTargetClass, registerAllFieds);\n+    }\n+\n+    private static void registerMethods(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, boolean registerAllMethods) {\n+        for (Method m : serializationTargetClass.getDeclaredMethods()) {\n+            boolean register;\n+            switch (m.getName()) {\n+                case \"readObject\":\n+                    register = m.getParameterCount() == 1 && m.getParameterTypes()[0].getName().equals(\"java.io.ObjectInputStream\");\n+                    break;\n+                case \"writeObject\":\n+                    register = m.getParameterCount() == 1 && m.getParameterTypes()[0].getName().equals(\"java.io.ObjectOutputStream\");\n+                    break;\n+                case \"readObjectNoData\":\n+                case \"writeReplace\":\n+                case \"readResolve\":\n+                    register = true;\n+                    break;\n+                default:\n+                    register = false;\n+            }\n+            if (register || registerAllMethods) {\n+                reflectionData.register(m);\n+            }\n+        }\n+    }\n+\n+    private static void registerFields(ReflectionDataBuilder reflectionData, Class<?> serializationTargetClass, boolean registerAllFieds) {\n+        int mask = Modifier.STATIC | Modifier.TRANSIENT;\n+        int staticFinalMask = Modifier.STATIC | Modifier.FINAL;\n+        int privateStaticFinalMask = Modifier.PRIVATE | staticFinalMask;\n+\n+        Set<String> serialPersistentFieldNames = new HashSet<>();\n+        try {\n+            Field f = serializationTargetClass.getDeclaredField(\"serialPersistentFields\");\n+            if ((f.getModifiers() & privateStaticFinalMask) == privateStaticFinalMask) {\n+                f.setAccessible(true);\n+                ObjectStreamField[] serialPersistentFields = (ObjectStreamField[]) f.get(null);\n+                for (int i = 0; i < serialPersistentFields.length; i++) {\n+                    serialPersistentFieldNames.add(serialPersistentFields[i].getName());\n+                }\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMDM1NQ==", "bodyText": "Also, this should be a HostedOptionKey, then you can simply call getValue().", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488920355", "createdAt": "2020-09-15T19:32:56Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjU5OQ=="}, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMjE1OA==", "bodyText": "I still think this patch needs substitutions to reset ObjectStreamClass.Caches members as described before.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488922158", "createdAt": "2020-09-15T19:34:53Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNDIxNA==", "bodyText": "Please use ReflectionUtil here and in the rest of the code.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488924214", "createdAt": "2020-09-15T19:37:11Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;\n+    private List<String> verifyChecksumErrors;\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        serializationTargetAndChecksums = new ConcurrentHashMap<>();\n+        verifyChecksumErrors = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void reportErrors(FeatureAccess access) {\n+        reportMultiClassLoaderIssue((FeatureImpl.DuringSetupAccessImpl) access);\n+        reportVerifyChecksumFail((FeatureImpl.DuringSetupAccessImpl) access);\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportVerifyChecksumFail(FeatureImpl.DuringSetupAccessImpl access) {\n+        if (verifyChecksumErrors.size() > 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"\\nDetected \").append(verifyChecksumErrors.size()).append(\" build time class checksum verify failures.\")\n+                            .append(\" These classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+            for (int i = 0; i < verifyChecksumErrors.size(); i++) {\n+                sb.append(\"(\").append(i + 1).append(\") \").append(verifyChecksumErrors.get(i)).append(\"\\n\");\n+            }\n+            String errorMsg = sb.toString();\n+            String option = SubstrateOptionsParser.commandArgument(SerializationFeatureOptions.AllowUncheckedSerialization, \"+\");\n+            if (!SerializationFeatureOptions.AllowUncheckedSerialization.getValue(HostedOptionValues.singleton())) {\n+                BigBang bb = access.getBigBang();\n+                String className = \"MethodAccessorGenerator\";\n+\n+                bb.getUnsupportedFeatures().addMessage(CHECKSUM_VERIFY_FAIL, null,\n+                                errorMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" +\n+                                                option);\n+            } else {\n+                System.out.println(errorMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportMultiClassLoaderIssue(FeatureImpl.DuringSetupAccessImpl access) {\n+        StringBuilder sb = new StringBuilder();\n+        serializationTargetAndChecksums.forEach((targetClass, definitions) -> {\n+            int size = definitions.size();\n+            if (size > 1) {\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"There are \" + size + \" SerializationConstructorAccessor classes have been defined for the same serialization target class:\\n\\n\");\n+                int i = 0;\n+                while (i < size) {\n+                    sb.append(\"(\").append((i + 1)).append(\")\");\n+                    sb.append(definitions.get(i).toString());\n+                    sb.append(\"\\n\");\n+                    i++;\n+                }\n+            }\n+        });\n+        String exceptionsMsg = sb.toString();\n+        // Checkstyle: stop\n+        if (exceptionsMsg.length() > 0) {\n+            String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+            if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(MULTIPLE_CHECKSUMS, null,\n+                                exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+            } else {\n+                System.out.println(exceptionsMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    @Override\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum) {\n+        if (serializationTargetClass.isArray() || serializationTargetClass.isEnum()) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ObjectStreamClass.class.getDeclaredMethod(\"getExternalizableConstructor\", Class.class);\n+                getExternalizableConstructor.setAccessible(true);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNjgzMw==", "bodyText": "Please use a simple POJO class for the value here rather than an entire key-value map.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488926833", "createdAt": "2020-09-15T19:40:09Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyODYzOQ==", "bodyText": "I don't really see the need to track these duplicates and checksums separately -- instead, the only error should be a mismatching checksum, and we can just record these as messages when we see them and submit to bb.getUnsupportedFeatures().", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488928639", "createdAt": "2020-09-15T19:42:16Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyOTIxOQ==", "bodyText": "As I mentioned elsewhere, I don't think the checksum should be required (although the agent should set it).", "url": "https://github.com/oracle/graal/pull/2730#discussion_r488929219", "createdAt": "2020-09-15T19:42:56Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;\n+    private List<String> verifyChecksumErrors;\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        serializationTargetAndChecksums = new ConcurrentHashMap<>();\n+        verifyChecksumErrors = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void reportErrors(FeatureAccess access) {\n+        reportMultiClassLoaderIssue((FeatureImpl.DuringSetupAccessImpl) access);\n+        reportVerifyChecksumFail((FeatureImpl.DuringSetupAccessImpl) access);\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportVerifyChecksumFail(FeatureImpl.DuringSetupAccessImpl access) {\n+        if (verifyChecksumErrors.size() > 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"\\nDetected \").append(verifyChecksumErrors.size()).append(\" build time class checksum verify failures.\")\n+                            .append(\" These classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+            for (int i = 0; i < verifyChecksumErrors.size(); i++) {\n+                sb.append(\"(\").append(i + 1).append(\") \").append(verifyChecksumErrors.get(i)).append(\"\\n\");\n+            }\n+            String errorMsg = sb.toString();\n+            String option = SubstrateOptionsParser.commandArgument(SerializationFeatureOptions.AllowUncheckedSerialization, \"+\");\n+            if (!SerializationFeatureOptions.AllowUncheckedSerialization.getValue(HostedOptionValues.singleton())) {\n+                BigBang bb = access.getBigBang();\n+                String className = \"MethodAccessorGenerator\";\n+\n+                bb.getUnsupportedFeatures().addMessage(CHECKSUM_VERIFY_FAIL, null,\n+                                errorMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" +\n+                                                option);\n+            } else {\n+                System.out.println(errorMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportMultiClassLoaderIssue(FeatureImpl.DuringSetupAccessImpl access) {\n+        StringBuilder sb = new StringBuilder();\n+        serializationTargetAndChecksums.forEach((targetClass, definitions) -> {\n+            int size = definitions.size();\n+            if (size > 1) {\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"There are \" + size + \" SerializationConstructorAccessor classes have been defined for the same serialization target class:\\n\\n\");\n+                int i = 0;\n+                while (i < size) {\n+                    sb.append(\"(\").append((i + 1)).append(\")\");\n+                    sb.append(definitions.get(i).toString());\n+                    sb.append(\"\\n\");\n+                    i++;\n+                }\n+            }\n+        });\n+        String exceptionsMsg = sb.toString();\n+        // Checkstyle: stop\n+        if (exceptionsMsg.length() > 0) {\n+            String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+            if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(MULTIPLE_CHECKSUMS, null,\n+                                exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+            } else {\n+                System.out.println(exceptionsMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    @Override\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum) {\n+        if (serializationTargetClass.isArray() || serializationTargetClass.isEnum()) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ObjectStreamClass.class.getDeclaredMethod(\"getExternalizableConstructor\", Class.class);\n+                getExternalizableConstructor.setAccessible(true);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                VMError.shouldNotReachHere();\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        SerializationKey serializationKey = new SerializationKey(targetClassName, configuredChecksum);\n+        ReflectionFactory reflFactory = ReflectionFactory.getReflectionFactory();\n+        Constructor<?> buildTimeConstructor = reflFactory.newConstructorForSerialization(serializationTargetClass);\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        if (configuredChecksum != null) {\n+            long buildTimeChecksum = getSerializationChecksum(buildTimeConsClass.getName());\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                verifyChecksumErrors.add(sb.toString());\n+            }\n+        } else {\n+            verifyChecksumErrors.add(\"Checksum for class \" + targetClassName + \" was not set in configuration\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 169}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b4c3dee22257d87c46be18eb6980f1ff2f294f16", "committedDate": "2020-09-07T05:44:38Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "69562906cdc41eef2d3436247d95d4d863f6d7ad", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/69562906cdc41eef2d3436247d95d4d863f6d7ad", "committedDate": "2020-09-16T02:59:07Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "69562906cdc41eef2d3436247d95d4d863f6d7ad", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/69562906cdc41eef2d3436247d95d4d863f6d7ad", "committedDate": "2020-09-16T02:59:07Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "d6b08b48efdf82f912c35e40495b108381746da4", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/d6b08b48efdf82f912c35e40495b108381746da4", "committedDate": "2020-09-17T02:30:47Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d6b08b48efdf82f912c35e40495b108381746da4", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/d6b08b48efdf82f912c35e40495b108381746da4", "committedDate": "2020-09-17T02:30:47Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "60ba70e4c95381643f894bbe2b6d58897bfb975f", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/60ba70e4c95381643f894bbe2b6d58897bfb975f", "committedDate": "2020-09-17T04:46:23Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60ba70e4c95381643f894bbe2b6d58897bfb975f", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/60ba70e4c95381643f894bbe2b6d58897bfb975f", "committedDate": "2020-09-17T04:46:23Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/fd40bb015a72d7da048ea0e0e8a632d5df9a47e1", "committedDate": "2020-09-23T06:15:40Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NzkwMDEx", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-494790011", "createdAt": "2020-09-23T15:33:05Z", "commit": {"oid": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNTozMzowNlrOHW0c2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNTo0ODowN1rOHYJIhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5MDA3NA==", "bodyText": "Please rename to hasInitializer().", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493690074", "createdAt": "2020-09-23T15:33:06Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/classinitialization/ClassInitializationInfo.java", "diffHunk": "@@ -124,18 +130,36 @@\n      */\n     private Condition initCondition;\n \n+    /**\n+     * Indicates if the class has a {@code <clinit>} method, no matter if it should be initialized\n+     * at native image's build time or run time.\n+     */\n+    private boolean hasInitializer;\n+\n+    @Platforms(Platform.HOSTED_ONLY.class)\n+    private ClassInitializationInfo(InitState initState, boolean hasInitializer) {\n+        this(initState);\n+        this.hasInitializer = hasInitializer;\n+    }\n+\n     @Platforms(Platform.HOSTED_ONLY.class)\n     private ClassInitializationInfo(InitState initState) {\n         this.classInitializer = null;\n         this.initState = initState;\n         this.initLock = initState == InitState.FullyInitialized ? null : new ReentrantLock();\n+        this.hasInitializer = true;\n     }\n \n     @Platforms(Platform.HOSTED_ONLY.class)\n     public ClassInitializationInfo(CFunctionPointer classInitializer) {\n         this.classInitializer = classInitializer == null || classInitializer.isNull() ? null : new ClassInitializerFunctionPointerHolder(classInitializer);\n         this.initState = InitState.Linked;\n         this.initLock = new ReentrantLock();\n+        this.hasInitializer = true;\n+    }\n+\n+    public boolean isHasInitializer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5MjE2Nw==", "bodyText": "There are still hosted methods in this interface.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493692167", "createdAt": "2020-09-23T15:35:54Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/serialize/SerializationRegistry.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.core.jdk.serialize;\n+\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public interface SerializationRegistry {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMTczMQ=="}, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcwMDgzMA==", "bodyText": "I'm not proposing to remove ObjectStreamClass.Caches, I'm arguing that the maps and reference queues in its fields should be reset via @Alias @RecomputeFieldValue(kind = RecomputeFieldValue.Kind.NewInstance). This way, they will be empty in the image heap, and no unneeded or outdated objects will be carried over from the image builder into the native image, and it will only contain objects created at image runtime through your code.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493700830", "createdAt": "2020-09-23T15:47:53Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMjE1OA=="}, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcwMzc1OA==", "bodyText": "There is no need to call setAccessible when using ReflectionUtil, please remove here and check for any other usages.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493703758", "createdAt": "2020-09-23T15:51:51Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;\n+    private List<String> verifyChecksumErrors;\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        serializationTargetAndChecksums = new ConcurrentHashMap<>();\n+        verifyChecksumErrors = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void reportErrors(FeatureAccess access) {\n+        reportMultiClassLoaderIssue((FeatureImpl.DuringSetupAccessImpl) access);\n+        reportVerifyChecksumFail((FeatureImpl.DuringSetupAccessImpl) access);\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportVerifyChecksumFail(FeatureImpl.DuringSetupAccessImpl access) {\n+        if (verifyChecksumErrors.size() > 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"\\nDetected \").append(verifyChecksumErrors.size()).append(\" build time class checksum verify failures.\")\n+                            .append(\" These classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+            for (int i = 0; i < verifyChecksumErrors.size(); i++) {\n+                sb.append(\"(\").append(i + 1).append(\") \").append(verifyChecksumErrors.get(i)).append(\"\\n\");\n+            }\n+            String errorMsg = sb.toString();\n+            String option = SubstrateOptionsParser.commandArgument(SerializationFeatureOptions.AllowUncheckedSerialization, \"+\");\n+            if (!SerializationFeatureOptions.AllowUncheckedSerialization.getValue(HostedOptionValues.singleton())) {\n+                BigBang bb = access.getBigBang();\n+                String className = \"MethodAccessorGenerator\";\n+\n+                bb.getUnsupportedFeatures().addMessage(CHECKSUM_VERIFY_FAIL, null,\n+                                errorMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" +\n+                                                option);\n+            } else {\n+                System.out.println(errorMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportMultiClassLoaderIssue(FeatureImpl.DuringSetupAccessImpl access) {\n+        StringBuilder sb = new StringBuilder();\n+        serializationTargetAndChecksums.forEach((targetClass, definitions) -> {\n+            int size = definitions.size();\n+            if (size > 1) {\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"There are \" + size + \" SerializationConstructorAccessor classes have been defined for the same serialization target class:\\n\\n\");\n+                int i = 0;\n+                while (i < size) {\n+                    sb.append(\"(\").append((i + 1)).append(\")\");\n+                    sb.append(definitions.get(i).toString());\n+                    sb.append(\"\\n\");\n+                    i++;\n+                }\n+            }\n+        });\n+        String exceptionsMsg = sb.toString();\n+        // Checkstyle: stop\n+        if (exceptionsMsg.length() > 0) {\n+            String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+            if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(MULTIPLE_CHECKSUMS, null,\n+                                exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+            } else {\n+                System.out.println(exceptionsMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    @Override\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum) {\n+        if (serializationTargetClass.isArray() || serializationTargetClass.isEnum()) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ObjectStreamClass.class.getDeclaredMethod(\"getExternalizableConstructor\", Class.class);\n+                getExternalizableConstructor.setAccessible(true);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNDIxNA=="}, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzcxNTY2Nw==", "bodyText": "Thanks for adding this comment.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r493715667", "createdAt": "2020-09-23T16:08:52Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.hosted.RuntimeReflection;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }\n+\n+    @Override\n+    public void beforeAnalysis(BeforeAnalysisAccess a) {\n+        FeatureImpl.BeforeAnalysisAccessImpl access = (FeatureImpl.BeforeAnalysisAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport = new SerializationSupport();\n+        ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, access);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum);\n+                addReflections(serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+        serializationSupport.reportErrors(access);\n+    }\n+\n+    public static void addReflections(Class<?> serializationTargetClass, Class<?> targetConstructorClass) {\n+        if (targetConstructorClass != null) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(targetConstructorClass));\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(serializationTargetClass, (Class<?>[]) null));\n+        }\n+\n+        RuntimeReflection.register(serializationTargetClass);\n+        boolean registerAllMethods = false;\n+        boolean registerAllFields = false;\n+        try {\n+            ReflectionUtil.lookupField(serializationTargetClass, \"serialVersionUID\");\n+        } catch (ReflectionUtil.ReflectionUtilError e) {\n+            /**\n+             * No field serialVersionUID suggests method ObjectSteamClass.computeDefaultSUID() shall\n+             * be called, and it will eventually call getDeclaredMethods, getDeclaredFields and\n+             * getDeclaredConstructors. So we need to prepare reflection data for them.\n+             */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0NzU5Mg==", "bodyText": "I'm not arguing that these checks should be disabled. We should always verify the checksum when it is present in the configuration file, and the agent should always include it in its generated configuration files. But we should still support that a user hand-writes a configuration file without knowing the checksum, or chooses to omit the checksum in a generated configuration file, for example to avoid re-running the agent to keep it up to date. Then we also don't need a new option, we can just require a user to not state the checksum in the configuration for that behavior, and it's more selective than disabling checks completely.\nOn that topic: the agent has a configuration-merging feature (config-merge-dir) where we need to think about what to do if the configurations contain the same serializable class with different checksums.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r494847592", "createdAt": "2020-09-25T08:57:45Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.hosted.ReflectionDataBuilder;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import org.graalvm.compiler.options.Option;\n+import org.graalvm.compiler.options.OptionKey;\n+import org.graalvm.compiler.options.OptionType;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.impl.RuntimeReflectionSupport;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    public static class SerializationFeatureOptions {\n+        @Option(help = \"Allow user don't set checksum in serialization configuration, and no build time checksum verify will be executed. May lead to unexpected run time behaviors.\", type = OptionType.User)\n+//\n+        public static final OptionKey<Boolean> AllowUncheckedSerialization = new OptionKey<>(false);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMjU5OQ=="}, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg3MDIyOA==", "bodyText": "The SerializationConstructorAccessor bit should be an implementation detail. For a user, it should be a configuration file (or multiple) where he/she lists classes which will can be serialized and deserialized in the native image. The checksum should be optional and how it is generated should be an implementation detail of the agent.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r494870228", "createdAt": "2020-09-25T09:38:09Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/configure/doc-files/SerializationConfigurationFilesHelp.txt", "diffHunk": "@@ -0,0 +1,11 @@\n+One or several (comma-separated) paths to JSON files that specify lists of serialization configurations that define Java SerializationConstructorAccessor classes.\n+The structure is an array of elements specifying the target serialization class name and a checksum calculated from its constructor's declaring class name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg4NTI4OQ==", "bodyText": "It's sufficient to check whether cachedSerializationConstructorAccessors already contains the class. Trying to register multiple classes with different checksums does not make sense because we only have a single image classloader. We can always call bb.getUnsupportedFeatures().addMessage() when that happens and print the two checksums, there is no need to collect the messages here first.\nWith verifyChecksumErrors, the code should also call bb.getUnsupportedFeatures().addMessage() immediately whenever there is a checksum mismatch.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r494885289", "createdAt": "2020-09-25T10:04:54Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.ReflectionFactory;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, Map<String, Object>> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyODYzOQ=="}, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0MDMzOA==", "bodyText": "Please use throw VMError.shouldNotReachHere(e) to preserve the exception (also applies below and possibly elsewhere).", "url": "https://github.com/oracle/graal/pull/2730#discussion_r495040338", "createdAt": "2020-09-25T14:48:50Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.configure.SerializationKey;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.option.RuntimeOptionValues;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.reflect.serialize.hosted.SerializationFeature.SerializationFeatureOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    /*\n+     * This map is used to track multiple classloader usage. Map key is serialization target class\n+     * name, value is the class name and class hierarchy checksum\n+     */\n+    private Map<String, List<SerializationKey>> serializationTargetAndChecksums;\n+    private List<String> verifyChecksumErrors;\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        serializationTargetAndChecksums = new ConcurrentHashMap<>();\n+        verifyChecksumErrors = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void reportErrors(FeatureAccess access) {\n+        reportMultiClassLoaderIssue((FeatureImpl.BeforeAnalysisAccessImpl) access);\n+        reportVerifyChecksumFail((FeatureImpl.BeforeAnalysisAccessImpl) access);\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportVerifyChecksumFail(FeatureImpl.BeforeAnalysisAccessImpl access) {\n+        if (verifyChecksumErrors.size() > 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"\\nDetected \").append(verifyChecksumErrors.size()).append(\" build time class checksum verify failures.\")\n+                            .append(\" These classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+            for (int i = 0; i < verifyChecksumErrors.size(); i++) {\n+                sb.append(\"(\").append(i + 1).append(\") \").append(verifyChecksumErrors.get(i)).append(\"\\n\");\n+            }\n+            String errorMsg = sb.toString();\n+            String option = SubstrateOptionsParser.commandArgument(SerializationFeatureOptions.AllowUncheckedSerialization, \"+\");\n+            if (!SerializationFeatureOptions.AllowUncheckedSerialization.getValue(HostedOptionValues.singleton())) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(CHECKSUM_VERIFY_FAIL, null,\n+                                errorMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" +\n+                                                option);\n+            } else {\n+                System.out.println(errorMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    private void reportMultiClassLoaderIssue(FeatureImpl.BeforeAnalysisAccessImpl access) {\n+        StringBuilder sb = new StringBuilder();\n+        serializationTargetAndChecksums.forEach((targetClass, definitions) -> {\n+            int size = definitions.size();\n+            if (size > 1) {\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"There are \" + size + \" SerializationConstructorAccessor classes have been defined for the same serialization target class:\\n\\n\");\n+                int i = 0;\n+                while (i < size) {\n+                    sb.append(\"(\").append((i + 1)).append(\")\");\n+                    sb.append(definitions.get(i).toString());\n+                    sb.append(\"\\n\");\n+                    i++;\n+                }\n+            }\n+        });\n+        String exceptionsMsg = sb.toString();\n+        // Checkstyle: stop\n+        if (exceptionsMsg.length() > 0) {\n+            String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+            if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+                BigBang bb = access.getBigBang();\n+                bb.getUnsupportedFeatures().addMessage(MULTIPLE_CHECKSUMS, null,\n+                                exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+            } else {\n+                System.out.println(exceptionsMsg);\n+                System.out.println(\"Compilation will continue because \" + option +\n+                                \" was set. But the program may behave unexpectedly at runtime.\");\n+            }\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    @Override\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum) {\n+        if (serializationTargetClass.isArray() || serializationTargetClass.isEnum()) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                getExternalizableConstructor.setAccessible(true);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                VMError.shouldNotReachHere();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3NzUxMA==", "bodyText": "Thanks for explaining. So we can tell whether the constructor that we generate during the image build matches the constructor from the agent run, but we cannot tell whether the serializable/deserializable class we have for the image build is the same as the ones seen during the agent run, unless their first unserializable superclass is different.\nIs this really sufficient? Why not just use a computed SUID and ensure that we have an exact match? I'm wondering about the specific use case here, and also worry about extensibility of the configuration in case we want to include more per-class information in the future and want to ensure an exact match for that.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r495077510", "createdAt": "2020-09-25T15:48:07Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -913,6 +918,52 @@ private static String asInternalSignature(Object paramTypesArray) {\n         return null;\n     }\n \n+    private static boolean objectStreamClassConstructor(JNIEnvironment jni, Breakpoint bp) {\n+        JNIObjectHandle callerClass = getDirectCallerClass();\n+        JNIObjectHandle self = getObjectArgument(0);\n+        JNIObjectHandle serializeTargetClass = getObjectArgument(1);\n+        String serializeTargetClassName = getClassNameOrNull(jni, serializeTargetClass);\n+        long checksum = 0;\n+\n+        JNIObjectHandle objectStreamClassInstance = newObjectL(jni, bp.clazz, bp.method, serializeTargetClass);\n+        Object result = nullHandle().notEqual(objectStreamClassInstance);\n+        if (clearException(jni)) {\n+            result = false;\n+        }\n+        if (result.equals(true)) {\n+            JNIObjectHandle cons = getObjectField(jni, bp.clazz, objectStreamClassInstance, \"cons\", \"Ljava/lang/reflect/Constructor;\");\n+            String targetConstructorClassName = \"\";\n+            if (nullHandle().notEqual(cons)) {\n+                JNIObjectHandle constructorClazz = jniFunctions().getGetObjectClass().invoke(jni, cons);\n+                try (CCharPointerHolder getDeclaringClassNameHolder = toCString(\"getDeclaringClass\");\n+                                CCharPointerHolder getDeclaringClassSigHolder = toCString(\"()Ljava/lang/Class;\");) {\n+                    JNIMethodId getDeclaringClassMId = jniFunctions().getGetMethodID().invoke(jni, constructorClazz, getDeclaringClassNameHolder.get(), getDeclaringClassSigHolder.get());\n+                    targetConstructorClassName = getClassNameOrNull(jni, callObjectMethod(jni, cons, getDeclaringClassMId));\n+                    checksum = targetConstructorClassName.hashCode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NTA1NQ=="}, "originalCommit": {"oid": "b4c3dee22257d87c46be18eb6980f1ff2f294f16"}, "originalPosition": 63}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd40bb015a72d7da048ea0e0e8a632d5df9a47e1", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/fd40bb015a72d7da048ea0e0e8a632d5df9a47e1", "committedDate": "2020-09-23T06:15:40Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "3f0103f851701e72ed2c40d51711120af5bfd107", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/3f0103f851701e72ed2c40d51711120af5bfd107", "committedDate": "2020-10-10T10:17:50Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f0103f851701e72ed2c40d51711120af5bfd107", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/3f0103f851701e72ed2c40d51711120af5bfd107", "committedDate": "2020-10-10T10:17:50Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "f7d02a0e2629eb85e1b2521ecf654a5da7d76fa0", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/f7d02a0e2629eb85e1b2521ecf654a5da7d76fa0", "committedDate": "2020-10-12T07:14:19Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7d02a0e2629eb85e1b2521ecf654a5da7d76fa0", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/f7d02a0e2629eb85e1b2521ecf654a5da7d76fa0", "committedDate": "2020-10-12T07:14:19Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "ee5a5ed39d22caf078a534c63020b47bcc4feee5", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/ee5a5ed39d22caf078a534c63020b47bcc4feee5", "committedDate": "2020-10-12T11:16:24Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee5a5ed39d22caf078a534c63020b47bcc4feee5", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/ee5a5ed39d22caf078a534c63020b47bcc4feee5", "committedDate": "2020-10-12T11:16:24Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "committedDate": "2020-10-14T02:22:22Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzU4NDE4", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-510758418", "createdAt": "2020-10-16T19:51:08Z", "commit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxOTo1MTowOFrOHjN6cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMToyMzoyMFrOHjQLvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5MDE2Mg==", "bodyText": "This method can be reduced to this line (and inlined) because registerAllMethods is always true.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506690162", "createdAt": "2020-10-16T19:51:08Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.hosted.RuntimeReflection;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    @Override\n+    public void beforeAnalysis(BeforeAnalysisAccess a) {\n+        FeatureImpl.BeforeAnalysisAccessImpl access = (FeatureImpl.BeforeAnalysisAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport = new SerializationSupport();\n+        ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, access);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum, access);\n+                addReflections(serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+    }\n+\n+    public static void addReflections(Class<?> serializationTargetClass, Class<?> targetConstructorClass) {\n+        if (targetConstructorClass != null) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(targetConstructorClass));\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(serializationTargetClass, (Class<?>[]) null));\n+        }\n+\n+        RuntimeReflection.register(serializationTargetClass);\n+        /**\n+         * ObjectStreamClass.computeDefaultSUID is always called at runtime to verify serialization\n+         * class consistency, so need to register all constructors, methods and fields/\n+         */\n+        RuntimeReflection.register(serializationTargetClass.getDeclaredConstructors());\n+        registerMethods(serializationTargetClass, true);\n+        registerFields(serializationTargetClass, true);\n+    }\n+\n+    private static void registerMethods(Class<?> serializationTargetClass, boolean registerAllMethods) {\n+        Method[] allMethods = serializationTargetClass.getDeclaredMethods();\n+        if (registerAllMethods) {\n+            RuntimeReflection.register(allMethods);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5MDg3MQ==", "bodyText": "This method can also be simplified significantly because registerAllFields is always true.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506690871", "createdAt": "2020-10-16T19:52:47Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.hosted.RuntimeReflection;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    @Override\n+    public void beforeAnalysis(BeforeAnalysisAccess a) {\n+        FeatureImpl.BeforeAnalysisAccessImpl access = (FeatureImpl.BeforeAnalysisAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport = new SerializationSupport();\n+        ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, access);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum, access);\n+                addReflections(serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+    }\n+\n+    public static void addReflections(Class<?> serializationTargetClass, Class<?> targetConstructorClass) {\n+        if (targetConstructorClass != null) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(targetConstructorClass));\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(serializationTargetClass, (Class<?>[]) null));\n+        }\n+\n+        RuntimeReflection.register(serializationTargetClass);\n+        /**\n+         * ObjectStreamClass.computeDefaultSUID is always called at runtime to verify serialization\n+         * class consistency, so need to register all constructors, methods and fields/\n+         */\n+        RuntimeReflection.register(serializationTargetClass.getDeclaredConstructors());\n+        registerMethods(serializationTargetClass, true);\n+        registerFields(serializationTargetClass, true);\n+    }\n+\n+    private static void registerMethods(Class<?> serializationTargetClass, boolean registerAllMethods) {\n+        Method[] allMethods = serializationTargetClass.getDeclaredMethods();\n+        if (registerAllMethods) {\n+            RuntimeReflection.register(allMethods);\n+        } else {\n+            for (Method m : allMethods) {\n+                boolean register;\n+                switch (m.getName()) {\n+                    case \"readObject\":\n+                        register = m.getParameterCount() == 1 && m.getParameterTypes()[0].getName().equals(\"java.io.ObjectInputStream\");\n+                        break;\n+                    case \"writeObject\":\n+                        register = m.getParameterCount() == 1 && m.getParameterTypes()[0].getName().equals(\"java.io.ObjectOutputStream\");\n+                        break;\n+                    case \"readObjectNoData\":\n+                    case \"writeReplace\":\n+                    case \"readResolve\":\n+                        register = true;\n+                        break;\n+                    default:\n+                        register = false;\n+                }\n+                if (register) {\n+                    RuntimeReflection.register(m);\n+                }\n+            }\n+        }\n+\n+        // computeDefaultSUID will be reflectively called at runtime to verify class consistency\n+        Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+        RuntimeReflection.register(computeDefaultSUID);\n+    }\n+\n+    private static void registerFields(Class<?> serializationTargetClass, boolean registerAllFields) {\n+        int mask = Modifier.STATIC | Modifier.TRANSIENT;\n+        int staticFinalMask = Modifier.STATIC | Modifier.FINAL;\n+        int privateStaticFinalMask = Modifier.PRIVATE | staticFinalMask;\n+\n+        Set<String> serialPersistentFieldNames = new HashSet<>();\n+        try {\n+            Field f = ReflectionUtil.lookupField(serializationTargetClass, \"serialPersistentFields\");\n+            if ((f.getModifiers() & privateStaticFinalMask) == privateStaticFinalMask) {\n+                f.setAccessible(true);\n+                ObjectStreamField[] serialPersistentFields = (ObjectStreamField[]) f.get(null);\n+                for (int i = 0; i < serialPersistentFields.length; i++) {\n+                    serialPersistentFieldNames.add(serialPersistentFields[i].getName());\n+                }\n+            }\n+        } catch (ReflectionUtil.ReflectionUtilError | ReflectiveOperationException e) {\n+        }\n+\n+        for (Field f : serializationTargetClass.getDeclaredFields()) {\n+            int modifiers = f.getModifiers();\n+            boolean allowWrite = false;\n+            boolean allowUnsafeAccess = false;\n+            if ((modifiers & staticFinalMask) != staticFinalMask) {\n+                allowWrite = Modifier.isFinal(f.getModifiers());\n+                allowUnsafeAccess = !Modifier.isStatic(f.getModifiers());\n+            }\n+            boolean registerField = false;\n+            String fieldName = f.getName();\n+            if (serialPersistentFieldNames.contains(fieldName)) {\n+                registerField = true;\n+            } else {\n+                switch (fieldName) {\n+                    case \"serialPersistentFields\":\n+                        if ((modifiers & privateStaticFinalMask) == privateStaticFinalMask) {\n+                            registerField = true;\n+                        }\n+                        break;\n+                    case \"serialVersionUID\":\n+                        if ((modifiers & staticFinalMask) == staticFinalMask) {\n+                            registerField = true;\n+                        }\n+                        break;\n+                    default:\n+                        if ((modifiers & mask) == 0) {\n+                            registerField = true;\n+                        }\n+                }\n+            }\n+            if (registerField || registerAllFields) {\n+                RuntimeReflection.register(allowWrite, allowUnsafeAccess, f);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcwNzk4MQ==", "bodyText": "Out of curiosity, what problem did you encounter here?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506707981", "createdAt": "2020-10-16T20:33:29Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/json/JSONParser.java", "diffHunk": "@@ -278,6 +278,7 @@ private void skipDigits() {\n     }\n \n     private Number parseNumber() {\n+        boolean isFloating = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcwOTc0NA==", "bodyText": "These can be final (and don't need to be public since the class is private).", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506709744", "createdAt": "2020-10-16T20:38:00Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMDYzMQ==", "bodyText": "existingEntity?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506710631", "createdAt": "2020-10-16T20:40:22Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMTQ2MA==", "bodyText": "Why do the check again at image runtime? It should be sufficient to check at image build time for the class provided by the image class loader.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506711460", "createdAt": "2020-10-16T20:42:14Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitedEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitedEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxMjg2Mw==", "bodyText": "This should not be needed: 0 ^ x == x", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506712863", "createdAt": "2020-10-16T20:45:27Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitedEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitedEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);\n+            // configuredChecksum could be null if it is not set in the configuration.\n+            if ((configuredChecksum != null && configuredChecksum.longValue() == runtimeChecksum) || configuredChecksum == null) {\n+                return accessor;\n+            } else {\n+                throw VMError.unimplemented(\"Serialization target class \" + className + \"'s hierarchy has been changed at run time. Configured checksum is \" + configuredChecksum +\n+                                \", runtime checksum is \" + runtimeChecksum);\n+            }\n+        }\n+    }\n+\n+    private long getSerializationChecksum(Class<?> serializationTargetClass, String constructorClassName) {\n+        try {\n+            if (constructorClassName != null && constructorClassName.length() > 0) {\n+                long checksum = 0L;\n+                String currentClassName = serializationTargetClass.getName();\n+                Class<?> currentClass = serializationTargetClass;\n+                // Compute SUID for each serializable superclass\n+                while (!constructorClassName.equals(currentClassName)) {\n+                    Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+                    long classSUID = (Long) computeDefaultSUID.invoke(null, currentClass);\n+                    if (checksum == 0L) {\n+                        checksum = classSUID;\n+                    } else {\n+                        checksum = checksum ^ classSUID;\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxNDM0Mw==", "bodyText": "It would be preferable to incrementally compute the hash with something like h = h * 31 + x rather than xor-ing all values together, which might result in a weaker hash with a higher chance of collision.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506714343", "createdAt": "2020-10-16T20:49:07Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitedEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitedEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);\n+            // configuredChecksum could be null if it is not set in the configuration.\n+            if ((configuredChecksum != null && configuredChecksum.longValue() == runtimeChecksum) || configuredChecksum == null) {\n+                return accessor;\n+            } else {\n+                throw VMError.unimplemented(\"Serialization target class \" + className + \"'s hierarchy has been changed at run time. Configured checksum is \" + configuredChecksum +\n+                                \", runtime checksum is \" + runtimeChecksum);\n+            }\n+        }\n+    }\n+\n+    private long getSerializationChecksum(Class<?> serializationTargetClass, String constructorClassName) {\n+        try {\n+            if (constructorClassName != null && constructorClassName.length() > 0) {\n+                long checksum = 0L;\n+                String currentClassName = serializationTargetClass.getName();\n+                Class<?> currentClass = serializationTargetClass;\n+                // Compute SUID for each serializable superclass\n+                while (!constructorClassName.equals(currentClassName)) {\n+                    Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+                    long classSUID = (Long) computeDefaultSUID.invoke(null, currentClass);\n+                    if (checksum == 0L) {\n+                        checksum = classSUID;\n+                    } else {\n+                        checksum = checksum ^ classSUID;\n+                    }\n+                    currentClass = currentClass.getSuperclass();\n+                    currentClassName = currentClass.getName();\n+                }\n+\n+                // Combine checksum with first unserializable superclass\n+                return checksum ^ constructorClassName.hashCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcxNDY0Ng==", "bodyText": "Why are exceptions caught here and not handled in a caller class? Does this code frequently throw under some circumstances?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506714646", "createdAt": "2020-10-16T20:49:49Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        public Object serializationConstructorAccessor;\n+        public Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitedEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitedEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitedEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);\n+            // configuredChecksum could be null if it is not set in the configuration.\n+            if ((configuredChecksum != null && configuredChecksum.longValue() == runtimeChecksum) || configuredChecksum == null) {\n+                return accessor;\n+            } else {\n+                throw VMError.unimplemented(\"Serialization target class \" + className + \"'s hierarchy has been changed at run time. Configured checksum is \" + configuredChecksum +\n+                                \", runtime checksum is \" + runtimeChecksum);\n+            }\n+        }\n+    }\n+\n+    private long getSerializationChecksum(Class<?> serializationTargetClass, String constructorClassName) {\n+        try {\n+            if (constructorClassName != null && constructorClassName.length() > 0) {\n+                long checksum = 0L;\n+                String currentClassName = serializationTargetClass.getName();\n+                Class<?> currentClass = serializationTargetClass;\n+                // Compute SUID for each serializable superclass\n+                while (!constructorClassName.equals(currentClassName)) {\n+                    Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+                    long classSUID = (Long) computeDefaultSUID.invoke(null, currentClass);\n+                    if (checksum == 0L) {\n+                        checksum = classSUID;\n+                    } else {\n+                        checksum = checksum ^ classSUID;\n+                    }\n+                    currentClass = currentClass.getSuperclass();\n+                    currentClassName = currentClass.getName();\n+                }\n+\n+                // Combine checksum with first unserializable superclass\n+                return checksum ^ constructorClassName.hashCode();\n+            } else {\n+                return 0L;\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNjYzOQ==", "bodyText": "If I understand correctly, the actions in this method can cause other ObjectStreamClass instances to be initialized and we miss that because the breakpoint is not triggered recursively. In that case, we should change the breakpoint to be in ObjectStreamClass.lookup(Class<?>, boolean) instead, which is called each time when a class is used in serialization, so we should never miss a class. For efficiency, we can just check in a map whether we have already handled this class, but we should still emit an event (with cached data) and do the access check with serializationAccessVerifier. This should be simpler and more reliable than trying to infer those classes from the descriptor cache.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506726639", "createdAt": "2020-10-16T21:21:22Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -913,6 +922,123 @@ private static String asInternalSignature(Object paramTypesArray) {\n         return null;\n     }\n \n+    private static boolean objectStreamClassConstructor(JNIEnvironment jni, Breakpoint bp) {\n+        JNIObjectHandle callerClass = getDirectCallerClass();\n+        JNIObjectHandle self = getObjectArgument(0);\n+        JNIObjectHandle serializeTargetClass = getObjectArgument(1);\n+        String serializeTargetClassName = getClassNameOrNull(jni, serializeTargetClass);\n+        long checksum = 0;\n+        List<SerializationInfo> traceCandidates = new ArrayList<>();\n+        JNIObjectHandle javaIOObjectStreamCaches = agent.handles().findClass(jni, \"java/io/ObjectStreamClass$Caches\");\n+        JNIFieldId localDescsFId = agent.handles().getFieldId(jni, javaIOObjectStreamCaches, \"localDescs\", \"Ljava/util/concurrent/ConcurrentMap;\", true);\n+        JNIObjectHandle concurrentHashMap = agent.handles().findClass(jni, \"Ljava/util/concurrent/ConcurrentHashMap;\");\n+\n+        /** Get ObjectStreamClass.Caches.localDescs' size before init */\n+        JNIObjectHandle localDescs = jniFunctions().getGetStaticObjectField().invoke(jni, javaIOObjectStreamCaches, localDescsFId);\n+        JNIMethodId sizeMId = agent.handles().getMethodId(jni, concurrentHashMap, \"size\", \"()I\", false);\n+        int oldCacheSize = jniFunctions().getCallIntMethodA().invoke(jni, localDescs, sizeMId, nullPointer());\n+\n+        JNIObjectHandle objectStreamClassInstance = newObjectL(jni, bp.clazz, bp.method, serializeTargetClass);\n+        Object result = nullHandle().notEqual(objectStreamClassInstance);\n+        if (clearException(jni)) {\n+            result = false;\n+        }\n+        if (result.equals(true)) {\n+            checksum = getChecksumFromOSC(jni, bp.clazz, objectStreamClassInstance, serializeTargetClass, serializeTargetClassName);\n+        }\n+        traceCandidates.add(new SerializationInfo(serializeTargetClassName, checksum));\n+\n+        /**\n+         * Check if ObjectStreamClass.Caches.localDescs has been changed If there are more elements\n+         * after the execution of ObjectStreamClass.<init>, it suggests the super class(es) of\n+         * current serialization target class get(s) serialized recursively during the process of\n+         * initialization. We need to find out the corresponding classes and checksums and add them\n+         * to the serialization configurations.\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNjg3MQ==", "bodyText": "Why these new imports?", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506726871", "createdAt": "2020-10-16T21:21:54Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/NativeImageAgentJNIHandleSet.java", "diffHunk": "@@ -26,10 +26,13 @@\n \n import static com.oracle.svm.jni.JNIObjectHandles.nullHandle;\n \n+import com.oracle.svm.jni.nativeapi.JNIFieldId;\n import com.oracle.svm.jvmtiagentbase.JNIHandleSet;\n import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n import com.oracle.svm.jni.nativeapi.JNIMethodId;\n import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+import com.oracle.svm.jvmtiagentbase.Support;\n+import org.graalvm.compiler.lir.util.GenericValueMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNzM1Nw==", "bodyText": "Eventually, we should add frequently used JNIMethodId and JNIObjectHandle values in the new code to this class, ideally initializing them lazily, so we can avoid repeated lookups by name.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r506727357", "createdAt": "2020-10-16T21:23:20Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/NativeImageAgentJNIHandleSet.java", "diffHunk": "@@ -26,10 +26,13 @@\n \n import static com.oracle.svm.jni.JNIObjectHandles.nullHandle;\n \n+import com.oracle.svm.jni.nativeapi.JNIFieldId;\n import com.oracle.svm.jvmtiagentbase.JNIHandleSet;\n import com.oracle.svm.jni.nativeapi.JNIEnvironment;\n import com.oracle.svm.jni.nativeapi.JNIMethodId;\n import com.oracle.svm.jni.nativeapi.JNIObjectHandle;\n+import com.oracle.svm.jvmtiagentbase.Support;\n+import org.graalvm.compiler.lir.util.GenericValueMap;\n \n public class NativeImageAgentJNIHandleSet extends JNIHandleSet {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/f5e388c9b0e6db727d0ab012f151dc83a09a54b4", "committedDate": "2020-10-14T02:22:22Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "3c6fb3646345af992772bb355c6fa9ccf44208bf", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/3c6fb3646345af992772bb355c6fa9ccf44208bf", "committedDate": "2020-10-21T07:43:05Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3c6fb3646345af992772bb355c6fa9ccf44208bf", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/3c6fb3646345af992772bb355c6fa9ccf44208bf", "committedDate": "2020-10-21T07:43:05Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "b89aad09c7921013af649d726b0e503c5df7e6f2", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b89aad09c7921013af649d726b0e503c5df7e6f2", "committedDate": "2020-10-21T09:43:14Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNDkyMzU5", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-521492359", "createdAt": "2020-11-02T10:11:45Z", "commit": {"oid": "b89aad09c7921013af649d726b0e503c5df7e6f2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDoxMTo0NVrOHr99Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxMDoxMTo0NVrOHr99Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2NTg5OA==", "bodyText": "You're right, that doesn't help either.\nStill, figuring out which classes were added to the cache seems unreliable for the task of determining the classes that are referenced by the current class. Other threads might add entries to the cache at the same time.\nI think what we should do instead is find the descriptors ourselves. This means reading fields superDesc, iterating dataLayout and reading ClassDataSlot.desc, and perhaps localDesc, and following them recursively (stopping if a descriptor we have already seen and processed a certain descriptor).", "url": "https://github.com/oracle/graal/pull/2730#discussion_r515865898", "createdAt": "2020-11-02T10:11:45Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.agent/src/com/oracle/svm/agent/BreakpointInterceptor.java", "diffHunk": "@@ -913,6 +922,123 @@ private static String asInternalSignature(Object paramTypesArray) {\n         return null;\n     }\n \n+    private static boolean objectStreamClassConstructor(JNIEnvironment jni, Breakpoint bp) {\n+        JNIObjectHandle callerClass = getDirectCallerClass();\n+        JNIObjectHandle self = getObjectArgument(0);\n+        JNIObjectHandle serializeTargetClass = getObjectArgument(1);\n+        String serializeTargetClassName = getClassNameOrNull(jni, serializeTargetClass);\n+        long checksum = 0;\n+        List<SerializationInfo> traceCandidates = new ArrayList<>();\n+        JNIObjectHandle javaIOObjectStreamCaches = agent.handles().findClass(jni, \"java/io/ObjectStreamClass$Caches\");\n+        JNIFieldId localDescsFId = agent.handles().getFieldId(jni, javaIOObjectStreamCaches, \"localDescs\", \"Ljava/util/concurrent/ConcurrentMap;\", true);\n+        JNIObjectHandle concurrentHashMap = agent.handles().findClass(jni, \"Ljava/util/concurrent/ConcurrentHashMap;\");\n+\n+        /** Get ObjectStreamClass.Caches.localDescs' size before init */\n+        JNIObjectHandle localDescs = jniFunctions().getGetStaticObjectField().invoke(jni, javaIOObjectStreamCaches, localDescsFId);\n+        JNIMethodId sizeMId = agent.handles().getMethodId(jni, concurrentHashMap, \"size\", \"()I\", false);\n+        int oldCacheSize = jniFunctions().getCallIntMethodA().invoke(jni, localDescs, sizeMId, nullPointer());\n+\n+        JNIObjectHandle objectStreamClassInstance = newObjectL(jni, bp.clazz, bp.method, serializeTargetClass);\n+        Object result = nullHandle().notEqual(objectStreamClassInstance);\n+        if (clearException(jni)) {\n+            result = false;\n+        }\n+        if (result.equals(true)) {\n+            checksum = getChecksumFromOSC(jni, bp.clazz, objectStreamClassInstance, serializeTargetClass, serializeTargetClassName);\n+        }\n+        traceCandidates.add(new SerializationInfo(serializeTargetClassName, checksum));\n+\n+        /**\n+         * Check if ObjectStreamClass.Caches.localDescs has been changed If there are more elements\n+         * after the execution of ObjectStreamClass.<init>, it suggests the super class(es) of\n+         * current serialization target class get(s) serialized recursively during the process of\n+         * initialization. We need to find out the corresponding classes and checksums and add them\n+         * to the serialization configurations.\n+         */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjcyNjYzOQ=="}, "originalCommit": {"oid": "f5e388c9b0e6db727d0ab012f151dc83a09a54b4"}, "originalPosition": 94}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b89aad09c7921013af649d726b0e503c5df7e6f2", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b89aad09c7921013af649d726b0e503c5df7e6f2", "committedDate": "2020-10-21T09:43:14Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "73ff3a91936d23b224a8062aeb884005e4ae4cfa", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/73ff3a91936d23b224a8062aeb884005e4ae4cfa", "committedDate": "2020-11-12T08:58:05Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "73ff3a91936d23b224a8062aeb884005e4ae4cfa", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/73ff3a91936d23b224a8062aeb884005e4ae4cfa", "committedDate": "2020-11-12T08:58:05Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "cf7defe36271537f22e7b7623261eef8930b15c5", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/cf7defe36271537f22e7b7623261eef8930b15c5", "committedDate": "2020-11-20T12:08:43Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzM1MDM4", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-535735038", "createdAt": "2020-11-20T19:55:21Z", "commit": {"oid": "cf7defe36271537f22e7b7623261eef8930b15c5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxOTo1NToyMlrOH3ezUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDowNDo1OVrOH3fEwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkzODM4Ng==", "bodyText": "This try-catch block should probably apply only to the reflective field lookup.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r527938386", "createdAt": "2020-11-20T19:55:22Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/hosted/SerializationFeature.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize.hosted;\n+\n+import com.oracle.svm.core.annotate.AutomaticFeature;\n+import com.oracle.svm.core.configure.ConfigurationFiles;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser;\n+import com.oracle.svm.core.configure.SerializationConfigurationParser.SerializationParserFunction;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.util.UserError;\n+import com.oracle.svm.core.util.json.JSONParserException;\n+import com.oracle.svm.hosted.FallbackFeature;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.hosted.config.ConfigurationParserUtils;\n+import com.oracle.svm.reflect.serialize.SerializationSupport;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.ImageSingletons;\n+import org.graalvm.nativeimage.hosted.Feature;\n+import org.graalvm.nativeimage.hosted.RuntimeReflection;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+@AutomaticFeature\n+public class SerializationFeature implements Feature {\n+    private int loadedConfigurations;\n+\n+    @Override\n+    public void beforeAnalysis(BeforeAnalysisAccess a) {\n+        FeatureImpl.BeforeAnalysisAccessImpl access = (FeatureImpl.BeforeAnalysisAccessImpl) a;\n+        ImageClassLoader imageClassLoader = access.getImageClassLoader();\n+\n+        SerializationSupport serializationSupport = new SerializationSupport();\n+        ImageSingletons.add(SerializationRegistry.class, serializationSupport);\n+\n+        SerializationParserFunction serializationAdapter = (strTargetSerializationClass, checksum) -> {\n+            Class<?> serializationTargetClass = resolveClass(strTargetSerializationClass, access);\n+            UserError.guarantee(serializationTargetClass != null, \"Cannot find serialization target class %s. The missing of this class can't be ignored even if -H:+AllowIncompleteClasspath is set.\" +\n+                            \" Please make sure it is in the classpath\", strTargetSerializationClass);\n+            if (Serializable.class.isAssignableFrom(serializationTargetClass)) {\n+                Class<?> targetConstructor = serializationSupport.addSerializationConstructorAccessorClass(serializationTargetClass, checksum, access);\n+                addReflections(serializationTargetClass, targetConstructor);\n+            }\n+        };\n+\n+        SerializationConfigurationParser parser = new SerializationConfigurationParser(serializationAdapter);\n+        loadedConfigurations = ConfigurationParserUtils.parseAndRegisterConfigurations(parser, imageClassLoader, \"serialization\",\n+                        ConfigurationFiles.Options.SerializationConfigurationFiles, ConfigurationFiles.Options.SerializationConfigurationResources,\n+                        ConfigurationFiles.SERIALIZATION_NAME);\n+    }\n+\n+    public static void addReflections(Class<?> serializationTargetClass, Class<?> targetConstructorClass) {\n+        if (targetConstructorClass != null) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(targetConstructorClass));\n+        }\n+\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            RuntimeReflection.register(ReflectionUtil.lookupConstructor(serializationTargetClass, (Class<?>[]) null));\n+        }\n+\n+        RuntimeReflection.register(serializationTargetClass);\n+        /**\n+         * ObjectStreamClass.computeDefaultSUID is always called at runtime to verify serialization\n+         * class consistency, so need to register all constructors, methods and fields/\n+         */\n+        RuntimeReflection.register(serializationTargetClass.getDeclaredConstructors());\n+        registerMethods(serializationTargetClass);\n+        registerFields(serializationTargetClass);\n+    }\n+\n+    private static void registerMethods(Class<?> serializationTargetClass) {\n+        RuntimeReflection.register(serializationTargetClass.getDeclaredMethods());\n+        // computeDefaultSUID will be reflectively called at runtime to verify class consistency\n+        Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+        RuntimeReflection.register(computeDefaultSUID);\n+    }\n+\n+    private static void registerFields(Class<?> serializationTargetClass) {\n+        int mask = Modifier.STATIC | Modifier.TRANSIENT;\n+        int staticFinalMask = Modifier.STATIC | Modifier.FINAL;\n+        int privateStaticFinalMask = Modifier.PRIVATE | staticFinalMask;\n+\n+        Set<String> serialPersistentFieldNames = new HashSet<>();\n+        try {\n+            Field f = ReflectionUtil.lookupField(serializationTargetClass, \"serialPersistentFields\");\n+            if ((f.getModifiers() & privateStaticFinalMask) == privateStaticFinalMask) {\n+                f.setAccessible(true);\n+                ObjectStreamField[] serialPersistentFields = (ObjectStreamField[]) f.get(null);\n+                for (int i = 0; i < serialPersistentFields.length; i++) {\n+                    serialPersistentFieldNames.add(serialPersistentFields[i].getName());\n+                }\n+            }\n+        } catch (ReflectionUtil.ReflectionUtilError | ReflectiveOperationException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf7defe36271537f22e7b7623261eef8930b15c5"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkzOTc0OQ==", "bodyText": "It seems like these can be deleted since they make no changes to the original class.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r527939749", "createdAt": "2020-11-20T19:58:16Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/JavaIOSubstitutions.java", "diffHunk": "@@ -47,31 +51,54 @@\n @TargetClass(java.io.ObjectInputStream.class)\n @SuppressWarnings({\"static-method\"})\n final class Target_java_io_ObjectInputStream {\n-\n+    /**\n+     * Private method latestUserDefinedLoader is called by\n+     * java.io.ObjectInputStream.resolveProxyClass and java.io.ObjectInputStream.resolveClass. The\n+     * returned classloader is eventually used in Class.forName and Proxy.getProxyClass0 which are\n+     * substituted by Substrate VM and the classloader is ignored. Therefore, this substitution is\n+     * safe.\n+     *\n+     * @return The only classloader in native image\n+     */\n     @Substitute\n-    private Object readObject() {\n-        throw VMError.unsupportedFeature(\"ObjectInputStream.readObject()\");\n+    private static ClassLoader latestUserDefinedLoader() {\n+        return Target_java_io_ObjectInputStream.class.getClassLoader();\n     }\n+}\n+\n+@TargetClass(java.io.ObjectStreamClass.class)\n+final class Target_java_io_ObjectStreamClass {\n \n     @Substitute\n-    private Object readUnshared() {\n-        throw VMError.unsupportedFeature(\"ObjectInputStream.readUnshared()\");\n+    private static boolean hasStaticInitializer(Class<?> cl) {\n+        return DynamicHub.fromClass(cl).getClassInitializationInfo().hasInitializer();\n     }\n }\n \n-@TargetClass(java.io.ObjectOutputStream.class)\n-@SuppressWarnings({\"static-method\", \"unused\"})\n-final class Target_java_io_ObjectOutputStream {\n+@TargetClass(value = java.io.ObjectStreamClass.class,  innerClass = \"Caches\")\n+final class Target_java_io_ObjectStreamClass_Caches {\n \n-    @Substitute\n-    private void writeObject(Object obj) {\n-        throw VMError.unsupportedFeature(\"ObjectOutputStream.writeObject()\");\n-    }\n+    @Alias @RecomputeFieldValue(kind = Kind.NewInstance, declClass = ConcurrentHashMap.class)\n+    static ConcurrentMap<Target_java_io_ObjectStreamClass_WeakClassKey, Reference<?>> localDescs;\n+\n+    @Alias @RecomputeFieldValue(kind = Kind.NewInstance, declClass = ConcurrentHashMap.class)\n+    static ConcurrentMap<Target_java_io_ObjectStreamClass_FieldReflectorKey, Reference<?>> reflectors;\n+\n+    @Alias @RecomputeFieldValue(kind = Kind.NewInstance, declClass = ReferenceQueue.class)\n+    private static ReferenceQueue<Class<?>> localDescsQueue;\n+\n+    @Alias @RecomputeFieldValue(kind = Kind.NewInstance, declClass = ReferenceQueue.class)\n+    private static ReferenceQueue<Class<?>> reflectorsQueue;\n+}\n+\n+@TargetClass(value = java.io.ObjectStreamClass.class, innerClass = \"WeakClassKey\")\n+final class Target_java_io_ObjectStreamClass_WeakClassKey{\n+\n+}\n+\n+@TargetClass(value = java.io.ObjectStreamClass.class, innerClass = \"FieldReflectorKey\")\n+final class Target_java_io_ObjectStreamClass_FieldReflectorKey {\n \n-    @Substitute\n-    private void writeUnshared(Object obj) {\n-        throw VMError.unsupportedFeature(\"ObjectOutputStream.writeUnshared()\");\n-    }\n }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf7defe36271537f22e7b7623261eef8930b15c5"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0Mjg1MA==", "bodyText": "Please try extracting the common algorithm in this method and in BreakpointInterceptor.getChecksumFromOSC into a method that can be called from both places with values from the different sources.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r527942850", "createdAt": "2020-11-20T20:04:59Z", "author": {"login": "peter-hofer"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    private class CachedEntity {\n+        private final Object serializationConstructorAccessor;\n+        private final Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+    }\n+\n+    private void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");188\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = Class.forName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        long buildTimeChecksum = getSerializationChecksum(serializationTargetClass, buildTimeConsClass.getName());\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitingEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitingEntity != null) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+                sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+                sb.append(\" is already registered with checksum \").append(exitingEntity.configuredChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+            }\n+        } catch (Exception e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+\n+        return buildTimeConsClass;\n+    }\n+\n+    @Override\n+    public Object getSerializationConstructorAccessorClass(Class<?> serializationTargetClass, String targetConstructorClass) {\n+        String className = serializationTargetClass.getName();\n+        CachedEntity ret = cachedSerializationConstructorAccessors.get(className);\n+        if (ret == null) {\n+            throw VMError.unsupportedFeature(\"SerializationConstructorAccessor class is not found for class :\" + className + \"\\n\" +\n+                            \"Generating SerializationConstructorAccessor classes at runtime is not supported. \");\n+        } else {\n+            Object accessor = ret.serializationConstructorAccessor;\n+            Long configuredChecksum = ret.configuredChecksum;\n+            long runtimeChecksum = getSerializationChecksum(serializationTargetClass, targetConstructorClass);\n+            // configuredChecksum could be null if it is not set in the configuration.\n+            if ((configuredChecksum != null && configuredChecksum.longValue() == runtimeChecksum) || configuredChecksum == null) {\n+                return accessor;\n+            } else {\n+                throw VMError.unimplemented(\"Serialization target class \" + className + \"'s hierarchy has been changed at run time. Configured checksum is \" + configuredChecksum +\n+                                \", runtime checksum is \" + runtimeChecksum);\n+            }\n+        }\n+    }\n+\n+    private long getSerializationChecksum(Class<?> serializationTargetClass, String constructorClassName) {\n+        if (constructorClassName != null && constructorClassName.length() > 0) {\n+            long checksum = 0L;\n+            String currentClassName = serializationTargetClass.getName();\n+            Class<?> currentClass = serializationTargetClass;\n+            // Compute SUID for each serializable superclass\n+            while (!constructorClassName.equals(currentClassName)) {\n+                Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", Class.class);\n+                try {\n+                    long classSUID = (Long) computeDefaultSUID.invoke(null, currentClass);\n+                    checksum = checksum * 31 + classSUID;\n+                    currentClass = currentClass.getSuperclass();\n+                    currentClassName = currentClass.getName();\n+                } catch (InvocationTargetException | IllegalAccessException e) {\n+                    throw VMError.shouldNotReachHere(e);\n+                }\n+            }\n+\n+            // Combine checksum with first unserializable superclass\n+            return checksum * 31 + constructorClassName.hashCode();\n+        } else {\n+            return 0L;\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf7defe36271537f22e7b7623261eef8930b15c5"}, "originalPosition": 198}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cf7defe36271537f22e7b7623261eef8930b15c5", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/cf7defe36271537f22e7b7623261eef8930b15c5", "committedDate": "2020-11-20T12:08:43Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "1a4fd2efbd30c9cc65dc421ca1e1240fdd2443a9", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/1a4fd2efbd30c9cc65dc421ca1e1240fdd2443a9", "committedDate": "2020-11-24T06:56:30Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a4fd2efbd30c9cc65dc421ca1e1240fdd2443a9", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/1a4fd2efbd30c9cc65dc421ca1e1240fdd2443a9", "committedDate": "2020-11-24T06:56:30Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "0a30a3050836f5184bcd912311cc7b6177f90c22", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/0a30a3050836f5184bcd912311cc7b6177f90c22", "committedDate": "2020-11-24T08:43:38Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a30a3050836f5184bcd912311cc7b6177f90c22", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/0a30a3050836f5184bcd912311cc7b6177f90c22", "committedDate": "2020-11-24T08:43:38Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "fe6adf251182a9d526a54b35a2f867c4f8f2f708", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/fe6adf251182a9d526a54b35a2f867c4f8f2f708", "committedDate": "2020-11-24T09:57:49Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe6adf251182a9d526a54b35a2f867c4f8f2f708", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/fe6adf251182a9d526a54b35a2f867c4f8f2f708", "committedDate": "2020-11-24T09:57:49Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "90d868edf83f86f4e8ac8e900fc8d248aa3bcdb1", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/90d868edf83f86f4e8ac8e900fc8d248aa3bcdb1", "committedDate": "2020-11-24T12:58:29Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "90d868edf83f86f4e8ac8e900fc8d248aa3bcdb1", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/90d868edf83f86f4e8ac8e900fc8d248aa3bcdb1", "committedDate": "2020-11-24T12:58:29Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "a51061feb65463853df995fd55eac04da045f740", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/a51061feb65463853df995fd55eac04da045f740", "committedDate": "2020-11-25T02:02:47Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a51061feb65463853df995fd55eac04da045f740", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/a51061feb65463853df995fd55eac04da045f740", "committedDate": "2020-11-25T02:02:47Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "8843fc96827d361f8e5b8fc0bc7e529a0ab456f2", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/8843fc96827d361f8e5b8fc0bc7e529a0ab456f2", "committedDate": "2020-11-26T09:35:11Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8843fc96827d361f8e5b8fc0bc7e529a0ab456f2", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/8843fc96827d361f8e5b8fc0bc7e529a0ab456f2", "committedDate": "2020-11-26T09:35:11Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "5992410139d58cf6b7902ec60d7207541632d681", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/5992410139d58cf6b7902ec60d7207541632d681", "committedDate": "2020-11-26T12:56:18Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMDgyMDI4", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-540082028", "createdAt": "2020-11-27T16:13:25Z", "commit": {"oid": "5992410139d58cf6b7902ec60d7207541632d681"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoxMzoyNVrOH7DUoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNjoxMzoyNVrOH7DUoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY4MjQ2NA==", "bodyText": "newConstructorForSerialization will try to find a constructor in the given class or in any of its parent:\nSo it's possible that buildTimeConstructor is null in case no constructor is found. Even though Java generates empty constructors automatically, the section 2.9.1 of the JVM specs says that:\nA class has zero or more instance initialization methods\n\nHaving no constructor happens only for inner classes in Java but is more common in Scala. So long story short, we need to handle the null case (maybe by skipping this case in beforeAnalysis), otherwise calling buildTimeConstructor.getDeclaringClass() below will generate an NPE.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r531682464", "createdAt": "2020-11-27T16:13:25Z", "author": {"login": "farquet"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+// Checkstyle: allow reflection\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import com.oracle.svm.util.SerializationChecksumCalculator;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    class ChecksumCalculator extends SerializationChecksumCalculator.JavaCalculator {\n+        @Override\n+        protected String getClassName(Class<?> clazz) {\n+            return clazz.getName();\n+        }\n+\n+        @Override\n+        protected Class<?> getSuperClass(Class<?> clazz) {\n+            return clazz.getSuperclass();\n+        }\n+\n+        @Override\n+        protected Long calculateFromComputeDefaultSUID(Class<?> clazz) {\n+            try {\n+                Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", java.lang.Class.class);\n+                return (Long) computeDefaultSUID.invoke(null, clazz);\n+            } catch (ReflectionUtil.ReflectionUtilError | InvocationTargetException | IllegalAccessException e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+    }\n+\n+    private class CachedEntity {\n+        private final Object serializationConstructorAccessor;\n+        private final Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+\n+    private final ChecksumCalculator checksumCalculator;\n+\n+    public SerializationSupport() {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        checksumCalculator = new ChecksumCalculator();\n+    }\n+\n+    private static void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = access.findClassByName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5992410139d58cf6b7902ec60d7207541632d681"}, "originalPosition": 140}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5992410139d58cf6b7902ec60d7207541632d681", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/5992410139d58cf6b7902ec60d7207541632d681", "committedDate": "2020-11-26T12:56:18Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "b891054cbc6cd2513e03d2673a703336296e3f7a", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b891054cbc6cd2513e03d2673a703336296e3f7a", "committedDate": "2020-11-30T09:09:04Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNzI0MTg4", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-541724188", "createdAt": "2020-12-01T09:47:59Z", "commit": {"oid": "b891054cbc6cd2513e03d2673a703336296e3f7a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo0Nzo1OVrOH8ijoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwOTo0Nzo1OVrOH8ijoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0Mjc4NA==", "bodyText": "A javadoc comment should be added here to match the other register methods.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r533242784", "createdAt": "2020-12-01T09:47:59Z", "author": {"login": "olpaw"}, "path": "sdk/src/org.graalvm.nativeimage/src/org/graalvm/nativeimage/hosted/RuntimeReflection.java", "diffHunk": "@@ -107,6 +107,10 @@ public static void register(boolean finalIsWritable, Field... fields) {\n         ImageSingletons.lookup(RuntimeReflectionSupport.class).register(finalIsWritable, false, fields);\n     }\n \n+    public static void register(boolean finalIsWritable, boolean allowUnsafeAccess, Field... fields) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b891054cbc6cd2513e03d2673a703336296e3f7a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMTI4NzEy", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-542128712", "createdAt": "2020-12-01T17:22:27Z", "commit": {"oid": "b891054cbc6cd2513e03d2673a703336296e3f7a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzoyMjoyN1rOH83oSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzoyMjoyN1rOH83oSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU4ODA0MQ==", "bodyText": "This is too strict. We have to be able to handle redundant / overlapping serialization-config.json entries (jar file from project X might have an embedded serialization config that overlaps with another one in project Y). Otherwise the accumulative nature of our configurations will interact badly with serialization configuration data.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r533588041", "createdAt": "2020-12-01T17:22:27Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+// Checkstyle: allow reflection\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import com.oracle.svm.util.SerializationChecksumCalculator;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    class ChecksumCalculator extends SerializationChecksumCalculator.JavaCalculator {\n+        @Override\n+        protected String getClassName(Class<?> clazz) {\n+            return clazz.getName();\n+        }\n+\n+        @Override\n+        protected Class<?> getSuperClass(Class<?> clazz) {\n+            return clazz.getSuperclass();\n+        }\n+\n+        @Override\n+        protected Long calculateFromComputeDefaultSUID(Class<?> clazz) {\n+            try {\n+                Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", java.lang.Class.class);\n+                return (Long) computeDefaultSUID.invoke(null, clazz);\n+            } catch (ReflectionUtil.ReflectionUtilError | InvocationTargetException | IllegalAccessException e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Using a separated classloader for serialization checksum computation to avoid initializing\n+     * Classes that should be initialized at run time.\n+     */\n+    class SerializationChecksumClassLoader extends URLClassLoader {\n+\n+        SerializationChecksumClassLoader(URL[] urls, ClassLoader parent) {\n+            super(urls, parent);\n+        }\n+\n+    }\n+\n+    private class CachedEntity {\n+        private final Object serializationConstructorAccessor;\n+        private final Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    private SerializationChecksumClassLoader serializationChecksumClassLoader;\n+    private final ChecksumCalculator checksumCalculator;\n+\n+    public SerializationSupport(ImageClassLoader imageClassLoader) {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        checksumCalculator = new ChecksumCalculator();\n+        URLClassLoader cl = (URLClassLoader) imageClassLoader.getClassLoader();\n+        serializationChecksumClassLoader = new SerializationChecksumClassLoader(cl.getURLs(), cl.getParent());\n+    }\n+\n+    private static void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        String targetClassName = serializationTargetClass.getName();\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        try {\n+            Class<?> reflectionFactoryClass = access.findClassByName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        if (buildTimeConstructor == null) {\n+            return null;\n+        }\n+        Class<?> buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+        // Prepare build time checksum and verify with configured checksum\n+        long checksum;\n+        // this class is getting from SerializationChecksumClassLoader classloader\n+        Class<?> checksumCalculationTargetClass;\n+        try {\n+            // Checkstyle: stop\n+            checksumCalculationTargetClass = Class.forName(serializationTargetClass.getName(), false, serializationChecksumClassLoader);\n+            // Checkstyle resume\n+        } catch (ClassNotFoundException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        long buildTimeChecksum = checksumCalculator.calculateChecksum(buildTimeConsClass.getName(), serializationTargetClass.getName(), checksumCalculationTargetClass);\n+        if (configuredChecksum != null) {\n+            if (configuredChecksum.longValue() != buildTimeChecksum) {\n+                StringBuilder sb = new StringBuilder();\n+                sb.append(\"\\nBuild time serialization class checksum verify failure.\")\n+                                .append(\" The classes' hierarchy may have been changed from configuration collecting time to image build time:\\n\");\n+                sb.append(targetClassName).append(\": configured checksum is \").append(configuredChecksum).append(\", build time checksum is \").append(buildTimeChecksum);\n+                reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, CHECKSUM_VERIFY_FAIL, sb.toString());\n+            }\n+            checksum = configuredChecksum;\n+        } else {\n+            // If the checksum is not set in configurations, use the build time checksum instead\n+            checksum = buildTimeChecksum;\n+        }\n+\n+        // Cache constructorAccessor\n+        try {\n+            Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+            Object constructorAccessor = getConstructorAccessor.invoke(buildTimeConstructor);\n+            CachedEntity exitingEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                            new CachedEntity(constructorAccessor, checksum));\n+            if (exitingEntity != null) {\n+                StringBuilder sb = new StringBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b891054cbc6cd2513e03d2673a703336296e3f7a"}, "originalPosition": 198}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b891054cbc6cd2513e03d2673a703336296e3f7a", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/b891054cbc6cd2513e03d2673a703336296e3f7a", "committedDate": "2020-11-30T09:09:04Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "9948ed89131ecfd69f44375cdd8b33b0c4c94028", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/9948ed89131ecfd69f44375cdd8b33b0c4c94028", "committedDate": "2020-12-03T13:06:32Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9948ed89131ecfd69f44375cdd8b33b0c4c94028", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/9948ed89131ecfd69f44375cdd8b33b0c4c94028", "committedDate": "2020-12-03T13:06:32Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "e42caa9ddd3bdace7f2a89482d879ca778c39747", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/e42caa9ddd3bdace7f2a89482d879ca778c39747", "committedDate": "2020-12-03T13:13:57Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDA0MTYy", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-544004162", "createdAt": "2020-12-03T14:25:23Z", "commit": {"oid": "e42caa9ddd3bdace7f2a89482d879ca778c39747"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDoyNToyM1rOH-eNYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDoyNToyM1rOH-eNYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI2ODcwNA==", "bodyText": "All Rights Reserved. causes problems. Please fix all header files to use\nAll rights reserved. (after Alibaba Group Holding Limited)\nSo that it matches exactly All rights reserved. (lowercase rights and lowercase reserved", "url": "https://github.com/oracle/graal/pull/2730#discussion_r535268704", "createdAt": "2020-12-03T14:25:23Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.configure/src/com/oracle/svm/configure/config/SerializationConfiguration.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42caa9ddd3bdace7f2a89482d879ca778c39747"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDEwNzg3", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-544010787", "createdAt": "2020-12-03T14:31:33Z", "commit": {"oid": "e42caa9ddd3bdace7f2a89482d879ca778c39747"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDE4MTQ0", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-544018144", "createdAt": "2020-12-03T14:38:19Z", "commit": {"oid": "e42caa9ddd3bdace7f2a89482d879ca778c39747"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDozODoxOVrOH-fDwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNDozODoxOVrOH-fDwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTI4MjYyNA==", "bodyText": "@ziyilin please also remove this bit. We have to allow overlapping/redundant entries in serialization-config.json files.", "url": "https://github.com/oracle/graal/pull/2730#discussion_r535282624", "createdAt": "2020-12-03T14:38:19Z", "author": {"login": "olpaw"}, "path": "substratevm/src/com.oracle.svm.reflect/src/com/oracle/svm/reflect/serialize/SerializationSupport.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.reflect.serialize;\n+\n+// Checkstyle: allow reflection\n+\n+import com.oracle.graal.pointsto.BigBang;\n+import com.oracle.svm.core.jdk.Package_jdk_internal_reflect;\n+import com.oracle.svm.core.jdk.serialize.SerializationRegistry;\n+import com.oracle.svm.core.option.SubstrateOptionsParser;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.FeatureImpl;\n+import com.oracle.svm.hosted.ImageClassLoader;\n+import com.oracle.svm.hosted.NativeImageOptions;\n+import com.oracle.svm.util.ReflectionUtil;\n+import com.oracle.svm.util.SerializationChecksumCalculator;\n+import org.graalvm.nativeimage.Platform;\n+import org.graalvm.nativeimage.Platforms;\n+import org.graalvm.nativeimage.hosted.Feature.FeatureAccess;\n+\n+import java.io.Externalizable;\n+import java.io.ObjectStreamClass;\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class SerializationSupport implements SerializationRegistry {\n+\n+    class ChecksumCalculator extends SerializationChecksumCalculator.JavaCalculator {\n+        @Override\n+        protected String getClassName(Class<?> clazz) {\n+            return clazz.getName();\n+        }\n+\n+        @Override\n+        protected Class<?> getSuperClass(Class<?> clazz) {\n+            return clazz.getSuperclass();\n+        }\n+\n+        @Override\n+        protected Long calculateFromComputeDefaultSUID(Class<?> clazz) {\n+            try {\n+                Method computeDefaultSUID = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"computeDefaultSUID\", java.lang.Class.class);\n+                return (Long) computeDefaultSUID.invoke(null, clazz);\n+            } catch (ReflectionUtil.ReflectionUtilError | InvocationTargetException | IllegalAccessException e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        @Override\n+        protected boolean isClassAbstract(Class<?> clazz) {\n+            return Modifier.isAbstract(clazz.getModifiers());\n+        }\n+    }\n+\n+    /**\n+     * Method MethodAccessorGenerator.generateSerializationConstructor dynamically defines a\n+     * SerializationConstructorAccessorImpl type class. The class has a newInstance method which\n+     * news the class specified by generateSerializationConstructor's first\n+     * parameter--declaringClass and then calls declaringClass' first non-serializable superclass.\n+     * The bytecode of the generated class like :\n+     * <code>\n+     * jdk.internal.reflect.GeneratedSerializationConstructorAccessor2.newInstance(Unknown Source)\n+     * [bci: 0, intrinsic: false] \n+     * 0: new #6 // declaringClass \n+     * 3: dup \n+     * 4: aload_1 \n+     * 5: ifnull 24 \n+     * 8: aload_1 \n+     * 9: arraylength \n+     * 10: sipush 0\n+     *  ...\n+     * </code>\n+     * The declaringClass could be an abstract class. At deserialization time,\n+     * SerializationConstructorAccessorImpl classes are generated for the target class and all of\n+     * its serializable super classes. The super classes could be abstract. So it is possible to\n+     * generate bytecode that new an abstract class. In JDK, the super class' generated newInstance\n+     * method shall never get invoked, so the \"new abstract class\" code won't cause any error. But\n+     * in Substrate VM, the generated class gets compiled at build time and the \"new abstract class\"\n+     * code causes compilation error.\n+     *\n+     * We introduce this StubForAbstractClass class to replace any abstract classes at method\n+     * generateSerializationConstructor's declaringClass parameter place. So there won't be \"new\n+     * abstract class\" bytecode anymore, and it's also safe for runtime as the corresponding\n+     * newInstance method is never actually called.\n+     */\n+    static class StubForAbstractClass implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    private static Object stubAccessor = null;\n+\n+    /**\n+     * Using a separated classloader for serialization checksum computation to avoid initializing\n+     * Classes that should be initialized at run time.\n+     */\n+    class SerializationChecksumClassLoader extends URLClassLoader {\n+\n+        SerializationChecksumClassLoader(URL[] urls, ClassLoader parent) {\n+            super(urls, parent);\n+        }\n+\n+    }\n+\n+    private class CachedEntity {\n+        private final Object serializationConstructorAccessor;\n+        private final Long configuredChecksum;\n+\n+        CachedEntity(Object accessor, Long checksum) {\n+            this.serializationConstructorAccessor = accessor;\n+            this.configuredChecksum = checksum;\n+        }\n+    }\n+\n+    // Cached SerializationConstructorAccessors for runtime usage\n+    private Map<String, CachedEntity> cachedSerializationConstructorAccessors;\n+    private static final String MULTIPLE_CHECKSUMS = \"MULTIPLE_CHECKSUM\";\n+    private static final String CHECKSUM_VERIFY_FAIL = \"CHECKSUM_VERIFY_FAIL\";\n+    private SerializationChecksumClassLoader serializationChecksumClassLoader;\n+    private final ChecksumCalculator checksumCalculator;\n+\n+    public SerializationSupport(ImageClassLoader imageClassLoader) {\n+        cachedSerializationConstructorAccessors = new ConcurrentHashMap<>();\n+        checksumCalculator = new ChecksumCalculator();\n+        URLClassLoader cl = (URLClassLoader) imageClassLoader.getClassLoader();\n+        serializationChecksumClassLoader = new SerializationChecksumClassLoader(cl.getURLs(), cl.getParent());\n+    }\n+\n+    private static void reportError(FeatureImpl.BeforeAnalysisAccessImpl access, String msgKey, String exceptionsMsg) {\n+        // Checkstyle: stop\n+        String option = SubstrateOptionsParser.commandArgument(NativeImageOptions.ReportUnsupportedElementsAtRuntime, \"+\");\n+        if (!NativeImageOptions.ReportUnsupportedElementsAtRuntime.getValue()) {\n+            BigBang bb = access.getBigBang();\n+            bb.getUnsupportedFeatures().addMessage(msgKey, null,\n+                            exceptionsMsg + \"\\n\" + \"To allow continuing compilation with above unsupported features, set \" + option);\n+        } else {\n+            System.out.println(exceptionsMsg);\n+            System.out.println(\"Compilation will continue because \" + option +\n+                            \" was set. But the program may behave unexpectedly at runtime.\");\n+        }\n+        // Checkstyle: resume\n+    }\n+\n+    @Platforms({Platform.HOSTED_ONLY.class})\n+    public Class<?> addSerializationConstructorAccessorClass(Class<?> serializationTargetClass, Long configuredChecksum, FeatureAccess access) {\n+        if (serializationTargetClass.isArray() || Enum.class.isAssignableFrom(serializationTargetClass)) {\n+            return null;\n+        }\n+        // Don't generate SerializationConstructorAccessor class for Externalizable case\n+        if (Externalizable.class.isAssignableFrom(serializationTargetClass)) {\n+            try {\n+                Method getExternalizableConstructor = ReflectionUtil.lookupMethod(ObjectStreamClass.class, \"getExternalizableConstructor\", Class.class);\n+                Constructor<?> c = (Constructor<?>) getExternalizableConstructor.invoke(null, serializationTargetClass);\n+                return c.getDeclaringClass();\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+\n+        /**\n+         * Using reflection to make sure code is compatible with both JDK 8 and above Reflectively\n+         * call method ReflectionFactory.newConstructorForSerialization(Class) to get the\n+         * SerializationConstructorAccessor instance.\n+         */\n+        Constructor<?> buildTimeConstructor;\n+        Class<?> buildTimeConsClass;\n+        long checksum = 0;\n+        Object constructorAccessor;\n+        String targetClassName = serializationTargetClass.getName();\n+        boolean isAbstract = Modifier.isAbstract(serializationTargetClass.getModifiers());\n+        Constructor<?> stubConstructor = null;\n+        try {\n+            Class<?> reflectionFactoryClass = access.findClassByName(Package_jdk_internal_reflect.getQualifiedName() + \".ReflectionFactory\");\n+            Method getReflectionFactoryMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"getReflectionFactory\");\n+            Object reflFactoryInstance = getReflectionFactoryMethod.invoke(null);\n+            Method newConstructorForSerializationMethod = ReflectionUtil.lookupMethod(reflectionFactoryClass, \"newConstructorForSerialization\", Class.class);\n+            buildTimeConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, serializationTargetClass);\n+\n+            // Calculate GeneratedSerializationConstructor for StubForAbstractClass only once\n+            if (isAbstract && stubAccessor == null) {\n+                stubConstructor = (Constructor<?>) newConstructorForSerializationMethod.invoke(reflFactoryInstance, StubForAbstractClass.class);\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw VMError.shouldNotReachHere(e);\n+        }\n+        if (buildTimeConstructor == null) {\n+            return null;\n+        }\n+        buildTimeConsClass = buildTimeConstructor.getDeclaringClass();\n+\n+        if (isAbstract && stubAccessor != null) {\n+            constructorAccessor = stubAccessor;\n+            targetClassName = StubForAbstractClass.class.getName();\n+        } else {\n+            // Prepare build time checksum and verify with configured checksum only for non-abstract\n+            // classes. Abstract class' checksum is always 0.\n+            if (!isAbstract) {\n+                checksum = getChecksum(serializationTargetClass, configuredChecksum, (FeatureImpl.BeforeAnalysisAccessImpl) access, buildTimeConsClass, targetClassName);\n+            }\n+            try {\n+                Method getConstructorAccessor = ReflectionUtil.lookupMethod(Constructor.class, \"getConstructorAccessor\");\n+                constructorAccessor = getConstructorAccessor.invoke(isAbstract ? stubConstructor : buildTimeConstructor);\n+                if (isAbstract) {\n+                    assert constructorAccessor != null;\n+                    stubAccessor = constructorAccessor;\n+                    targetClassName = StubForAbstractClass.class.getName();\n+                }\n+            } catch (Exception e) {\n+                throw VMError.shouldNotReachHere(e);\n+            }\n+        }\n+        // Cache constructorAccessor\n+        CachedEntity exitingEntity = cachedSerializationConstructorAccessors.putIfAbsent(targetClassName,\n+                        new CachedEntity(constructorAccessor, checksum));\n+        if (exitingEntity != null && exitingEntity.configuredChecksum != checksum) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Suspicious multiple-classloader usage is detected from serialization configurations:\\n\");\n+            sb.append(\"Serialization target class (name=\").append(targetClassName).append(\", checksum=\").append(checksum).append(\")\");\n+            sb.append(\" is already registered with checksum \").append(exitingEntity.configuredChecksum);\n+            reportError((FeatureImpl.BeforeAnalysisAccessImpl) access, MULTIPLE_CHECKSUMS, sb.toString());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e42caa9ddd3bdace7f2a89482d879ca778c39747"}, "originalPosition": 250}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4fb66ce6f44c55764bbe759c94ee2b34985d37e", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/c4fb66ce6f44c55764bbe759c94ee2b34985d37e", "committedDate": "2020-12-03T15:23:00Z", "message": "Support JDK serialization"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e42caa9ddd3bdace7f2a89482d879ca778c39747", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/e42caa9ddd3bdace7f2a89482d879ca778c39747", "committedDate": "2020-12-03T13:13:57Z", "message": "Support JDK serialization"}, "afterCommit": {"oid": "c4fb66ce6f44c55764bbe759c94ee2b34985d37e", "author": {"user": {"login": "ziyilin", "name": null}}, "url": "https://github.com/oracle/graal/commit/c4fb66ce6f44c55764bbe759c94ee2b34985d37e", "committedDate": "2020-12-03T15:23:00Z", "message": "Support JDK serialization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MjQ0NjI2", "url": "https://github.com/oracle/graal/pull/2730#pullrequestreview-544244626", "createdAt": "2020-12-03T18:13:11Z", "commit": {"oid": "c4fb66ce6f44c55764bbe759c94ee2b34985d37e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1079, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}