{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3MDk2MDM2", "number": 2588, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo0NDoxOFrOEWSHgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo1MjozMlrOEkoy0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODAwOTYzOnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNjo0NDoxOFrOG9gtTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTowMTo1MFrOHHG6sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1MjIwNA==", "bodyText": "Since Max/Min are associative, I believe also hooks for them must be added into BinaryArithmeticNode.reassociate", "url": "https://github.com/oracle/graal/pull/2588#discussion_r467152204", "createdAt": "2020-08-07T16:44:18Z", "author": {"login": "teshull"}, "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "diffHunk": "@@ -910,6 +910,76 @@ public Stamp foldStamp(Stamp s) {\n \n                     null, null, null,\n \n+                    new BinaryOp.Max(true, true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1267fbd41fcbee180c66cd5b2760659764046f3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNTQwOQ==", "bodyText": "Done!", "url": "https://github.com/oracle/graal/pull/2588#discussion_r477215409", "createdAt": "2020-08-26T11:01:50Z", "author": {"login": "SwapnilGaikwad"}, "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "diffHunk": "@@ -910,6 +910,76 @@ public Stamp foldStamp(Stamp s) {\n \n                     null, null, null,\n \n+                    new BinaryOp.Max(true, true) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1MjIwNA=="}, "originalCommit": {"oid": "d1267fbd41fcbee180c66cd5b2760659764046f3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODUxMjA0OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0OTowN1rOHTsU9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODo0MTozM1rOHaTTVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMTI1NA==", "bodyText": "Can you tighten the bounds of the returned stamp? Since this is a max operation, we know the lower bound will be max(stamp1.lowerBound(), stamp2.lowerBound()) and the upper bound likewise will be the max of the two stamps' upper bounds.", "url": "https://github.com/oracle/graal/pull/2588#discussion_r490411254", "createdAt": "2020-09-17T16:49:07Z", "author": {"login": "teshull"}, "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "diffHunk": "@@ -910,6 +910,76 @@ public Stamp foldStamp(Stamp s) {\n \n                     null, null, null,\n \n+                    new BinaryOp.Max(true, true) {\n+\n+                        @Override\n+                        public Constant foldConstant(Constant const1, Constant const2) {\n+                            PrimitiveConstant a = (PrimitiveConstant) const1;\n+                            PrimitiveConstant b = (PrimitiveConstant) const2;\n+                            assert a.getJavaKind() == b.getJavaKind();\n+                            switch (a.getJavaKind()) {\n+                                case Float:\n+                                    return JavaConstant.forFloat(Math.max(a.asFloat(), b.asFloat()));\n+                                case Double:\n+                                    return JavaConstant.forDouble(Math.max(a.asDouble(), b.asDouble()));\n+                                default:\n+                                    throw GraalError.shouldNotReachHere();\n+                            }\n+                        }\n+\n+                        @Override\n+                        public Stamp foldStamp(Stamp s1, Stamp s2) {\n+                            if (s1.isEmpty()) {\n+                                return s1;\n+                            }\n+                            if (s2.isEmpty()) {\n+                                return s2;\n+                            }\n+                            FloatStamp stamp1 = (FloatStamp) s1;\n+                            FloatStamp stamp2 = (FloatStamp) s2;\n+                            Stamp folded = maybeFoldConstant(this, stamp1, stamp2);\n+                            if (folded != null) {\n+                                return folded;\n+                            }\n+                            return stamp1.unrestricted();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0112744b46bad63e756876dfc1c469e72ee81bfe"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM0MTI3MQ==", "bodyText": "Done!", "url": "https://github.com/oracle/graal/pull/2588#discussion_r497341271", "createdAt": "2020-09-30T08:41:33Z", "author": {"login": "SwapnilGaikwad"}, "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "diffHunk": "@@ -910,6 +910,76 @@ public Stamp foldStamp(Stamp s) {\n \n                     null, null, null,\n \n+                    new BinaryOp.Max(true, true) {\n+\n+                        @Override\n+                        public Constant foldConstant(Constant const1, Constant const2) {\n+                            PrimitiveConstant a = (PrimitiveConstant) const1;\n+                            PrimitiveConstant b = (PrimitiveConstant) const2;\n+                            assert a.getJavaKind() == b.getJavaKind();\n+                            switch (a.getJavaKind()) {\n+                                case Float:\n+                                    return JavaConstant.forFloat(Math.max(a.asFloat(), b.asFloat()));\n+                                case Double:\n+                                    return JavaConstant.forDouble(Math.max(a.asDouble(), b.asDouble()));\n+                                default:\n+                                    throw GraalError.shouldNotReachHere();\n+                            }\n+                        }\n+\n+                        @Override\n+                        public Stamp foldStamp(Stamp s1, Stamp s2) {\n+                            if (s1.isEmpty()) {\n+                                return s1;\n+                            }\n+                            if (s2.isEmpty()) {\n+                                return s2;\n+                            }\n+                            FloatStamp stamp1 = (FloatStamp) s1;\n+                            FloatStamp stamp2 = (FloatStamp) s2;\n+                            Stamp folded = maybeFoldConstant(this, stamp1, stamp2);\n+                            if (folded != null) {\n+                                return folded;\n+                            }\n+                            return stamp1.unrestricted();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMTI1NA=="}, "originalCommit": {"oid": "0112744b46bad63e756876dfc1c469e72ee81bfe"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODUxNTI1OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0OTo1NlrOHTsW-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0OTo1NlrOHTsW-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMTc2OQ==", "bodyText": "Same thing as the comment above, except this time the upper/lower bounds would be the min of the two stamps' respective values", "url": "https://github.com/oracle/graal/pull/2588#discussion_r490411769", "createdAt": "2020-09-17T16:49:56Z", "author": {"login": "teshull"}, "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "diffHunk": "@@ -910,6 +910,76 @@ public Stamp foldStamp(Stamp s) {\n \n                     null, null, null,\n \n+                    new BinaryOp.Max(true, true) {\n+\n+                        @Override\n+                        public Constant foldConstant(Constant const1, Constant const2) {\n+                            PrimitiveConstant a = (PrimitiveConstant) const1;\n+                            PrimitiveConstant b = (PrimitiveConstant) const2;\n+                            assert a.getJavaKind() == b.getJavaKind();\n+                            switch (a.getJavaKind()) {\n+                                case Float:\n+                                    return JavaConstant.forFloat(Math.max(a.asFloat(), b.asFloat()));\n+                                case Double:\n+                                    return JavaConstant.forDouble(Math.max(a.asDouble(), b.asDouble()));\n+                                default:\n+                                    throw GraalError.shouldNotReachHere();\n+                            }\n+                        }\n+\n+                        @Override\n+                        public Stamp foldStamp(Stamp s1, Stamp s2) {\n+                            if (s1.isEmpty()) {\n+                                return s1;\n+                            }\n+                            if (s2.isEmpty()) {\n+                                return s2;\n+                            }\n+                            FloatStamp stamp1 = (FloatStamp) s1;\n+                            FloatStamp stamp2 = (FloatStamp) s2;\n+                            Stamp folded = maybeFoldConstant(this, stamp1, stamp2);\n+                            if (folded != null) {\n+                                return folded;\n+                            }\n+                            return stamp1.unrestricted();\n+                        }\n+                    },\n+\n+                    new BinaryOp.Min(true, true) {\n+\n+                        @Override\n+                        public Constant foldConstant(Constant const1, Constant const2) {\n+                            PrimitiveConstant a = (PrimitiveConstant) const1;\n+                            PrimitiveConstant b = (PrimitiveConstant) const2;\n+                            assert a.getJavaKind() == b.getJavaKind();\n+                            switch (a.getJavaKind()) {\n+                                case Float:\n+                                    return JavaConstant.forFloat(Math.min(a.asFloat(), b.asFloat()));\n+                                case Double:\n+                                    return JavaConstant.forDouble(Math.min(a.asDouble(), b.asDouble()));\n+                                default:\n+                                    throw GraalError.shouldNotReachHere();\n+                            }\n+                        }\n+\n+                        @Override\n+                        public Stamp foldStamp(Stamp s1, Stamp s2) {\n+                            if (s1.isEmpty()) {\n+                                return s1;\n+                            }\n+                            if (s2.isEmpty()) {\n+                                return s2;\n+                            }\n+                            FloatStamp stamp1 = (FloatStamp) s1;\n+                            FloatStamp stamp2 = (FloatStamp) s2;\n+                            Stamp folded = maybeFoldConstant(this, stamp1, stamp2);\n+                            if (folded != null) {\n+                                return folded;\n+                            }\n+                            return stamp1.unrestricted();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0112744b46bad63e756876dfc1c469e72ee81bfe"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODUxOTg5OnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MaxNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo1MTowOVrOHTsZyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODo0MzoxN1rOHaTXfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMjQ5MQ==", "bodyText": "Can you create a shared abstract superclass for the Max and Min nodes, called MinMaxNode, and lift the common logic into this class?", "url": "https://github.com/oracle/graal/pull/2588#discussion_r490412491", "createdAt": "2020-09-17T16:51:09Z", "author": {"login": "teshull"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MaxNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.nodes.calc;\n+\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Max;\n+import org.graalvm.compiler.core.common.type.Stamp;\n+import org.graalvm.compiler.graph.NodeClass;\n+import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;\n+import org.graalvm.compiler.graph.spi.CanonicalizerTool;\n+import org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool;\n+import org.graalvm.compiler.nodeinfo.NodeInfo;\n+import org.graalvm.compiler.nodes.ConstantNode;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;\n+\n+import jdk.vm.ci.meta.Value;\n+\n+@NodeInfo(shortName = \"MAX\")\n+public class MaxNode extends BinaryArithmeticNode<Max> implements NarrowableArithmeticNode, BinaryCommutative<ValueNode> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0112744b46bad63e756876dfc1c469e72ee81bfe"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM0MjMzMw==", "bodyText": "Done, added MinMaxNode.java", "url": "https://github.com/oracle/graal/pull/2588#discussion_r497342333", "createdAt": "2020-09-30T08:43:17Z", "author": {"login": "SwapnilGaikwad"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MaxNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.nodes.calc;\n+\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Max;\n+import org.graalvm.compiler.core.common.type.Stamp;\n+import org.graalvm.compiler.graph.NodeClass;\n+import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;\n+import org.graalvm.compiler.graph.spi.CanonicalizerTool;\n+import org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool;\n+import org.graalvm.compiler.nodeinfo.NodeInfo;\n+import org.graalvm.compiler.nodes.ConstantNode;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;\n+\n+import jdk.vm.ci.meta.Value;\n+\n+@NodeInfo(shortName = \"MAX\")\n+public class MaxNode extends BinaryArithmeticNode<Max> implements NarrowableArithmeticNode, BinaryCommutative<ValueNode> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMjQ5MQ=="}, "originalCommit": {"oid": "0112744b46bad63e756876dfc1c469e72ee81bfe"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODUyNTYwOnYy", "diffSide": "RIGHT", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MaxNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo1MjozMlrOHTsdIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQwODo0Mzo0MlrOHaTYeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMzM0NA==", "bodyText": "Can you add the assert assert stamp instanceof FloatStamp?", "url": "https://github.com/oracle/graal/pull/2588#discussion_r490413344", "createdAt": "2020-09-17T16:52:32Z", "author": {"login": "teshull"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MaxNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.nodes.calc;\n+\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Max;\n+import org.graalvm.compiler.core.common.type.Stamp;\n+import org.graalvm.compiler.graph.NodeClass;\n+import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;\n+import org.graalvm.compiler.graph.spi.CanonicalizerTool;\n+import org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool;\n+import org.graalvm.compiler.nodeinfo.NodeInfo;\n+import org.graalvm.compiler.nodes.ConstantNode;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;\n+\n+import jdk.vm.ci.meta.Value;\n+\n+@NodeInfo(shortName = \"MAX\")\n+public class MaxNode extends BinaryArithmeticNode<Max> implements NarrowableArithmeticNode, BinaryCommutative<ValueNode> {\n+\n+    public static final NodeClass<MaxNode> TYPE = NodeClass.create(MaxNode.class);\n+\n+    public MaxNode(ValueNode x, ValueNode y) {\n+        super(TYPE, getArithmeticOpTable(x).getMax(), x, y);\n+    }\n+\n+    @Override\n+    protected BinaryOp<Max> getOp(ArithmeticOpTable table) {\n+        return table.getMax();\n+    }\n+\n+    public static ValueNode create(ValueNode x, ValueNode y, NodeView view) {\n+        BinaryOp<Max> op = ArithmeticOpTable.forStamp(x.stamp(view)).getMax();\n+        Stamp stamp = op.foldStamp(x.stamp(view), y.stamp(view));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0112744b46bad63e756876dfc1c469e72ee81bfe"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM0MjU4Ng==", "bodyText": "Done!", "url": "https://github.com/oracle/graal/pull/2588#discussion_r497342586", "createdAt": "2020-09-30T08:43:42Z", "author": {"login": "SwapnilGaikwad"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MaxNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.nodes.calc;\n+\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Max;\n+import org.graalvm.compiler.core.common.type.Stamp;\n+import org.graalvm.compiler.graph.NodeClass;\n+import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;\n+import org.graalvm.compiler.graph.spi.CanonicalizerTool;\n+import org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool;\n+import org.graalvm.compiler.nodeinfo.NodeInfo;\n+import org.graalvm.compiler.nodes.ConstantNode;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;\n+\n+import jdk.vm.ci.meta.Value;\n+\n+@NodeInfo(shortName = \"MAX\")\n+public class MaxNode extends BinaryArithmeticNode<Max> implements NarrowableArithmeticNode, BinaryCommutative<ValueNode> {\n+\n+    public static final NodeClass<MaxNode> TYPE = NodeClass.create(MaxNode.class);\n+\n+    public MaxNode(ValueNode x, ValueNode y) {\n+        super(TYPE, getArithmeticOpTable(x).getMax(), x, y);\n+    }\n+\n+    @Override\n+    protected BinaryOp<Max> getOp(ArithmeticOpTable table) {\n+        return table.getMax();\n+    }\n+\n+    public static ValueNode create(ValueNode x, ValueNode y, NodeView view) {\n+        BinaryOp<Max> op = ArithmeticOpTable.forStamp(x.stamp(view)).getMax();\n+        Stamp stamp = op.foldStamp(x.stamp(view), y.stamp(view));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMzM0NA=="}, "originalCommit": {"oid": "0112744b46bad63e756876dfc1c469e72ee81bfe"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 774, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}