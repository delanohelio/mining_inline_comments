{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NDA4NzU4", "number": 2455, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo0NDo1NlrOD8Jm2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjo0OToxMVrOD_wwLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Mzk4NTUyOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo0NDo1NlrOGU6dkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjoxMTo0NVrOGVFVLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4MjU0Ng==", "bodyText": "You cannot just ignore InstanceOfNode and FixedGuardNode. That would mean you omit necessary type checks.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424582546", "createdAt": "2020-05-13T16:44:56Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -487,10 +490,15 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n              */\n             Node singleFunctionality = null;\n             ReturnNode singleReturn = null;\n+            ValueNode singleNewInstance = null;\n             for (Node node : graph.getNodes()) {\n                 if (node == graph.start() || node instanceof ParameterNode || node instanceof ConstantNode || node instanceof FrameState) {\n                     /* Ignore the allowed framework around the nodes we care about. */\n-                } else if (node instanceof MethodCallTargetNode) {\n+                } else if (node instanceof DynamicNewInstanceNode && singleNewInstance == null && ((DynamicNewInstanceNode) node).getInstanceType().isConstant()) {\n+                    singleNewInstance = (DynamicNewInstanceNode) node;\n+                } else if (node instanceof NewInstanceNode && singleNewInstance == null) {\n+                    singleNewInstance = (NewInstanceNode) node;\n+                } else if (node instanceof MethodCallTargetNode || node instanceof InstanceOfNode || node instanceof FixedGuardNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MDYyMg==", "bodyText": "This should be fixed.  Removed these and added a ClassCast check in the transplanted nodes.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424760622", "createdAt": "2020-05-13T22:11:45Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -487,10 +490,15 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n              */\n             Node singleFunctionality = null;\n             ReturnNode singleReturn = null;\n+            ValueNode singleNewInstance = null;\n             for (Node node : graph.getNodes()) {\n                 if (node == graph.start() || node instanceof ParameterNode || node instanceof ConstantNode || node instanceof FrameState) {\n                     /* Ignore the allowed framework around the nodes we care about. */\n-                } else if (node instanceof MethodCallTargetNode) {\n+                } else if (node instanceof DynamicNewInstanceNode && singleNewInstance == null && ((DynamicNewInstanceNode) node).getInstanceType().isConstant()) {\n+                    singleNewInstance = (DynamicNewInstanceNode) node;\n+                } else if (node instanceof NewInstanceNode && singleNewInstance == null) {\n+                    singleNewInstance = (NewInstanceNode) node;\n+                } else if (node instanceof MethodCallTargetNode || node instanceof InstanceOfNode || node instanceof FixedGuardNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4MjU0Ng=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Mzk4OTk4OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo0NjowMVrOGU6gWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxOTo1MjoxOVrOGVr2fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4MzI1OA==", "bodyText": "We need to immediately have a complete implementation. So you need to preserve this information from the image generator in a flag in DynamicHub so that you can return it here.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424583258", "createdAt": "2020-05-13T16:46:01Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "diffHunk": "@@ -755,6 +756,12 @@ private boolean isAnonymousClass() {\n         }\n     }\n \n+    @Substitute\n+    @TargetElement(onlyWith = JDK15OrLater.class)\n+    public boolean isHidden() {\n+        throw VMError.shouldNotReachHere();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzkyMw==", "bodyText": "Complete Hidden Class support is most likely going to take a lot of additional effort.  Creating Hidden classes is implemented in Hotspot and the hidden attribute is extracted via a native call to Hotspot.  My goal with this fix is to just get past these existing problems with JDK 15 and allow native-image to be used in the mean time.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424663923", "createdAt": "2020-05-13T18:59:37Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "diffHunk": "@@ -755,6 +756,12 @@ private boolean isAnonymousClass() {\n         }\n     }\n \n+    @Substitute\n+    @TargetElement(onlyWith = JDK15OrLater.class)\n+    public boolean isHidden() {\n+        throw VMError.shouldNotReachHere();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4MzI1OA=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MDk4NA==", "bodyText": "Why would getting the information be difficult? You only need to call the isHidden method during image generation and store it in DynamicHub. SVMHost.createHub already has the javaClass.\nYou need to call isHidden via reflection since it doesn't exist in prior JDKs. But that's OK.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424670984", "createdAt": "2020-05-13T19:12:28Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "diffHunk": "@@ -755,6 +756,12 @@ private boolean isAnonymousClass() {\n         }\n     }\n \n+    @Substitute\n+    @TargetElement(onlyWith = JDK15OrLater.class)\n+    public boolean isHidden() {\n+        throw VMError.shouldNotReachHere();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4MzI1OA=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4NDY0OQ==", "bodyText": "I can do that but there are other changes throughout the JDK that added support for isHidden like reflection and methodhandles.  These need to be looked at carefully.  Isn't it better to get an error if someone is trying to reference the isHidden attribute rather than to just report that is was or wasn't hidden during native-image generation?  I can go either way.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424684649", "createdAt": "2020-05-13T19:37:40Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "diffHunk": "@@ -755,6 +756,12 @@ private boolean isAnonymousClass() {\n         }\n     }\n \n+    @Substitute\n+    @TargetElement(onlyWith = JDK15OrLater.class)\n+    public boolean isHidden() {\n+        throw VMError.shouldNotReachHere();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4MzI1OA=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1ODEwOQ==", "bodyText": "Preserving the information from the image builder is the correct thing to do. There are never any new classes created at image run time, and the \"hidden\" attribute never changes at run time.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424758109", "createdAt": "2020-05-13T22:05:49Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "diffHunk": "@@ -755,6 +756,12 @@ private boolean isAnonymousClass() {\n         }\n     }\n \n+    @Substitute\n+    @TargetElement(onlyWith = JDK15OrLater.class)\n+    public boolean isHidden() {\n+        throw VMError.shouldNotReachHere();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4MzI1OA=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MDg1Ng==", "bodyText": "Ok, I'll add a reflected call to get the value and store it in a local DynamicHub field.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424760856", "createdAt": "2020-05-13T22:12:24Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "diffHunk": "@@ -755,6 +756,12 @@ private boolean isAnonymousClass() {\n         }\n     }\n \n+    @Substitute\n+    @TargetElement(onlyWith = JDK15OrLater.class)\n+    public boolean isHidden() {\n+        throw VMError.shouldNotReachHere();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4MzI1OA=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5MTc0Mw==", "bodyText": "Done.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r425391743", "createdAt": "2020-05-14T19:52:19Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java", "diffHunk": "@@ -755,6 +756,12 @@ private boolean isAnonymousClass() {\n         }\n     }\n \n+    @Substitute\n+    @TargetElement(onlyWith = JDK15OrLater.class)\n+    public boolean isHidden() {\n+        throw VMError.shouldNotReachHere();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4MzI1OA=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDAxMjg2OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo1MTo1M1rOGU6vDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxOToyNDoyMVrOGVAQTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NzAyMQ==", "bodyText": "Why is such a  DynamicNewInstanceNode not canonicalized to a NewInstanceNode? Because the type is not initialized yet?", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424587021", "createdAt": "2020-05-13T16:51:53Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -487,10 +490,15 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n              */\n             Node singleFunctionality = null;\n             ReturnNode singleReturn = null;\n+            ValueNode singleNewInstance = null;\n             for (Node node : graph.getNodes()) {\n                 if (node == graph.start() || node instanceof ParameterNode || node instanceof ConstantNode || node instanceof FrameState) {\n                     /* Ignore the allowed framework around the nodes we care about. */\n-                } else if (node instanceof MethodCallTargetNode) {\n+                } else if (node instanceof DynamicNewInstanceNode && singleNewInstance == null && ((DynamicNewInstanceNode) node).getInstanceType().isConstant()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MTAyMA==", "bodyText": "I don't know for sure.  This was the initial cause of the failure requiring the fixes.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424661020", "createdAt": "2020-05-13T18:54:34Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -487,10 +490,15 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n              */\n             Node singleFunctionality = null;\n             ReturnNode singleReturn = null;\n+            ValueNode singleNewInstance = null;\n             for (Node node : graph.getNodes()) {\n                 if (node == graph.start() || node instanceof ParameterNode || node instanceof ConstantNode || node instanceof FrameState) {\n                     /* Ignore the allowed framework around the nodes we care about. */\n-                } else if (node instanceof MethodCallTargetNode) {\n+                } else if (node instanceof DynamicNewInstanceNode && singleNewInstance == null && ((DynamicNewInstanceNode) node).getInstanceType().isConstant()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NzAyMQ=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NzQ1NQ==", "bodyText": "I only see the DynamicNewInstanceNodes during the clinit phase of native-image.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424677455", "createdAt": "2020-05-13T19:24:21Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -487,10 +490,15 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n              */\n             Node singleFunctionality = null;\n             ReturnNode singleReturn = null;\n+            ValueNode singleNewInstance = null;\n             for (Node node : graph.getNodes()) {\n                 if (node == graph.start() || node instanceof ParameterNode || node instanceof ConstantNode || node instanceof FrameState) {\n                     /* Ignore the allowed framework around the nodes we care about. */\n-                } else if (node instanceof MethodCallTargetNode) {\n+                } else if (node instanceof DynamicNewInstanceNode && singleNewInstance == null && ((DynamicNewInstanceNode) node).getInstanceType().isConstant()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NzAyMQ=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDAxNzc5OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo1MzoxOVrOGU6ydg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo1MzoyNlrOGU_NXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4Nzg5NA==", "bodyText": "Why do you need this class initialization check for the invoke when there is a singleNewInstance?", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424587894", "createdAt": "2020-05-13T16:53:19Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -516,12 +524,26 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n \n             JavaKind returnResultKind = b.getInvokeReturnType().getJavaKind().getStackKind();\n             ValueNode transplantedSingleFunctionality = null;\n+            NewInstanceNode transplantedNewInstance = null;\n             if (singleFunctionality instanceof Invoke) {\n+\n                 Invoke singleInvoke = (Invoke) singleFunctionality;\n                 MethodCallTargetNode singleCallTarget = (MethodCallTargetNode) singleInvoke.callTarget();\n                 ResolvedJavaMethod resolvedTarget = lookup(singleCallTarget.targetMethod());\n \n-                maybeEmitClassInitialization(b, singleCallTarget.invokeKind() == InvokeKind.Static, resolvedTarget.getDeclaringClass());\n+                if (singleNewInstance != null) {\n+                    ResolvedJavaType type = null;\n+                    if (singleNewInstance instanceof DynamicNewInstanceNode) {\n+                        type = lookup(originalProviders.getConstantReflection().asJavaType(((DynamicNewInstanceNode) singleNewInstance).getInstanceType().asConstant()));\n+                    }\n+                    if (singleNewInstance instanceof NewInstanceNode) {\n+                        type = lookup(((NewInstanceNode) singleNewInstance).instanceClass());\n+                    }\n+                    maybeEmitClassInitialization(b, true, resolvedTarget.getDeclaringClass());\n+                    transplantedNewInstance = b.add(new SubstrateNewInstanceNode(type, true));\n+                } else {\n+                    maybeEmitClassInitialization(b, singleCallTarget.invokeKind() == InvokeKind.Static, resolvedTarget.getDeclaringClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MDMxNw==", "bodyText": "I only added this during debugging thinking that it was the cause of a problem I was having. I'll remove it.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424660317", "createdAt": "2020-05-13T18:53:26Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -516,12 +524,26 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n \n             JavaKind returnResultKind = b.getInvokeReturnType().getJavaKind().getStackKind();\n             ValueNode transplantedSingleFunctionality = null;\n+            NewInstanceNode transplantedNewInstance = null;\n             if (singleFunctionality instanceof Invoke) {\n+\n                 Invoke singleInvoke = (Invoke) singleFunctionality;\n                 MethodCallTargetNode singleCallTarget = (MethodCallTargetNode) singleInvoke.callTarget();\n                 ResolvedJavaMethod resolvedTarget = lookup(singleCallTarget.targetMethod());\n \n-                maybeEmitClassInitialization(b, singleCallTarget.invokeKind() == InvokeKind.Static, resolvedTarget.getDeclaringClass());\n+                if (singleNewInstance != null) {\n+                    ResolvedJavaType type = null;\n+                    if (singleNewInstance instanceof DynamicNewInstanceNode) {\n+                        type = lookup(originalProviders.getConstantReflection().asJavaType(((DynamicNewInstanceNode) singleNewInstance).getInstanceType().asConstant()));\n+                    }\n+                    if (singleNewInstance instanceof NewInstanceNode) {\n+                        type = lookup(((NewInstanceNode) singleNewInstance).instanceClass());\n+                    }\n+                    maybeEmitClassInitialization(b, true, resolvedTarget.getDeclaringClass());\n+                    transplantedNewInstance = b.add(new SubstrateNewInstanceNode(type, true));\n+                } else {\n+                    maybeEmitClassInitialization(b, singleCallTarget.invokeKind() == InvokeKind.Static, resolvedTarget.getDeclaringClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4Nzg5NA=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDAyMzcwOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNjo1NTowMVrOGU62gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjoxNDo0NFrOGVFZhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4ODkzMQ==", "bodyText": "What happens if there is a singleNewInstance but singleFunctionality is not an Invoke?", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424588931", "createdAt": "2020-05-13T16:55:01Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -516,12 +524,26 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n \n             JavaKind returnResultKind = b.getInvokeReturnType().getJavaKind().getStackKind();\n             ValueNode transplantedSingleFunctionality = null;\n+            NewInstanceNode transplantedNewInstance = null;\n             if (singleFunctionality instanceof Invoke) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2NDQzMA==", "bodyText": "The processInvokeWithMethodHandle should always have an Invoke but I can add an assert.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424664430", "createdAt": "2020-05-13T19:00:30Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -516,12 +524,26 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n \n             JavaKind returnResultKind = b.getInvokeReturnType().getJavaKind().getStackKind();\n             ValueNode transplantedSingleFunctionality = null;\n+            NewInstanceNode transplantedNewInstance = null;\n             if (singleFunctionality instanceof Invoke) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4ODkzMQ=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MTczMw==", "bodyText": "Added a check for this situation.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r424761733", "createdAt": "2020-05-13T22:14:44Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -516,12 +524,26 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n \n             JavaKind returnResultKind = b.getInvokeReturnType().getJavaKind().getStackKind();\n             ValueNode transplantedSingleFunctionality = null;\n+            NewInstanceNode transplantedNewInstance = null;\n             if (singleFunctionality instanceof Invoke) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4ODkzMQ=="}, "originalCommit": {"oid": "0fe26e7ca966728c63a84b9847ad42aab6b069c8"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjM1ODk5OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/SVMHost.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozNjo0M1rOGXrVRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozNjo0M1rOGXrVRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MDM4OQ==", "bodyText": "Certainly a high overhead to do the reflective lookup every time. You could store the Method in s static final field.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r427480389", "createdAt": "2020-05-19T17:36:43Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/SVMHost.java", "diffHunk": "@@ -296,8 +298,22 @@ private DynamicHub createHub(AnalysisType type) {\n          */\n         String sourceFileName = stringTable.deduplicate(type.getSourceFileName(), true);\n \n+        /*\n+         * JDK 15 added support for Hidden Classes. Record if this javaClass is hidden.\n+         */\n+        boolean isHidden = false;\n+        if (JavaVersionUtil.JAVA_SPEC >= 15) {\n+            try {\n+                Method isHiddenMethod = Class.class.getMethod(\"isHidden\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d245184d672a8fb77c4b6c333b3fa53dd9a89385"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjM2MzQ0OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/SVMHost.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozNzo0OFrOGXrX6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozNzo0OFrOGXrX6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MTA2Nw==", "bodyText": "We usually just use throw VMError.shouldNotReachHere(e) to convert impossible checked exceptions into unchecked. No need to build a fancy error message.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r427481067", "createdAt": "2020-05-19T17:37:48Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/SVMHost.java", "diffHunk": "@@ -296,8 +298,22 @@ private DynamicHub createHub(AnalysisType type) {\n          */\n         String sourceFileName = stringTable.deduplicate(type.getSourceFileName(), true);\n \n+        /*\n+         * JDK 15 added support for Hidden Classes. Record if this javaClass is hidden.\n+         */\n+        boolean isHidden = false;\n+        if (JavaVersionUtil.JAVA_SPEC >= 15) {\n+            try {\n+                Method isHiddenMethod = Class.class.getMethod(\"isHidden\");\n+                isHidden = (boolean) isHiddenMethod.invoke(javaClass);\n+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n+                String message = \"Exception trying to lookup or call isHidden on class: \" + javaClass + \" \" + e;\n+                throw new UnsupportedFeatureException(message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d245184d672a8fb77c4b6c333b3fa53dd9a89385"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjM3MjAyOnYy", "diffSide": "LEFT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/jdk/JNIRegistrationJavaNet.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzo0MDowNFrOGXrdYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOToyMjo1NVrOGXvPRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MjQ2Ng==", "bodyText": "Why is it safe to remove this code?", "url": "https://github.com/oracle/graal/pull/2455#discussion_r427482466", "createdAt": "2020-05-19T17:40:04Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/jdk/JNIRegistrationJavaNet.java", "diffHunk": "@@ -115,14 +114,6 @@ public void beforeAnalysis(BeforeAnalysisAccess a) {\n         a.registerReachabilityHandler(JNIRegistrationJavaNet::registerDatagramPacketInit,\n                         method(a, \"java.net.DatagramPacket\", \"init\"));\n \n-        if (JavaVersionUtil.JAVA_SPEC >= 15) {\n-            a.registerReachabilityHandler(JNIRegistrationJavaNet::registerDatagramSocketCheckOldImpl,\n-                            method(a, \"java.net.DatagramSocket\", \"checkOldImpl\", java.net.DatagramSocketImpl.class));\n-        } else {\n-            a.registerReachabilityHandler(JNIRegistrationJavaNet::registerDatagramSocketCheckOldImpl,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d245184d672a8fb77c4b6c333b3fa53dd9a89385"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0NDM4OA==", "bodyText": "Check the lasted version of this file in the PR.  I fixed this.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r427544388", "createdAt": "2020-05-19T19:22:55Z", "author": {"login": "bobvandette"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/jdk/JNIRegistrationJavaNet.java", "diffHunk": "@@ -115,14 +114,6 @@ public void beforeAnalysis(BeforeAnalysisAccess a) {\n         a.registerReachabilityHandler(JNIRegistrationJavaNet::registerDatagramPacketInit,\n                         method(a, \"java.net.DatagramPacket\", \"init\"));\n \n-        if (JavaVersionUtil.JAVA_SPEC >= 15) {\n-            a.registerReachabilityHandler(JNIRegistrationJavaNet::registerDatagramSocketCheckOldImpl,\n-                            method(a, \"java.net.DatagramSocket\", \"checkOldImpl\", java.net.DatagramSocketImpl.class));\n-        } else {\n-            a.registerReachabilityHandler(JNIRegistrationJavaNet::registerDatagramSocketCheckOldImpl,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MjQ2Ng=="}, "originalCommit": {"oid": "d245184d672a8fb77c4b6c333b3fa53dd9a89385"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjM3OTUwOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzo0MjowNVrOGXriXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzo0MjowNVrOGXriXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4Mzc0Mw==", "bodyText": "That cannot be a VMError but needs to be properly reported like any other unsupported condition, via reportUnsupportedFeature.\nBut why actually introduce this restriction? You can easily refactor your code below to transplant the singleNewInstance independently from the invoke.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r427483743", "createdAt": "2020-05-19T17:42:05Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -502,6 +510,10 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n                 }\n             }\n \n+            if (singleNewInstance != null && !(singleFunctionality instanceof Invoke)) {\n+                throw VMError.shouldNotReachHere(\"singleFunctionality != Invoke with non null singleNewInstance\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d245184d672a8fb77c4b6c333b3fa53dd9a89385"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjY4OTEzOnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOTowNDo1NFrOGXumqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOTowNDo1NFrOGXumqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMzk5Mw==", "bodyText": "You also need a maybeEmitClassInitialization before the NewInstanceNode, otherwise you might allocate a non-initialized class.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r427533993", "createdAt": "2020-05-19T19:04:54Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -516,13 +528,26 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n \n             JavaKind returnResultKind = b.getInvokeReturnType().getJavaKind().getStackKind();\n             ValueNode transplantedSingleFunctionality = null;\n+            ValueNode transplantedNewInstance = null;\n             if (singleFunctionality instanceof Invoke) {\n+\n                 Invoke singleInvoke = (Invoke) singleFunctionality;\n                 MethodCallTargetNode singleCallTarget = (MethodCallTargetNode) singleInvoke.callTarget();\n                 ResolvedJavaMethod resolvedTarget = lookup(singleCallTarget.targetMethod());\n \n-                maybeEmitClassInitialization(b, singleCallTarget.invokeKind() == InvokeKind.Static, resolvedTarget.getDeclaringClass());\n+                if (singleNewInstance != null) {\n+                    ResolvedJavaType type = null;\n+                    if (singleNewInstance instanceof DynamicNewInstanceNode) {\n+                        type = lookup(originalProviders.getConstantReflection().asJavaType(((DynamicNewInstanceNode) singleNewInstance).getInstanceType().asConstant()));\n+                    }\n+                    if (singleNewInstance instanceof NewInstanceNode) {\n+                        type = lookup(((NewInstanceNode) singleNewInstance).instanceClass());\n+                    }\n+                    ValueNode newInstance = b.add(new NewInstanceNode(type, true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22a2d9ca5bddb029e24a0b9d35cc145be30c1d72"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjY5NDA5OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOTowNjoxMVrOGXupqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOToyMDowMlrOGXvIjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNDc2MA==", "bodyText": "How do you know the classCastStamp applies to the newinstance node?", "url": "https://github.com/oracle/graal/pull/2455#discussion_r427534760", "createdAt": "2020-05-19T19:06:11Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -516,13 +528,26 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n \n             JavaKind returnResultKind = b.getInvokeReturnType().getJavaKind().getStackKind();\n             ValueNode transplantedSingleFunctionality = null;\n+            ValueNode transplantedNewInstance = null;\n             if (singleFunctionality instanceof Invoke) {\n+\n                 Invoke singleInvoke = (Invoke) singleFunctionality;\n                 MethodCallTargetNode singleCallTarget = (MethodCallTargetNode) singleInvoke.callTarget();\n                 ResolvedJavaMethod resolvedTarget = lookup(singleCallTarget.targetMethod());\n \n-                maybeEmitClassInitialization(b, singleCallTarget.invokeKind() == InvokeKind.Static, resolvedTarget.getDeclaringClass());\n+                if (singleNewInstance != null) {\n+                    ResolvedJavaType type = null;\n+                    if (singleNewInstance instanceof DynamicNewInstanceNode) {\n+                        type = lookup(originalProviders.getConstantReflection().asJavaType(((DynamicNewInstanceNode) singleNewInstance).getInstanceType().asConstant()));\n+                    }\n+                    if (singleNewInstance instanceof NewInstanceNode) {\n+                        type = lookup(((NewInstanceNode) singleNewInstance).instanceClass());\n+                    }\n+                    ValueNode newInstance = b.add(new NewInstanceNode(type, true));\n+                    transplantedNewInstance = maybeEmitClassCast(b, classCastStamp, newInstance);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22a2d9ca5bddb029e24a0b9d35cc145be30c1d72"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU0MjY2OA==", "bodyText": "Actually the maybeEmitClassCast here is not necessary. A class cast is only removed above when the checked value is a Invoke or LoadFieldNode.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r427542668", "createdAt": "2020-05-19T19:20:02Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -516,13 +528,26 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n \n             JavaKind returnResultKind = b.getInvokeReturnType().getJavaKind().getStackKind();\n             ValueNode transplantedSingleFunctionality = null;\n+            ValueNode transplantedNewInstance = null;\n             if (singleFunctionality instanceof Invoke) {\n+\n                 Invoke singleInvoke = (Invoke) singleFunctionality;\n                 MethodCallTargetNode singleCallTarget = (MethodCallTargetNode) singleInvoke.callTarget();\n                 ResolvedJavaMethod resolvedTarget = lookup(singleCallTarget.targetMethod());\n \n-                maybeEmitClassInitialization(b, singleCallTarget.invokeKind() == InvokeKind.Static, resolvedTarget.getDeclaringClass());\n+                if (singleNewInstance != null) {\n+                    ResolvedJavaType type = null;\n+                    if (singleNewInstance instanceof DynamicNewInstanceNode) {\n+                        type = lookup(originalProviders.getConstantReflection().asJavaType(((DynamicNewInstanceNode) singleNewInstance).getInstanceType().asConstant()));\n+                    }\n+                    if (singleNewInstance instanceof NewInstanceNode) {\n+                        type = lookup(((NewInstanceNode) singleNewInstance).instanceClass());\n+                    }\n+                    ValueNode newInstance = b.add(new NewInstanceNode(type, true));\n+                    transplantedNewInstance = maybeEmitClassCast(b, classCastStamp, newInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNDc2MA=="}, "originalCommit": {"oid": "22a2d9ca5bddb029e24a0b9d35cc145be30c1d72"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MTg1NjQ0OnYy", "diffSide": "RIGHT", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjo0OToxMVrOGanXkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjo0OToxMVrOGanXkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2MTE3MQ==", "bodyText": "I just merged 18bdfdd which ensures that DynamicNewInstanceNode with a constant class is always constant folded to a NewInstanceNode. Please remove this check now (and everything else related to DynamicNewInstanceNode in this PR), it should no longer be necessary.", "url": "https://github.com/oracle/graal/pull/2455#discussion_r430561171", "createdAt": "2020-05-26T16:49:11Z", "author": {"login": "christianwimmer"}, "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/phases/IntrinsifyMethodHandlesInvocationPlugin.java", "diffHunk": "@@ -487,9 +492,14 @@ private void processInvokeWithMethodHandle(GraphBuilderContext b, Replacements r\n              */\n             Node singleFunctionality = null;\n             ReturnNode singleReturn = null;\n+            ValueNode singleNewInstance = null;\n             for (Node node : graph.getNodes()) {\n                 if (node == graph.start() || node instanceof ParameterNode || node instanceof ConstantNode || node instanceof FrameState) {\n                     /* Ignore the allowed framework around the nodes we care about. */\n+                } else if (node instanceof DynamicNewInstanceNode && singleNewInstance == null && ((DynamicNewInstanceNode) node).getInstanceType().isConstant()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5541bc66713e12b1d2600b1f9c9913a7d527b6"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 752, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}