{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3Mjk5NjE5", "number": 2664, "title": "Add more re-associations for associative binary operations", "bodyText": "It has supported the re-association to associate the values which satisfy the specified criterion like \"(a + 1) + 2 => a + (1 + 2)\".\nHowever, it needs one of the original operands satisfy the criterion. It cannot handle patterns like \"(a + 1) + (b + 2)\", which could be optimized to \"(a + b) + (1 + 2)\".\nThis patch adds another kind of re-association to expose the matched values as the operand. For example with the constantness criterion, \"(a + 1) + b\" is re-associated to \"(a + b) + 1\". Used together with the existed re-association, it could create more opportunities for other optimizations like constant-fold and loop-invariant elimination.\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221", "createdAt": "2020-07-10T08:21:32Z", "url": "https://github.com/oracle/graal/pull/2664", "merged": true, "mergeCommit": {"oid": "e011e75acafab6663df5e9d801e6a7ce4202d871"}, "closed": true, "closedAt": "2020-09-16T10:43:42Z", "author": {"login": "XiaohongGong"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0YXxjABqjM1Mzc3NzUzODc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFdACugBqjM3Mjc3NTE5NTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c6a365c5cec948d2f3f84a2026f6dc0f535fa91", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/2c6a365c5cec948d2f3f84a2026f6dc0f535fa91", "committedDate": "2020-07-10T08:18:25Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: I1fa87e348b9e66eb958bd43e9f0ebceff8ad2fcc"}, "afterCommit": {"oid": "9804f7ebbd1be5ea5945d97d6ca8f5f3525c1c6f", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/9804f7ebbd1be5ea5945d97d6ca8f5f3525c1c6f", "committedDate": "2020-07-13T02:52:44Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: I1fa87e348b9e66eb958bd43e9f0ebceff8ad2fcc"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9804f7ebbd1be5ea5945d97d6ca8f5f3525c1c6f", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/9804f7ebbd1be5ea5945d97d6ca8f5f3525c1c6f", "committedDate": "2020-07-13T02:52:44Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: I1fa87e348b9e66eb958bd43e9f0ebceff8ad2fcc"}, "afterCommit": {"oid": "bb7477d0fddaf512fc2dd76705828eb1a61619b1", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/bb7477d0fddaf512fc2dd76705828eb1a61619b1", "committedDate": "2020-07-14T03:54:47Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: I8de6040ee07a09cdb17d57b17bcddaa8ea5f8f68"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bb7477d0fddaf512fc2dd76705828eb1a61619b1", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/bb7477d0fddaf512fc2dd76705828eb1a61619b1", "committedDate": "2020-07-14T03:54:47Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: I8de6040ee07a09cdb17d57b17bcddaa8ea5f8f68"}, "afterCommit": {"oid": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "committedDate": "2020-07-14T05:19:27Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNjEzNjAx", "url": "https://github.com/oracle/graal/pull/2664#pullrequestreview-451613601", "createdAt": "2020-07-20T13:38:43Z", "commit": {"oid": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzozODo0M1rOG0M_pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzo0MjozNFrOG0NNkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MjAzOQ==", "bodyText": "please use a constant seed for tests (e.g. a prime number)", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457392039", "createdAt": "2020-07-20T13:38:43Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ReassociateAndCanonicalTest2.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.core.test;\n+\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;\n+import org.junit.Test;\n+\n+public class ReassociateAndCanonicalTest2 extends GraalCompilerTest {\n+\n+    private static int rnd1 = (int) (Math.random() * 100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MjU3OA==", "bodyText": "Could you also please provide test cases for loops? some we are sure we do not want to regress any more in the future", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457392578", "createdAt": "2020-07-20T13:39:16Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ReassociateAndCanonicalTest2.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.core.test;\n+\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;\n+import org.junit.Test;\n+\n+public class ReassociateAndCanonicalTest2 extends GraalCompilerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MzQ4Mw==", "bodyText": "I would prefer a regular loop here if possible", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457393483", "createdAt": "2020-07-20T13:40:16Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/ReassociateInvariantPhase.java", "diffHunk": "@@ -31,25 +31,36 @@\n import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n import org.graalvm.compiler.phases.Phase;\n \n+import java.util.function.Predicate;\n+\n /**\n  * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} so that\n  * invariant parts of the expression can move outside of the loop.\n  */\n public class ReassociateInvariantPhase extends Phase {\n+    private static final Predicate<LoopEx> reassociateVariants = loop -> loop.reassociateVariants();\n+    private static final Predicate<LoopEx> reassociateInvariants = loop -> loop.reassociateInvariants();\n \n     @SuppressWarnings(\"try\")\n     @Override\n     protected void run(StructuredGraph graph) {\n-        int iterations = 0;\n         DebugContext debug = graph.getDebug();\n-        try (DebugContext.Scope s = debug.scope(\"ReassociateInvariants\")) {\n+        try (DebugContext.Scope s = debug.scope(\"ReassociateLoopInvariant\")) {\n+            doReassociate(graph, reassociateVariants, debug, \"ReassociateVariants\");\n+            doReassociate(graph, reassociateInvariants, debug, \"ReassociateInvariants\");\n+        } catch (Throwable e) {\n+            throw debug.handle(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"try\")\n+    private static void doReassociate(StructuredGraph graph, Predicate<LoopEx> predicate, DebugContext debug, String scope) {\n+        int iterations = 0;\n+        try (DebugContext.Scope s = debug.scope(scope)) {\n             boolean changed = true;\n             while (changed) {\n-                changed = false;\n                 final LoopsData dataReassociate = new LoopsData(graph);\n-                for (LoopEx loop : dataReassociate.loops()) {\n-                    changed |= loop.reassociateInvariants();\n-                }\n+                changed = dataReassociate.loops().stream().anyMatch(predicate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NDc0Mw==", "bodyText": "is the phi predicate class & allocation necessary here? I might miss something but it seems it does not escape and the logic of apply is very simple.", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457394743", "createdAt": "2020-07-20T13:41:36Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/BinaryArithmeticNode.java", "diffHunk": "@@ -235,6 +235,165 @@ private static ReassociateMatch findReassociate(BinaryNode binary, NodePredicate\n         return null;\n     }\n \n+    private static ReassociateMatch findReassociativeOperand(BinaryArithmeticNode<?> binary, NodePredicate criterion) {\n+        NodePredicate binaryCriterion = new ReassociativePredicate(binary);\n+        ValueNode forX = binary.getX();\n+        ValueNode forY = binary.getY();\n+        if (binaryCriterion.apply(forX) && findReassociate((BinaryNode) forX, criterion) != null) {\n+            return ReassociateMatch.x;\n+        }\n+\n+        if (binaryCriterion.apply(forY) && findReassociate((BinaryNode) forY, criterion) != null) {\n+            return ReassociateMatch.y;\n+        }\n+        return null;\n+    }\n+\n+    private static class ReassociativePredicate implements NodePredicate {\n+        private final BinaryArithmeticNode<?> binary;\n+\n+        ReassociativePredicate(BinaryArithmeticNode<?> binary) {\n+            this.binary = binary;\n+        }\n+\n+        @Override\n+        public boolean apply(Node node) {\n+            if (binary instanceof AddNode || binary instanceof SubNode) {\n+                return node instanceof AddNode || node instanceof SubNode;\n+            }\n+            return node.getClass() == binary.getClass();\n+        }\n+    }\n+\n+    private static class LoopPhiPredicate implements NodePredicate {\n+        private final BinaryArithmeticNode<?> binary;\n+\n+        LoopPhiPredicate(BinaryArithmeticNode<?> binary) {\n+            this.binary = binary;\n+        }\n+\n+        @Override\n+        public boolean apply(Node node) {\n+            if (node instanceof ValuePhiNode) {\n+                ValuePhiNode iv = (ValuePhiNode) node;\n+                return iv.values().contains(binary);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Tries to expose values which satisfy the criterion as an operand. This could create more\n+     * opportunities for other optimizations like constant-fold and loop-invariant elimination. For\n+     * example with a constantness criterion: {@code (a * 2) * b => (a * b) * 2}\n+     *\n+     * This method accepts only {@linkplain BinaryOp#isAssociative() associative} operations such as\n+     * +, -, *, &, | and ^\n+     */\n+    public static ValueNode reassociateUnmatchedValues(BinaryArithmeticNode<?> node, NodePredicate criterion, NodeView view, boolean skipLoopPhiValues) {\n+        ValueNode forX = node.getX();\n+        ValueNode forY = node.getY();\n+        assert node.getOp(forX, forY).isAssociative();\n+\n+        // Skip re-associations for expressions like \"i = i + var\". This may influence the counted\n+        // loop detection. For example, if the loop counter is re-associated from \"i += (var + 1)\"\n+        // to \"i = (i + var) + 1\", the counted loop will not be detected as expected.\n+        if (skipLoopPhiValues) {\n+            LoopPhiPredicate phiCriterion = new LoopPhiPredicate(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NTYwMQ==", "bodyText": "also I am not sure this is restrictive enough. Have you tried with derived induction variables as well and what happens for re-associations of mul nodes?", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457395601", "createdAt": "2020-07-20T13:42:34Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/BinaryArithmeticNode.java", "diffHunk": "@@ -235,6 +235,165 @@ private static ReassociateMatch findReassociate(BinaryNode binary, NodePredicate\n         return null;\n     }\n \n+    private static ReassociateMatch findReassociativeOperand(BinaryArithmeticNode<?> binary, NodePredicate criterion) {\n+        NodePredicate binaryCriterion = new ReassociativePredicate(binary);\n+        ValueNode forX = binary.getX();\n+        ValueNode forY = binary.getY();\n+        if (binaryCriterion.apply(forX) && findReassociate((BinaryNode) forX, criterion) != null) {\n+            return ReassociateMatch.x;\n+        }\n+\n+        if (binaryCriterion.apply(forY) && findReassociate((BinaryNode) forY, criterion) != null) {\n+            return ReassociateMatch.y;\n+        }\n+        return null;\n+    }\n+\n+    private static class ReassociativePredicate implements NodePredicate {\n+        private final BinaryArithmeticNode<?> binary;\n+\n+        ReassociativePredicate(BinaryArithmeticNode<?> binary) {\n+            this.binary = binary;\n+        }\n+\n+        @Override\n+        public boolean apply(Node node) {\n+            if (binary instanceof AddNode || binary instanceof SubNode) {\n+                return node instanceof AddNode || node instanceof SubNode;\n+            }\n+            return node.getClass() == binary.getClass();\n+        }\n+    }\n+\n+    private static class LoopPhiPredicate implements NodePredicate {\n+        private final BinaryArithmeticNode<?> binary;\n+\n+        LoopPhiPredicate(BinaryArithmeticNode<?> binary) {\n+            this.binary = binary;\n+        }\n+\n+        @Override\n+        public boolean apply(Node node) {\n+            if (node instanceof ValuePhiNode) {\n+                ValuePhiNode iv = (ValuePhiNode) node;\n+                return iv.values().contains(binary);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Tries to expose values which satisfy the criterion as an operand. This could create more\n+     * opportunities for other optimizations like constant-fold and loop-invariant elimination. For\n+     * example with a constantness criterion: {@code (a * 2) * b => (a * b) * 2}\n+     *\n+     * This method accepts only {@linkplain BinaryOp#isAssociative() associative} operations such as\n+     * +, -, *, &, | and ^\n+     */\n+    public static ValueNode reassociateUnmatchedValues(BinaryArithmeticNode<?> node, NodePredicate criterion, NodeView view, boolean skipLoopPhiValues) {\n+        ValueNode forX = node.getX();\n+        ValueNode forY = node.getY();\n+        assert node.getOp(forX, forY).isAssociative();\n+\n+        // Skip re-associations for expressions like \"i = i + var\". This may influence the counted\n+        // loop detection. For example, if the loop counter is re-associated from \"i += (var + 1)\"\n+        // to \"i = (i + var) + 1\", the counted loop will not be detected as expected.\n+        if (skipLoopPhiValues) {\n+            LoopPhiPredicate phiCriterion = new LoopPhiPredicate(node);\n+            if (phiCriterion.apply(forX) || phiCriterion.apply(forY)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3"}, "originalPosition": 76}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "committedDate": "2020-07-14T05:19:27Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221"}, "afterCommit": {"oid": "154eef3a845c3d8cbd72f3bd09197fdfd3b7daa7", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/154eef3a845c3d8cbd72f3bd09197fdfd3b7daa7", "committedDate": "2020-07-23T03:17:58Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "154eef3a845c3d8cbd72f3bd09197fdfd3b7daa7", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/154eef3a845c3d8cbd72f3bd09197fdfd3b7daa7", "committedDate": "2020-07-23T03:17:58Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221"}, "afterCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/2c32b5b3b31f58a241b934c468f1dce00a29d248", "committedDate": "2020-08-17T10:00:54Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNzcwNzM0", "url": "https://github.com/oracle/graal/pull/2664#pullrequestreview-480770734", "createdAt": "2020-09-02T12:32:43Z", "commit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjozMjo0M1rOHLs3Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMjo0MjowMlrOHLtMsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMTM2Nw==", "bodyText": "we had problems with while(true) loops in the past and thus impose a policy where every while true loop must have an upper bound of iterations that should be a sanity filter.\nWhile it is true that this loop should terminate, in favor of defensive programming please add a constant upper number of iterations (idk 32? or what was the highest number of iterations y have seen during testing?) and abort the loop if the upper bound is reached.", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482031367", "createdAt": "2020-09-02T12:32:43Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.\n+ */\n+public class ReassociationPhase extends Phase {\n+\n+    @SuppressWarnings(\"try\")\n+    @Override\n+    protected void run(StructuredGraph graph) {\n+        DebugContext debug = graph.getDebug();\n+        try (DebugContext.Scope s = debug.scope(\"ReassociationPhase\")) {\n+            reassociateInvariant(graph, debug);\n+            reassociateConstant(graph, debug);\n+        } catch (Throwable e) {\n+            throw debug.handle(e);\n+        }\n+        graph.setAfterReassociation();\n+    }\n+\n+    /**\n+     * Re-associate loop invariant so that invariant parts of the expression can move outside of the\n+     * loop.\n+     */\n+    @SuppressWarnings(\"try\")\n+    private static void reassociateInvariant(StructuredGraph graph, DebugContext debug) {\n+        LoopsData loopsData = new LoopsData(graph);\n+        int iterations = 0;\n+        try (DebugContext.Scope s = debug.scope(\"ReassociateInvariants\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMTc2Ng==", "bodyText": "pls make that a VERY_DETAILED level and add the string \"reassociation:\" to the message", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482031766", "createdAt": "2020-09-02T12:33:26Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.\n+ */\n+public class ReassociationPhase extends Phase {\n+\n+    @SuppressWarnings(\"try\")\n+    @Override\n+    protected void run(StructuredGraph graph) {\n+        DebugContext debug = graph.getDebug();\n+        try (DebugContext.Scope s = debug.scope(\"ReassociationPhase\")) {\n+            reassociateInvariant(graph, debug);\n+            reassociateConstant(graph, debug);\n+        } catch (Throwable e) {\n+            throw debug.handle(e);\n+        }\n+        graph.setAfterReassociation();\n+    }\n+\n+    /**\n+     * Re-associate loop invariant so that invariant parts of the expression can move outside of the\n+     * loop.\n+     */\n+    @SuppressWarnings(\"try\")\n+    private static void reassociateInvariant(StructuredGraph graph, DebugContext debug) {\n+        LoopsData loopsData = new LoopsData(graph);\n+        int iterations = 0;\n+        try (DebugContext.Scope s = debug.scope(\"ReassociateInvariants\")) {\n+            boolean changed = true;\n+            while (changed) {\n+                changed = false;\n+                for (LoopEx loop : loopsData.loops()) {\n+                    changed |= loop.reassociateInvariants();\n+                }\n+                loopsData.deleteUnusedNodes();\n+                iterations++;\n+                debug.dump(DebugContext.VERBOSE_LEVEL, graph, \"after iteration %d\", iterations);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjMxOA==", "bodyText": "maybe you could also add a simple java doc example here pls?", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482032318", "createdAt": "2020-09-02T12:34:22Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.\n+ */\n+public class ReassociationPhase extends Phase {\n+\n+    @SuppressWarnings(\"try\")\n+    @Override\n+    protected void run(StructuredGraph graph) {\n+        DebugContext debug = graph.getDebug();\n+        try (DebugContext.Scope s = debug.scope(\"ReassociationPhase\")) {\n+            reassociateInvariant(graph, debug);\n+            reassociateConstant(graph, debug);\n+        } catch (Throwable e) {\n+            throw debug.handle(e);\n+        }\n+        graph.setAfterReassociation();\n+    }\n+\n+    /**\n+     * Re-associate loop invariant so that invariant parts of the expression can move outside of the\n+     * loop.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjc0OA==", "bodyText": "every phase has its own scope why is this one necessary?", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482032748", "createdAt": "2020-09-02T12:35:08Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.\n+ */\n+public class ReassociationPhase extends Phase {\n+\n+    @SuppressWarnings(\"try\")\n+    @Override\n+    protected void run(StructuredGraph graph) {\n+        DebugContext debug = graph.getDebug();\n+        try (DebugContext.Scope s = debug.scope(\"ReassociationPhase\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjg5OA==", "bodyText": "please add a simple code sample here that shows such an operation", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482032898", "createdAt": "2020-09-02T12:35:25Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMzU0OQ==", "bodyText": "We try to always use factory methods of nodes so any immediate folding can occur during construction already", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482033549", "createdAt": "2020-09-02T12:36:34Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MulNode.java", "diffHunk": "@@ -92,27 +93,37 @@ public ValueNode canonical(CanonicalizerTool tool, ValueNode forX, ValueNode for\n         }\n         BinaryOp<Mul> op = getOp(forX, forY);\n         NodeView view = NodeView.from(tool);\n-        return canonical(this, op, stamp(view), forX, forY, view);\n+        return canonical(tool, this, op, stamp(view), forX, forY, view);\n     }\n \n-    private static ValueNode canonical(MulNode self, BinaryOp<Mul> op, Stamp stamp, ValueNode forX, ValueNode forY, NodeView view) {\n+    private static ValueNode canonical(CanonicalizerTool tool, MulNode self, BinaryOp<Mul> op, Stamp stamp, ValueNode forX, ValueNode forY, NodeView view) {\n         if (forY.isConstant()) {\n             Constant c = forY.asConstant();\n             if (op.isNeutral(c)) {\n                 return forX;\n             }\n \n-            if (c instanceof PrimitiveConstant && ((PrimitiveConstant) c).getJavaKind().isNumericInteger()) {\n-                long i = ((PrimitiveConstant) c).asLong();\n-                ValueNode result = canonical(stamp, forX, i, view);\n-                if (result != null) {\n-                    return result;\n+            if (op.isAssociative()) {\n+                // Canonicalize expressions like \"(a * 2) * 4\" => \"(a * 8)\"\n+                ValueNode reassociated = reassociate1(self != null ? self : (MulNode) new MulNode(forX, forY).maybeCommuteInputs(), ValueNode.isConstantPredicate(), forX, forY, view);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNDM5OA==", "bodyText": "please give this method and the reassociate2 a better descriptive name that makes clear what is done in each method", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482034398", "createdAt": "2020-09-02T12:38:05Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/BinaryArithmeticNode.java", "diffHunk": "@@ -261,7 +393,7 @@ private static ReassociateMatch findReassociate(BinaryNode binary, NodePredicate\n      * @param forY\n      * @param forX\n      */\n-    public static ValueNode reassociate(BinaryArithmeticNode<?> node, NodePredicate criterion, ValueNode forX, ValueNode forY, NodeView view) {\n+    public static ValueNode reassociate1(BinaryArithmeticNode<?> node, NodePredicate criterion, ValueNode forX, ValueNode forY, NodeView view) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNTcyNQ==", "bodyText": "I think this name alone is not descriptive enough, maybe ReassociateLoopInvariants? Also, please add a small sentence in the help text above in the annotation", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482035725", "createdAt": "2020-09-02T12:40:21Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/GraalOptions.java", "diffHunk": "@@ -94,7 +94,7 @@\n     public static final OptionKey<Boolean> LoopPeeling = new OptionKey<>(true);\n \n     @Option(help = \"\", type = OptionType.Debug)\n-    public static final OptionKey<Boolean> ReassociateInvariants = new OptionKey<>(true);\n+    public static final OptionKey<Boolean> Reassociation = new OptionKey<>(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNjQ5MA==", "bodyText": "In the course of my suggestion for the mul node this can be removed in favor of the shift to mul transformation", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482036490", "createdAt": "2020-09-02T12:41:30Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/StructuredGraph.java", "diffHunk": "@@ -978,6 +980,14 @@ public void setAfterExpandLogic() {\n         isAfterExpandLogic = true;\n     }\n \n+    public boolean isAfterReassociation() {\n+        return isAfterReassociation;\n+    }\n+\n+    public void setAfterReassociation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNjkxMw==", "bodyText": "See my general review comments about the shift to mul rewrite.", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482036913", "createdAt": "2020-09-02T12:42:02Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MulNode.java", "diffHunk": "@@ -92,27 +93,37 @@ public ValueNode canonical(CanonicalizerTool tool, ValueNode forX, ValueNode for\n         }\n         BinaryOp<Mul> op = getOp(forX, forY);\n         NodeView view = NodeView.from(tool);\n-        return canonical(this, op, stamp(view), forX, forY, view);\n+        return canonical(tool, this, op, stamp(view), forX, forY, view);\n     }\n \n-    private static ValueNode canonical(MulNode self, BinaryOp<Mul> op, Stamp stamp, ValueNode forX, ValueNode forY, NodeView view) {\n+    private static ValueNode canonical(CanonicalizerTool tool, MulNode self, BinaryOp<Mul> op, Stamp stamp, ValueNode forX, ValueNode forY, NodeView view) {\n         if (forY.isConstant()) {\n             Constant c = forY.asConstant();\n             if (op.isNeutral(c)) {\n                 return forX;\n             }\n \n-            if (c instanceof PrimitiveConstant && ((PrimitiveConstant) c).getJavaKind().isNumericInteger()) {\n-                long i = ((PrimitiveConstant) c).asLong();\n-                ValueNode result = canonical(stamp, forX, i, view);\n-                if (result != null) {\n-                    return result;\n+            if (op.isAssociative()) {\n+                // Canonicalize expressions like \"(a * 2) * 4\" => \"(a * 8)\"\n+                ValueNode reassociated = reassociate1(self != null ? self : (MulNode) new MulNode(forX, forY).maybeCommuteInputs(), ValueNode.isConstantPredicate(), forX, forY, view);\n+                if (reassociated != self) {\n+                    return reassociated;\n                 }\n             }\n \n-            if (op.isAssociative()) {\n-                // canonicalize expressions like \"(a * 1) * 2\"\n-                return reassociate(self != null ? self : (MulNode) new MulNode(forX, forY).maybeCommuteInputs(), ValueNode.isConstantPredicate(), forX, forY, view);\n+            // Defer the lowering to make sure the constant values have been re-associated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNjQ0Mjcx", "url": "https://github.com/oracle/graal/pull/2664#pullrequestreview-481644271", "createdAt": "2020-09-03T09:08:00Z", "commit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOTowODowMFrOHMdWJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOTowODowMFrOHMdWJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgyNTc2Ng==", "bodyText": "that's something I overlooked. While this is a nice way of testing the pure functionality of the phase I think we also want to test the application of the phase embedded in the regular compilation pipeline.\nFor the test cases above can you please add assertions for the most important node counts, e.g. for the mul test ensure after a regular compilation the final low tier graph before backend contains one mul node with constant 15 and so on.\nWe want to especially test the mul stuff we are discussing about and for that we need to test the final graph result after all phases.", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482825766", "createdAt": "2020-09-03T09:08:00Z", "author": {"login": "davleopo"}, "path": "compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ReassociationTest.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.core.test;\n+\n+import org.graalvm.compiler.graph.Node;\n+import org.graalvm.compiler.graph.iterators.FilteredNodeIterable;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.phases.common.ReassociationPhase;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Random;\n+\n+public class ReassociationTest extends GraalCompilerTest {\n+\n+    private static final Random random = new Random(11);\n+    private static int rnd1 = random.nextInt();\n+    private static int rnd2 = random.nextInt();\n+    private static long rndL1 = random.nextLong();\n+    private static long rndL2 = random.nextLong();\n+\n+    // Re-association tests with int type.\n+    @Test\n+    public void testAddAdd() {\n+        testReassociateConstant(\"testAddAddSnippet\", \"refAddAddSnippet\");\n+    }\n+\n+    public static int testAddAddSnippet() {\n+        return rnd1 + (rnd2 + 2) + 3;\n+    }\n+\n+    public static int refAddAddSnippet() {\n+        return rnd1 + rnd2 + 5;\n+    }\n+\n+    @Test\n+    public void testAddSubX() {\n+        testReassociateConstant(\"testAddSubXSnippet\", \"refAddSubXSnippet\");\n+    }\n+\n+    public static int testAddSubXSnippet() {\n+        return rnd1 + (3 - rnd2) + 2;\n+    }\n+\n+    public static int refAddSubXSnippet() {\n+        return (rnd1 - rnd2) + 5;\n+    }\n+\n+    @Test\n+    public void testAddSubY() {\n+        testReassociateConstant(\"testAddSubYSnippet\", \"refAddSubYSnippet\");\n+    }\n+\n+    public static int testAddSubYSnippet() {\n+        return rnd1 + (rnd2 - 3) + 2;\n+    }\n+\n+    public static int refAddSubYSnippet() {\n+        return (rnd1 + rnd2) - 1;\n+    }\n+\n+    @Test\n+    public void testSubAddX() {\n+        testReassociateConstant(\"testSubAddXSnippet\", \"refSubAddXSnippet\");\n+    }\n+\n+    public static int testSubAddXSnippet() {\n+        return (3 + rnd1) - rnd2 + 1;\n+    }\n+\n+    public static int refSubAddXSnippet() {\n+        return 4 + (rnd1 - rnd2);\n+    }\n+\n+    @Test\n+    public void testSubAddY() {\n+        testReassociateConstant(\"testSubAddYSnippet\", \"refSubAddYSnippet\");\n+    }\n+\n+    public static int testSubAddYSnippet() {\n+        return rnd1 - (3 + rnd2) + 1;\n+    }\n+\n+    public static int refSubAddYSnippet() {\n+        return (rnd1 - rnd2) - 2;\n+    }\n+\n+    @Test\n+    public void testSubSubYX() {\n+        testReassociateConstant(\"testSubSubYXSnippet\", \"refSubSubYXSnippet\");\n+    }\n+\n+    public static int testSubSubYXSnippet() {\n+        return rnd1 - (3 - rnd2) + 1;\n+    }\n+\n+    public static int refSubSubYXSnippet() {\n+        return (rnd1 + rnd2) - 2;\n+    }\n+\n+    @Test\n+    public void testSubSubYY() {\n+        testReassociateConstant(\"testSubSubYYSnippet\", \"refSubSubYYSnippet\");\n+    }\n+\n+    public static int testSubSubYYSnippet() {\n+        return rnd1 - (rnd2 - 3) + 1;\n+    }\n+\n+    public static int refSubSubYYSnippet() {\n+        return (rnd1 - rnd2) + 4;\n+    }\n+\n+    @Test\n+    public void testSubSubXX() {\n+        testReassociateConstant(\"testSubSubXXSnippet\", \"refSubSubXXSnippet\");\n+    }\n+\n+    public static int testSubSubXXSnippet() {\n+        return (3 - rnd1) - rnd2 + 1;\n+    }\n+\n+    public static int refSubSubXXSnippet() {\n+        return 4 - (rnd1 + rnd2);\n+    }\n+\n+    @Test\n+    public void testSubSubXY() {\n+        testReassociateConstant(\"testSubSubXYSnippet\", \"refSubSubXYSnippet\");\n+    }\n+\n+    public static int testSubSubXYSnippet() {\n+        return (rnd1 - 3) - rnd2 + 1;\n+    }\n+\n+    public static int refSubSubXYSnippet() {\n+        return (rnd1 - rnd2) - 2;\n+    }\n+\n+    @Test\n+    public void testMul() {\n+        testReassociateConstant(\"testMulSnippet\", \"refMulSnippet\");\n+    }\n+\n+    public static int testMulSnippet() {\n+        return rnd1 * (-3 * rnd2) * -5;\n+    }\n+\n+    public static int refMulSnippet() {\n+        return (rnd1 * rnd2) * 15;\n+    }\n+\n+    @Test\n+    public void testAnd() {\n+        testReassociateConstant(\"testAndSnippet\", \"refAndSnippet\");\n+    }\n+\n+    public static int testAndSnippet() {\n+        return rnd1 & (3 & rnd2) & 2;\n+    }\n+\n+    public static int refAndSnippet() {\n+        return (rnd1 & rnd2) & 2;\n+    }\n+\n+    @Test\n+    public void testOr() {\n+        testReassociateConstant(\"testOrSnippet\", \"refOrSnippet\");\n+    }\n+\n+    public static int testOrSnippet() {\n+        return rnd1 | (3 | rnd2) | 4;\n+    }\n+\n+    public static int refOrSnippet() {\n+        return (rnd1 | rnd2) | 7;\n+    }\n+\n+    @Test\n+    public void testXor() {\n+        testReassociateConstant(\"testXorSnippet\", \"refXorSnippet\");\n+    }\n+\n+    public static int testXorSnippet() {\n+        return rnd1 ^ (3 ^ rnd2) ^ 1;\n+    }\n+\n+    public static int refXorSnippet() {\n+        return (rnd1 ^ rnd2) ^ 2;\n+    }\n+\n+    // Re-association tests with long type.\n+    @Test\n+    public void testAddAddLong() {\n+        testReassociateConstant(\"testAddAddLongSnippet\", \"refAddAddLongSnippet\");\n+    }\n+\n+    public static long testAddAddLongSnippet() {\n+        return rndL1 + (rndL2 + 2L) + 3L;\n+    }\n+\n+    public static long refAddAddLongSnippet() {\n+        return rndL1 + rndL2 + 5L;\n+    }\n+\n+    @Test\n+    public void testSubAddLong() {\n+        testReassociateConstant(\"testSubAddLongSnippet\", \"refSubAddLongSnippet\");\n+    }\n+\n+    public static long testSubAddLongSnippet() {\n+        return (3L + rndL1) - rndL2 + 1L;\n+    }\n+\n+    public static long refSubAddLongSnippet() {\n+        return 4L + (rndL1 - rndL2);\n+    }\n+\n+    @Test\n+    public void testMulLong() {\n+        testReassociateConstant(\"testMulLongSnippet\", \"refMulLongSnippet\");\n+    }\n+\n+    public static long testMulLongSnippet() {\n+        return rndL1 * (-3L * rndL2) * -5L;\n+    }\n+\n+    public static long refMulLongSnippet() {\n+        return (rndL1 * rndL2) * 15L;\n+    }\n+\n+    @Test\n+    public void testAndLong() {\n+        testReassociateConstant(\"testAndLongSnippet\", \"refAndLongSnippet\");\n+    }\n+\n+    public static long testAndLongSnippet() {\n+        return rndL1 & (3L & rndL2) & 2L;\n+    }\n+\n+    public static long refAndLongSnippet() {\n+        return (rndL1 & rndL2) & 2L;\n+    }\n+\n+    @Test\n+    public void testOrLong() {\n+        testReassociateConstant(\"testOrLongSnippet\", \"refOrLongSnippet\");\n+    }\n+\n+    public static long testOrLongSnippet() {\n+        return rndL1 | (3L | rndL2) | 4L;\n+    }\n+\n+    public static long refOrLongSnippet() {\n+        return (rndL1 | rndL2) | 7L;\n+    }\n+\n+    @Test\n+    public void testXorLong() {\n+        testReassociateConstant(\"testXorLongSnippet\", \"refXorLongSnippet\");\n+    }\n+\n+    public static long testXorLongSnippet() {\n+        return rndL1 ^ (3L ^ rndL2) ^ 1L;\n+    }\n+\n+    public static long refXorLongSnippet() {\n+        return (rndL1 ^ rndL2) ^ 2L;\n+    }\n+\n+    // Re-association overflow tests.\n+    @Test\n+    public void testOverflow1() {\n+        testReassociateConstant(\"testOverflow1Snippet\", \"refOverflow1Snippet\");\n+    }\n+\n+    public static int testOverflow1Snippet() {\n+        return rnd1 + (rnd2 + Integer.MAX_VALUE) + Integer.MIN_VALUE;\n+    }\n+\n+    public static int refOverflow1Snippet() {\n+        return (rnd1 + rnd2) - 1;\n+    }\n+\n+    @Test\n+    public void testOverflow2() {\n+        testReassociateConstant(\"testOverflow2Snippet\", \"refOverflow2Snippet\");\n+    }\n+\n+    public static long testOverflow2Snippet() {\n+        return rndL1 + (rndL2 + Long.MAX_VALUE) - Long.MIN_VALUE;\n+    }\n+\n+    public static long refOverflow2Snippet() {\n+        return (rndL1 + rndL2) + (-1L);\n+    }\n+\n+    @Test\n+    public void testOverflow3() {\n+        testReassociateConstant(\"testOverflow3Snippet\", \"refOverflow3Snippet\");\n+    }\n+\n+    public static int testOverflow3Snippet() {\n+        return rnd1 + (rnd2 - Integer.MIN_VALUE) - 5;\n+    }\n+\n+    public static int refOverflow3Snippet() {\n+        return (rnd1 + rnd2) - 0x80000005;\n+    }\n+\n+    @Test\n+    public void testOverflow4() {\n+        testReassociateConstant(\"testOverflow4Snippet\", \"refOverflow4Snippet\");\n+    }\n+\n+    public static long testOverflow4Snippet() {\n+        return rndL1 * (Long.MIN_VALUE * rndL2) * (-3L);\n+    }\n+\n+    public static long refOverflow4Snippet() {\n+        return (rndL1 * rndL2) * (Long.MIN_VALUE * (-3L));\n+    }\n+\n+    private void testReassociateConstant(String testMethod, String refMethod) {\n+        test(testMethod);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248"}, "originalPosition": 350}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b0ecdddfd802e24b250653e1572c9ab93c1eb17", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/0b0ecdddfd802e24b250653e1572c9ab93c1eb17", "committedDate": "2020-09-04T03:52:52Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/2c32b5b3b31f58a241b934c468f1dce00a29d248", "committedDate": "2020-08-17T10:00:54Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221"}, "afterCommit": {"oid": "0b0ecdddfd802e24b250653e1572c9ab93c1eb17", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/0b0ecdddfd802e24b250653e1572c9ab93c1eb17", "committedDate": "2020-09-04T03:52:52Z", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1053, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}