{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4ODM0OTIw", "number": 2181, "title": "AArch64: Conditionally use barriers for atomic operations.", "bodyText": "Graal always uses LDAXR+STLXR for Unsafe atomic operations. However this is not sufficient on AArch64 for the VM internal atomics that need the full barrier semantics (See [1]).\nAnother issue in Graal is for the java volatile read. Currently graal uses the LDR+DMB for volatile read, which might have issues when it is used together with STLR/STLXR (See [2]). And this has\nalready made several Renaissance benchmarks hang on some machines (See [3]).\nThis patch resolved these issues with the modifications:\n\nAdd a \"conservative\" field for \"LocationIdentity\" to decide whether to use the full semantic barriers for VM internal atomic operations.\nAlways use the optimized \"ldaxr/stlxr\" pattern for java atomics.\nTemporarily insert a full barrier after STLXR for the normal atomics to make the Renaissance benchmark work well. This can be removed once \"LDAR\" is used for java volatile read (See [4]).\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] #2045\n[4] #1772\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0", "createdAt": "2020-02-24T06:50:48Z", "url": "https://github.com/oracle/graal/pull/2181", "merged": true, "mergeCommit": {"oid": "e2102032b3493588cad94e0193c4ccc9d535feb9"}, "closed": true, "closedAt": "2020-11-16T19:21:01Z", "author": {"login": "XiaohongGong"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHX70BAFqTM2MzE5MTk3OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdauKTOgBqjM5NzE5MTI5OTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMTkxOTc5", "url": "https://github.com/oracle/graal/pull/2181#pullrequestreview-363191979", "createdAt": "2020-02-24T06:56:42Z", "commit": {"oid": "c8db37bc7a888351be06ccab499852a11057e291"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNjo1Njo0MlrOFtW5ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNjo1Njo0MlrOFtW5ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEwNTQ0Mw==", "bodyText": "Temporarily insert a full barrier after each atomic operations, even though it is a non-conservative model. This is added here to resolve the renassiance banchmark hang issue (#2045) when \"STLXR\" is used together with \"LDR/DMB\" for java volatile read. This issue can also be resolved once \"LDAR/STLR\" is used for java volatile access. So once the PR #1772 is merged, the temporarily codes can be deleted.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r383105443", "createdAt": "2020-02-24T06:56:42Z", "author": {"login": "XiaohongGong"}, "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64AtomicMove.java", "diffHunk": "@@ -80,23 +85,35 @@ public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n             Register address = asRegister(addressValue);\n             Register result = asRegister(resultValue);\n             Register newVal = asRegister(newValue);\n+            if (masm.isFlagSet(AArch64.Flag.UseBarriersForVolatile) || useBarriers) {\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                emitCompareAndSwap(masm, size, address, result, newVal, false /* acquire */, false /* release */);\n+                masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+            } else {\n+                emitCompareAndSwap(masm, size, address, result, newVal, true /* acquire */, true /* release */);\n+                if (!AArch64LIRFlagsVersioned.useLSE(masm.target.arch)) {\n+                    // Temporarily add a fullbarrier after STLXR. This can be removed when LDAR is\n+                    // used for java volatile read.\n+                    masm.dmb(AArch64Assembler.BarrierKind.ANY_ANY);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8db37bc7a888351be06ccab499852a11057e291"}, "originalPosition": 48}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8db37bc7a888351be06ccab499852a11057e291", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/c8db37bc7a888351be06ccab499852a11057e291", "committedDate": "2020-02-24T06:49:34Z", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses LDAXR+STLXR for Unsafe atomic operations.\nHowever this is not sufficient on AArch64 for the VM internal\natomics that need the full barrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently\ngraal uses the LDR+DMB for volatile read, which might have issues\nwhen it is used together with STLR/STLXR (See [2]). And this has\nalready made several Renaissance benchmarks hang on some machines\n(See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. For non-java (VM internal) atomic operations, we always use\n     the conservative barriers.\n  2. For java field atomic, we use \"UseBarriersForVolatile\" option\n     to decide whether to use conservative barriers or not. This\n     option is also added for SubstrateVM.\n  3. Temporarily insert a full barrier after STLXR of the normal\n     atomics to make the Renaissance benchmark work well. This can\n     be removed once LDAR is used for java volatile read.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}, "afterCommit": {"oid": "ddb2ecc46c5b24cce15cb320e3363202c859c2e4", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/ddb2ecc46c5b24cce15cb320e3363202c859c2e4", "committedDate": "2020-02-27T01:35:51Z", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses LDAXR+STLXR for Unsafe atomic operations.\nHowever this is not sufficient on AArch64 for the VM internal\natomics that need the full barrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently\ngraal uses the LDR+DMB for volatile read, which might have issues\nwhen it is used together with STLR/STLXR (See [2]). And this has\nalready made several Renaissance benchmarks hang on some machines\n(See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. For non-java (VM internal) atomic operations, we always use\n     the conservative barriers.\n  2. For java field atomic, we use \"UseBarriersForVolatile\" option\n     to decide whether to use conservative barriers or not. This\n     option is also added for SubstrateVM.\n  3. Temporarily insert a full barrier after STLXR of the normal\n     atomics to make the Renaissance benchmark work well. This can\n     be removed once LDAR is used for java volatile read.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ddb2ecc46c5b24cce15cb320e3363202c859c2e4", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/ddb2ecc46c5b24cce15cb320e3363202c859c2e4", "committedDate": "2020-02-27T01:35:51Z", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses LDAXR+STLXR for Unsafe atomic operations.\nHowever this is not sufficient on AArch64 for the VM internal\natomics that need the full barrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently\ngraal uses the LDR+DMB for volatile read, which might have issues\nwhen it is used together with STLR/STLXR (See [2]). And this has\nalready made several Renaissance benchmarks hang on some machines\n(See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. For non-java (VM internal) atomic operations, we always use\n     the conservative barriers.\n  2. For java field atomic, we use \"UseBarriersForVolatile\" option\n     to decide whether to use conservative barriers or not. This\n     option is also added for SubstrateVM.\n  3. Temporarily insert a full barrier after STLXR of the normal\n     atomics to make the Renaissance benchmark work well. This can\n     be removed once LDAR is used for java volatile read.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}, "afterCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/fd66ae895d85ba0d0b66923b853ee55c18cfe37a", "committedDate": "2020-03-23T04:13:46Z", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses LDAXR+STLXR for Unsafe atomic operations.\nHowever this is not sufficient on AArch64 for the VM internal\natomics that need the full barrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently\ngraal uses the LDR+DMB for volatile read, which might have issues\nwhen it is used together with STLR/STLXR (See [2]). And this has\nalready made several Renaissance benchmarks hang on some machines\n(See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. For non-java (VM internal) atomic operations, we always use\n     the conservative barriers.\n  2. For java field atomic, we use \"UseBarriersForVolatile\" option\n     to decide whether to use conservative barriers or not. This\n     option is also added for SubstrateVM.\n  3. Temporarily insert a full barrier after STLXR of the normal\n     atomics to make the Renaissance benchmark work well. This can\n     be removed once LDAR is used for java volatile read.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDI5MTk5", "url": "https://github.com/oracle/graal/pull/2181#pullrequestreview-380429199", "createdAt": "2020-03-24T15:33:04Z", "commit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTozMzowNFrOF61_rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTozMzowNFrOF61_rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0NjM4Mg==", "bodyText": "I think it would be cleaner to pass a new flag into the existing methods instead of adding a whole new method.  Other platforms might ignore it but that's fine.", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397246382", "createdAt": "2020-03-24T15:33:04Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/gen/LIRGeneratorTool.java", "diffHunk": "@@ -155,6 +155,15 @@ default boolean mayEmbedConstantLoad(Constant constant) {\n \n     Value emitValueCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue);\n \n+    default Variable emitJavaLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDM0MzQw", "url": "https://github.com/oracle/graal/pull/2181#pullrequestreview-380434340", "createdAt": "2020-03-24T15:38:23Z", "commit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTozODoyNFrOF62QDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTozODoyNFrOF62QDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI1MDU3NA==", "bodyText": "I think I understand the practical meaning of this flag but I'm not sure the naming is clear enough.  So basically in ARM there are 2 ways of doing volatiles and this flag is meant to distinguish between these 2 cases?  In almost all cases Java volatile should be considered the normal one I think and maybe this flag should be something like isNonStandardVolatile?  Actually what are there cases where we use a CompareAndSwapNode against a location which is acquired using the other sequence?", "url": "https://github.com/oracle/graal/pull/2181#discussion_r397250574", "createdAt": "2020-03-24T15:38:24Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/java/AbstractCompareAndSwapNode.java", "diffHunk": "@@ -50,6 +50,7 @@\n     @Input ValueNode expectedValue;\n     @Input ValueNode newValue;\n     @OptionalInput(State) FrameState stateAfter;\n+    protected final boolean isJavaVolatile;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDQ2Njcy", "url": "https://github.com/oracle/graal/pull/2181#pullrequestreview-380446672", "createdAt": "2020-03-24T15:50:32Z", "commit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd66ae895d85ba0d0b66923b853ee55c18cfe37a", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/fd66ae895d85ba0d0b66923b853ee55c18cfe37a", "committedDate": "2020-03-23T04:13:46Z", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses LDAXR+STLXR for Unsafe atomic operations.\nHowever this is not sufficient on AArch64 for the VM internal\natomics that need the full barrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently\ngraal uses the LDR+DMB for volatile read, which might have issues\nwhen it is used together with STLR/STLXR (See [2]). And this has\nalready made several Renaissance benchmarks hang on some machines\n(See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. For non-java (VM internal) atomic operations, we always use\n     the conservative barriers.\n  2. For java field atomic, we use \"UseBarriersForVolatile\" option\n     to decide whether to use conservative barriers or not. This\n     option is also added for SubstrateVM.\n  3. Temporarily insert a full barrier after STLXR of the normal\n     atomics to make the Renaissance benchmark work well. This can\n     be removed once LDAR is used for java volatile read.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}, "afterCommit": {"oid": "3adf06358ae733ae5e8edba94144e51da78182f1", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/3adf06358ae733ae5e8edba94144e51da78182f1", "committedDate": "2020-05-13T10:40:45Z", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However this\nis not sufficient on AArch64 for the VM internal atomics that need the full\nbarrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently graal uses\nthe \"LDR+DMB\" for volatile read, which might have issues when it is used\ntogether with STLR/STLXR (See [2]). This has already made several Renaissance\nbenchmarks hang on some machines (See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. Add a \"conservative\" field for \"LocationIdentity\" to decide whether to\n     use the full semantic barriers for VM internal atomic operations.\n  2. Always use the optimized \"ldaxr/stlxr\" pattern for java atomics.\n  3. Temporarily insert a full barrier after STLXR for the normal atomics to\n     make the Renaissance benchmark work well. This can be removed once \"LDAR\"\n     is used for java volatile read (See [4]).\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n[4] https://github.com/oracle/graal/pull/1772\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3adf06358ae733ae5e8edba94144e51da78182f1", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/3adf06358ae733ae5e8edba94144e51da78182f1", "committedDate": "2020-05-13T10:40:45Z", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However this\nis not sufficient on AArch64 for the VM internal atomics that need the full\nbarrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently graal uses\nthe \"LDR+DMB\" for volatile read, which might have issues when it is used\ntogether with STLR/STLXR (See [2]). This has already made several Renaissance\nbenchmarks hang on some machines (See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. Add a \"conservative\" field for \"LocationIdentity\" to decide whether to\n     use the full semantic barriers for VM internal atomic operations.\n  2. Always use the optimized \"ldaxr/stlxr\" pattern for java atomics.\n  3. Temporarily insert a full barrier after STLXR for the normal atomics to\n     make the Renaissance benchmark work well. This can be removed once \"LDAR\"\n     is used for java volatile read (See [4]).\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n[4] https://github.com/oracle/graal/pull/1772\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}, "afterCommit": {"oid": "cdd71fb4a4dbe7e27d507d3081e180e535bb9aa6", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/cdd71fb4a4dbe7e27d507d3081e180e535bb9aa6", "committedDate": "2020-05-14T02:21:27Z", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However this\nis not sufficient on AArch64 for the VM internal atomics that need the full\nbarrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently graal uses\nthe \"LDR+DMB\" for volatile read, which might have issues when it is used\ntogether with STLR/STLXR (See [2]). This has already made several Renaissance\nbenchmarks hang on some machines (See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. Add a \"conservative\" field for \"LocationIdentity\" to decide whether to\n     use the full semantic barriers for VM internal atomic operations.\n  2. Always use the optimized \"ldaxr/stlxr\" pattern for java atomics.\n  3. Temporarily insert a full barrier after STLXR for the normal atomics to\n     make the Renaissance benchmark work well. This can be removed once \"LDAR\"\n     is used for java volatile read (See [4]).\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n[4] https://github.com/oracle/graal/pull/1772\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cdd71fb4a4dbe7e27d507d3081e180e535bb9aa6", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/cdd71fb4a4dbe7e27d507d3081e180e535bb9aa6", "committedDate": "2020-05-14T02:21:27Z", "message": "AArch64: Conditionally use barriers for atomic operations.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However this\nis not sufficient on AArch64 for the VM internal atomics that need the full\nbarrier semantics (See [1]).\n\nAnother issue in Graal is for the java volatile read. Currently graal uses\nthe \"LDR+DMB\" for volatile read, which might have issues when it is used\ntogether with STLR/STLXR (See [2]). This has already made several Renaissance\nbenchmarks hang on some machines (See [3]).\n\nThis patch resolved these issues with the modifications:\n  1. Add a \"conservative\" field for \"LocationIdentity\" to decide whether to\n     use the full semantic barriers for VM internal atomic operations.\n  2. Always use the optimized \"ldaxr/stlxr\" pattern for java atomics.\n  3. Temporarily insert a full barrier after STLXR for the normal atomics to\n     make the Renaissance benchmark work well. This can be removed once \"LDAR\"\n     is used for java volatile read (See [4]).\n\n[1] https://patchwork.kernel.org/patch/3575821/\n[2] https://bugs.openjdk.java.net/browse/JDK-8179954\n[3] https://github.com/oracle/graal/issues/2045\n[4] https://github.com/oracle/graal/pull/1772\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}, "afterCommit": {"oid": "2f01e36c3eb0328d00058eb4d627be84850e6673", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/2f01e36c3eb0328d00058eb4d627be84850e6673", "committedDate": "2020-06-04T05:38:20Z", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NjUxNjE2", "url": "https://github.com/oracle/graal/pull/2181#pullrequestreview-424651616", "createdAt": "2020-06-04T17:01:05Z", "commit": {"oid": "2f01e36c3eb0328d00058eb4d627be84850e6673"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzowMTowNVrOGfPXbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNzowMTowNVrOGfPXbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxMDc5Ng==", "bodyText": "Shouldn't this be checking that true and false are 1 and 0 respectively?", "url": "https://github.com/oracle/graal/pull/2181#discussion_r435410796", "createdAt": "2020-06-04T17:01:05Z", "author": {"login": "tkrodriguez"}, "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64LIRGenerator.java", "diffHunk": "@@ -151,21 +151,23 @@ public AArch64AddressValue asAddressValue(Value address) {\n     }\n \n     @Override\n-    public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue) {\n-        Variable prevValue = newVariable(expectedValue.getValueKind());\n-        Variable scratch = newVariable(LIRKind.value(AArch64Kind.DWORD));\n-        append(new CompareAndSwapOp(prevValue, loadReg(expectedValue), loadReg(newValue), asAllocatable(address), scratch));\n+    public Variable emitLogicCompareAndSwap(LIRKind accessKind, Value address, Value expectedValue, Value newValue, Value trueValue, Value falseValue, boolean useBarriers) {\n+        emitCompareAndSwap(address, expectedValue, newValue, useBarriers);\n         assert trueValue.getValueKind().equals(falseValue.getValueKind());\n         Variable result = newVariable(trueValue.getValueKind());\n-        append(new CondMoveOp(result, ConditionFlag.EQ, asAllocatable(trueValue), asAllocatable(falseValue)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f01e36c3eb0328d00058eb4d627be84850e6673"}, "originalPosition": 19}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f01e36c3eb0328d00058eb4d627be84850e6673", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/2f01e36c3eb0328d00058eb4d627be84850e6673", "committedDate": "2020-06-04T05:38:20Z", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}, "afterCommit": {"oid": "e34bf91ef7334f0fc9d3ab0eed772944172eb07f", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/e34bf91ef7334f0fc9d3ab0eed772944172eb07f", "committedDate": "2020-06-08T09:26:19Z", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e34bf91ef7334f0fc9d3ab0eed772944172eb07f", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/e34bf91ef7334f0fc9d3ab0eed772944172eb07f", "committedDate": "2020-06-08T09:26:19Z", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/\n\nChange-Id: Ifa57c9733b1dd1a2e2208e885a11932475a4e3b0"}, "afterCommit": {"oid": "d852eab212231765449a9708aed200ff5d0002df", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/d852eab212231765449a9708aed200ff5d0002df", "committedDate": "2020-11-06T07:40:46Z", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebb0931a863d476206ec8bfa4a049a758ee32f24", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/ebb0931a863d476206ec8bfa4a049a758ee32f24", "committedDate": "2020-11-09T05:45:22Z", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d852eab212231765449a9708aed200ff5d0002df", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/d852eab212231765449a9708aed200ff5d0002df", "committedDate": "2020-11-06T07:40:46Z", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/"}, "afterCommit": {"oid": "ebb0931a863d476206ec8bfa4a049a758ee32f24", "author": {"user": {"login": "XiaohongGong", "name": null}}, "url": "https://github.com/oracle/graal/commit/ebb0931a863d476206ec8bfa4a049a758ee32f24", "committedDate": "2020-11-09T05:45:22Z", "message": "AArch64: Add the full barrier implementation support for CAS.\n\nGraal always uses \"LDAXR+STLXR\" for Unsafe atomic operations. However\nthis is not sufficient on AArch64 for the VM internal atomics that need\nthe full barrier semantics (See [1]).\n\nThis patch adds an alternative implementation for \"CAS\", which has the\nfull barrier semantics. The final \"CAS\" pattern is decided by an flag\n\"useBarriers\". Since we prefer to use the optimized \"LDAXR+STLXR\" pattern\n, the flag is false by default. It can be set to true by checking the\nmemory \"LocationIdentity\" for the VM internal \"CAS\" operation if it needs\nthe full barrier semantic.\n\n[1] https://patchwork.kernel.org/patch/3575821/"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1095, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}