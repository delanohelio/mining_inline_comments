{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0OTIwNzA4", "number": 832, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMDo0NzoyOVrOEGJ9cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODozMzozOVrOEPQNJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODkwMDk5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventFile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMDo0NzoyOVrOGkx3fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoxODoxNFrOGyOVbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxODk0MQ==", "bodyText": "Since it's new, let's name it previous_hash so we don't have to manually map the name", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r441218941", "createdAt": "2020-06-17T00:47:29Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventFile.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Column;\n+import javax.persistence.Transient;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@NoArgsConstructor\n+public class EventFile {\n+    private String name;\n+\n+    private Long loadStart;\n+\n+    private Long loadEnd;\n+\n+    private String fileHash;\n+\n+    @Column(name = \"prev_hash\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185c45647a793a6a47733eacaa84f0c491021a20"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNjg0NQ==", "bodyText": "removed the Column annotation", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455316845", "createdAt": "2020-07-15T20:18:14Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventFile.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Column;\n+import javax.persistence.Transient;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@NoArgsConstructor\n+public class EventFile {\n+    private String name;\n+\n+    private Long loadStart;\n+\n+    private Long loadEnd;\n+\n+    private String fileHash;\n+\n+    @Column(name = \"prev_hash\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxODk0MQ=="}, "originalCommit": {"oid": "185c45647a793a6a47733eacaa84f0c491021a20"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODkwNTcxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventFile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMDo1MDoyOFrOGkx6bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoxODozNVrOGyOWGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxOTY5NA==", "bodyText": "Why transient? Let's store it", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r441219694", "createdAt": "2020-06-17T00:50:28Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventFile.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Column;\n+import javax.persistence.Transient;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@NoArgsConstructor\n+public class EventFile {\n+    private String name;\n+\n+    private Long loadStart;\n+\n+    private Long loadEnd;\n+\n+    private String fileHash;\n+\n+    @Column(name = \"prev_hash\")\n+    private String previousHash;\n+\n+    @Transient", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185c45647a793a6a47733eacaa84f0c491021a20"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNzAxOA==", "bodyText": "removed transient", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455317018", "createdAt": "2020-07-15T20:18:35Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventFile.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Column;\n+import javax.persistence.Transient;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+@Data\n+@NoArgsConstructor\n+public class EventFile {\n+    private String name;\n+\n+    private Long loadStart;\n+\n+    private Long loadEnd;\n+\n+    private String fileHash;\n+\n+    @Column(name = \"prev_hash\")\n+    private String previousHash;\n+\n+    @Transient", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxOTY5NA=="}, "originalCommit": {"oid": "185c45647a793a6a47733eacaa84f0c491021a20"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODk2ODYzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMToyOToyMlrOGkyg-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMToyOToyMlrOGkyg-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyOTU2Mw==", "bodyText": "moved tests from RecordFileDownloaderTest to here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r441229563", "createdAt": "2020-06-17T01:29:22Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractDownloaderTest.java", "diffHunk": "@@ -153,31 +160,44 @@ protected void assertValidFiles(List<String> filenames) throws Exception {\n                 .containsAll(filenames);\n     }\n \n-    protected void overwriteOnDownloadHelper(String fileName1, String fileName2, ApplicationStatusCode key)\n-            throws Exception {\n+    protected void testMaxDownloadItemsReached(String filename) throws Exception {\n         fileCopier.copy();\n         downloader.download();\n-        verify(applicationStatusRepository).updateStatusValue(key, fileName1);\n-        verify(applicationStatusRepository).updateStatusValue(key, fileName2);\n-        assertValidFiles(List.of(fileName1, fileName2));\n+        assertValidFiles(List.of(filename));\n+    }\n \n-        reset(applicationStatusRepository);\n-        // Corrupt the downloaded signatures to test that they get overwritten by good ones on re-download.\n-        Files.walk(downloaderProperties.getSignaturesPath()).filter(this::isSigFile)\n-                .forEach(AbstractDownloaderTest::corruptFile);\n-        // fileName1 will be used to calculate marker for list request. mockS3 also returns back the marker in the\n-        // results. This is unlike AWS S3 which does not return back the marker.\n-        doReturn(fileName1).when(applicationStatusRepository).findByStatusCode(key);\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977e0df2ca46a0e04ef30cdc56bd2aead9d6a42c"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODk2OTUyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMToyOTo1MFrOGkyhgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMToyOTo1MFrOGkyhgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyOTY5Nw==", "bodyText": "moved here from RecordFileDownloaderTest", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r441229697", "createdAt": "2020-06-17T01:29:50Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.hedera.mirror.importer.downloader;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.time.Instant;\n+import java.util.List;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+// Common tests for streams (record and events) which are linked by previous file's hash.\n+@ExtendWith(MockitoExtension.class)\n+public abstract class AbstractLinkedStreamDownloaderTest extends AbstractDownloaderTest {\n+\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "977e0df2ca46a0e04ef30cdc56bd2aead9d6a42c"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjI1OTcxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNToxNDoyNlrOGmyJYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNToxNDoyNlrOGmyJYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyMDY3NA==", "bodyText": "nit: Logic used twice. Just set a boolean with the value 1st time and use it in your if statements", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443320674", "createdAt": "2020-06-22T05:14:26Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjI2OTg1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNToyMTozMlrOGmyPng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyMDozMFrOGyOaPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyMjI3MA==", "bodyText": "Isn't this supposed to be done once per file? If so then just do it once by moving this right after the fileName variable is assigned a value.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443322270", "createdAt": "2020-06-22T05:21:32Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxODA3OQ==", "bodyText": "changed it in EventFileReaderImpl.read", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455318079", "createdAt": "2020-07-15T20:20:30Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyMjI3MA=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjI4NjA4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNTozMjoxM1rOGmyZrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyNTozM1rOGyOk1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNDg0NA==", "bodyText": "nit: Seems like the read order is important. You might want to put a comment to state this and or reference the actual order so future updates have this in mind.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443324844", "createdAt": "2020-06-22T05:32:13Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMDc5MQ==", "bodyText": "will address it in #812", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455320791", "createdAt": "2020-07-15T20:25:33Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNDg0NA=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjI5NDUwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNTozNzo0OFrOGmye1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyMTozOFrOGyOc1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNjE2NQ==", "bodyText": "nit: All the checkSum values used when calling readAndValidateChecksum () should be private class variables.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443326165", "createdAt": "2020-06-22T05:37:48Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxODc0MA==", "bodyText": "will be addressed in the #812, for this PR only events downloader is implemented.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455318740", "createdAt": "2020-07-15T20:21:38Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNjE2NQ=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjMwNDA4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNTo0NDowMFrOGmykvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoxOTozMlrOGyOYHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNzY3Nw==", "bodyText": "Q: Shouldn't these `read?' methods be in the Utility class alongside the other file read methods?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443327677", "createdAt": "2020-06-22T05:44:00Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);\n+        List<Transaction> transactions = new ArrayList<>(numTransactions);\n+        for (int i = 0; i < numTransactions; i++) {\n+            transactions.add(deserialize(dis, md));\n+        }\n+        return transactions;\n+    }\n+\n+    /**\n+     * Read single {@link Transaction} from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Transaction deserialize(DataInputStream dis, MessageDigest md) throws IOException {\n+        int txLen = readInt(dis, md);\n+        if (txLen < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + txLen);\n+        }\n+        readAndValidateChecksum(dis, 277 - txLen, md);\n+        readBoolean(dis, md); // system field of transaction\n+        byte[] contents = readBytes(dis, txLen, md);\n+        Signature[] signatures = readSignatures(dis, md);\n+        return new Transaction(contents, signatures);\n+    }\n+\n+    /**\n+     * Read all {@link Signature}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Signature[] readSignatures(DataInputStream dis, MessageDigest md) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMjIyNQ==", "bodyText": "I think it's the other way around. The reading specific methods in Utility should move into a proper class in the same package as this file in the future.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443612225", "createdAt": "2020-06-22T14:44:24Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);\n+        List<Transaction> transactions = new ArrayList<>(numTransactions);\n+        for (int i = 0; i < numTransactions; i++) {\n+            transactions.add(deserialize(dis, md));\n+        }\n+        return transactions;\n+    }\n+\n+    /**\n+     * Read single {@link Transaction} from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Transaction deserialize(DataInputStream dis, MessageDigest md) throws IOException {\n+        int txLen = readInt(dis, md);\n+        if (txLen < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + txLen);\n+        }\n+        readAndValidateChecksum(dis, 277 - txLen, md);\n+        readBoolean(dis, md); // system field of transaction\n+        byte[] contents = readBytes(dis, txLen, md);\n+        Signature[] signatures = readSignatures(dis, md);\n+        return new Transaction(contents, signatures);\n+    }\n+\n+    /**\n+     * Read all {@link Signature}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Signature[] readSignatures(DataInputStream dis, MessageDigest md) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNzY3Nw=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNzUzNQ==", "bodyText": "EventsFileDecoder is removed and parsing the file to get prevHash and calculate the hash of the file itself is handled by EventFileReaderImpl.java", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455317535", "createdAt": "2020-07-15T20:19:32Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);\n+        List<Transaction> transactions = new ArrayList<>(numTransactions);\n+        for (int i = 0; i < numTransactions; i++) {\n+            transactions.add(deserialize(dis, md));\n+        }\n+        return transactions;\n+    }\n+\n+    /**\n+     * Read single {@link Transaction} from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Transaction deserialize(DataInputStream dis, MessageDigest md) throws IOException {\n+        int txLen = readInt(dis, md);\n+        if (txLen < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + txLen);\n+        }\n+        readAndValidateChecksum(dis, 277 - txLen, md);\n+        readBoolean(dis, md); // system field of transaction\n+        byte[] contents = readBytes(dis, txLen, md);\n+        Signature[] signatures = readSignatures(dis, md);\n+        return new Transaction(contents, signatures);\n+    }\n+\n+    /**\n+     * Read all {@link Signature}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Signature[] readSignatures(DataInputStream dis, MessageDigest md) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNzY3Nw=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDA0MzU0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDozNTozMlrOGnDhHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyMjozOVrOGyOe0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTI3Nw==", "bodyText": "How can EventFileDownloaderTest return a rcd file?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443605277", "createdAt": "2020-06-22T14:35:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.hedera.mirror.importer.downloader;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.time.Instant;\n+import java.util.List;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+// Common tests for streams (record and events) which are linked by previous file's hash.\n+@ExtendWith(MockitoExtension.class)\n+public abstract class AbstractLinkedStreamDownloaderTest extends AbstractDownloaderTest {\n+\n+    @Test\n+    @DisplayName(\"Doesn't match last valid hash\")\n+    void hashMismatchWithPrevious() throws Exception {\n+        doReturn(\"2019-01-01T01:00:00.000000Z.rcd\").when(applicationStatusRepository)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI1MA==", "bodyText": "fixed by setting fileExtension in inherited test classes and compose the correct filename in hashMismatchWithPrevious.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455319250", "createdAt": "2020-07-15T20:22:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/AbstractLinkedStreamDownloaderTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.hedera.mirror.importer.downloader;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.time.Instant;\n+import java.util.List;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+// Common tests for streams (record and events) which are linked by previous file's hash.\n+@ExtendWith(MockitoExtension.class)\n+public abstract class AbstractLinkedStreamDownloaderTest extends AbstractDownloaderTest {\n+\n+    @Test\n+    @DisplayName(\"Doesn't match last valid hash\")\n+    void hashMismatchWithPrevious() throws Exception {\n+        doReturn(\"2019-01-01T01:00:00.000000Z.rcd\").when(applicationStatusRepository)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTI3Nw=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDA5ODY5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDo0NjozMVrOGnECSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyMjo1M1rOGyOfXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMzc2OQ==", "bodyText": "This should be higher since it's not currently a requirement to have low latency for this stream. Maybe 5s?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443613769", "createdAt": "2020-06-22T14:46:31Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 15;\n+\n+    private boolean enabled = false;\n+\n+    @NotNull\n+    private Duration frequency = Duration.ofMillis(500L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTM5MQ==", "bodyText": "changed it to 5s.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455319391", "createdAt": "2020-07-15T20:22:53Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 15;\n+\n+    private boolean enabled = false;\n+\n+    @NotNull\n+    private Duration frequency = Duration.ofMillis(500L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMzc2OQ=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDE4MjIyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNTowNToxMVrOGnE4CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyNzoxMFrOGyOoVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYyNzUyOA==", "bodyText": "This is too low and makes catch up very inefficient. Would set to 100. We can test later for optimal amount, but 15 definitely too low.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443627528", "createdAt": "2020-06-22T15:05:11Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 15;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTY4Nw==", "bodyText": "updated to 100.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455321687", "createdAt": "2020-07-15T20:27:10Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 15;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYyNzUyOA=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDM0OTkzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNTo0NDo0M1rOGnGiFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyODo1NFrOGyOryA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY1NDY3OA==", "bodyText": "Static methods should be avoided. Remember RecordFileLogger? Once you make non-static you could use dependency injection to inject properties and repo so you don't need to pass the hash and verifyhashafter as parameters. It would also allow us to support different event versions in the future more easily via different concrete implementations.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443654678", "createdAt": "2020-06-22T15:44:43Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjU2OA==", "bodyText": "the class is removed and the functionality is partially replaced by EventFileReader.read which is a instance method.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455322568", "createdAt": "2020-07-15T20:28:54Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY1NDY3OA=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDM5NTI5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNTo1NToyNlrOGnG-Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyMzoyMFrOGyOgKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2MTg5OA==", "bodyText": "Would prefer filereader or reader as it's not decoding anything per se. Same for class name.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443661898", "createdAt": "2020-06-22T15:55:26Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTU5Mg==", "bodyText": "changed to EventFileReader & EventFileReaderImpl", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455319592", "createdAt": "2020-07-15T20:23:20Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2MTg5OA=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDQ1NjYwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoxMDoxMVrOGnHkdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyNDowM1rOGyOhog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MTY2OA==", "bodyText": "IllegalArgumentException is generally used for user input. Would be better to create a custom exception like FileReaderException extends ImporterException.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443671668", "createdAt": "2020-06-22T16:10:11Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTk3MA==", "bodyText": "added InvalidEventFileException extends ImporterException", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455319970", "createdAt": "2020-07-15T20:24:03Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MTY2OA=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NDQ2ODExOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventFileDownloader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjoxMzoxN1rOGnHrug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyNjoyNlrOGyOm0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MzUzMA==", "bodyText": "Pass File object so you don't create a duplicate File object unnecessarily via FileInputStream", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443673530", "createdAt": "2020-06-22T16:13:17Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventFileDownloader.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import java.io.File;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+import org.springframework.scheduling.annotation.Scheduled;\n+import software.amazon.awssdk.services.s3.S3AsyncClient;\n+\n+import com.hedera.mirror.importer.addressbook.NetworkAddressBook;\n+import com.hedera.mirror.importer.domain.ApplicationStatusCode;\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.downloader.Downloader;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.filedecoder.EventsFileDecoder;\n+import com.hedera.mirror.importer.leader.Leader;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+\n+@Log4j2\n+@Named\n+public class EventFileDownloader extends Downloader {\n+\n+    public EventFileDownloader(\n+            S3AsyncClient s3Client, ApplicationStatusRepository applicationStatusRepository,\n+            NetworkAddressBook networkAddressBook, EventDownloaderProperties downloaderProperties,\n+            MeterRegistry meterRegistry) {\n+        super(s3Client, applicationStatusRepository, networkAddressBook, downloaderProperties, meterRegistry);\n+    }\n+\n+    @Leader\n+    @Override\n+    @Scheduled(fixedRateString = \"${hedera.mirror.downloader.event.frequency:500}\")\n+    public void download() {\n+        downloadNextBatch();\n+    }\n+\n+    @Override\n+    protected ApplicationStatusCode getLastValidDownloadedFileKey() {\n+        return ApplicationStatusCode.LAST_VALID_DOWNLOADED_EVENT_FILE;\n+    }\n+\n+    @Override\n+    protected ApplicationStatusCode getLastValidDownloadedFileHashKey() {\n+        return ApplicationStatusCode.LAST_VALID_DOWNLOADED_EVENT_FILE_HASH;\n+    }\n+\n+    /**\n+     * Checks that hash of data file matches the verified hash and that data file is next in line based on previous file\n+     * hash. Returns false if any condition is false.\n+     */\n+    @Override\n+    protected boolean verifyDataFile(File file, byte[] verifiedHash) {\n+        String expectedPrevFileHash = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileHashKey());\n+        try {\n+            EventFile eventFile = EventsFileDecoder.decode(file.getPath(), expectedPrevFileHash,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTI5Ng==", "bodyText": "updated.\npublic interface EventFileReader {\n    /**\n     * Read event file. Throws {@link InvalidEventFileException} if file is malformatted.\n     *\n     * @param file event file object\n     * @return {@link EventFile} object\n     */\n    EventFile read(File file);\n}", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455321296", "createdAt": "2020-07-15T20:26:26Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventFileDownloader.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import java.io.File;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+import org.springframework.scheduling.annotation.Scheduled;\n+import software.amazon.awssdk.services.s3.S3AsyncClient;\n+\n+import com.hedera.mirror.importer.addressbook.NetworkAddressBook;\n+import com.hedera.mirror.importer.domain.ApplicationStatusCode;\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.downloader.Downloader;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.filedecoder.EventsFileDecoder;\n+import com.hedera.mirror.importer.leader.Leader;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+\n+@Log4j2\n+@Named\n+public class EventFileDownloader extends Downloader {\n+\n+    public EventFileDownloader(\n+            S3AsyncClient s3Client, ApplicationStatusRepository applicationStatusRepository,\n+            NetworkAddressBook networkAddressBook, EventDownloaderProperties downloaderProperties,\n+            MeterRegistry meterRegistry) {\n+        super(s3Client, applicationStatusRepository, networkAddressBook, downloaderProperties, meterRegistry);\n+    }\n+\n+    @Leader\n+    @Override\n+    @Scheduled(fixedRateString = \"${hedera.mirror.downloader.event.frequency:500}\")\n+    public void download() {\n+        downloadNextBatch();\n+    }\n+\n+    @Override\n+    protected ApplicationStatusCode getLastValidDownloadedFileKey() {\n+        return ApplicationStatusCode.LAST_VALID_DOWNLOADED_EVENT_FILE;\n+    }\n+\n+    @Override\n+    protected ApplicationStatusCode getLastValidDownloadedFileHashKey() {\n+        return ApplicationStatusCode.LAST_VALID_DOWNLOADED_EVENT_FILE_HASH;\n+    }\n+\n+    /**\n+     * Checks that hash of data file matches the verified hash and that data file is next in line based on previous file\n+     * hash. Returns false if any condition is false.\n+     */\n+    @Override\n+    protected boolean verifyDataFile(File file, byte[] verifiedHash) {\n+        String expectedPrevFileHash = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileHashKey());\n+        try {\n+            EventFile eventFile = EventsFileDecoder.decode(file.getPath(), expectedPrevFileHash,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3MzUzMA=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTQ2MjM4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMToyNDo1MVrOGnRikQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoyNDozOVrOGyOizA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNTAyNQ==", "bodyText": "Would prefer deserialize logic not be a static method or coupled with the POJO. Recommend moving here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443835025", "createdAt": "2020-06-22T21:24:51Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);\n+        List<Transaction> transactions = new ArrayList<>(numTransactions);\n+        for (int i = 0; i < numTransactions; i++) {\n+            transactions.add(deserialize(dis, md));\n+        }\n+        return transactions;\n+    }\n+\n+    /**\n+     * Read single {@link Transaction} from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Transaction deserialize(DataInputStream dis, MessageDigest md) throws IOException {\n+        int txLen = readInt(dis, md);\n+        if (txLen < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + txLen);\n+        }\n+        readAndValidateChecksum(dis, 277 - txLen, md);\n+        readBoolean(dis, md); // system field of transaction\n+        byte[] contents = readBytes(dis, txLen, md);\n+        Signature[] signatures = readSignatures(dis, md);\n+        return new Transaction(contents, signatures);\n+    }\n+\n+    /**\n+     * Read all {@link Signature}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Signature[] readSignatures(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numSigs = readInt(dis, md);\n+        if (numSigs < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of signatures: \" + numSigs);\n+        }\n+        readAndValidateChecksum(dis, 353 - numSigs, md);\n+        Signature[] signatures = null;\n+        if (numSigs > 0) {\n+            signatures = new Signature[numSigs];\n+            for (int i = 0; i < numSigs; i++) {\n+                signatures[i] = Signature.deserialize(dis, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMDI2OA==", "bodyText": "will be address in #812 since this PR only handles events downloader.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455320268", "createdAt": "2020-07-15T20:24:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/filedecoder/EventsFileDecoder.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.filedecoder;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static com.hedera.mirror.importer.util.Utility.readBytes;\n+import static com.hedera.mirror.importer.util.Utility.readInt;\n+\n+import com.swirlds.common.Transaction;\n+import com.swirlds.common.crypto.Signature;\n+import java.io.DataInputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.domain.EventItem;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+public class EventsFileDecoder {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";\n+    public static final byte EVENT_TYPE_PREV_HASH = 1;       // next 48 bytes are hash384 or previous files\n+    public static final byte EVENT_STREAM_FILE_VERSION_LEGACY = 2;\n+    public static final byte EVENT_STREAM_VERSION = 2;\n+    public static final byte EVENT_STREAM_FILE_VERSION_CURRENT = 3;\n+    public static final byte EVENT_STREAM_START_NO_TRANS_WITH_VERSION = 0x5b;\n+    public static final byte EVENT_STREAM_START_WITH_VERSION = 0x5a;\n+    public static final byte EVENT_COMM_EVENT_LAST = 0x46;\n+\n+    /**\n+     * Decodes event stream file.\n+\n+     * @param filePath path to event file\n+     * @param expectedPrevFileHash expected previous file's hash in current file. Throws {@link HashMismatchException}\n+     *                             on mismatch\n+     * @param verifyHashAfter previous file's hash mismatch is ignored if file is from before this time\n+     * @param eventItemConsumer if not null, consumer is invoked for each event in the file\n+     */\n+    public static EventFile decode(String filePath, String expectedPrevFileHash, Instant verifyHashAfter,\n+                                   Consumer<EventItem> eventItemConsumer) {\n+        EventFile eventFile = new EventFile();\n+        eventFile.setName(filePath);\n+        String fileName = Utility.getFileName(filePath);\n+\n+        try (DataInputStream dis = new DataInputStream(new FileInputStream(filePath))) {\n+            // MessageDigest for getting the file Hash\n+            // suppose file[i] = p[i] || h[i] || c[i];\n+            // p[i] denotes the bytes before previousFileHash;\n+            // h[i] denotes the hash of file i - 1, i.e., previousFileHash;\n+            // c[i] denotes the bytes after previousFileHash;\n+            // '||' means concatenation\n+            // for Version2, h[i + 1] = hash(p[i] || h[i] || c[i]);\n+            // for Version3, h[i + 1] = hash(p[i] || h[i] || hash(c[i]))\n+            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n+\n+            int fileVersion = readInt(dis, md);\n+            if (fileVersion < EVENT_STREAM_FILE_VERSION_LEGACY) {\n+                throw new IllegalArgumentException(\"Invalid event stream file version \" + fileVersion);\n+            }\n+            eventFile.setFileVersion(fileVersion);\n+\n+            MessageDigest mdForContent = md;\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                // For calculating hash(c[i]) separately if version >= 3\n+                mdForContent = MessageDigest.getInstance(HASH_ALGORITHM);\n+            }\n+            while (dis.available() != 0) {\n+                byte typeDelimiter = dis.readByte();\n+                EventItem eventItem;\n+                switch (typeDelimiter) {\n+                    case EVENT_TYPE_PREV_HASH:\n+                        md.update(typeDelimiter);\n+                        byte[] readPrevFileHash = readBytes(dis, 48, md);\n+                        eventFile.setPreviousHash(Hex.encodeHexString(readPrevFileHash));\n+                        Instant fileInstant = Instant.parse(fileName.replaceAll(\".evts\", \"\").replaceAll(\"_\", \":\"));\n+\n+                        if (!Utility.verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n+                                verifyHashAfter, fileInstant)) {\n+                            throw new HashMismatchException(\"Hash mismatch for file \" + fileName);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_NO_TRANS_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, false);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    case EVENT_STREAM_START_WITH_VERSION:\n+                        mdForContent.update(typeDelimiter);\n+                        eventItem = loadEvent(dis, mdForContent, true);\n+                        if (eventItemConsumer != null) {\n+                            eventItemConsumer.accept(eventItem);\n+                        }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Unknown event file delimiter %s for file %s\", typeDelimiter, fileName));\n+                }\n+            }\n+            if (fileVersion >= EVENT_STREAM_FILE_VERSION_CURRENT) {\n+                md.update(mdForContent.digest());\n+            }\n+            if (eventFile.getPreviousHash() == null) {\n+                throw new IllegalArgumentException(\"previous hash is null in file \" + fileName);\n+            }\n+            eventFile.setFileHash(Hex.encodeHexString(md.digest()));\n+            log.trace(\"Calculated file hash for the event file {}\", eventFile.getFileHash());\n+            return eventFile;\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Error parsing bad event file \" + fileName, e);\n+        }\n+    }\n+\n+    private static EventItem loadEvent(DataInputStream dis, MessageDigest md, boolean hasTransactions)\n+            throws IOException {\n+        EventItem eventItem = new EventItem();\n+        int version = readInt(dis, md);\n+        if (version != EVENT_STREAM_VERSION) {\n+            throw new IllegalArgumentException(\"Invalid EventStream format version : \" + version);\n+        }\n+\n+        eventItem.setCreatorId(readLong(dis, md));\n+        eventItem.setCreatorSeq(readLong(dis, md));\n+        eventItem.setOtherId(readLong(dis, md));\n+        eventItem.setOtherSeq(readLong(dis, md));\n+        eventItem.setSelfParentGen(readLong(dis, md));\n+        eventItem.setOtherParentGen(readLong(dis, md));\n+        eventItem.setSelfParentHash(readBytesWithChecksum(dis, md, true));\n+        eventItem.setOtherParentHash(readBytesWithChecksum(dis, md, true));\n+        if (hasTransactions) {\n+            eventItem.setTransactions(readTransactions(dis, md));\n+        }\n+        eventItem.setTimeCreated(readInstant(dis, md));\n+        eventItem.setSignature(readBytesWithChecksum(dis, md, false));\n+\n+        byte eventEndMarker = dis.readByte();\n+        if (eventEndMarker != EVENT_COMM_EVENT_LAST) {\n+            throw new IllegalArgumentException(\"Invalid event end marker : \" + eventEndMarker);\n+        }\n+        md.update(EVENT_COMM_EVENT_LAST);\n+\n+        eventItem.setHash(readBytesWithChecksum(dis, md, false));  // event's hash\n+        eventItem.setConsensusTimeStamp(readInstant(dis, md));\n+        eventItem.setConsensusOrder(readLong(dis, md));\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Event: {}\", eventItem);\n+        }\n+        return eventItem;\n+    }\n+\n+    /**\n+     * Read all {@link Transaction}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    public static List<Transaction> readTransactions(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numTransactions = readInt(dis, md);\n+        if (numTransactions < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + numTransactions);\n+        }\n+        readAndValidateChecksum(dis, 1873 - numTransactions, md);\n+        List<Transaction> transactions = new ArrayList<>(numTransactions);\n+        for (int i = 0; i < numTransactions; i++) {\n+            transactions.add(deserialize(dis, md));\n+        }\n+        return transactions;\n+    }\n+\n+    /**\n+     * Read single {@link Transaction} from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Transaction deserialize(DataInputStream dis, MessageDigest md) throws IOException {\n+        int txLen = readInt(dis, md);\n+        if (txLen < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of transactions: \" + txLen);\n+        }\n+        readAndValidateChecksum(dis, 277 - txLen, md);\n+        readBoolean(dis, md); // system field of transaction\n+        byte[] contents = readBytes(dis, txLen, md);\n+        Signature[] signatures = readSignatures(dis, md);\n+        return new Transaction(contents, signatures);\n+    }\n+\n+    /**\n+     * Read all {@link Signature}s from the {@link DataInputStream}.\n+     *\n+     * @throws IOException  if the internal checksum cannot be validated, or if any error occurs when reading the file\n+     */\n+    private static Signature[] readSignatures(DataInputStream dis, MessageDigest md) throws IOException {\n+        int numSigs = readInt(dis, md);\n+        if (numSigs < 0) {\n+            throw new IllegalArgumentException(\"Invalid number of signatures: \" + numSigs);\n+        }\n+        readAndValidateChecksum(dis, 353 - numSigs, md);\n+        Signature[] signatures = null;\n+        if (numSigs > 0) {\n+            signatures = new Signature[numSigs];\n+            for (int i = 0; i < numSigs; i++) {\n+                signatures[i] = Signature.deserialize(dis, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNTAyNQ=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTQ2Mzk4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventItem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMToyNToyMFrOGnRjlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNjoyMTo1NlrOGyFmGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNTI4NQ==", "bodyText": "Will we be storing event item in the database?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r443835285", "createdAt": "2020-06-22T21:25:20Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventItem.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.swirlds.common.Transaction;\n+import java.time.Instant;\n+import java.util.List;\n+import lombok.Data;\n+\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+public class EventItem {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3MzY1Nw==", "bodyText": "it should be stored in the database. I will delete the class for now since it's not used after my changes and in the event parser issue we will add it back and persist it in database.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455173657", "createdAt": "2020-07-15T16:21:56Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventItem.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.swirlds.common.Transaction;\n+import java.time.Instant;\n+import java.util.List;\n+import lombok.Data;\n+\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+public class EventItem {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNTI4NQ=="}, "originalCommit": {"oid": "e3ebb26716b48396be28c17d9e60d415a8a32684"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTc1MDgyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTowNjoxMlrOGyL-lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDoxMjozOVrOGyOJ4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODIzMA==", "bodyText": "Configuration doc says 1m but this says 5s. Update them to agree", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455278230", "createdAt": "2020-07-15T19:06:12Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 100;\n+\n+    private boolean enabled = false;\n+\n+    @NotNull\n+    private Duration frequency = Duration.ofMillis(5000L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "017800baa9518bcd2e033b73f89775500cec8099"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMzg4OQ==", "bodyText": "made the change. also updated the description to match other frequency fields.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455313889", "createdAt": "2020-07-15T20:12:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 100;\n+\n+    private boolean enabled = false;\n+\n+    @NotNull\n+    private Duration frequency = Duration.ofMillis(5000L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODIzMA=="}, "originalCommit": {"oid": "017800baa9518bcd2e033b73f89775500cec8099"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzOTc3MzUwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOToxMjozOVrOGyMMQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMDowNToyOVrOGyN7mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MTcyOA==", "bodyText": "nit: eventsStreams/event?\nAssuming you want standard with accountBalances (accountBalances/balance) and records (recordstreams/record)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455281728", "createdAt": "2020-07-15T19:12:39Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 100;\n+\n+    private boolean enabled = false;\n+\n+    @NotNull\n+    private Duration frequency = Duration.ofMillis(5000L);\n+\n+    private boolean keepSignatures = false;\n+\n+    @NotBlank\n+    private String prefix = \"eventsStreams/events_\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "017800baa9518bcd2e033b73f89775500cec8099"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDIzMw==", "bodyText": "This is the actual prefix in S3 that devops uploads to. It's not under our control. events_ is correct.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455310233", "createdAt": "2020-07-15T20:05:29Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventDownloaderProperties.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import javax.validation.constraints.Min;\n+import javax.validation.constraints.NotBlank;\n+import javax.validation.constraints.NotNull;\n+import lombok.Data;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.validation.annotation.Validated;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.CommonDownloaderProperties;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+\n+@Data\n+@Validated\n+@ConfigurationProperties(\"hedera.mirror.importer.downloader.event\")\n+public class EventDownloaderProperties implements DownloaderProperties {\n+\n+    private final MirrorProperties mirrorProperties;\n+\n+    private final CommonDownloaderProperties common;\n+\n+    @Min(1)\n+    private int batchSize = 100;\n+\n+    private boolean enabled = false;\n+\n+    @NotNull\n+    private Duration frequency = Duration.ofMillis(5000L);\n+\n+    private boolean keepSignatures = false;\n+\n+    @NotBlank\n+    private String prefix = \"eventsStreams/events_\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MTcyOA=="}, "originalCommit": {"oid": "017800baa9518bcd2e033b73f89775500cec8099"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NDA3OTUxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/controller/ConsensusControllerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzozNjo0N1rOGy1a3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxOTowMjo1N1rOGy4fbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NzIxMg==", "bodyText": "Nana's PR fixes it. Let's make sure if this is merged first that Nana's PR removes this.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455957212", "createdAt": "2020-07-16T17:36:47Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/controller/ConsensusControllerTest.java", "diffHunk": "@@ -221,6 +222,7 @@ void subscribeVerifySequence() throws Exception {\n                 .verify(Duration.ofMillis(1000));\n     }\n \n+    @Disabled(\"Temporarily disable it since it fails randomly\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNzUzNA==", "bodyText": "will remove it.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r456007534", "createdAt": "2020-07-16T19:02:57Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/controller/ConsensusControllerTest.java", "diffHunk": "@@ -221,6 +222,7 @@ void subscribeVerifySequence() throws Exception {\n                 .verify(Duration.ofMillis(1000));\n     }\n \n+    @Disabled(\"Temporarily disable it since it fails randomly\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NzIxMg=="}, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NDA4Njg0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventFileDownloader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzozODo0NlrOGy1flA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxOTozMToxNFrOGy5hIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1ODQyMA==", "bodyText": "Should be 5000 to match readme and properties", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455958420", "createdAt": "2020-07-16T17:38:46Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventFileDownloader.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hedera.mirror.importer.exception.ImporterException;\n+\n+import com.hedera.mirror.importer.util.Utility;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import java.io.File;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.io.FilenameUtils;\n+import org.springframework.scheduling.annotation.Scheduled;\n+import com.hedera.mirror.importer.reader.event.EventFileReader;\n+import software.amazon.awssdk.services.s3.S3AsyncClient;\n+\n+import com.hedera.mirror.importer.addressbook.NetworkAddressBook;\n+import com.hedera.mirror.importer.domain.ApplicationStatusCode;\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.downloader.Downloader;\n+import com.hedera.mirror.importer.leader.Leader;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+\n+import static com.hedera.mirror.importer.util.Utility.verifyHashChain;\n+\n+@Log4j2\n+@Named\n+public class EventFileDownloader extends Downloader {\n+\n+    private EventFileReader eventFileReader;\n+\n+    public EventFileDownloader(\n+            S3AsyncClient s3Client, ApplicationStatusRepository applicationStatusRepository,\n+            NetworkAddressBook networkAddressBook, EventDownloaderProperties downloaderProperties,\n+            MeterRegistry meterRegistry, EventFileReader eventFileReader) {\n+        super(s3Client, applicationStatusRepository, networkAddressBook, downloaderProperties, meterRegistry);\n+        this.eventFileReader = eventFileReader;\n+    }\n+\n+    @Leader\n+    @Override\n+    @Scheduled(fixedRateString = \"${hedera.mirror.downloader.event.frequency:500}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAyNDM1NQ==", "bodyText": "updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r456024355", "createdAt": "2020-07-16T19:31:14Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventFileDownloader.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.hedera.mirror.importer.downloader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hedera.mirror.importer.exception.ImporterException;\n+\n+import com.hedera.mirror.importer.util.Utility;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import java.io.File;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.codec.binary.Hex;\n+import org.apache.commons.io.FilenameUtils;\n+import org.springframework.scheduling.annotation.Scheduled;\n+import com.hedera.mirror.importer.reader.event.EventFileReader;\n+import software.amazon.awssdk.services.s3.S3AsyncClient;\n+\n+import com.hedera.mirror.importer.addressbook.NetworkAddressBook;\n+import com.hedera.mirror.importer.domain.ApplicationStatusCode;\n+import com.hedera.mirror.importer.domain.EventFile;\n+import com.hedera.mirror.importer.downloader.Downloader;\n+import com.hedera.mirror.importer.leader.Leader;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+\n+import static com.hedera.mirror.importer.util.Utility.verifyHashChain;\n+\n+@Log4j2\n+@Named\n+public class EventFileDownloader extends Downloader {\n+\n+    private EventFileReader eventFileReader;\n+\n+    public EventFileDownloader(\n+            S3AsyncClient s3Client, ApplicationStatusRepository applicationStatusRepository,\n+            NetworkAddressBook networkAddressBook, EventDownloaderProperties downloaderProperties,\n+            MeterRegistry meterRegistry, EventFileReader eventFileReader) {\n+        super(s3Client, applicationStatusRepository, networkAddressBook, downloaderProperties, meterRegistry);\n+        this.eventFileReader = eventFileReader;\n+    }\n+\n+    @Leader\n+    @Override\n+    @Scheduled(fixedRateString = \"${hedera.mirror.downloader.event.frequency:500}\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1ODQyMA=="}, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NDI5NjA3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/event/EventFileConstants.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODozMzozOVrOGy3f7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxOTozMTo0NVrOGy5isg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5MTI3Ng==", "bodyText": "These constants aren't used outside of EventFileReaderImpl and its associated test. Would prefer they be moved as private members in EventFileReaderImpl.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r455991276", "createdAt": "2020-07-16T18:33:39Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/event/EventFileConstants.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.hedera.mirror.importer.reader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+public class EventFileConstants {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAwNjgzNg==", "bodyText": "my thought is in the parser there will be a different class to parse the individual events and that class will also use these constants.\nAlso, in the future when we may have new format, this is the place to aggregate all the constants.\nI can move it into EventFileReaderImpl now. What's your thought?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r456006836", "createdAt": "2020-07-16T19:01:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/event/EventFileConstants.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.hedera.mirror.importer.reader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+public class EventFileConstants {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5MTI3Ng=="}, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAxMDA1MQ==", "bodyText": "I think it should be moved into EventFileReaderImpl. If there's a new format, it would be EventFileReaderImplV4 and have potentially different constants. Or if there's overlap it can be moved to EventFileReader interface or to an abstract class.\nI don't think there will be a different class to parse the individual events, it would just be an extra parameter or overloaded method to existing EventFileReader.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r456010051", "createdAt": "2020-07-16T19:07:30Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/event/EventFileConstants.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.hedera.mirror.importer.reader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+public class EventFileConstants {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5MTI3Ng=="}, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjAyNDc1NA==", "bodyText": "sure. just moved the constants into EventFileReaderImpl", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/832#discussion_r456024754", "createdAt": "2020-07-16T19:31:45Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/reader/event/EventFileConstants.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.hedera.mirror.importer.reader.event;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+public class EventFileConstants {\n+    public static final String HASH_ALGORITHM = \"SHA-384\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5MTI3Ng=="}, "originalCommit": {"oid": "b55662475c9d31e2a42ec98d6c1aad5be284b39b"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1096, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}