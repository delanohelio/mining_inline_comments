{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4OTA3NjA2", "number": 966, "reviewThreads": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjoyNjoxMFrOEZHfEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjozODozMVrOEcqFWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzcyNDk3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjoyNjoxMFrOHBv4WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNToxMDo0MVrOHDL_0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU5NTA5Ng==", "bodyText": "nit: to be consistent with above method\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String getStreamFilenameForInstant(StreamType streamType, Instant instant) {\n          \n          \n            \n                public static final String getStreamFilenameFromInstant(StreamType streamType, Instant instant) {", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r471595096", "createdAt": "2020-08-17T16:26:10Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java", "diffHunk": "@@ -416,10 +416,19 @@ public static final long getTimestampFromFilename(String filename) {\n         }\n \n         date = date.replace('_', ':');\n-        Instant instant = Instant.parse(date);\n+        return Instant.parse(date);\n+    }\n+\n+    public static final long getTimestampFromFilename(String filename) {\n+        Instant instant = getInstantFromFilename(filename);\n         return Utility.convertToNanosMax(instant.getEpochSecond(), instant.getNano());\n     }\n \n+    public static final String getStreamFilenameForInstant(StreamType streamType, Instant instant) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDMzOA==", "bodyText": "will update as suggested", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r473104338", "createdAt": "2020-08-19T15:10:41Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java", "diffHunk": "@@ -416,10 +416,19 @@ public static final long getTimestampFromFilename(String filename) {\n         }\n \n         date = date.replace('_', ':');\n-        Instant instant = Instant.parse(date);\n+        return Instant.parse(date);\n+    }\n+\n+    public static final long getTimestampFromFilename(String filename) {\n+        Instant instant = getInstantFromFilename(filename);\n         return Utility.convertToNanosMax(instant.getEpochSecond(), instant.getNano());\n     }\n \n+    public static final String getStreamFilenameForInstant(StreamType streamType, Instant instant) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU5NTA5Ng=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Nzc0MzI5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjozMToxOVrOHBwDng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNToxMDo0NVrOHDMAFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU5Nzk4Mg==", "bodyText": "nit: This method will call StringUtils.isBlank(lastValidFilename) at least once so you might as well pull it out before the first if after the lastValidFileName retrieval and share it\nboolean isLastValidFileNameBlank = StringUtils.isBlank(lastValidFilename);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r471597982", "createdAt": "2020-08-17T16:31:19Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDQwNw==", "bodyText": "will update as suggested", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r473104407", "createdAt": "2020-08-19T15:10:45Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU5Nzk4Mg=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Nzc3MjMzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjozOToyMFrOHBwVbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjozOToyMFrOHBwVbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwMjU0Mw==", "bodyText": "Q: Are we sure we want to set the start if the lastValidFileInstant.isBefore(startDate)?\nWon't this result in the breaking of the hash chain for record file meaning missing transactions in the mirror node.\nIs this a flow we want to support just yet, as there could be unknown implications?\nI thought we'd only want to support, 1) Start from EPOCH 2) Start from some point in the past 3) Start now\nIn all cases don't we want the mirror node to flow sequentially with no time jumps?\nThis scenario is a subset of having a start and end date. Once you're done you could set another star toad end date in the future. I just want to make sure this is an intentional option we're opening up", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r471602543", "createdAt": "2020-08-17T16:39:20Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzgzMjk3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNjo1NTo1NVrOHBw6jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNToxNDo1NFrOHCZXvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYxMjA0NA==", "bodyText": "Probably want to add a case for when the user sets endDate < startDate accidentally.\nAlso add a unit test that makes sure the expected behavior is carried out.\nPreferably we'd make this a constraint so that it fails at startUp.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r471612044", "createdAt": "2020-08-17T16:55:55Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgxNjgzMQ==", "bodyText": "the constraint should be endDate > effective startDate and the effective startDate depends on the configured startDate & the application status table\nwe need a validator class which depends on the application status repo and errors out if any enabled downloader's effective startDate and the configured endData violates the constraint.\nIt's a bit complicated. Not sure if we want to do it OR we just spit out warning and disables the downloader when the scheduled tasks run", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r471816831", "createdAt": "2020-08-17T22:51:09Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYxMjA0NA=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI3NDg3OQ==", "bodyText": "At minimum, can just do the simpler check without db calls:\nif (endDate != null && startDate != null) {\n  return startDate.compareTo(endDate) <= 0;\n}\nOr you can just do the validation here as this only runs once.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r472274879", "createdAt": "2020-08-18T15:14:54Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYxMjA0NA=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODg4NjEzOnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMToyNTozMVrOHB7Zdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMDo1NTozOFrOHGpZsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4Mzc5OQ==", "bodyText": "Instead of no file is downloaded, would prefer the database is empty. With read only mirror nodes coming up, we may or may not be downloading. Should mention format like verifyHashAfter.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r471783799", "createdAt": "2020-08-17T21:25:31Z", "author": {"login": "steven-sheehy"}, "path": "docs/configuration.md", "diffHunk": "@@ -82,6 +83,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.parser.record.pubsub.maxSendAttempts`               | 5                       | Number of attempts when sending messages to PubSub (only for retryable errors)                 |\n | `hedera.mirror.importer.topicRunningHashV2AddedTimestamp`            | Network-based  | Unix timestamp (in nanos) of first topic message with v2 as running hash version. Use this config to override the default network based value |\n | `hedera.mirror.importer.shard`                                       | 0                       | The default shard number that the component participates in                                    |\n+| `hedera.mirror.importer.startDate`                                   |                         | The start date (inclusive) of the data to import. It takes effect 1) if it's set and the date is after the last downloaded file or no file is downloaded; 2) if it's not set and no file is downloaded, it defaults to now |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjczMTgyNA==", "bodyText": "updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r476731824", "createdAt": "2020-08-25T20:55:38Z", "author": {"login": "xin-hedera"}, "path": "docs/configuration.md", "diffHunk": "@@ -82,6 +83,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.parser.record.pubsub.maxSendAttempts`               | 5                       | Number of attempts when sending messages to PubSub (only for retryable errors)                 |\n | `hedera.mirror.importer.topicRunningHashV2AddedTimestamp`            | Network-based  | Unix timestamp (in nanos) of first topic message with v2 as running hash version. Use this config to override the default network based value |\n | `hedera.mirror.importer.shard`                                       | 0                       | The default shard number that the component participates in                                    |\n+| `hedera.mirror.importer.startDate`                                   |                         | The start date (inclusive) of the data to import. It takes effect 1) if it's set and the date is after the last downloaded file or no file is downloaded; 2) if it's not set and no file is downloaded, it defaults to now |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4Mzc5OQ=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0ODkxMDk0OnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMTozNDoyNVrOHB7otA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMDo1NTo0N1rOHGpaBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4NzcwMA==", "bodyText": "Description should be clearer. Should mention inclusive or exclusive. Should mention transactions after this date will be ignored. Should mention format like verifyHashAfter.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r471787700", "createdAt": "2020-08-17T21:34:25Z", "author": {"login": "steven-sheehy"}, "path": "docs/configuration.md", "diffHunk": "@@ -53,6 +53,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.downloader.record.threads`                   | 13                      | The number of threads to search for new files to download                                      |\n | `hedera.mirror.importer.downloader.region`                           | us-east-1               | The region associated with the bucket                                                          |\n | `hedera.mirror.importer.downloader.secretKey`                        | \"\"                      | The cloud storage secret key                                                                   |\n+| `hedera.mirror.importer.endDate`                                     |                         | The end date of the data to import                                                             |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjczMTkwOQ==", "bodyText": "updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r476731909", "createdAt": "2020-08-25T20:55:47Z", "author": {"login": "xin-hedera"}, "path": "docs/configuration.md", "diffHunk": "@@ -53,6 +53,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.downloader.record.threads`                   | 13                      | The number of threads to search for new files to download                                      |\n | `hedera.mirror.importer.downloader.region`                           | us-east-1               | The region associated with the bucket                                                          |\n | `hedera.mirror.importer.downloader.secretKey`                        | \"\"                      | The cloud storage secret key                                                                   |\n+| `hedera.mirror.importer.endDate`                                     |                         | The end date of the data to import                                                             |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4NzcwMA=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTAxNTE1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMjoxMzoxNFrOHB8nIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMjoxMzoxNFrOHB8nIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgwMzY4Mw==", "bodyText": "This isn't quite the right spot for this logic. verifySigsAndDownloadDataFiles can potentially verify multiple stream files and this just checks if the last one is past. That means files with timestamps after the end date can sneak through.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r471803683", "createdAt": "2020-08-17T22:13:14Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -144,6 +151,12 @@ protected void downloadNextBatch() {\n             log.warn(e.getMessage());\n         } catch (Exception e) {\n             log.error(\"Error downloading files\", e);\n+        } finally {\n+            if (isEndDateReached()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0OTA0MjAxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMjoyNDowOVrOHB82jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMDo1Nzo1MFrOHGpd_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgwNzYyOQ==", "bodyText": "This only gives us resolution at the file level. We should probably have a transaction level check in the parser as well so we don't import transactions in the last file we accept that are past the end date.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r471807629", "createdAt": "2020-08-17T22:24:09Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {\n+                    return !Utility.getInstantFromFilename(filename).isBefore(endDate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEyMDA3MA==", "bodyText": "it's straightforward to apply end date at the level of transaction consensus timestamp. the question is, if we intend to define end date this way, we should define start date the same way. For record file and event file, we have to rely on close interval to infer from what timestamp we download the files. it's error prone since a shorter close interval configured can lead to the wrong inferred effective start date.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r473120070", "createdAt": "2020-08-19T15:32:17Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {\n+                    return !Utility.getInstantFromFilename(filename).isBefore(endDate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgwNzYyOQ=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEyODM5NQ==", "bodyText": "Yes, I didn't clarify but I meant both startDate and endDate should apply to the transactions within the file. But we should also do at file level in the downloader so we can disable that poller (as you are doing now).\nI'm not sure how close interval comes into play. We should only be comparing startDate/endDate with the consensus timestamp in filename in downloader and the individual transactions' consensus timestamp in parser. If the filename is one nanosecond before the endDate, we would still pass it on to parser and he would accept the single transaction and ignore the rest.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r473128395", "createdAt": "2020-08-19T15:44:33Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {\n+                    return !Utility.getInstantFromFilename(filename).isBefore(endDate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgwNzYyOQ=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEzNDkwNQ==", "bodyText": "for record file, because it contains transactions in the range [consensus_start, consensus_end], for example, if start date is set to a value in (consensus_start, consensus_end) and we want to apply it at transaction level, without inferring the effective record file name, we will start downloading, at best, the next record file, which does not have transactions from [start date, consensus_start of the file).\nwith an accurate close interval, we can infer the correct timestamp.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r473134905", "createdAt": "2020-08-19T15:54:01Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {\n+                    return !Utility.getInstantFromFilename(filename).isBefore(endDate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgwNzYyOQ=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE1MjAxMw==", "bodyText": "I don't think we should rely on close interval. The two options I see are a) downloader handles file level granularity and parser handles transaction level granularity b) downloader handles transaction level granularity by passing a consumer to Utility.parseRecordFile() that throws some exception if not within start, end. Latter seems cleanest approach.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r473152013", "createdAt": "2020-08-19T16:20:03Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {\n+                    return !Utility.getInstantFromFilename(filename).isBefore(endDate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgwNzYyOQ=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE2MzU2MQ==", "bodyText": "sure, I'll go with the latter approach", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r473163561", "createdAt": "2020-08-19T16:30:42Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {\n+                    return !Utility.getInstantFromFilename(filename).isBefore(endDate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgwNzYyOQ=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjczMjkyNw==", "bodyText": "add startDateAdjustment to DownloaderProperties, defaults to 30s for both record file and event file ,1s for account balance file. The new field is not described in configuration doc.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r476732927", "createdAt": "2020-08-25T20:57:50Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());\n+        }\n+\n+        dataStartDateUpdated = true;\n+    }\n+\n+    private boolean isEndDateReached() {\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (endDate != null) {\n+            try {\n+                String filename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+                if (!StringUtils.isBlank(filename)) {\n+                    return !Utility.getInstantFromFilename(filename).isBefore(endDate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgwNzYyOQ=="}, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjEzNzk3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNTozMToyNFrOHCaHig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNTozMToyNFrOHCaHig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4NzExNA==", "bodyText": "This method would be more appropriate and encapsulated in MirrorProperties. Would recommend using a framework to ensure only invoked once on startup instead of dataStartDateUpdated.\nclass MirrorProperties {\n  @Async\n  @EventListener(ApplicationReadyEvent.class)\n  public void init() {}", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r472287114", "createdAt": "2020-08-18T15:31:24Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjE4ODQ2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNTo0Mjo1NVrOHCanNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNTo0Mjo1NVrOHCanNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI5NTIyMw==", "bodyText": "nit: Can just log StreamType itself instead of getPath() here and in other places. Path is used for the filesystem path and the enum name would be more appropriate.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r472295223", "createdAt": "2020-08-18T15:42:55Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);\n+            log.info(\"Set downloader to start polling from {} for {}\", startDate, streamType.getPath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjQzMDcxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjo0MjowNFrOHCc_wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjo0MjowNFrOHCc_wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNDI3Mw==", "bodyText": "Since this is a transient update but the database is permanent, we should probably always set verifyHashAfter equal to startDate if the user supplied an explicit startDate.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r472334273", "createdAt": "2020-08-18T16:42:04Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjQzMjMxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjo0MjozMFrOHCdArQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNjo0MjozMFrOHCdArQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNDUwOQ==", "bodyText": "We should not override verifyHashAfter if it's not null and it's after startDate.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r472334509", "createdAt": "2020-08-18T16:42:30Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {\n+                shouldUpdate = true;\n+            }\n+        } else if (StringUtils.isBlank(lastValidFilename)) {\n+            startDate = MirrorProperties.getStartDateNow();\n+            shouldUpdate = true;\n+        }\n+\n+        if (shouldUpdate) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            applicationStatusRepository.updateStatusValue(getLastValidDownloadedFileKey(),\n+                    Utility.getStreamFilenameForInstant(streamType, startDate));\n+            mirrorProperties.setVerifyHashAfter(startDate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MjUwNDI1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzowMTozNlrOHCdupA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxNzowMTozNlrOHCdupA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM0NjI3Ng==", "bodyText": "Can just remove StringUtils.isBlank(lastValidFilename) since Utility.getInstantFromFilename already does that check and returns epoch. Then can pull lastValidFileInstant up like Nana mentioned and flatten this if statement.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r472346276", "createdAt": "2020-08-18T17:01:36Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,6 +433,60 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n+    /**\n+     * Sets the start date of the data based on property startDate and current application status if it's not\n+     * updated yet.\n+     * <ul>\n+     *  <li>If the property startDate is set and application status is empty or less than startDate, set application\n+     *  status and verifyHashAfter to startDate.</li>\n+     *  <li>If the property startDate is not set and application status is empty, set application status and\n+     *  verifyHashAfter to now.</li>\n+     *  </ul>\n+     */\n+    private void updateDataStartDate() {\n+        if (dataStartDateUpdated) {\n+            return;\n+        }\n+\n+        boolean shouldUpdate = false;\n+        Instant startDate = mirrorProperties.getStartDate();\n+        String lastValidFilename = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileKey());\n+        if (startDate != null) {\n+            Instant lastValidFileInstant = Utility.getInstantFromFilename(lastValidFilename);\n+            if (StringUtils.isBlank(lastValidFilename) || lastValidFileInstant.isBefore(startDate)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e81c6061668b2727fa2b561c382cf717d0a703e0"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTM4MTMyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMDo1Nzo0NFrOHFRjqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMDo1ODowNlrOHGpefA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI5MjU4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean mirrorDateRagePropertiesProcessed = false;\n          \n          \n            \n                private boolean mirrorDateRangePropertiesProcessed = false;", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475292584", "createdAt": "2020-08-24T00:57:44Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -86,6 +95,11 @@\n     protected final Timer downloadLatencyMetric;\n     protected final Timer streamCloseMetric;\n \n+    private boolean mirrorDateRagePropertiesProcessed = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjczMzA1Mg==", "bodyText": "fixed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r476733052", "createdAt": "2020-08-25T20:58:06Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -86,6 +95,11 @@\n     protected final Timer downloadLatencyMetric;\n     protected final Timer streamCloseMetric;\n \n+    private boolean mirrorDateRagePropertiesProcessed = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI5MjU4NA=="}, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTM4MjMxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMDo1ODozNVrOHFRkMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjo0MDozNlrOHFtbYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI5MjcyMA==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for\n          \n          \n            \n                 * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate) range for\n          \n      \n    \n    \n  \n\nor\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for\n          \n          \n            \n                 * @param downloaderProperties The properties of the downloader to validate the [startDate, endDate] range for", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475292720", "createdAt": "2020-08-24T00:58:35Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Instant;\n+import java.util.List;\n+import javax.inject.Named;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            validateDateRange(downloaderProperties);\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            updateApplicationStatus(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Validates the configured (startDate, endDate] range for downloader.\n+     * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5MzEwNQ==", "bodyText": "I'm not quite sure about the suggested change. As described in configuration.md, the range is startDate exclusive and endDate inclusive, so (startDate, endDate] is the correct expression.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475693105", "createdAt": "2020-08-24T15:18:09Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Instant;\n+import java.util.List;\n+import javax.inject.Named;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            validateDateRange(downloaderProperties);\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            updateApplicationStatus(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Validates the configured (startDate, endDate] range for downloader.\n+     * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI5MjcyMA=="}, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0OTIxNg==", "bodyText": "That's correct, ignore this :)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475749216", "createdAt": "2020-08-24T16:40:36Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Instant;\n+import java.util.List;\n+import javax.inject.Named;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            validateDateRange(downloaderProperties);\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            updateApplicationStatus(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Validates the configured (startDate, endDate] range for downloader.\n+     * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI5MjcyMA=="}, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTM4MzAyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/MirrorProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMDo1OTowNlrOHFRklA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjowNDozOVrOHHTKVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI5MjgyMA==", "bodyText": "nit: name this something like startUpInstant so it's not confused with startDate.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475292820", "createdAt": "2020-08-24T00:59:06Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/MirrorProperties.java", "diffHunk": "@@ -38,6 +38,8 @@\n @ConfigurationProperties(\"hedera.mirror.importer\")\n public class MirrorProperties {\n \n+    private static final Instant startDateNow = Instant.now();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQxNjAyMg==", "bodyText": "updated", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477416022", "createdAt": "2020-08-26T16:04:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/MirrorProperties.java", "diffHunk": "@@ -38,6 +38,8 @@\n @ConfigurationProperties(\"hedera.mirror.importer\")\n public class MirrorProperties {\n \n+    private static final Instant startDateNow = Instant.now();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI5MjgyMA=="}, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTQwMDQyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMToxMzo0OVrOHFRt8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjowNDozM1rOHHTKIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI5NTIxNg==", "bodyText": "This could also be moved to Utility as Utility. isFileAfterInstant() below\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean isFileAfterEndDate(String filename) {\n          \n          \n            \n                private boolean isFileAfterInstant(String filename, Instant instant) {\n          \n          \n            \n                    return instant != null && Utility.getInstantFromFilename(filename).isAfter(instant);\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nThen call  Utility.isFileAfterInstant(filename, mirrorProperties.getEndDate()) on line 244", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475295216", "createdAt": "2020-08-24T01:13:49Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,9 +475,10 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n-    protected abstract ApplicationStatusCode getLastValidDownloadedFileKey();\n-\n-    protected abstract ApplicationStatusCode getLastValidDownloadedFileHashKey();\n+    private boolean isFileAfterEndDate(String filename) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQxNTk2OA==", "bodyText": "updated as suggested", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477415968", "createdAt": "2020-08-26T16:04:33Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -420,9 +475,10 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n-    protected abstract ApplicationStatusCode getLastValidDownloadedFileKey();\n-\n-    protected abstract ApplicationStatusCode getLastValidDownloadedFileHashKey();\n+    private boolean isFileAfterEndDate(String filename) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI5NTIxNg=="}, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTU0MDEwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMjo1NDowN1rOHFS9VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNToyOTo1MFrOHFqfcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMxNTU0MQ==", "bodyText": "Maybe add a log message here. If it returns a couple of times and the parser isn't downloading it'd be good to know why", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475315541", "createdAt": "2020-08-24T02:54:07Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -96,40 +110,56 @@ public Downloader(S3AsyncClient s3Client, ApplicationStatusRepository applicatio\n         this.meterRegistry = meterRegistry;\n         signatureDownloadThreadPool = Executors.newFixedThreadPool(downloaderProperties.getThreads());\n         Runtime.getRuntime().addShutdownHook(new Thread(signatureDownloadThreadPool::shutdown));\n-        commonDownloaderProperties = downloaderProperties.getCommon();\n         mirrorProperties = downloaderProperties.getMirrorProperties();\n+        commonDownloaderProperties = downloaderProperties.getCommon();\n+\n+        lastValidDownloadedFileKey = downloaderProperties.getLastValidDownloadedFileKey();\n+        lastValidDownloadedFileHashKey = downloaderProperties.getLastValidDownloadedFileHashKey();\n+\n+        StreamType streamType = downloaderProperties.getStreamType();\n+        defaultSigFilename = DEFAULT_FILE_BASENAME + streamType.getSuffix() + \".\" + streamType.getSignatureExtension();\n \n         // Metrics\n         signatureVerificationMetric = Counter.builder(\"hedera.mirror.download.signature.verification\")\n                 .description(\"The number of signatures verified from a particular node\")\n-                .tag(\"type\", downloaderProperties.getStreamType().toString());\n+                .tag(\"type\", streamType.toString());\n \n         streamVerificationMetric = Timer.builder(\"hedera.mirror.download.stream.verification\")\n                 .description(\"The duration in seconds it took to verify consensus and hash chain of a stream file\")\n-                .tag(\"type\", downloaderProperties.getStreamType().toString());\n+                .tag(\"type\", streamType.toString());\n \n         downloadLatencyMetric = Timer.builder(\"hedera.mirror.download.latency\")\n                 .description(\"The difference in ms between the consensus time of the last transaction in the file \" +\n                         \"and the time at which the file was downloaded and verified\")\n-                .tag(\"type\", downloaderProperties.getStreamType().toString())\n+                .tag(\"type\", streamType.toString())\n                 .register(meterRegistry);\n \n         streamCloseMetric = Timer.builder(\"hedera.mirror.stream.close.latency\")\n                 .description(\"The difference between the consensus time of the last and first transaction in the \" +\n                         \"stream file\")\n-                .tag(\"type\", downloaderProperties.getStreamType().toString())\n+                .tag(\"type\", streamType.toString())\n                 .register(meterRegistry);\n     }\n \n+\n+    @EventListener(MirrorDateRangePropertiesProcessedEvent.class)\n+    public void onMirrorDateRangePropertiesProcessedEvent() {\n+        mirrorDateRagePropertiesProcessed = true;\n+    }\n+\n     protected void downloadNextBatch() {\n-        try {\n-            if (!downloaderProperties.isEnabled()) {\n-                return;\n-            }\n-            if (ShutdownHelper.isStopping()) {\n-                return;\n-            }\n+        if (!mirrorDateRagePropertiesProcessed) {\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwMTEwNg==", "bodyText": "in case the configured startDate and endDate causes violation, the InvalidConfigurationException will be logged and the event will never be fired. If there is a log, that message will repeat forever.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475701106", "createdAt": "2020-08-24T15:29:50Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -96,40 +110,56 @@ public Downloader(S3AsyncClient s3Client, ApplicationStatusRepository applicatio\n         this.meterRegistry = meterRegistry;\n         signatureDownloadThreadPool = Executors.newFixedThreadPool(downloaderProperties.getThreads());\n         Runtime.getRuntime().addShutdownHook(new Thread(signatureDownloadThreadPool::shutdown));\n-        commonDownloaderProperties = downloaderProperties.getCommon();\n         mirrorProperties = downloaderProperties.getMirrorProperties();\n+        commonDownloaderProperties = downloaderProperties.getCommon();\n+\n+        lastValidDownloadedFileKey = downloaderProperties.getLastValidDownloadedFileKey();\n+        lastValidDownloadedFileHashKey = downloaderProperties.getLastValidDownloadedFileHashKey();\n+\n+        StreamType streamType = downloaderProperties.getStreamType();\n+        defaultSigFilename = DEFAULT_FILE_BASENAME + streamType.getSuffix() + \".\" + streamType.getSignatureExtension();\n \n         // Metrics\n         signatureVerificationMetric = Counter.builder(\"hedera.mirror.download.signature.verification\")\n                 .description(\"The number of signatures verified from a particular node\")\n-                .tag(\"type\", downloaderProperties.getStreamType().toString());\n+                .tag(\"type\", streamType.toString());\n \n         streamVerificationMetric = Timer.builder(\"hedera.mirror.download.stream.verification\")\n                 .description(\"The duration in seconds it took to verify consensus and hash chain of a stream file\")\n-                .tag(\"type\", downloaderProperties.getStreamType().toString());\n+                .tag(\"type\", streamType.toString());\n \n         downloadLatencyMetric = Timer.builder(\"hedera.mirror.download.latency\")\n                 .description(\"The difference in ms between the consensus time of the last transaction in the file \" +\n                         \"and the time at which the file was downloaded and verified\")\n-                .tag(\"type\", downloaderProperties.getStreamType().toString())\n+                .tag(\"type\", streamType.toString())\n                 .register(meterRegistry);\n \n         streamCloseMetric = Timer.builder(\"hedera.mirror.stream.close.latency\")\n                 .description(\"The difference between the consensus time of the last and first transaction in the \" +\n                         \"stream file\")\n-                .tag(\"type\", downloaderProperties.getStreamType().toString())\n+                .tag(\"type\", streamType.toString())\n                 .register(meterRegistry);\n     }\n \n+\n+    @EventListener(MirrorDateRangePropertiesProcessedEvent.class)\n+    public void onMirrorDateRangePropertiesProcessedEvent() {\n+        mirrorDateRagePropertiesProcessed = true;\n+    }\n+\n     protected void downloadNextBatch() {\n-        try {\n-            if (!downloaderProperties.isEnabled()) {\n-                return;\n-            }\n-            if (ShutdownHelper.isStopping()) {\n-                return;\n-            }\n+        if (!mirrorDateRagePropertiesProcessed) {\n+            return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMxNTU0MQ=="}, "originalCommit": {"oid": "aa3f2651bd0bac995b1f99a61f958330280084c4"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTU1MTIxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMzowMTo0OVrOHFTDmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjozOToxMVrOHFtYNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMxNzE0NA==", "bodyText": "q: should this check be done much earlier? Maybe at the beginning of process()?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475317144", "createdAt": "2020-08-24T03:01:49Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Instant;\n+import java.util.List;\n+import javax.inject.Named;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            validateDateRange(downloaderProperties);\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            updateApplicationStatus(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Validates the configured (startDate, endDate] range for downloader.\n+     * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for\n+     * @throws InvalidConfigurationException if the constraint effective startDate < endDate is violated\n+     */\n+    private void validateDateRange(DownloaderProperties downloaderProperties) {\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (effectiveStartDate != null && endDate != null && !endDate.isAfter(effectiveStartDate)) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation for %s downloader: \" +\n+                            \"startDate (%s) >= endDate (%s)\", downloaderProperties.getStreamType(),\n+                    effectiveStartDate, endDate));\n+        }\n+    }\n+\n+    /**\n+     * Updates the application status for downloader based on the validated (startDate, endDate] range.\n+     * If effective startDate is not null, the application status is set so the downloader will pull data from files\n+     * after the effective startDate. In addition, verifyHashAfter is set to effective startDate if not set or before\n+     * effective startDate.\n+     * @param downloaderProperties The properties of the downloader to update application status for\n+     */\n+    private void updateApplicationStatus(DownloaderProperties downloaderProperties) {\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant lastFileInstant = getLastValidDownloadedFileInstant(downloaderProperties);\n+        if (effectiveStartDate != null && !effectiveStartDate.equals(lastFileInstant)) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            String filename = Utility.getStreamFilenameFromInstant(streamType, effectiveStartDate);\n+            applicationStatusRepository.updateStatusValue(downloaderProperties.getLastValidDownloadedFileKey(), filename);\n+            log.debug(\"Set last valid downloaded file to {} for {} downloader\", filename, streamType);\n+\n+            Instant verifyHashAfter = mirrorProperties.getVerifyHashAfter();\n+            if (verifyHashAfter == null || verifyHashAfter.isBefore(effectiveStartDate)) {\n+                mirrorProperties.setVerifyHashAfter(effectiveStartDate);\n+                log.debug(\"Set verifyHashAfter to {}\", effectiveStartDate);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the effective startDate for downloader based on startDate in MirrorProperties and last valid downloaded file.\n+     * @param downloaderProperties The downloader's properties\n+     * @return The effective startDate: null if downloader is disabled; if startDate is set, the effective startDate is\n+     * startDate if the database is empty or max(startDate, timestamp of last valid downloaded file); if startDate is\n+     * not set, the effective startDate is now if the database is empty, or the timestamp of last valid downloaded file\n+     */\n+    private Instant getEffectiveStartDate(DownloaderProperties downloaderProperties) {\n+        if (!downloaderProperties.isEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5ODIzMA==", "bodyText": "I feel the current implementation is better. subtle details are hidden and the top level function looks clean and is easy to read.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475698230", "createdAt": "2020-08-24T15:25:38Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Instant;\n+import java.util.List;\n+import javax.inject.Named;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            validateDateRange(downloaderProperties);\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            updateApplicationStatus(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Validates the configured (startDate, endDate] range for downloader.\n+     * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for\n+     * @throws InvalidConfigurationException if the constraint effective startDate < endDate is violated\n+     */\n+    private void validateDateRange(DownloaderProperties downloaderProperties) {\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (effectiveStartDate != null && endDate != null && !endDate.isAfter(effectiveStartDate)) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation for %s downloader: \" +\n+                            \"startDate (%s) >= endDate (%s)\", downloaderProperties.getStreamType(),\n+                    effectiveStartDate, endDate));\n+        }\n+    }\n+\n+    /**\n+     * Updates the application status for downloader based on the validated (startDate, endDate] range.\n+     * If effective startDate is not null, the application status is set so the downloader will pull data from files\n+     * after the effective startDate. In addition, verifyHashAfter is set to effective startDate if not set or before\n+     * effective startDate.\n+     * @param downloaderProperties The properties of the downloader to update application status for\n+     */\n+    private void updateApplicationStatus(DownloaderProperties downloaderProperties) {\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant lastFileInstant = getLastValidDownloadedFileInstant(downloaderProperties);\n+        if (effectiveStartDate != null && !effectiveStartDate.equals(lastFileInstant)) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            String filename = Utility.getStreamFilenameFromInstant(streamType, effectiveStartDate);\n+            applicationStatusRepository.updateStatusValue(downloaderProperties.getLastValidDownloadedFileKey(), filename);\n+            log.debug(\"Set last valid downloaded file to {} for {} downloader\", filename, streamType);\n+\n+            Instant verifyHashAfter = mirrorProperties.getVerifyHashAfter();\n+            if (verifyHashAfter == null || verifyHashAfter.isBefore(effectiveStartDate)) {\n+                mirrorProperties.setVerifyHashAfter(effectiveStartDate);\n+                log.debug(\"Set verifyHashAfter to {}\", effectiveStartDate);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the effective startDate for downloader based on startDate in MirrorProperties and last valid downloaded file.\n+     * @param downloaderProperties The downloader's properties\n+     * @return The effective startDate: null if downloader is disabled; if startDate is set, the effective startDate is\n+     * startDate if the database is empty or max(startDate, timestamp of last valid downloaded file); if startDate is\n+     * not set, the effective startDate is now if the database is empty, or the timestamp of last valid downloaded file\n+     */\n+    private Instant getEffectiveStartDate(DownloaderProperties downloaderProperties) {\n+        if (!downloaderProperties.isEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMxNzE0NA=="}, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0ODQwNA==", "bodyText": "Sounds good", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475748404", "createdAt": "2020-08-24T16:39:11Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Instant;\n+import java.util.List;\n+import javax.inject.Named;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            validateDateRange(downloaderProperties);\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            updateApplicationStatus(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Validates the configured (startDate, endDate] range for downloader.\n+     * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for\n+     * @throws InvalidConfigurationException if the constraint effective startDate < endDate is violated\n+     */\n+    private void validateDateRange(DownloaderProperties downloaderProperties) {\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (effectiveStartDate != null && endDate != null && !endDate.isAfter(effectiveStartDate)) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation for %s downloader: \" +\n+                            \"startDate (%s) >= endDate (%s)\", downloaderProperties.getStreamType(),\n+                    effectiveStartDate, endDate));\n+        }\n+    }\n+\n+    /**\n+     * Updates the application status for downloader based on the validated (startDate, endDate] range.\n+     * If effective startDate is not null, the application status is set so the downloader will pull data from files\n+     * after the effective startDate. In addition, verifyHashAfter is set to effective startDate if not set or before\n+     * effective startDate.\n+     * @param downloaderProperties The properties of the downloader to update application status for\n+     */\n+    private void updateApplicationStatus(DownloaderProperties downloaderProperties) {\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant lastFileInstant = getLastValidDownloadedFileInstant(downloaderProperties);\n+        if (effectiveStartDate != null && !effectiveStartDate.equals(lastFileInstant)) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            String filename = Utility.getStreamFilenameFromInstant(streamType, effectiveStartDate);\n+            applicationStatusRepository.updateStatusValue(downloaderProperties.getLastValidDownloadedFileKey(), filename);\n+            log.debug(\"Set last valid downloaded file to {} for {} downloader\", filename, streamType);\n+\n+            Instant verifyHashAfter = mirrorProperties.getVerifyHashAfter();\n+            if (verifyHashAfter == null || verifyHashAfter.isBefore(effectiveStartDate)) {\n+                mirrorProperties.setVerifyHashAfter(effectiveStartDate);\n+                log.debug(\"Set verifyHashAfter to {}\", effectiveStartDate);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the effective startDate for downloader based on startDate in MirrorProperties and last valid downloaded file.\n+     * @param downloaderProperties The downloader's properties\n+     * @return The effective startDate: null if downloader is disabled; if startDate is set, the effective startDate is\n+     * startDate if the database is empty or max(startDate, timestamp of last valid downloaded file); if startDate is\n+     * not set, the effective startDate is now if the database is empty, or the timestamp of last valid downloaded file\n+     */\n+    private Instant getEffectiveStartDate(DownloaderProperties downloaderProperties) {\n+        if (!downloaderProperties.isEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMxNzE0NA=="}, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDA2Mzg1OnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNTozNzoyNFrOHFq1Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMDo1ODoyMVrOHGpe8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwNjYyNg==", "bodyText": "When I said \"Should mention format like verifyHashAfter\", I meant that it should explicitly specify the Format: YYYY-MM-ddTHH:mm:ss.nnnnnnnnnZ instead of saying it's the same as verifyHashAfter. Same for endDate", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475706626", "createdAt": "2020-08-24T15:37:24Z", "author": {"login": "steven-sheehy"}, "path": "docs/configuration.md", "diffHunk": "@@ -82,6 +83,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.parser.record.pubsub.maxSendAttempts`               | 5                       | Number of attempts when sending messages to PubSub (only for retryable errors)                 |\n | `hedera.mirror.importer.topicRunningHashV2AddedTimestamp`            | Network-based  | Unix timestamp (in nanos) of first topic message with v2 as running hash version. Use this config to override the default network based value |\n | `hedera.mirror.importer.shard`                                       | 0                       | The default shard number that the component participates in                                    |\n+| `hedera.mirror.importer.startDate`                                   |                         | The start date (exclusive) of the data to import. It takes effect 1) if it's set and the date is after the last downloaded file or the database is empty; 2) if it's not set and the database is empty, it defaults to now. The format is the same as `verifyHashAfter` |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjczMzE2OA==", "bodyText": "fixed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r476733168", "createdAt": "2020-08-25T20:58:21Z", "author": {"login": "xin-hedera"}, "path": "docs/configuration.md", "diffHunk": "@@ -82,6 +83,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.parser.record.pubsub.maxSendAttempts`               | 5                       | Number of attempts when sending messages to PubSub (only for retryable errors)                 |\n | `hedera.mirror.importer.topicRunningHashV2AddedTimestamp`            | Network-based  | Unix timestamp (in nanos) of first topic message with v2 as running hash version. Use this config to override the default network based value |\n | `hedera.mirror.importer.shard`                                       | 0                       | The default shard number that the component participates in                                    |\n+| `hedera.mirror.importer.startDate`                                   |                         | The start date (exclusive) of the data to import. It takes effect 1) if it's set and the date is after the last downloaded file or the database is empty; 2) if it's not set and the database is empty, it defaults to now. The format is the same as `verifyHashAfter` |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwNjYyNg=="}, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDA3MDQyOnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNTozOTowNFrOHFq5Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxOTo0ODozNlrOHFz1tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwNzY4Ng==", "bodyText": "Why exclusive? I think if the customer has a specific transaction in mind they want it to start at they might populate that here expecting it to show up in the database. I think it should be inclusive.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475707686", "createdAt": "2020-08-24T15:39:04Z", "author": {"login": "steven-sheehy"}, "path": "docs/configuration.md", "diffHunk": "@@ -82,6 +83,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.parser.record.pubsub.maxSendAttempts`               | 5                       | Number of attempts when sending messages to PubSub (only for retryable errors)                 |\n | `hedera.mirror.importer.topicRunningHashV2AddedTimestamp`            | Network-based  | Unix timestamp (in nanos) of first topic message with v2 as running hash version. Use this config to override the default network based value |\n | `hedera.mirror.importer.shard`                                       | 0                       | The default shard number that the component participates in                                    |\n+| `hedera.mirror.importer.startDate`                                   |                         | The start date (exclusive) of the data to import. It takes effect 1) if it's set and the date is after the last downloaded file or the database is empty; 2) if it's not set and the database is empty, it defaults to now. The format is the same as `verifyHashAfter` |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0ODk5NA==", "bodyText": "We really need to clarify whether startDate is designed to work at individual transaction level or not. As I previously claimed, say, a client sets startDate at instant T1, he wants it to work at transaction level, and there happens to be a transaction whose consensus timestamp == T1,  based on the current implementation, it won't work for most cases.\nThe cause is, most likely the record file which contains that transaction is named at timestamp T1 - some amount of time. In order to make it work at transaction level, we need to introduce close interval and infer the correct record file name to begin with. We had a discussion about the close interval and my argument is it's error prone. On the other hand, we can choose to set a really large close interval and the compromise is we always download more than needed record files. What do you think?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475848994", "createdAt": "2020-08-24T19:37:47Z", "author": {"login": "xin-hedera"}, "path": "docs/configuration.md", "diffHunk": "@@ -82,6 +83,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.parser.record.pubsub.maxSendAttempts`               | 5                       | Number of attempts when sending messages to PubSub (only for retryable errors)                 |\n | `hedera.mirror.importer.topicRunningHashV2AddedTimestamp`            | Network-based  | Unix timestamp (in nanos) of first topic message with v2 as running hash version. Use this config to override the default network based value |\n | `hedera.mirror.importer.shard`                                       | 0                       | The default shard number that the component participates in                                    |\n+| `hedera.mirror.importer.startDate`                                   |                         | The start date (exclusive) of the data to import. It takes effect 1) if it's set and the date is after the last downloaded file or the database is empty; 2) if it's not set and the database is empty, it defaults to now. The format is the same as `verifyHashAfter` |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwNzY4Ng=="}, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg1NDI2Mg==", "bodyText": "I'm not sure why we're re-hashing the same argument. We discussed this previously and you agreed that we don't need close interval and can use item consumer to accomplish the same thing.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475854262", "createdAt": "2020-08-24T19:48:36Z", "author": {"login": "steven-sheehy"}, "path": "docs/configuration.md", "diffHunk": "@@ -82,6 +83,7 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.importer.parser.record.pubsub.maxSendAttempts`               | 5                       | Number of attempts when sending messages to PubSub (only for retryable errors)                 |\n | `hedera.mirror.importer.topicRunningHashV2AddedTimestamp`            | Network-based  | Unix timestamp (in nanos) of first topic message with v2 as running hash version. Use this config to override the default network based value |\n | `hedera.mirror.importer.shard`                                       | 0                       | The default shard number that the component participates in                                    |\n+| `hedera.mirror.importer.startDate`                                   |                         | The start date (exclusive) of the data to import. It takes effect 1) if it's set and the date is after the last downloaded file or the database is empty; 2) if it's not set and the database is empty, it defaults to now. The format is the same as `verifyHashAfter` |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwNzY4Ng=="}, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDEwMTg5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNTo0Njo0MlrOHFrMcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMToxMTozN1rOHF2bvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcxMjYyNw==", "bodyText": "mirrorProperties.getEndDate() uses reflection and is slow to put in a tight loop like this. As this change is only used to update a log statement, it's not important and recommend it be reverted. Changing order of counter.incrementAndGet() to be after processRecordItem should be sufficient.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475712627", "createdAt": "2020-08-24T15:46:42Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -174,14 +182,20 @@ public void loadRecordFile(StreamFileData streamFileData) {\n         }\n     }\n \n-    private void processRecordItem(RecordItem recordItem) {\n+    private boolean processRecordItem(RecordItem recordItem) {\n         if (log.isTraceEnabled()) {\n             log.trace(\"Transaction = {}, Record = {}\",\n                     Utility.printProtoMessage(recordItem.getTransaction()),\n                     Utility.printProtoMessage(recordItem.getRecord()));\n         } else if (log.isDebugEnabled()) {\n             log.debug(\"Storing transaction with consensus timestamp {}\", recordItem.getConsensusTimestamp());\n         }\n+\n+        Instant endDate = mirrorProperties.getEndDate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg1OTAyNg==", "bodyText": "Sorry, looking again this logic is necessary. But point still stands about slow method. Recommend retrieving it once per file and passing it to processRecordItem.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475859026", "createdAt": "2020-08-24T19:57:47Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -174,14 +182,20 @@ public void loadRecordFile(StreamFileData streamFileData) {\n         }\n     }\n \n-    private void processRecordItem(RecordItem recordItem) {\n+    private boolean processRecordItem(RecordItem recordItem) {\n         if (log.isTraceEnabled()) {\n             log.trace(\"Transaction = {}, Record = {}\",\n                     Utility.printProtoMessage(recordItem.getTransaction()),\n                     Utility.printProtoMessage(recordItem.getRecord()));\n         } else if (log.isDebugEnabled()) {\n             log.debug(\"Storing transaction with consensus timestamp {}\", recordItem.getConsensusTimestamp());\n         }\n+\n+        Instant endDate = mirrorProperties.getEndDate();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcxMjYyNw=="}, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg5Njc2Ng==", "bodyText": "Thanks for the clarification. I was confused at first when I read the feedback. Also thanks for pointing out the performance issue, will change as suggested.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475896766", "createdAt": "2020-08-24T21:11:37Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -174,14 +182,20 @@ public void loadRecordFile(StreamFileData streamFileData) {\n         }\n     }\n \n-    private void processRecordItem(RecordItem recordItem) {\n+    private boolean processRecordItem(RecordItem recordItem) {\n         if (log.isTraceEnabled()) {\n             log.trace(\"Transaction = {}, Record = {}\",\n                     Utility.printProtoMessage(recordItem.getTransaction()),\n                     Utility.printProtoMessage(recordItem.getRecord()));\n         } else if (log.isDebugEnabled()) {\n             log.debug(\"Storing transaction with consensus timestamp {}\", recordItem.getConsensusTimestamp());\n         }\n+\n+        Instant endDate = mirrorProperties.getEndDate();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcxMjYyNw=="}, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDE2ODk4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjowMjo0MFrOHFr1jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjowMjo0MFrOHFr1jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyMzE1MA==", "bodyText": "Seems inefficient to loop over downloaderPropertiesList twice and retrieve effective start date twice. Recommend it be refactored to push validateDateRange into updateApplicationStatus to avoid the duplication.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475723150", "createdAt": "2020-08-24T16:02:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Instant;\n+import java.util.List;\n+import javax.inject.Named;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            validateDateRange(downloaderProperties);\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            updateApplicationStatus(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Validates the configured (startDate, endDate] range for downloader.\n+     * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for\n+     * @throws InvalidConfigurationException if the constraint effective startDate < endDate is violated\n+     */\n+    private void validateDateRange(DownloaderProperties downloaderProperties) {\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDc3MzkxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxODo0MTozNVrOHFxvHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxODo0MTozNVrOHFxvHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxOTgwNw==", "bodyText": "getLastValidDownloadedFileInstant actually gets called 4 times per stream type. Since it's a cached method it's maybe not a big deal but still.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475819807", "createdAt": "2020-08-24T18:41:35Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Instant;\n+import java.util.List;\n+import javax.inject.Named;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            validateDateRange(downloaderProperties);\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            updateApplicationStatus(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Validates the configured (startDate, endDate] range for downloader.\n+     * @param downloaderProperties The properties of the downloader to validate the (startDate, endDate] range for\n+     * @throws InvalidConfigurationException if the constraint effective startDate < endDate is violated\n+     */\n+    private void validateDateRange(DownloaderProperties downloaderProperties) {\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (effectiveStartDate != null && endDate != null && !endDate.isAfter(effectiveStartDate)) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation for %s downloader: \" +\n+                            \"startDate (%s) >= endDate (%s)\", downloaderProperties.getStreamType(),\n+                    effectiveStartDate, endDate));\n+        }\n+    }\n+\n+    /**\n+     * Updates the application status for downloader based on the validated (startDate, endDate] range.\n+     * If effective startDate is not null, the application status is set so the downloader will pull data from files\n+     * after the effective startDate. In addition, verifyHashAfter is set to effective startDate if not set or before\n+     * effective startDate.\n+     * @param downloaderProperties The properties of the downloader to update application status for\n+     */\n+    private void updateApplicationStatus(DownloaderProperties downloaderProperties) {\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant lastFileInstant = getLastValidDownloadedFileInstant(downloaderProperties);\n+        if (effectiveStartDate != null && !effectiveStartDate.equals(lastFileInstant)) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            String filename = Utility.getStreamFilenameFromInstant(streamType, effectiveStartDate);\n+            applicationStatusRepository.updateStatusValue(downloaderProperties.getLastValidDownloadedFileKey(), filename);\n+            log.debug(\"Set last valid downloaded file to {} for {} downloader\", filename, streamType);\n+\n+            Instant verifyHashAfter = mirrorProperties.getVerifyHashAfter();\n+            if (verifyHashAfter == null || verifyHashAfter.isBefore(effectiveStartDate)) {\n+                mirrorProperties.setVerifyHashAfter(effectiveStartDate);\n+                log.debug(\"Set verifyHashAfter to {}\", effectiveStartDate);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the effective startDate for downloader based on startDate in MirrorProperties and last valid downloaded file.\n+     * @param downloaderProperties The downloader's properties\n+     * @return The effective startDate: null if downloader is disabled; if startDate is set, the effective startDate is\n+     * startDate if the database is empty or max(startDate, timestamp of last valid downloaded file); if startDate is\n+     * not set, the effective startDate is now if the database is empty, or the timestamp of last valid downloaded file\n+     */\n+    private Instant getEffectiveStartDate(DownloaderProperties downloaderProperties) {\n+        if (!downloaderProperties.isEnabled()) {\n+            return null;\n+        }\n+\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant lastFileInstant = getLastValidDownloadedFileInstant(downloaderProperties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDgzMTc5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxODo1ODozM1rOHFyTAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMDo1OTowNFrOHGpgQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyODk5NA==", "bodyText": "Again, I don't feel this logic should be here. I also don't like making this class stateful by storing lastSigFilenameToVerify. Recommend removing lastSigFilenameToVerify and pushing this logic into if (isFileAfterEndDate(sigFilename)) check inside verifySigsAndDownloadDataFiles. There you can just directly return from the method after disabling polling if it's after and avoid the multiple break statements. It makes the logic cleaner and is more encapsulated.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475828994", "createdAt": "2020-08-24T18:58:33Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -144,6 +174,17 @@ protected void downloadNextBatch() {\n             log.warn(e.getMessage());\n         } catch (Exception e) {\n             log.error(\"Error downloading files\", e);\n+        } finally {\n+            if (!StringUtils.isEmpty(lastSigFilenameToVerify)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjczMzUwNg==", "bodyText": "Simplified the logic", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r476733506", "createdAt": "2020-08-25T20:59:04Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -144,6 +174,17 @@ protected void downloadNextBatch() {\n             log.warn(e.getMessage());\n         } catch (Exception e) {\n             log.error(\"Error downloading files\", e);\n+        } finally {\n+            if (!StringUtils.isEmpty(lastSigFilenameToVerify)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyODk5NA=="}, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDgzODExOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxOTowMDoyN1rOHFyW7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxOTowMDoyN1rOHFyW7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyOTk5Ng==", "bodyText": "Can just downloaderProperties.setEnabled(false); here or call a method that does so.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475829996", "createdAt": "2020-08-24T19:00:27Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -389,13 +439,23 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n                 }\n             }\n \n-            if (!valid) {\n-                log.error(\"None of the data files could be verified, signatures: {}\", signatures);\n-            }\n-\n             streamVerificationMetric.tag(\"success\", String.valueOf(valid))\n                     .register(meterRegistry)\n                     .record(Duration.between(startTime, Instant.now()));\n+\n+            if (isEndDateReached) {\n+                // stop processing here since the file is after the configured endDate\n+                lastSigFilenameToVerify = lastValidSigFilename;\n+                break;\n+            } else if (!valid) {\n+                log.error(\"None of the data files could be verified, signatures: {}\", signatures);\n+            }\n+        }\n+\n+        if (!sigFilesMap.isEmpty() && lastSigFilenameToVerify != null && lastSigFilenameToVerify.isEmpty()) {\n+            // when all files in the bucket are after endDate and there is no last downloaded file in db,\n+            // use defaultSigFilename as sentinel to disable the downloader\n+            lastSigFilenameToVerify = defaultSigFilename;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDg0NDg0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxOTowMjozNlrOHFybUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxOTowMjozNlrOHFybUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzMTEyMg==", "bodyText": "This still doesn't seem to support transaction level granularity.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475831122", "createdAt": "2020-08-24T19:02:36Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -365,16 +408,23 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n                     if (signedDataFile == null) {\n                         continue;\n                     }\n+\n                     if (verifyDataFile(signedDataFile, signature.getHash())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NTA0NDkxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMDowNDoyM1rOHF0ViA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMDowNDoyM1rOHF0ViA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg2MjQwOA==", "bodyText": "This should probably still disable the parser poller otherwise the files in valid folder will be repeatedly parsed indefinitely.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r475862408", "createdAt": "2020-08-24T20:04:23Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -153,8 +160,9 @@ public void loadRecordFile(StreamFileData streamFileData) {\n                     streamFileData.getFilename(), expectedPrevFileHash,\n                     parserProperties.getMirrorProperties().getVerifyHashAfter(),\n                     recordItem -> {\n-                        counter.incrementAndGet();\n-                        processRecordItem(recordItem);\n+                        if (processRecordItem(recordItem)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c213b85105d61b4f90c231d845f0a5329b5dffb"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDc3MDQzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjoxODoyNlrOHHTtRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMDowNzo0OFrOHHb5dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNDk2NA==", "bodyText": "nit: Use @Value for immutable classes.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477424964", "createdAt": "2020-08-26T16:18:26Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.apache.commons.lang3.ObjectUtils.max;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.inject.Named;\n+import javax.transaction.Transactional;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    private Map<StreamType, DateRangeFilter> filters = new HashMap<>();\n+\n+    @Transactional\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (startDate != null && endDate != null && startDate.compareTo(endDate) > 0) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation: \" +\n+                    \"startDate (%s) > endDate (%s)\", startDate, endDate));\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            processDateRange(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Gets the DateRangeFilter for the downloader (record, balance, event).\n+     * @param type - downloader type\n+     * @return the DateRangeFilter\n+     */\n+    public DateRangeFilter getDateRangeFilter(StreamType type) {\n+        return filters.get(type);\n+    }\n+\n+    /**\n+     * Validates the configured [startDate, endDate] range for downloader and updates its application status if needed.\n+     * @param downloaderProperties the properties of the downloader to validate the [startDate, endDate] range for\n+     * @throws InvalidConfigurationException if the constraint effective startDate < endDate is violated\n+     */\n+    private void processDateRange(DownloaderProperties downloaderProperties) {\n+        // validate date range\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (effectiveStartDate != null && endDate != null && effectiveStartDate.compareTo(endDate) > 0) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation for %s downloader: \" +\n+                            \"effective startDate (%s) > endDate (%s)\", downloaderProperties.getStreamType(),\n+                    effectiveStartDate, endDate));\n+        }\n+\n+        // update application status\n+        Instant lastFileInstant = getLastValidDownloadedFileInstant(downloaderProperties);\n+        if (effectiveStartDate != null && !effectiveStartDate.equals(lastFileInstant)) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            String filename = Utility.getStreamFilenameFromInstant(streamType, effectiveStartDate);\n+            applicationStatusRepository.updateStatusValue(downloaderProperties.getLastValidDownloadedFileKey(), filename);\n+            log.debug(\"Set last valid downloaded file to {} for {} downloader\", filename, streamType);\n+\n+            Instant verifyHashAfter = mirrorProperties.getVerifyHashAfter();\n+            if (verifyHashAfter == null || verifyHashAfter.isBefore(effectiveStartDate)) {\n+                mirrorProperties.setVerifyHashAfter(effectiveStartDate);\n+                log.debug(\"Set verifyHashAfter to {}\", effectiveStartDate);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the effective startDate for downloader based on startDate in MirrorProperties, the startDateAdjustment\n+     * and last valid downloaded file. Also sets the effective inclusive start date of the items to accept.\n+     * @param downloaderProperties The downloader's properties\n+     * @return The effective startDate: null if downloader is disabled; if startDate is set, the effective startDate is\n+     * startDate if the database is empty or max(startDate, timestamp of last valid downloaded file); if startDate is\n+     * not set, the effective startDate is now if the database is empty, or the timestamp of last valid downloaded file\n+     */\n+    private Instant getEffectiveStartDate(DownloaderProperties downloaderProperties) {\n+        if (!downloaderProperties.isEnabled()) {\n+            filters.put(downloaderProperties.getStreamType(), DateRangeFilter.empty());\n+            return null;\n+        }\n+\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant startUpInstant = MirrorProperties.getStartUpInstant();\n+        Instant endDate = mirrorProperties.getEndDate();\n+        Instant lastFileInstant = getLastValidDownloadedFileInstant(downloaderProperties);\n+        Duration adjustment = downloaderProperties.getStartDateAdjustment();\n+        if (startDate != null) {\n+            if (startDate.isAfter(lastFileInstant) || endDate != null) {\n+                filters.put(downloaderProperties.getStreamType(), new DateRangeFilter(startDate, endDate));\n+            }\n+            return max(startDate.minus(adjustment), lastFileInstant);\n+        } else {\n+            if (lastFileInstant.equals(Instant.EPOCH)) {\n+                filters.put(downloaderProperties.getStreamType(), new DateRangeFilter(startUpInstant, endDate));\n+                return startUpInstant.minus(adjustment);\n+            } else {\n+                if (endDate != null) {\n+                    filters.put(downloaderProperties.getStreamType(), new DateRangeFilter(lastFileInstant, endDate));\n+                }\n+                return lastFileInstant;\n+            }\n+        }\n+    }\n+\n+    private Instant getLastValidDownloadedFileInstant(DownloaderProperties downloaderProperties) {\n+        String filename = applicationStatusRepository.findByStatusCode(downloaderProperties.getLastValidDownloadedFileKey());\n+        return Utility.getInstantFromFilename(filename);\n+    }\n+\n+    @Data", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1OTE1OA==", "bodyText": "changed as suggested", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477559158", "createdAt": "2020-08-26T20:07:48Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.apache.commons.lang3.ObjectUtils.max;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.inject.Named;\n+import javax.transaction.Transactional;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    private Map<StreamType, DateRangeFilter> filters = new HashMap<>();\n+\n+    @Transactional\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (startDate != null && endDate != null && startDate.compareTo(endDate) > 0) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation: \" +\n+                    \"startDate (%s) > endDate (%s)\", startDate, endDate));\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            processDateRange(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Gets the DateRangeFilter for the downloader (record, balance, event).\n+     * @param type - downloader type\n+     * @return the DateRangeFilter\n+     */\n+    public DateRangeFilter getDateRangeFilter(StreamType type) {\n+        return filters.get(type);\n+    }\n+\n+    /**\n+     * Validates the configured [startDate, endDate] range for downloader and updates its application status if needed.\n+     * @param downloaderProperties the properties of the downloader to validate the [startDate, endDate] range for\n+     * @throws InvalidConfigurationException if the constraint effective startDate < endDate is violated\n+     */\n+    private void processDateRange(DownloaderProperties downloaderProperties) {\n+        // validate date range\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (effectiveStartDate != null && endDate != null && effectiveStartDate.compareTo(endDate) > 0) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation for %s downloader: \" +\n+                            \"effective startDate (%s) > endDate (%s)\", downloaderProperties.getStreamType(),\n+                    effectiveStartDate, endDate));\n+        }\n+\n+        // update application status\n+        Instant lastFileInstant = getLastValidDownloadedFileInstant(downloaderProperties);\n+        if (effectiveStartDate != null && !effectiveStartDate.equals(lastFileInstant)) {\n+            StreamType streamType = downloaderProperties.getStreamType();\n+            String filename = Utility.getStreamFilenameFromInstant(streamType, effectiveStartDate);\n+            applicationStatusRepository.updateStatusValue(downloaderProperties.getLastValidDownloadedFileKey(), filename);\n+            log.debug(\"Set last valid downloaded file to {} for {} downloader\", filename, streamType);\n+\n+            Instant verifyHashAfter = mirrorProperties.getVerifyHashAfter();\n+            if (verifyHashAfter == null || verifyHashAfter.isBefore(effectiveStartDate)) {\n+                mirrorProperties.setVerifyHashAfter(effectiveStartDate);\n+                log.debug(\"Set verifyHashAfter to {}\", effectiveStartDate);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the effective startDate for downloader based on startDate in MirrorProperties, the startDateAdjustment\n+     * and last valid downloaded file. Also sets the effective inclusive start date of the items to accept.\n+     * @param downloaderProperties The downloader's properties\n+     * @return The effective startDate: null if downloader is disabled; if startDate is set, the effective startDate is\n+     * startDate if the database is empty or max(startDate, timestamp of last valid downloaded file); if startDate is\n+     * not set, the effective startDate is now if the database is empty, or the timestamp of last valid downloaded file\n+     */\n+    private Instant getEffectiveStartDate(DownloaderProperties downloaderProperties) {\n+        if (!downloaderProperties.isEnabled()) {\n+            filters.put(downloaderProperties.getStreamType(), DateRangeFilter.empty());\n+            return null;\n+        }\n+\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant startUpInstant = MirrorProperties.getStartUpInstant();\n+        Instant endDate = mirrorProperties.getEndDate();\n+        Instant lastFileInstant = getLastValidDownloadedFileInstant(downloaderProperties);\n+        Duration adjustment = downloaderProperties.getStartDateAdjustment();\n+        if (startDate != null) {\n+            if (startDate.isAfter(lastFileInstant) || endDate != null) {\n+                filters.put(downloaderProperties.getStreamType(), new DateRangeFilter(startDate, endDate));\n+            }\n+            return max(startDate.minus(adjustment), lastFileInstant);\n+        } else {\n+            if (lastFileInstant.equals(Instant.EPOCH)) {\n+                filters.put(downloaderProperties.getStreamType(), new DateRangeFilter(startUpInstant, endDate));\n+                return startUpInstant.minus(adjustment);\n+            } else {\n+                if (endDate != null) {\n+                    filters.put(downloaderProperties.getStreamType(), new DateRangeFilter(lastFileInstant, endDate));\n+                }\n+                return lastFileInstant;\n+            }\n+        }\n+    }\n+\n+    private Instant getLastValidDownloadedFileInstant(DownloaderProperties downloaderProperties) {\n+        String filename = applicationStatusRepository.findByStatusCode(downloaderProperties.getLastValidDownloadedFileKey());\n+        return Utility.getInstantFromFilename(filename);\n+    }\n+\n+    @Data", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNDk2NA=="}, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDc4NTQ4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjoyMjoxOVrOHHT23Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjoyMjoxOVrOHHT23Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzQyMQ==", "bodyText": "I'm not a fan of using this helper processor class to store state and this state used by other classes. Logically this should belong in a properties class, but we can get this in and revisit it later.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477427421", "createdAt": "2020-08-26T16:22:19Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.apache.commons.lang3.ObjectUtils.max;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.inject.Named;\n+import javax.transaction.Transactional;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    private Map<StreamType, DateRangeFilter> filters = new HashMap<>();\n+\n+    @Transactional\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (startDate != null && endDate != null && startDate.compareTo(endDate) > 0) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation: \" +\n+                    \"startDate (%s) > endDate (%s)\", startDate, endDate));\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            processDateRange(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Gets the DateRangeFilter for the downloader (record, balance, event).\n+     * @param type - downloader type\n+     * @return the DateRangeFilter\n+     */\n+    public DateRangeFilter getDateRangeFilter(StreamType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDc5NTA0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjoyNDozNlrOHHT8qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNzoxMzoyOFrOHHVzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyODkwNQ==", "bodyText": "Would it help cleanup this logic here and in other places if we defaulted startDate=Instant.EPOCH and endDate=Instant.MAX then made the two fields @NotNull validated? It would also make effectiveStartDate never null.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477428905", "createdAt": "2020-08-26T16:24:36Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.apache.commons.lang3.ObjectUtils.max;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.inject.Named;\n+import javax.transaction.Transactional;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    private Map<StreamType, DateRangeFilter> filters = new HashMap<>();\n+\n+    @Transactional\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (startDate != null && endDate != null && startDate.compareTo(endDate) > 0) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation: \" +\n+                    \"startDate (%s) > endDate (%s)\", startDate, endDate));\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            processDateRange(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Gets the DateRangeFilter for the downloader (record, balance, event).\n+     * @param type - downloader type\n+     * @return the DateRangeFilter\n+     */\n+    public DateRangeFilter getDateRangeFilter(StreamType type) {\n+        return filters.get(type);\n+    }\n+\n+    /**\n+     * Validates the configured [startDate, endDate] range for downloader and updates its application status if needed.\n+     * @param downloaderProperties the properties of the downloader to validate the [startDate, endDate] range for\n+     * @throws InvalidConfigurationException if the constraint effective startDate < endDate is violated\n+     */\n+    private void processDateRange(DownloaderProperties downloaderProperties) {\n+        // validate date range\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (effectiveStartDate != null && endDate != null && effectiveStartDate.compareTo(endDate) > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1OTI1Mw==", "bodyText": "we can't default startDate to Instant.EPOCH because in the design we have a case that it defaults to now. We can default endDate to Instant.MAX and I'll move up the downloader is disabled check to processDateRange so effectiveStartDate returned by getEffectiveStartDate will never be null. I think this will cleanup the logic here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477459253", "createdAt": "2020-08-26T17:13:28Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.apache.commons.lang3.ObjectUtils.max;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.inject.Named;\n+import javax.transaction.Transactional;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    private Map<StreamType, DateRangeFilter> filters = new HashMap<>();\n+\n+    @Transactional\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (startDate != null && endDate != null && startDate.compareTo(endDate) > 0) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation: \" +\n+                    \"startDate (%s) > endDate (%s)\", startDate, endDate));\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            processDateRange(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");\n+    }\n+\n+    /**\n+     * Gets the DateRangeFilter for the downloader (record, balance, event).\n+     * @param type - downloader type\n+     * @return the DateRangeFilter\n+     */\n+    public DateRangeFilter getDateRangeFilter(StreamType type) {\n+        return filters.get(type);\n+    }\n+\n+    /**\n+     * Validates the configured [startDate, endDate] range for downloader and updates its application status if needed.\n+     * @param downloaderProperties the properties of the downloader to validate the [startDate, endDate] range for\n+     * @throws InvalidConfigurationException if the constraint effective startDate < endDate is violated\n+     */\n+    private void processDateRange(DownloaderProperties downloaderProperties) {\n+        // validate date range\n+        Instant effectiveStartDate = getEffectiveStartDate(downloaderProperties);\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (effectiveStartDate != null && endDate != null && effectiveStartDate.compareTo(endDate) > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyODkwNQ=="}, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDgzMjc4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjozNDozNVrOHHUUXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNzoxNDozOVrOHHV2Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzNDk3NQ==", "bodyText": "I think this log is less important and should be debug. Instead, I think an info log that states that it is only downloading files between x and y should be present.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477434975", "createdAt": "2020-08-26T16:34:35Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.apache.commons.lang3.ObjectUtils.max;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.inject.Named;\n+import javax.transaction.Transactional;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    private Map<StreamType, DateRangeFilter> filters = new HashMap<>();\n+\n+    @Transactional\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (startDate != null && endDate != null && startDate.compareTo(endDate) > 0) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation: \" +\n+                    \"startDate (%s) > endDate (%s)\", startDate, endDate));\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            processDateRange(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1OTk3MQ==", "bodyText": "will make this at debug level and add an info log to each downloader about the effective range and actual transaction level range", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477459971", "createdAt": "2020-08-26T17:14:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.apache.commons.lang3.ObjectUtils.max;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.inject.Named;\n+import javax.transaction.Transactional;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    private Map<StreamType, DateRangeFilter> filters = new HashMap<>();\n+\n+    @Transactional\n+    @Async\n+    @EventListener(ApplicationReadyEvent.class)\n+    public void process() {\n+        Instant startDate = mirrorProperties.getStartDate();\n+        Instant endDate = mirrorProperties.getEndDate();\n+        if (startDate != null && endDate != null && startDate.compareTo(endDate) > 0) {\n+            throw new InvalidConfigurationException(String.format(\"Date range constraint violation: \" +\n+                    \"startDate (%s) > endDate (%s)\", startDate, endDate));\n+        }\n+\n+        for (DownloaderProperties downloaderProperties : downloaderPropertiesList) {\n+            processDateRange(downloaderProperties);\n+        }\n+\n+        applicationEventPublisher.publishEvent(new MirrorDateRangePropertiesProcessedEvent(this));\n+        log.info(\"Mirror date range properties processed successfully, MirrorDateRangePropertiesProcessedEvent fired\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzNDk3NQ=="}, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDg0MjAwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjozNzowNFrOHHUaBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNzoyMjowOFrOHHWHrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzNjQyMw==", "bodyText": "I don't think transactionality is important here as it's read only and the system doesn't change until this event publishes.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477436423", "createdAt": "2020-08-26T16:37:04Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.apache.commons.lang3.ObjectUtils.max;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.inject.Named;\n+import javax.transaction.Transactional;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    private Map<StreamType, DateRangeFilter> filters = new HashMap<>();\n+\n+    @Transactional", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2NDQ5NQ==", "bodyText": "application status (last valid downloaded file) is updated for each downloader if needed and effectiveStartDate <= endDate constraint is verified for each downloader separately. in case db error happens or the date range constraint is violated, the db may be left in a state that application status for one downloader is updated. it may not be a big issue but I think enabling transaction here so db rolls back is better.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477464495", "createdAt": "2020-08-26T17:22:08Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/config/MirrorDateRangePropertiesProcessor.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package com.hedera.mirror.importer.config;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.apache.commons.lang3.ObjectUtils.max;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.inject.Named;\n+import javax.transaction.Transactional;\n+import lombok.Data;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.springframework.boot.context.event.ApplicationReadyEvent;\n+import org.springframework.context.ApplicationEventPublisher;\n+import org.springframework.context.event.EventListener;\n+import org.springframework.scheduling.annotation.Async;\n+\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.config.event.MirrorDateRangePropertiesProcessedEvent;\n+import com.hedera.mirror.importer.domain.StreamType;\n+import com.hedera.mirror.importer.downloader.DownloaderProperties;\n+import com.hedera.mirror.importer.exception.InvalidConfigurationException;\n+import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+@RequiredArgsConstructor\n+public class MirrorDateRangePropertiesProcessor {\n+\n+    private final ApplicationEventPublisher applicationEventPublisher;\n+    private final MirrorProperties mirrorProperties;\n+    private final ApplicationStatusRepository applicationStatusRepository;\n+    private final List<DownloaderProperties> downloaderPropertiesList;\n+\n+    private Map<StreamType, DateRangeFilter> filters = new HashMap<>();\n+\n+    @Transactional", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzNjQyMw=="}, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDg1MDgxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjozODozMVrOHHUfNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNzoyMjo1N1rOHHWJnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzNzc1MQ==", "bodyText": "Pull mirrorProperties.getEndDate() out of loops and into a variable as it is slow. Also, no need to log stream type as Logger itself will show concrete type like RecordFileDownloader", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477437751", "createdAt": "2020-08-26T16:38:31Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -365,16 +388,25 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n                     if (signedDataFile == null) {\n                         continue;\n                     }\n+\n                     if (verifyDataFile(signedDataFile, signature.getHash())) {\n+                        if (Utility.isStreamFileAfterInstant(sigFilename, mirrorProperties.getEndDate())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2NDk5MQ==", "bodyText": "sure", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/966#discussion_r477464991", "createdAt": "2020-08-26T17:22:57Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -365,16 +388,25 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n                     if (signedDataFile == null) {\n                         continue;\n                     }\n+\n                     if (verifyDataFile(signedDataFile, signature.getHash())) {\n+                        if (Utility.isStreamFileAfterInstant(sigFilename, mirrorProperties.getEndDate())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQzNzc1MQ=="}, "originalCommit": {"oid": "3487c0f1f39982e626fdecc72e245e598cec3500"}, "originalPosition": 151}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 949, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}