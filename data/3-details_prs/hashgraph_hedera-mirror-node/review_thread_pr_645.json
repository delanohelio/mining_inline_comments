{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MjIxNDgy", "number": 645, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjo1OTowOFrODuCyuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzoyNjo1N1rODuetKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NjA2ODQwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityId.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjo1OTowOFrOF_0orA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjo1OTowOFrOF_0orA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2Njk4OA==", "bodyText": "Should use type.getId() instead. Ordinal starts at 0, which is wrong. Not sure how your tests are passing.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402466988", "createdAt": "2020-04-02T16:59:08Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityId.java", "diffHunk": "@@ -20,13 +20,58 @@\n  * \u200d\n  */\n \n+import com.hederahashgraph.api.proto.java.AccountID;\n+import com.hederahashgraph.api.proto.java.ContractID;\n+import com.hederahashgraph.api.proto.java.FileID;\n+import com.hederahashgraph.api.proto.java.TopicID;\n import lombok.Value;\n \n+/**\n+ * Common encapsulation for accountID, fileID, contractID, and topicID.\n+ *\n+ * There is no valid entity in Hedera network with an id '0.0.0'. When AccountID/FileID/ContractID/TopicID are not set,\n+ * their values default to '0.0.0'. If such an unset (default) instance is used to create EntityId using one of the\n+ * of(..) functions, null is returned.\n+ */\n @Value\n public class EntityId {\n     private Long id;\n     private Long entityShard;\n     private Long entityRealm;\n     private Long entityNum;\n     private Integer entityTypeId;\n+\n+    public Entities toEntity() {\n+        Entities entity = new Entities();\n+        entity.setId(id);\n+        entity.setEntityShard(entityShard);\n+        entity.setEntityRealm(entityRealm);\n+        entity.setEntityNum(entityNum);\n+        entity.setEntityTypeId(entityTypeId);\n+        return entity;\n+    }\n+\n+    public static EntityId of(AccountID accountID) {\n+        return of(accountID.getShardNum(), accountID.getRealmNum(), accountID.getAccountNum(), EntityTypeEnum.ACCOUNT);\n+    }\n+\n+    public static EntityId of(ContractID contractID) {\n+        return of(contractID.getShardNum(), contractID.getRealmNum(), contractID.getContractNum(),\n+                EntityTypeEnum.CONTRACT);\n+    }\n+\n+    public static EntityId of(FileID fileID) {\n+        return of(fileID.getShardNum(), fileID.getRealmNum(), fileID.getFileNum(), EntityTypeEnum.FILE);\n+    }\n+\n+    public static EntityId of(TopicID topicID) {\n+        return of(topicID.getShardNum(), topicID.getRealmNum(), topicID.getTopicNum(), EntityTypeEnum.TOPIC);\n+    }\n+\n+    private static EntityId of(long entityShard, long entityRealm, long entityNum, EntityTypeEnum type) {\n+        if (entityNum == 0 && entityRealm == 0 && entityShard == 0) {\n+            return null;\n+        }\n+        return new EntityId(null, entityShard, entityRealm, entityNum, type.ordinal());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NjMxODg5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzo1ODoxN1rOF_3Elw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMTowMzoyMVrOGAQyjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNjkwMw==", "bodyText": "I don't think this will work since EntityId will have a null id. JPA won't know to lookup by shard/realm/num. Also, this won't go through cache so will be slow.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402506903", "createdAt": "2020-04-02T17:58:17Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -455,28 +411,23 @@ private void addNonFeeTransferInserts(long consensusTimestamp, long realm, long\n     /**\n      * Store ConsensusCreateTopic transaction in the database.\n      *\n-     * @param body\n-     * @param transactionRecord\n-     * @return Entity ID of the newly created topic, or 0 if no topic was created\n-     * @throws SQLException\n      * @throws IllegalArgumentException\n      */\n-    private Entities storeConsensusCreateTopic(TransactionBody body,\n-                                               TransactionRecord transactionRecord) {\n+    private void consensusCreateTopicUpdateEntity(\n+            Entities entity, TransactionBody body, TransactionRecord transactionRecord) {\n         if (!body.hasConsensusCreateTopic()) {\n             throw new IllegalArgumentException(\"transaction is not a ConsensusCreateTopic\");\n         }\n \n         if (!transactionRecord.getReceipt().hasTopicID()) {\n-            return null;\n+            return;\n         }\n \n-        Entities entity = getEntity(transactionRecord.getReceipt().getTopicID());\n         var transactionBody = body.getConsensusCreateTopic();\n \n         if (transactionBody.hasAutoRenewAccount()) {\n-            Entities autoRenewAccount = getEntity(transactionBody.getAutoRenewAccount());\n-            entity.setAutoRenewAccount(autoRenewAccount);\n+            // Entity's id will be looked up/created lazily when its needed for persisting.\n+            entity.setAutoRenewAccount(EntityId.of(transactionBody.getAutoRenewAccount()).toEntity());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkyODI2OA==", "bodyText": "Changed. Should use big cache now.\nPunting batching of lookups/writes to end of transaction to later date.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402928268", "createdAt": "2020-04-03T11:03:21Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -455,28 +411,23 @@ private void addNonFeeTransferInserts(long consensusTimestamp, long realm, long\n     /**\n      * Store ConsensusCreateTopic transaction in the database.\n      *\n-     * @param body\n-     * @param transactionRecord\n-     * @return Entity ID of the newly created topic, or 0 if no topic was created\n-     * @throws SQLException\n      * @throws IllegalArgumentException\n      */\n-    private Entities storeConsensusCreateTopic(TransactionBody body,\n-                                               TransactionRecord transactionRecord) {\n+    private void consensusCreateTopicUpdateEntity(\n+            Entities entity, TransactionBody body, TransactionRecord transactionRecord) {\n         if (!body.hasConsensusCreateTopic()) {\n             throw new IllegalArgumentException(\"transaction is not a ConsensusCreateTopic\");\n         }\n \n         if (!transactionRecord.getReceipt().hasTopicID()) {\n-            return null;\n+            return;\n         }\n \n-        Entities entity = getEntity(transactionRecord.getReceipt().getTopicID());\n         var transactionBody = body.getConsensusCreateTopic();\n \n         if (transactionBody.hasAutoRenewAccount()) {\n-            Entities autoRenewAccount = getEntity(transactionBody.getAutoRenewAccount());\n-            entity.setAutoRenewAccount(autoRenewAccount);\n+            // Entity's id will be looked up/created lazily when its needed for persisting.\n+            entity.setAutoRenewAccount(EntityId.of(transactionBody.getAutoRenewAccount()).toEntity());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNjkwMw=="}, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NjMyMzUxOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzo1OToyOVrOF_3Hig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzo1OToyOVrOF_3Hig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNzY1OA==", "bodyText": "EntityId.id can be null as well since it's a primitive wrapper Long.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402507658", "createdAt": "2020-04-02T17:59:29Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -749,76 +659,28 @@ private void insertContractResults(\n                 new ContractResult(consensusTimestamp, functionParams, gasSupplied, callResult, gasUsed));\n     }\n \n-    public Entities getEntity(AccountID accountID) {\n-        return getEntity(accountID.getShardNum(), accountID.getRealmNum(), accountID.getAccountNum(), \"account\");\n-    }\n-\n-    public Entities getEntity(ContractID cid) {\n-        return getEntity(cid.getShardNum(), cid.getRealmNum(), cid.getContractNum(), \"contract\");\n-    }\n-\n-    public Entities getEntity(FileID fileId) {\n-        return getEntity(fileId.getShardNum(), fileId.getRealmNum(), fileId.getFileNum(), \"file\");\n-    }\n-\n-    public Entities getEntity(TopicID topicId) {\n-        return getEntity(topicId.getShardNum(), topicId.getRealmNum(), topicId.getTopicNum(), \"topic\");\n-    }\n-\n-    private Entities getEntity(long shardNum, long realmNum, long entityNum, String type) {\n-        return entityRepository.findByPrimaryKey(shardNum, realmNum, entityNum).orElseGet(() -> {\n-            Entities entity = new Entities();\n-            entity.setEntityNum(entityNum);\n-            entity.setEntityRealm(realmNum);\n-            entity.setEntityShard(shardNum);\n-            entity.setEntityTypeId(entityTypeRepository.findByName(type).map(EntityType::getId).get());\n-            return entity;\n-        });\n-    }\n-\n-    public EntityId getEntityId(AccountID accountID) {\n-        return getEntityId(accountID.getShardNum(), accountID.getRealmNum(), accountID.getAccountNum(), \"account\");\n-    }\n-\n-    public EntityId getEntityId(ContractID cid) {\n-        return getEntityId(cid.getShardNum(), cid.getRealmNum(), cid.getContractNum(), \"contract\");\n-    }\n-\n-    public EntityId getEntityId(FileID fileId) {\n-        return getEntityId(fileId.getShardNum(), fileId.getRealmNum(), fileId.getFileNum(), \"file\");\n-    }\n-\n-    public EntityId getEntityId(TopicID topicId) {\n-        return getEntityId(topicId.getShardNum(), topicId.getRealmNum(), topicId.getTopicNum(), \"topic\");\n-    }\n-\n-    private EntityId getEntityId(long shardNum, long realmNum, long entityNum, String type) {\n-        if (0 == entityNum) {\n+    private Entities getEntity(EntityId entityId) {\n+        if (entityId == null) {\n             return null;\n         }\n-        return entityRepository.findEntityIdByNativeIds(shardNum, realmNum, entityNum).orElseGet(() -> {\n-            Entities entityId = new Entities();\n-            entityId.setEntityShard(shardNum);\n-            entityId.setEntityRealm(realmNum);\n-            entityId.setEntityNum(entityNum);\n-            entityId.setEntityTypeId(entityTypeRepository.findByName(type).map(EntityType::getId).get());\n-            return entityRepository.saveAndCacheEntityId(entityId);\n-        });\n+        return entityRepository.findByPrimaryKey(\n+                entityId.getEntityShard(), entityId.getEntityRealm(), entityId.getEntityNum())\n+                .orElseGet(entityId::toEntity);\n     }\n \n-    private Entities createEntity(Entities entity) {\n-        if (entity != null && entity.getId() == null) {\n-            log.debug(\"Creating entity: {}\", () -> entity.getDisplayId());\n-            var result = entityRepository.save(entity);\n-            var entityId = new EntityId(result.getId(), result.getEntityShard(), result.getEntityRealm(),\n-                    result.getEntityNum(), result.getEntityTypeId());\n-            entityRepository.cache(entityId);\n-            return result;\n-        }\n-        return entity;\n-    }\n-\n-    public enum INIT_RESULT {\n-        OK, FAIL, SKIP\n+    /**\n+     * @param entityId containing shard, realm, num, and type for which the id needs to be looked up (from cache/repo).\n+     *                 If no id is found, the the entity is inserted into the repo and the newly minted id is returned.\n+     * @return looked up/newly minted id of the given entityId.\n+     */\n+    public long lookupOrCreateId(EntityId entityId) {\n+        log.debug(\"lookupOrCreateId for {}\", entityId);\n+        if (entityId.getId() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 580}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NjM3OTgyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoTransferTransactionHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxODoxNToxMFrOF_3rQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMTowNjoxMlrOGAQ4TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNjgwMQ==", "bodyText": "This seems to be an oversight with the old code. Should we be extracting the payer account ID from the TransactionID?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402516801", "createdAt": "2020-04-02T18:15:10Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoTransferTransactionHandler.java", "diffHunk": "@@ -20,10 +20,18 @@\n  * \u200d\n  */\n \n-import lombok.AllArgsConstructor;\n import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n \n @Named\n @AllArgsConstructor\n public class CryptoTransferTransactionHandler implements TransactionHandler {\n+\n+    @Override\n+    public EntityId getEntityId(RecordItem recordItem) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkyOTc0MA==", "bodyText": "probably because payer account id is already populated in separate column for each transaction.\nDuplicating it seems unnecessary.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402929740", "createdAt": "2020-04-03T11:06:12Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoTransferTransactionHandler.java", "diffHunk": "@@ -20,10 +20,18 @@\n  * \u200d\n  */\n \n-import lombok.AllArgsConstructor;\n import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n \n @Named\n @AllArgsConstructor\n public class CryptoTransferTransactionHandler implements TransactionHandler {\n+\n+    @Override\n+    public EntityId getEntityId(RecordItem recordItem) {\n+        return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNjgwMQ=="}, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NjQzMDQ3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxODoyOToxNVrOF_4LGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMTowNDowNFrOGAQ0Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNDk1NQ==", "bodyText": "I think the id is actually always null based upon EntityId.of(), not 0. As a result, this won't work. It will always try to insert the entity thinking it's new but it may or may not exist. You need to lookup or create entity", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402524955", "createdAt": "2020-04-02T18:29:15Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -335,12 +288,7 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n         tx.setChargedTxFee(txRecord.getTransactionFee());\n         tx.setConsensusNs(consensusNs);\n         if (entityId != null) {\n-            var tempEntity = new Entities();\n-            tempEntity.setId(entityId.getId());\n-            tempEntity.setEntityShard(entityId.getEntityShard());\n-            tempEntity.setEntityRealm(entityId.getEntityRealm());\n-            tempEntity.setEntityNum(entityId.getEntityNum());\n-            tx.setEntity(tempEntity);\n+            tx.setEntity(entityId.toEntity()); // entityId.id is always 0 here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkyODcwNg==", "bodyText": "Fixed. Please verify if this looks okay.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402928706", "createdAt": "2020-04-03T11:04:04Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -335,12 +288,7 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n         tx.setChargedTxFee(txRecord.getTransactionFee());\n         tx.setConsensusNs(consensusNs);\n         if (entityId != null) {\n-            var tempEntity = new Entities();\n-            tempEntity.setId(entityId.getId());\n-            tempEntity.setEntityShard(entityId.getEntityShard());\n-            tempEntity.setEntityRealm(entityId.getEntityRealm());\n-            tempEntity.setEntityNum(entityId.getEntityNum());\n-            tx.setEntity(tempEntity);\n+            tx.setEntity(entityId.toEntity()); // entityId.id is always 0 here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNDk1NQ=="}, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 270}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMDMyNDI3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/CommonParserProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNjoyMzo0NVrOGAczLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxODozNDoxN1rOGAjLGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyNTAzNw==", "bodyText": "This is a breaking change to people using the configuration property. Would prefer to keep it as before unless there's a need to change now.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403125037", "createdAt": "2020-04-03T16:23:45Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/CommonParserProperties.java", "diffHunk": "@@ -78,21 +81,21 @@\n         private Collection<String> entity = new LinkedHashSet<>();\n \n         @NotNull\n-        private Collection<TransactionTypeEnum> transaction = new LinkedHashSet<>();\n+        private Collection<TransactionTypeEnum> transactionType = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyOTQ2NA==", "bodyText": "done", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403229464", "createdAt": "2020-04-03T18:34:17Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/CommonParserProperties.java", "diffHunk": "@@ -78,21 +81,21 @@\n         private Collection<String> entity = new LinkedHashSet<>();\n \n         @NotNull\n-        private Collection<TransactionTypeEnum> transaction = new LinkedHashSet<>();\n+        private Collection<TransactionTypeEnum> transactionType = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyNTAzNw=="}, "originalCommit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMDY0MTY4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzoyNjo1N1rOGAfoAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxODo0NjoxMlrOGAjxxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE3MTMyOQ==", "bodyText": "Calling toString() on a protobuf produces some ugly output, which is why we have helper methods in Utility. However, I think just printing transactionType, entityId and consensusTimestamp would be enough here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403171329", "createdAt": "2020-04-03T17:26:57Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -129,37 +126,53 @@ private static int getTransactionType(TransactionBody body) {\n     public void onItem(RecordItem recordItem) throws ImporterException {\n         TransactionRecord txRecord = recordItem.getRecord();\n         TransactionBody body = recordItem.getTransactionBody();\n-\n+        TransactionHandler transactionHandler = transactionHandlerFactory.create(body);\n         log.trace(\"Storing transaction body: {}\", () -> Utility.printProtoMessage(body));\n-        long initialBalance = 0;\n \n+        int transactionType = getTransactionType(body);\n+        EntityId entityId = transactionHandler.getEntityId(recordItem);\n+\n+        TransactionFilterFields transactionFilterFields =\n+                new TransactionFilterFields(entityId, TransactionTypeEnum.of(transactionType));\n+        if (!transactionFilter.test(transactionFilterFields)) {\n+            log.debug(\"Ignoring recordItem {}\", txRecord);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzOTM2Ng==", "bodyText": "done", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403239366", "createdAt": "2020-04-03T18:46:12Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -129,37 +126,53 @@ private static int getTransactionType(TransactionBody body) {\n     public void onItem(RecordItem recordItem) throws ImporterException {\n         TransactionRecord txRecord = recordItem.getRecord();\n         TransactionBody body = recordItem.getTransactionBody();\n-\n+        TransactionHandler transactionHandler = transactionHandlerFactory.create(body);\n         log.trace(\"Storing transaction body: {}\", () -> Utility.printProtoMessage(body));\n-        long initialBalance = 0;\n \n+        int transactionType = getTransactionType(body);\n+        EntityId entityId = transactionHandler.getEntityId(recordItem);\n+\n+        TransactionFilterFields transactionFilterFields =\n+                new TransactionFilterFields(entityId, TransactionTypeEnum.of(transactionType));\n+        if (!transactionFilter.test(transactionFilterFields)) {\n+            log.debug(\"Ignoring recordItem {}\", txRecord);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE3MTMyOQ=="}, "originalCommit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1274, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}