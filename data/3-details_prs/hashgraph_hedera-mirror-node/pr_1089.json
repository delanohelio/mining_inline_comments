{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1MTc4MDM3", "number": 1089, "title": "HTS: Add support for token transactions to Importer", "bodyText": "Detailed description:\nTo support the new Token HAPI, we should enhance our importer to import the new token transactions.\n\nAdd a TransactionHandler for each new transaction type\nAdd new repository and domain classes for Token, TokenAccount and TokenTransfer\nUpdate EntityListener and its concrete implementations for the new entities with OnToken(), OnTokenAccount() and OnTokenTransfer()\nUpdate EntityTypeEnum and EntityId with new TokenID\nUpdate EntityRecordItemListener to parse the new transaction types and create appropriate domain objects for persistence\nUpdate TransactionHandlerFactory to return appropriate Token transactionHandler on appropriate transactions type\nUpdate TransactionTypeEnum with Token transaction types\n\nWhich issue(s) this PR fixes:\nFixes #1051\nSpecial notes for your reviewer:\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-09-30T00:02:20Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089", "merged": true, "mergeCommit": {"oid": "53237aa496805c216c66586835cfd53c5d3a5835"}, "closed": true, "closedAt": "2020-10-06T20:50:28Z", "author": {"login": "Nana-EC"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOD4omgFqTQ5OTc5ODExMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdP-lXzAFqTUwMzM0MTQwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5Nzk4MTEy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#pullrequestreview-499798112", "createdAt": "2020-09-30T20:46:05Z", "commit": {"oid": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMDo0NjowNVrOHaurGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMTozODowMFrOHawP4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4OTcyMw==", "bodyText": "Removing this so as not to conflict w Ian's PR", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497789723", "createdAt": "2020-09-30T20:46:05Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenBalance.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import java.io.Serializable;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import org.springframework.data.domain.Persistable;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@AllArgsConstructor\n+@NoArgsConstructor\n+@Entity\n+\n+public class TokenBalance implements Persistable<TokenBalance.Id> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5MTQ4MA==", "bodyText": "Add a tokenUpdate tests in EntityRecordItemListenerTokenTest.java", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497791480", "createdAt": "2020-09-30T20:49:21Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -166,6 +190,32 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n                         txRecord.getReceipt().getFileID(), transactionType);\n             } else if (body.hasFileUpdate()) {\n                 insertFileUpdate(consensusNs, body.getFileUpdate(), transactionType);\n+            } else if (body.hasTokenAssociate()) {\n+                insertTokenAssociate(consensusNs, body);\n+            } else if (body.hasTokenBurn()) {\n+                insertTokenBurn(consensusNs, body);\n+            } else if (body.hasTokenCreation()) {\n+                insertTokenCreate(consensusNs, txRecord, body);\n+            } else if (body.hasTokenDeletion()) {\n+                insertTokenDelete(consensusNs, body);\n+            } else if (body.hasTokenDissociate()) {\n+                insertTokenDissociate(consensusNs, body);\n+            } else if (body.hasTokenFreeze()) {\n+                insertTokenAccountFreezeBody(consensusNs, body);\n+            } else if (body.hasTokenGrantKyc()) {\n+                insertTokenAccountGrantKyc(consensusNs, body);\n+            } else if (body.hasTokenMint()) {\n+                insertTokenMint(consensusNs, body);\n+            } else if (body.hasTokenRevokeKyc()) {\n+                insertTokenAccountRevokeKyc(consensusNs, body);\n+            } else if (body.hasTokenTransfers()) {\n+                insertTokenTransfers(consensusNs, txRecord);\n+            } else if (body.hasTokenUnfreeze()) {\n+                insertTokenAccountUnfreeze(consensusNs, body);\n+            } else if (body.hasTokenUpdate()) {\n+                insertTokenUpdate(consensusNs, body);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwNzI0NA==", "bodyText": "remove and use enum. Here and below", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497807244", "createdAt": "2020-09-30T21:20:13Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +430,262 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxMzA4OA==", "bodyText": "remove tokens and tokenAccounts lists for now as we save immediately", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497813088", "createdAt": "2020-09-30T21:32:29Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java", "diffHunk": "@@ -124,6 +139,9 @@ public SqlEntityListener(SqlProperties sqlProperties, DataSource dataSource,\n         liveHashes = new ArrayList<>();\n         entityIds = new HashSet<>();\n         topicMessages = new ArrayList<>();\n+        tokens = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNDU1NA==", "bodyText": "Add conditional check and add expiry set", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497814554", "createdAt": "2020-09-30T21:35:47Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNTMwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (txMessage.getExpiry() != 0) {\n          \n          \n            \n                    if (txMessage.getAutoRenewPeriod() != 0) {", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497815305", "createdAt": "2020-09-30T21:37:29Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenUpdateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenUpdateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUpdate().getToken());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenUpdateTransactionBody txMessage = recordItem.getTransactionBody().getTokenUpdate();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        if (txMessage.getExpiry() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNTUyMw==", "bodyText": "Delete to not conflict with Ian", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497815523", "createdAt": "2020-09-30T21:38:00Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/TokenBalanceRepository.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+import com.hedera.mirror.importer.domain.TokenBalance;\n+\n+public interface TokenBalanceRepository extends CrudRepository<TokenBalance, TokenBalance.Id> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTI0NTQ4", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#pullrequestreview-500524548", "createdAt": "2020-10-01T16:31:35Z", "commit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNjozMTozNlrOHbSYMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjozMDowNVrOHb0Bxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3NDcwNQ==", "bodyText": "Should exclude the hex form as well as it will be quite large. Might be simpler to put the @ToString.Exclude annotation on the fields with this many.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498374705", "createdAt": "2020-10-01T16:31:36Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5MzYxNA==", "bodyText": "Since both clients that use this catch and return null, let's just change the Utility implementation to do so. Then you can use utility directly and don't need wrapper convertByteKeyToHex", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498393614", "createdAt": "2020-10-01T17:05:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")\n+    private String wipeKeyEd25519Hex;\n+\n+    public void setInitialSupply(Long initialSupply) {\n+        this.initialSupply = initialSupply;\n+\n+        // default totalSupply to initial supply\n+        totalSupply = initialSupply;\n+    }\n+\n+    public void setFreezeKey(byte[] key) {\n+        freezeKey = key;\n+        freezeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setKycKey(byte[] key) {\n+        kycKey = key;\n+        kycKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setSupplyKey(byte[] key) {\n+        supplyKey = key;\n+        supplyKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setWipeKey(byte[] key) {\n+        wipeKey = key;\n+        wipeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+    // If the token does not have Freeze key, FreezeNotApplicable is returned, if not take value of freezeDefault\n+\n+    /**\n+     * Get initial freeze status for an account being associated with this token. If the token does not have a\n+     * freezeKey, FreezeNotApplicable is returned, if it does account frozen status is set based on freezeDefault.\n+     * FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+     *\n+     * @return Freeze status code\n+     */\n+    public int getNewAccountFreezeStatus() {\n+        if (freezeKey == null) {\n+            return TokenFreezeStatus.FreezeNotApplicable_VALUE;\n+        }\n+\n+        return freezeDefault ? TokenFreezeStatus.Frozen_VALUE : TokenFreezeStatus.Unfrozen_VALUE;\n+    }\n+\n+    /**\n+     * Get initial kyc status for an account being associated with this token. If the token does not have a kycKey,\n+     * KycNotApplicable is returned, if it does account should be set to Revoked as kyc must be performed.\n+     * KycNotApplicable = 0, Granted = 1, Revoked = 2\n+     *\n+     * @return Kyc status code\n+     */\n+    public int getNewAccountKycStatus() {\n+        if (kycKey == null) {\n+            return TokenKycStatus.KycNotApplicable_VALUE;\n+        }\n+\n+        return TokenKycStatus.Revoked_VALUE;\n+    }\n+\n+    private String convertByteKeyToHex(byte[] key) {\n+        try {\n+            return Utility.protobufKeyToHexIfEd25519OrNull(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDI4OQ==", "bodyText": "We don't need an embedded id if it's not a composite key. Just use EntityId directly.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498394289", "createdAt": "2020-10-01T17:07:06Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")\n+    private String wipeKeyEd25519Hex;\n+\n+    public void setInitialSupply(Long initialSupply) {\n+        this.initialSupply = initialSupply;\n+\n+        // default totalSupply to initial supply\n+        totalSupply = initialSupply;\n+    }\n+\n+    public void setFreezeKey(byte[] key) {\n+        freezeKey = key;\n+        freezeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setKycKey(byte[] key) {\n+        kycKey = key;\n+        kycKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setSupplyKey(byte[] key) {\n+        supplyKey = key;\n+        supplyKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setWipeKey(byte[] key) {\n+        wipeKey = key;\n+        wipeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+    // If the token does not have Freeze key, FreezeNotApplicable is returned, if not take value of freezeDefault\n+\n+    /**\n+     * Get initial freeze status for an account being associated with this token. If the token does not have a\n+     * freezeKey, FreezeNotApplicable is returned, if it does account frozen status is set based on freezeDefault.\n+     * FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+     *\n+     * @return Freeze status code\n+     */\n+    public int getNewAccountFreezeStatus() {\n+        if (freezeKey == null) {\n+            return TokenFreezeStatus.FreezeNotApplicable_VALUE;\n+        }\n+\n+        return freezeDefault ? TokenFreezeStatus.Frozen_VALUE : TokenFreezeStatus.Unfrozen_VALUE;\n+    }\n+\n+    /**\n+     * Get initial kyc status for an account being associated with this token. If the token does not have a kycKey,\n+     * KycNotApplicable is returned, if it does account should be set to Revoked as kyc must be performed.\n+     * KycNotApplicable = 0, Granted = 1, Revoked = 2\n+     *\n+     * @return Kyc status code\n+     */\n+    public int getNewAccountKycStatus() {\n+        if (kycKey == null) {\n+            return TokenKycStatus.KycNotApplicable_VALUE;\n+        }\n+\n+        return TokenKycStatus.Revoked_VALUE;\n+    }\n+\n+    private String convertByteKeyToHex(byte[] key) {\n+        try {\n+            return Utility.protobufKeyToHexIfEd25519OrNull(key);\n+        } catch (Exception e) {\n+            log.error(\"Invalid ED25519 key could not be translated to hex text for entity {}. Field \" +\n+                    \"will be nulled\", tokenId, e);\n+            return null;\n+        }\n+    }\n+\n+    @Data\n+    @Embeddable\n+    @AllArgsConstructor\n+    @NoArgsConstructor\n+    public static class Id implements Serializable {\n+\n+        private static final long serialVersionUID = -4595724698253758379L;\n+\n+        @Convert(converter = TokenIdConverter.class)\n+        @JsonSerialize(using = EntityIdSerializer.class)\n+        private EntityId tokenId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTE1Mw==", "bodyText": "We shouldn't import protobuf classes into domain classes. We should create our own enum for kyc status and  freeze status and make the domain classes use those.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498395153", "createdAt": "2020-10-01T17:08:42Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")\n+    private String wipeKeyEd25519Hex;\n+\n+    public void setInitialSupply(Long initialSupply) {\n+        this.initialSupply = initialSupply;\n+\n+        // default totalSupply to initial supply\n+        totalSupply = initialSupply;\n+    }\n+\n+    public void setFreezeKey(byte[] key) {\n+        freezeKey = key;\n+        freezeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setKycKey(byte[] key) {\n+        kycKey = key;\n+        kycKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setSupplyKey(byte[] key) {\n+        supplyKey = key;\n+        supplyKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setWipeKey(byte[] key) {\n+        wipeKey = key;\n+        wipeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+    // If the token does not have Freeze key, FreezeNotApplicable is returned, if not take value of freezeDefault\n+\n+    /**\n+     * Get initial freeze status for an account being associated with this token. If the token does not have a\n+     * freezeKey, FreezeNotApplicable is returned, if it does account frozen status is set based on freezeDefault.\n+     * FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+     *\n+     * @return Freeze status code\n+     */\n+    public int getNewAccountFreezeStatus() {\n+        if (freezeKey == null) {\n+            return TokenFreezeStatus.FreezeNotApplicable_VALUE;\n+        }\n+\n+        return freezeDefault ? TokenFreezeStatus.Frozen_VALUE : TokenFreezeStatus.Unfrozen_VALUE;\n+    }\n+\n+    /**\n+     * Get initial kyc status for an account being associated with this token. If the token does not have a kycKey,\n+     * KycNotApplicable is returned, if it does account should be set to Revoked as kyc must be performed.\n+     * KycNotApplicable = 0, Granted = 1, Revoked = 2\n+     *\n+     * @return Kyc status code\n+     */\n+    public int getNewAccountKycStatus() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTIyMg==", "bodyText": "We should use primitives for non-null numbers like initialSupply and totalSupply.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498421222", "createdAt": "2020-10-01T17:56:17Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTM1Mw==", "bodyText": "Would prefer fields sorted by name.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498421353", "createdAt": "2020-10-01T17:56:30Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTgxNA==", "bodyText": "This is a bigint in the schema. Should the schema be changed or this changed to long?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498421814", "createdAt": "2020-10-01T17:57:22Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMjU2MQ==", "bodyText": "Should we rename as wipe_key_ed_25519_hex so we don't have to manually map?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498422561", "createdAt": "2020-10-01T17:58:46Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTYxOQ==", "bodyText": "Should use enums for status", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498531619", "createdAt": "2020-10-01T21:52:34Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@Entity\n+@Log4j2\n+public class TokenAccount {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId accountId;\n+\n+    private boolean associated;\n+\n+    private long createdTimestamp;\n+\n+    private int freezeStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzODU3Ng==", "bodyText": "We should avoid doing conditional logic based upon nulls. Would prefer taking advantage of the optional returned by the repo and chaining to ifPresent().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498538576", "createdAt": "2020-10-01T22:14:02Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMzUxOA==", "bodyText": "This should probably return the account id being associated to allow clients to filter transactions by that entity id and relate it to the transaction.entity_id.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498913518", "createdAt": "2020-10-02T16:05:31Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenAssociateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenAssociateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDM1Mw==", "bodyText": "This should probably return the account id being associated to allow clients to filter transactions by that entity id and relate it to the transaction.entity_id.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498914353", "createdAt": "2020-10-02T16:07:14Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenDissociateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenDissociateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNTA0NQ==", "bodyText": "nit: Would prefer a variable name that represents the thing it's holding. e.g. tokenCreateTransactionBody, transactionBody, body.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498915045", "createdAt": "2020-10-02T16:08:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNjcyOA==", "bodyText": "Not an issue with your code, but autoRenewPeriod is modeled as a Duration in ConsensusCreateTopic and a uint64 here. Can we ask Michael if this can be switched to Duration?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498916728", "createdAt": "2020-10-02T16:11:52Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        if (txMessage.getAutoRenewPeriod() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNzcyNw==", "bodyText": "Should we ask services to model this as a Timestamp?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498917727", "createdAt": "2020-10-02T16:13:49Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        if (txMessage.getAutoRenewPeriod() != 0) {\n+            entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod());\n+        }\n+\n+        if (txMessage.getExpiry() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxODUzNg==", "bodyText": "Should this be the token or the account? We're not freezing the token we're freezing the account's use of this token. Or more generically, this action is modifying the account not the token.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498918536", "createdAt": "2020-10-02T16:15:23Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenFreezeTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenFreezeTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenFreeze().getToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxOTM5OQ==", "bodyText": "Should this be the token or the account for the same reasons as above?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498919399", "createdAt": "2020-10-02T16:17:00Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenGrantKycTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenGrantKycTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenGrantKyc().getToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMTQyMg==", "bodyText": "Should this be the token or the account for the same reasons as above?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498921422", "createdAt": "2020-10-02T16:20:57Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenRevokeKycTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenRevokeKycTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenRevokeKyc().getToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjI0Nw==", "bodyText": "Should this be the token or the account for the same reasons as above?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498922247", "createdAt": "2020-10-02T16:22:34Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUnfreezeTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenUnfreezeTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUnfreeze().getToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjc4MQ==", "bodyText": "Move to transactionHandler.getAutoRenewAccount()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498922781", "createdAt": "2020-10-02T16:23:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenUpdateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenUpdateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUpdate().getToken());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenUpdateTransactionBody txMessage = recordItem.getTransactionBody().getTokenUpdate();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjg2NQ==", "bodyText": "Move to transactionHandler.getAutoRenewAccount()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498922865", "createdAt": "2020-10-02T16:23:51Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzM1MQ==", "bodyText": "Should this be the token or the account for the same reasons as above?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498923351", "createdAt": "2020-10-02T16:24:53Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenWipeTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenWipeTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenWipe().getToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjAyMw==", "bodyText": "We don't make use of this id, right? To save space and time it might be better to switch to a composite primary key.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498926023", "createdAt": "2020-10-02T16:30:05Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@Entity\n+@Log4j2\n+public class TokenAccount {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjk2MzM5", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#pullrequestreview-501296339", "createdAt": "2020-10-02T16:53:57Z", "commit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNjo1Mzo1N1rOHb0vdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMjowNDozMlrOHb8wIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNzcxNg==", "bodyText": "This is brittle. What's wrong with using assertThat(expected).isEqualTo(actual) and using ignoringGivenFields if needed?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498937716", "createdAt": "2020-10-02T16:53:57Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/TokenRepositoryTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package com.hedera.mirror.importer.repository;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.google.protobuf.ByteString;\n+import com.hederahashgraph.api.proto.java.Key;\n+import javax.annotation.Resource;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.binary.Hex;\n+import org.junit.jupiter.api.Test;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Token;\n+\n+public class TokenRepositoryTest extends AbstractRepositoryTest {\n+    @Resource\n+    protected TokenRepository tokenRepository;\n+\n+    private final EntityId FOO_COIN_ID = EntityId.of(\"0.0.101\", EntityTypeEnum.TOKEN);\n+    String key = \"0011223344556677889900aabbccddeeff0011223344556677889900aabbccddeeff\";\n+    private final EntityId treasuryAccount = EntityId.of(\"0.0.102\", EntityTypeEnum.ACCOUNT);\n+\n+    @Test\n+    void save() throws DecoderException {\n+        Token token = tokenRepository.save(token(1));\n+        tokenMatch(token, tokenRepository.findById(token.getTokenId())\n+                .get());\n+    }\n+\n+    private Token token(long consensusTimestamp) throws DecoderException {\n+        var hexKey = Key.newBuilder().setEd25519(ByteString.copyFrom(Hex.decodeHex(key))).build().toByteArray();\n+        Token token = new Token();\n+        token.setCreatedTimestamp(1L);\n+        token.setDecimals(1000);\n+        token.setFreezeDefault(false);\n+        token.setFreezeKey(hexKey);\n+        token.setInitialSupply(1_000_000_000L);\n+        token.setKycKey(hexKey);\n+        token.setModifiedTimestamp(3L);\n+        token.setName(\"FOO COIN TOKEN\");\n+        token.setSupplyKey(hexKey);\n+        token.setSymbol(\"FOOTOK\");\n+        token.setTokenId(new Token.Id(FOO_COIN_ID));\n+        token.setTreasuryAccountId(treasuryAccount);\n+        token.setWipeKey(hexKey);\n+        return token;\n+    }\n+\n+    private void tokenMatch(Token expected, Token actual) {\n+        assertAll(\n+                () -> assertNotNull(actual),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NTg1Mw==", "bodyText": "These two repository calls will definitely slow things down. I haven't had time to verify if multiple calls to save will be internally batched. This might be fine for now but we'll need to revisit this next sprint.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498945853", "createdAt": "2020-10-02T17:10:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java", "diffHunk": "@@ -239,6 +255,21 @@ public void onLiveHash(LiveHash liveHash) throws ImporterException {\n         liveHashes.add(liveHash);\n     }\n \n+    @Override\n+    public void onToken(Token token) throws ImporterException {\n+        tokenRepository.save(token);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MDE0OA==", "bodyText": "Would be cleaner to pass only RecordItem to all methods as it already contains the necessary fields and will be more encapsulated for future refactoring. I was tempted to do that for existing methods at one point but didn't want the code churn at the time, but since this is new it might make more sense to start here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498960148", "createdAt": "2020-10-02T17:40:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -166,6 +192,32 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n                         txRecord.getReceipt().getFileID(), transactionType);\n             } else if (body.hasFileUpdate()) {\n                 insertFileUpdate(consensusNs, body.getFileUpdate(), transactionType);\n+            } else if (body.hasTokenAssociate()) {\n+                insertTokenAssociate(consensusNs, body);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ==", "bodyText": "All token Ids need to be passed to onEntityId(). All accounts do as well but that should be taken care of by generic handler.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499063065", "createdAt": "2020-10-02T21:43:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTE2Nw==", "bodyText": "I don't think we should waste performance updating a timestamp when no other fields on that tokenaccount changed. We should treat the timestamp as audit info that only gets updated when a field on it changes.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499065167", "createdAt": "2020-10-02T21:51:09Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTUyMg==", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499065522", "createdAt": "2020-10-02T21:52:22Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 349}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjAxMA==", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499066010", "createdAt": "2020-10-02T21:54:02Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjY1NQ==", "bodyText": "We should create it if it's not returned from the database. All methods that use this object should remove null check. This is how we handle the only other updateable object Entities. In theory it should never happen that we get a freeze/grant/revoke/unfreeze without an associate first, but if we have a stream reset like at OA it is possible.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499066655", "createdAt": "2020-10-02T21:56:23Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private TokenAccount retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+        return tokenAccountRepository\n+                .findByTokenIdAndAccountId(EntityId.of(tokenID), EntityId.of(accountID))\n+                .orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2Njc4Mg==", "bodyText": "We should create it if it's not returned from the database. All methods that use this object should remove null check. This is how we handle the only other updateable object Entities. In theory it should never happen that we get a update/delete/etc without a create first, but if we have a stream reset like at OA it is possible.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499066782", "createdAt": "2020-10-02T21:56:52Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private TokenAccount retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+        return tokenAccountRepository\n+                .findByTokenIdAndAccountId(EntityId.of(tokenID), EntityId.of(accountID))\n+                .orElse(null);\n+    }\n+\n+    private Token retrieveToken(TokenID tokenID) {\n+        return tokenRepository\n+                .findById(new Token.Id(EntityId.of(tokenID)))\n+                .orElse(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzIyNg==", "bodyText": "Token and treasury should be passed to onEntityId either here or in handler", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499067226", "createdAt": "2020-10-02T21:58:18Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzY2OQ==", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499067669", "createdAt": "2020-10-02T21:59:58Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzgzOA==", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499067838", "createdAt": "2020-10-02T22:00:30Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODM2MA==", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068360", "createdAt": "2020-10-02T22:02:23Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODQwNQ==", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068405", "createdAt": "2020-10-02T22:02:35Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODUxNA==", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068514", "createdAt": "2020-10-02T22:02:57Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODY5NA==", "bodyText": "Should we also have a delete flag on token?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068694", "createdAt": "2020-10-02T22:03:38Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODk2Mw==", "bodyText": "Treasury and token should be passed to onEntityId either here or in handler", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068963", "createdAt": "2020-10-02T22:04:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjY2MzU2", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#pullrequestreview-502266356", "createdAt": "2020-10-05T17:22:35Z", "commit": {"oid": "b1055f75c69e20a1a63c3fd59c595f2181f71acb"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoyMjozNVrOHcmqQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozODowNlrOHcnKtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NTU4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // if not onboarded create create TokenAccount based off of Token details\n          \n          \n            \n                                // if not onboarded create TokenAccount based on Token details", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499755586", "createdAt": "2020-10-05T17:22:35Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1055f75c69e20a1a63c3fd59c595f2181f71acb"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDEwNw==", "bodyText": "Remove a already handled in OnItem()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        entityListener.onEntityId(accountEntityId);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499760107", "createdAt": "2020-10-05T17:30:55Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1055f75c69e20a1a63c3fd59c595f2181f71acb"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDk3MA==", "bodyText": "Remove since covered by OnItem()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        entityListener.onEntityId(accountEntityId);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499760970", "createdAt": "2020-10-05T17:32:38Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1055f75c69e20a1a63c3fd59c595f2181f71acb"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTQ4Nw==", "bodyText": "Add OnEntityId for every Token\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n          \n          \n            \n                            entityListener.onEntityId(EntityId.of(token));\n          \n          \n            \n                            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499761487", "createdAt": "2020-10-05T17:33:32Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1055f75c69e20a1a63c3fd59c595f2181f71acb"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2Mjc4Mg==", "bodyText": "Swap to do for Token since Account is covered by OnItem()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        entityListener.onEntityId(accountEntityId);\n          \n          \n            \n            TokenID tokenID = tokenFreezeAccountTransactionBody.getToken();\n          \n          \n            \n            EntityId.of(tokenID)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499762782", "createdAt": "2020-10-05T17:35:58Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenFreeze();\n+            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1055f75c69e20a1a63c3fd59c595f2181f71acb"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2Mzg5NQ==", "bodyText": "Swap to do token", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499763895", "createdAt": "2020-10-05T17:38:06Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenFreeze();\n+            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n+                    .getToken(), accountID, false, true, false);\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenGrantKyc();\n+            AccountID accountID = tokenGrantKycTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1055f75c69e20a1a63c3fd59c595f2181f71acb"}, "originalPosition": 248}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNDg0NTQ1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#pullrequestreview-502484545", "createdAt": "2020-10-05T23:18:53Z", "commit": {"oid": "4a40fbc3922abf545401ad950fb7a2d610708b1f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMzoxODo1M1rOHcw3EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo1Mzo1MlrOHdOs7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMjcwNQ==", "bodyText": "nit: Generally enum values are named like static constants in upper snake case, so NOT_APPLICABLE.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499922705", "createdAt": "2020-10-05T23:18:53Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenKycStatusEnum.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@Getter\n+@RequiredArgsConstructor\n+public enum TokenKycStatusEnum {\n+\n+    NOTAPPLICABLE(0),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a40fbc3922abf545401ad950fb7a2d610708b1f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyNTEyOA==", "bodyText": "I'm not a fan of these toggle methods. If we get two freeze accounts transactions back to back (not sure if possible), then it would be unfrozen. Would prefer simpler setters to avoid this even if platform makes this impossible.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499925128", "createdAt": "2020-10-05T23:26:49Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import java.io.Serializable;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+public class TokenAccount {\n+    @EmbeddedId\n+    @JsonUnwrapped\n+    private TokenAccount.Id id;\n+\n+    private boolean associated;\n+\n+    private long createdTimestamp;\n+\n+    @Enumerated(EnumType.ORDINAL)\n+    private TokenFreezeStatusEnum freezeStatus;\n+\n+    @Enumerated(EnumType.ORDINAL)\n+    private TokenKycStatusEnum kycStatus;\n+\n+    private long modifiedTimestamp;\n+\n+    public TokenAccount(EntityId tokenId, EntityId accountId) {\n+        id = new TokenAccount.Id(tokenId, accountId);\n+    }\n+\n+    public void toggleAssociatedStatus() {\n+        associated = !associated;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a40fbc3922abf545401ad950fb7a2d610708b1f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODc0MQ==", "bodyText": "Not a fan of these generic methods that then have transaction specific checks within them. Also not ideal because it denormalizes the token account object into a bunch of parameters, which is less maintainable when those change. Code reuse should not be done at the expense of maintainability and encapsulation.\nTransaction specific logic should be contained within the insertToken... methods.  This encapsulates the logic and will allow us to lift and shift it to the transaction handlers later. You can achieve something similar without this by pushing most of this common logic into the retrieve method.\nWe can always change this in a follow up or when we move to transaction handlers, though.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500408741", "createdAt": "2020-10-06T15:49:53Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +435,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+\n+                long consensusTimeStamp = recordItem.getConsensusTimestamp();\n+                if (!insertTokenAccountUpdate(consensusTimeStamp, token, accountID,\n+                        TransactionTypeEnum.TOKENASSOCIATE)) {\n+                    // if not onboarded create TokenAccount based on Token details\n+                    EntityId tokenID = EntityId.of(token);\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        TokenAccount tokenAccount = new TokenAccount(tokenID, EntityId.of(accountID));\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                        tokenAccount.setAssociated(true);\n+                        tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                        entityListener.onTokenAccount(tokenAccount);\n+                    } else {\n+                        log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENASSOCIATE,\n+                                consensusTimeStamp);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenBurnTransactionBody\n+                    .getToken(), tokenBurnTransactionBody.getAmount(), TransactionTypeEnum.TOKENBURN);\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenDeleteTransactionBody\n+                    .getToken(), 0, TransactionTypeEnum.TOKENDELETION);\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem\n+                        .getConsensusTimestamp(), token, accountID, TransactionTypeEnum.TOKENDISSOCIATE);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenFreeze();\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n+                    .getToken(), tokenFreezeAccountTransactionBody.getAccount(), TransactionTypeEnum.TOKENFREEZE);\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenGrantKyc();\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n+                    .getToken(), tokenGrantKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENGRANTKYC);\n+        }\n+    }\n+\n+    private void insertTokenMint(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n+            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenMintTransactionBody\n+                    .getToken(), tokenMintTransactionBody.getAmount(), TransactionTypeEnum.TOKENMINT);\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenRevokeKyc();\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n+                    .getToken(), tokenRevokeKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENREVOKEKYC);\n+        }\n+    }\n+\n+    private void insertTokenTransfers(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                entityListener.onEntityId(tokenId);\n+\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+                    entityListener.onEntityId(accountId);\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n+            TokenID tokenID = tokenUpdateTransactionBody.getToken();\n+\n+            Optional<Token> optionalToken = retrieveToken(tokenID);\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n+                    entityListener.onEntityId(treasuryEntityId);\n+                    token.setTreasuryAccountId(treasuryEntityId);\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            } else {\n+                log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENDELETION, recordItem\n+                        .getConsensusTimestamp());\n+            }\n+        }\n+    }\n+\n+    private boolean insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n+                                             TransactionTypeEnum transactionTypeEnum) {\n+        entityListener.onEntityId(EntityId.of(tokenID));\n+\n+        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n+        boolean tokenAccountFound = optionalTokenAccount.isPresent();\n+        if (tokenAccountFound) {\n+\n+            TokenAccount tokenAccount = optionalTokenAccount.get();\n+            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+\n+            if (transactionTypeEnum == TransactionTypeEnum.TOKENASSOCIATE || transactionTypeEnum == TransactionTypeEnum.TOKENDISSOCIATE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a40fbc3922abf545401ad950fb7a2d610708b1f"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMTYyOQ==", "bodyText": "nit: Already have consensusTimeStamp variable extracted that you can use for both timestamps.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500411629", "createdAt": "2020-10-06T15:53:52Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +435,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+\n+                long consensusTimeStamp = recordItem.getConsensusTimestamp();\n+                if (!insertTokenAccountUpdate(consensusTimeStamp, token, accountID,\n+                        TransactionTypeEnum.TOKENASSOCIATE)) {\n+                    // if not onboarded create TokenAccount based on Token details\n+                    EntityId tokenID = EntityId.of(token);\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        TokenAccount tokenAccount = new TokenAccount(tokenID, EntityId.of(accountID));\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a40fbc3922abf545401ad950fb7a2d610708b1f"}, "originalPosition": 137}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "462dad70ae7386a570bca26efaff4a8246c9952c", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/462dad70ae7386a570bca26efaff4a8246c9952c", "committedDate": "2020-10-06T19:09:47Z", "message": "Add Importer Logic to Persist HTS transactions\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4055e58777092ee0d6f00f2c5d71c2c34e1acafc", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4055e58777092ee0d6f00f2c5d71c2c34e1acafc", "committedDate": "2020-10-06T19:09:47Z", "message": "Fixing and adding tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1d6863fcbc487d35cd94f10523608f55f872086", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d1d6863fcbc487d35cd94f10523608f55f872086", "committedDate": "2020-10-06T19:09:47Z", "message": "Added TransactionsHandlerTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9b9afd3b98119183404d1ba2935334479e4aa28", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c9b9afd3b98119183404d1ba2935334479e4aa28", "committedDate": "2020-10-06T19:09:47Z", "message": "Updated transaction handler tests and Added repository tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb322f88d90f8442fd8063bb9d4653416b2b02e0", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fb322f88d90f8442fd8063bb9d4653416b2b02e0", "committedDate": "2020-10-06T19:09:47Z", "message": "Fixed transaction handler tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68db9fe273bf04ab9d8d4214484493adcc913013", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/68db9fe273bf04ab9d8d4214484493adcc913013", "committedDate": "2020-10-06T19:09:48Z", "message": "Fixing merge conflicts with alpha5\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93c9d48c4dba6f2f62f186c9e881c0625575d8b3", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/93c9d48c4dba6f2f62f186c9e881c0625575d8b3", "committedDate": "2020-10-06T19:09:48Z", "message": "Added caching to token and token_account repo calls\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4923866fa05ab8dd6cd479f3ae2edee59d29b866", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4923866fa05ab8dd6cd479f3ae2edee59d29b866", "committedDate": "2020-10-06T19:09:48Z", "message": "Removed tokenBalance domain and repo and added tokenUpdate test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ec96df9ed8aa4d7a428399ef725c508839cedc4", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6ec96df9ed8aa4d7a428399ef725c508839cedc4", "committedDate": "2020-10-06T19:09:48Z", "message": "Added tests to increase coverage\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "327505df3664012ca17684df155a3cb47ac9615e", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/327505df3664012ca17684df155a3cb47ac9615e", "committedDate": "2020-10-06T19:09:48Z", "message": "Addressed initial round of feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d17c1e90444e83e77d5b84eb00fcb944cc740b2b", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d17c1e90444e83e77d5b84eb00fcb944cc740b2b", "committedDate": "2020-10-06T19:09:48Z", "message": "Addresed feedback 2 around EntityRecordItemListener\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cbfde0c55c1e1e0b126ada028ef5dca910a16c24", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cbfde0c55c1e1e0b126ada028ef5dca910a16c24", "committedDate": "2020-10-06T19:09:48Z", "message": "Updating to have all TokenId's and AccountId's be passed to OnEntityId\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7b5f6aa4a191b47345c0a8c69531aad7da0d0d2", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f7b5f6aa4a191b47345c0a8c69531aad7da0d0d2", "committedDate": "2020-10-06T19:09:48Z", "message": "Cleaned up and added logs message where missing token or token_account\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67738e1ff0c53481b5fba389d226f0ceb1f981d0", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/67738e1ff0c53481b5fba389d226f0ceb1f981d0", "committedDate": "2020-10-06T19:09:48Z", "message": "Pulled in TokenBalance changes and addressed feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8057ddeb11ff23051738f7b887e57c3041c9ba97", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8057ddeb11ff23051738f7b887e57c3041c9ba97", "committedDate": "2020-10-06T19:09:48Z", "message": "Add Importer Logic to Persist HTS transactions\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1b1530b732bcc2cb8413c04047d51f567f62e10", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d1b1530b732bcc2cb8413c04047d51f567f62e10", "committedDate": "2020-10-06T19:09:48Z", "message": "Fixing and adding tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdb341700207fbd55431276bf7e6d1835ce7959f", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/bdb341700207fbd55431276bf7e6d1835ce7959f", "committedDate": "2020-10-06T19:09:48Z", "message": "Added TransactionsHandlerTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13a3db327004fcb200aa1e768d1363950e61206e", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/13a3db327004fcb200aa1e768d1363950e61206e", "committedDate": "2020-10-06T19:09:48Z", "message": "Updated transaction handler tests and Added repository tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "837657ffa53fc6fa5291f886272b1d8cc2e874f0", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/837657ffa53fc6fa5291f886272b1d8cc2e874f0", "committedDate": "2020-10-06T19:09:48Z", "message": "Fixed transaction handler tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34bc0786a4a60bfc52c211543a792cd2319b1eb1", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/34bc0786a4a60bfc52c211543a792cd2319b1eb1", "committedDate": "2020-10-06T19:09:48Z", "message": "Fixing merge conflicts with alpha5\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f11b44341b886c0417e25c0c1a092c6a035f9f2a", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f11b44341b886c0417e25c0c1a092c6a035f9f2a", "committedDate": "2020-10-06T19:09:48Z", "message": "Added caching to token and token_account repo calls\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "878f7d75528c7156a3cf432b5c2ced0e4c97dd63", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/878f7d75528c7156a3cf432b5c2ced0e4c97dd63", "committedDate": "2020-10-06T19:09:49Z", "message": "Removed tokenBalance domain and repo and added tokenUpdate test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed01943c39423880777ea583f49be45f6b5fbdab", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ed01943c39423880777ea583f49be45f6b5fbdab", "committedDate": "2020-10-06T19:09:49Z", "message": "Added tests to increase coverage\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85b2ba5a4db4171c6084457864416dad07b97626", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/85b2ba5a4db4171c6084457864416dad07b97626", "committedDate": "2020-10-06T19:09:49Z", "message": "Addressed initial round of feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c26d0c6c6c5487468db55677cae1164acae833b7", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c26d0c6c6c5487468db55677cae1164acae833b7", "committedDate": "2020-10-06T19:09:49Z", "message": "Addresed feedback 2 around EntityRecordItemListener\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80d726b39e21a825c8c9a7b6ca608af8fd653013", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/80d726b39e21a825c8c9a7b6ca608af8fd653013", "committedDate": "2020-10-06T19:09:49Z", "message": "Cleaned up and added logs message where missing token or token_account\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0915f179f097448ba94a24076cdd0a4a09546d1c", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0915f179f097448ba94a24076cdd0a4a09546d1c", "committedDate": "2020-10-06T19:05:15Z", "message": "Merge resolution\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}, "afterCommit": {"oid": "80d726b39e21a825c8c9a7b6ca608af8fd653013", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/80d726b39e21a825c8c9a7b6ca608af8fd653013", "committedDate": "2020-10-06T19:09:49Z", "message": "Cleaned up and added logs message where missing token or token_account\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "814c1fb8589220de2b0afe01e883dc949edea521", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/814c1fb8589220de2b0afe01e883dc949edea521", "committedDate": "2020-10-06T20:04:14Z", "message": "Fixed mad merge\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c61ddd9e1432033b274041f62defb9e0b9c8c36", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6c61ddd9e1432033b274041f62defb9e0b9c8c36", "committedDate": "2020-10-06T20:27:54Z", "message": "Removed merge artifcats and toggle methods\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMzQxNDA2", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#pullrequestreview-503341406", "createdAt": "2020-10-06T20:41:02Z", "commit": {"oid": "6c61ddd9e1432033b274041f62defb9e0b9c8c36"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3568, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}