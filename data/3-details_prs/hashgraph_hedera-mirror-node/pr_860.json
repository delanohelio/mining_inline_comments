{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTQ5NDA3", "number": 860, "title": "Add a NotifyingTopicListener", "bodyText": "Detailed description:\n\nAdd a NotifyingTopicListener that uses PostgreSQL listen/notify and set as default\nChange hedera.mirror.grpc.listener.pollingFrequency to hedera.mirror.grpc.listener.frequency so it can be used by all listener types\nChange hedera.mirror.grpc.listener.frequency to 500ms for notify error retry\nChange hedera.mirror.grpc.listener.maxPageSize to 5000 to improve latency with polling types\n\nWhich issue(s) this PR fixes:\nFixes #859\nSpecial notes for your reviewer:\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-07-10T17:09:05Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860", "merged": true, "mergeCommit": {"oid": "b7b0692e031fa4e81ac7dc42a3216e9e48ea003e"}, "closed": true, "closedAt": "2020-07-10T18:56:28Z", "author": {"login": "steven-sheehy"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABczlv4CAH2gAyNDQ3NTQ5NDA3OjlkMzVmODQ1OTIxNWIwNjBmZTEwZDEwNDkyZmIzNWQ1NWE4ZjM1NjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczoAOUAFqTQ0NjYxNjUwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9d35f8459215b060fe10d10492fb35d55a8f3563", "committedDate": "2020-07-10T15:55:00Z", "message": "Add a NotifyingTopicListener\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NTY2Mzkw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#pullrequestreview-446566390", "createdAt": "2020-07-10T17:15:06Z", "commit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzoxNTowNlrOGv_Iyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzo1NTozNFrOGwAUNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3MDY5OA==", "bodyText": "I thought we were leaving the shared poller as the default until we'd gone through through testing?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452970698", "createdAt": "2020-07-10T17:15:06Z", "author": {"login": "Nana-EC"}, "path": "docs/configuration.md", "diffHunk": "@@ -109,9 +109,9 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.grpc.endTimeInterval`                        | 30s              | How often we should check if a subscription has gone past the end time                         |\n | `hedera.mirror.grpc.entityCacheSize`                        | 50000            | The maximum size of the cache to store entities used for existence check                       |\n | `hedera.mirror.grpc.listener.enabled`                       | true             | Whether to listen for incoming massages or not                                                 |\n-| `hedera.mirror.grpc.listener.maxPageSize`                   | 10000            | The maximum number of messages the listener can return in a single call to the database        |\n-| `hedera.mirror.grpc.listener.pollingFrequency`              | 1s               | How often to polling for new topic messages. Can accept duration units like `50ms`, `10s` etc. |\n-| `hedera.mirror.grpc.listener.type`                          | SHARED_POLL      | The type of listener to use for incoming messages. Accepts either POLL or SHARED_POLL          |\n+| `hedera.mirror.grpc.listener.maxPageSize`                   | 5000             | The maximum number of messages the listener can return in a single call to the database        |\n+| `hedera.mirror.grpc.listener.frequency`                     | 500ms            | How often to poll or retry errors (varies by type). Can accept duration units like `50ms`, `10s`, etc. |\n+| `hedera.mirror.grpc.listener.type`                          | NOTIFY           | The type of listener to use for incoming messages. Accepts either NOTIFY, POLL or SHARED_POLL  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3NTI4Mg==", "bodyText": "q: what do you think about adding a now timestamp here to help give us when the insert happened?\nWe could make a DTO with this additional insertTimestamp that metrics could use to calculate\n\nConsensus -> Ingestion\nConsensus -> Message publish/delivery", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452975282", "createdAt": "2020-07-10T17:24:44Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.26.1__pg_notify.sql", "diffHunk": "@@ -0,0 +1,34 @@\n+-- Define trigger function. Base64 encoding is required since JSON doesn't support binary\n+create or replace function topic_message_notifier()\n+    returns trigger\n+    language plpgsql\n+as\n+$$\n+declare\n+    topicmessage text := TG_ARGV[0];\n+begin\n+    perform (\n+        with payload(consensus_timestamp, message, realm_num, running_hash, running_hash_version, sequence_number, topic_num) as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3NzEwNQ==", "bodyText": "If this logic is shared by all the Listeners should we move it to the CompositeTopicListener()?\nThen the CompositeTopicListener.listen() could call the filter method.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452977105", "createdAt": "2020-07-10T17:28:28Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk4MDk4Ng==", "bodyText": "Similar to Shared poller maybe we should have a log for total messages and rate\n\"Finished listen with {} messages in {} ({}/s)\"", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452980986", "createdAt": "2020-07-10T17:36:40Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n+        return message.getRealmNum() == filter.getRealmNum() &&\n+                message.getTopicNum() == filter.getTopicNum() &&\n+                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    }\n+\n+    private Flux<String> listen() {\n+        EmitterProcessor<String> emitterProcessor = EmitterProcessor.create();\n+        channel.handler(json -> emitterProcessor.onNext(json));\n+        log.info(\"Listening for messages\");\n+        return emitterProcessor;\n+    }\n+\n+    private void unlisten() {\n+        channel.handler(null);\n+        log.info(\"Stopped listening for messages\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk5MDAwNA==", "bodyText": "If there's a way to pull the notify time from this handler as part of it's in-built API that would be useful for metrics.\nIf not then consider my other suggestion to explore adding the approximate insert time to the notify operation.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452990004", "createdAt": "2020-07-10T17:55:34Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n+        return message.getRealmNum() == filter.getRealmNum() &&\n+                message.getTopicNum() == filter.getTopicNum() &&\n+                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    }\n+\n+    private Flux<String> listen() {\n+        EmitterProcessor<String> emitterProcessor = EmitterProcessor.create();\n+        channel.handler(json -> emitterProcessor.onNext(json));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563"}, "originalPosition": 101}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "482eee54c0478d40c58e78dbd37c74d672d32ff2", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/482eee54c0478d40c58e78dbd37c74d672d32ff2", "committedDate": "2020-07-10T17:58:53Z", "message": "Fix chunk info not in notifications\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjE2NTA3", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#pullrequestreview-446616507", "createdAt": "2020-07-10T18:32:40Z", "commit": {"oid": "482eee54c0478d40c58e78dbd37c74d672d32ff2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3002, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}