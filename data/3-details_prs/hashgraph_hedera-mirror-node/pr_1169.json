{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4MDkxNjgw", "number": 1169, "title": "Rosetta: Unit tests - Construction API", "bodyText": "Unit Tests for Construction Service\nConstructor\n\nTestNewConstructionAPIService <- makes sure that the constructor for ConstructionAPIService works properly\n\nConstructionCombine\n2. TestConstructionCombine <- unit test for the working case of the ConstructionCombine() function with one valid signature\n3. TestConstructionCombineThrowsWithMultipleSignatures <- makes sure that ConstructionCombine() throws an error when signed with more than one signature\n4. TestConstructionCombineThrowsWhenDecodeStringFails <- makes sure that ConstructionCombine() throws an error when it fails to decode the transaction hash\n5. TestConstructionCombineThrowsWhenUnmarshallFails <- makes sure that ConstructionCombine() throws an error when it fails to unmarshall the passed transaction\n6. TestConstructionCombineThrowsWithInvalidPublicKey <- makes sure that ConstructionCombine() throws when an invalid public key is passed\n7. TestConstructionCombineThrowsWhenSignatureIsNotVerified <- makes sure that ConstructionCombine() throws when the passed signature is not verified\nConstructionDerive\n8. TestConstructionDerive <- makes sure that ConstructionDerive() throws a NotImplemented error\nConstructionHash\n9. TestConstructionHash <- straight case for ConstructionHash() and Nil error assertion\n10. TestConstructionHashThrowsWhenDecodeStringFails <- makes sure that ConstructionHash() throws when it fails to decode the transaction hash\nConstructionMetadata\n11. TestConstructionMetadata <- straight case for ConstructionMetadata() and Nil error assertion\nConstructionParse\n12. TestConstructionParse <- straight case for ConstructionParse() and Nil error assertion\n13. TestConstructionParseSigned <- makes sure that ConstructionParse() works with both signed and unsigned transactions\n14. TestConstructionParseThrowsWhenDecodeStringFails <- makes sure that ConstructionParse() throws when it fails to decode the transaction hash\n15. TestConstructionParseThrowsWhenUnmarshallFails <- makes sure that ConstructionParse() throws an error when it fails to unmarshall the passed transaction\nConstructionPayloads\n16. TestConstructionPayloads <- straight case for ConstructionPayloads() and Nil error assertion\n17. TestConstructionPayloadsThrowsWhenInvalidOperationsSum <- makes sure that ConstructionPayloads() throws an error when the passed operations do not meet the requirements from the ValidateOperationsSum() method\n18. TestConstructionPayloadsThrowsWhenInvalidAccount <- makes sure that ConstructionPayloads() throws an error when the passed account is invalid\nConstructionSubmit\n19. TestConstructionSubmitThrowsWhenDecodeStringFails <- makes sure that ConstructionSubmit() throws an error when it fails to decode the transaction hash\n20. TestConstructionSubmitThrowsWhenUnmarshalBinaryFails <- makes sure that ConstructionSubmit() throws an error when it fails to unmarshall the passed transaction\nConstructionPreprocess\n21. TestConstructionPreprocess <- straight case for ConstructionPreprocess() and Nil error assertion\n22. TestConstructionPreprocessThrowsWithInvalidOperationsSum <- makes sure that ConstructionPreprocess() throws an error when the passed operations do not meet the requirements from the ValidateOperationsSum() method", "createdAt": "2020-10-22T07:50:57Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169", "merged": true, "mergeCommit": {"oid": "2f84830398f76ade8ad9fdc64647c1999c0eb57b"}, "closed": true, "closedAt": "2020-10-27T20:08:26Z", "author": {"login": "georgiyazovaliiski"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTGmlJAH2gAyNTA4MDkxNjgwOmMyYmZmZjRiMjMzZTM5NWNiYzIwZjdhYzA0YTZkZGU3ZGY1ZGE0N2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdWsh0iAFqTUxNzk3NTY1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c2bfff4b233e395cbc20f7ac04a6dde7df5da47a", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c2bfff4b233e395cbc20f7ac04a6dde7df5da47a", "committedDate": "2020-10-16T13:43:22Z", "message": "Tests: Account, Block, Mempool, Network API Services (#149)\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>\r\nSigned-off-by: Daniel Ivanov <daniel.k.ivanov95@gmail.com>\r\nSigned-off-by: Daniel <Daniel.K.Ivanov95@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "def3c7e8f0f892d74c0b50a2c818289b45505e3b", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/def3c7e8f0f892d74c0b50a2c818289b45505e3b", "committedDate": "2020-10-20T08:12:20Z", "message": "Assertion of equal, unordered Error elements function\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cde549244da3a6c93c13c8a7b858707e5b478844", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cde549244da3a6c93c13c8a7b858707e5b478844", "committedDate": "2020-10-20T08:13:01Z", "message": "remove unnecessary assertion\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32fde97e1799c56cf9fc37dabadfc563b658f743", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/32fde97e1799c56cf9fc37dabadfc563b658f743", "committedDate": "2020-10-20T09:19:05Z", "message": "Refactor Equals method\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0de14c302e0a1596121e26970e708152a1e2cf21", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0de14c302e0a1596121e26970e708152a1e2cf21", "committedDate": "2020-10-20T09:24:48Z", "message": "efficiency refactor\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ea66a387458bd3915345544f2300309197f64fc", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0ea66a387458bd3915345544f2300309197f64fc", "committedDate": "2020-10-20T10:17:27Z", "message": "remove unnecessary test\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13c49fee2a151bfb650ae0fa77084f283a66a6c2", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/13c49fee2a151bfb650ae0fa77084f283a66a6c2", "committedDate": "2020-10-20T13:32:55Z", "message": "Error comparison method rename\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79d5b6580e7757a708653cfe67da18c9146a57ef", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/79d5b6580e7757a708653cfe67da18c9146a57ef", "committedDate": "2020-10-20T13:56:01Z", "message": "Merge pull request #155 from LimeChain/tests/data-api-unit-tests-rework\n\nPR Comments resolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47747872f276eb2619f4f8bfa03847117581bdfd", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/47747872f276eb2619f4f8bfa03847117581bdfd", "committedDate": "2020-10-22T06:22:09Z", "message": "Construction API Unit Tests (#154)\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>\r\nSigned-off-by: Daniel <Daniel.K.Ivanov95@gmail.com>\r\nSigned-off-by: Daniel Ivanov <daniel.k.ivanov95@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44a4258babe05a98b0089e7be0a60e60e31cb04e", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/44a4258babe05a98b0089e7be0a60e60e31cb04e", "committedDate": "2020-10-22T07:29:32Z", "message": "Merge remote-tracking branch 'limechain/tests/construction-api-unit-tests' into tests/construction-api-unit-tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48f7b588621676a2eedf335bfc5c89c2cf3ba16b", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/48f7b588621676a2eedf335bfc5c89c2cf3ba16b", "committedDate": "2020-10-22T07:32:19Z", "message": "Merge remote-tracking branch 'hashgraph/rosetta' into tests/construction-api-unit-tests\n\n# Conflicts:\n#\thedera-mirror-rosetta/app/services/network/network_service_test.go"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/86dc63ba21f1d0722be1b0b26b53222445f34dc2", "committedDate": "2020-10-22T07:34:06Z", "message": "Network Service Unit Tests optimisation\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MjI5MDgw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#pullrequestreview-515229080", "createdAt": "2020-10-23T01:58:54Z", "commit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMTo1ODo1NFrOHm5q3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMjo1NDoyM1rOHm6dLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1Mjc5Ng==", "bodyText": "unmarshableTxHash is confusing since:\n\nit should be un-unmarshable\nit's not hash, it's the hex encoded marshaled transaction bytes\n\nsomething like corruptedTxHexStr provides better clarity\nalso have to rename exampleInvalidTxHashConstructionCombineRequest as it looks like copied from the previous test case.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510552796", "createdAt": "2020-10-23T01:58:54Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MzQyMQ==", "bodyText": "it shouldn't be named invalidTxHash since it's not a hash. rename exampleInvalidTxHashConstructionCombineRequest as well.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510553421", "createdAt": "2020-10-23T02:01:34Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTEzNw==", "bodyText": "the arg name txHash is misleading, should be signedTx or signedTransaction", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510555137", "createdAt": "2020-10-23T02:09:11Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTQxNw==", "bodyText": "as in the previous comment, validSignedTxHash is misleading, should be named sth like validSignedTransaction", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510555417", "createdAt": "2020-10-23T02:10:26Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTc0MQ==", "bodyText": "similar as above, invalidTxHash should be renamed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510555741", "createdAt": "2020-10-23T02:11:41Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NjU2Ng==", "bodyText": "validUnsignedTxHash should be named sth like validTxHexStr since it's the hex encoded string of the marshalled transaction bytes", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510556566", "createdAt": "2020-10-23T02:15:22Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NzAyNQ==", "bodyText": "validSignedTx", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510557025", "createdAt": "2020-10-23T02:17:31Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MTYyNA==", "bodyText": "it's not a hash", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510561624", "createdAt": "2020-10-23T02:37:16Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MzAzMg==", "bodyText": "hex.DecodeString returns err, so expectedDecodedBytes is an empty slice", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510563032", "createdAt": "2020-10-23T02:43:37Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(unmarshableTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\texpectedDecodedBytes, _ := hex.DecodeString(unmarshableTxHash)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 353}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2Mzk5Ng==", "bodyText": "should check Payloads not just Payloads[0]. AccountIdentifier.Address", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510563996", "createdAt": "2020-10-23T02:47:20Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(unmarshableTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\texpectedDecodedBytes, _ := hex.DecodeString(unmarshableTxHash)\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\texpectedPayloadsResponse := &types.ConstructionPayloadsResponse{\n+\t\tUnsignedTransaction: \"0x1a00223d0a140a0c08faf3b5fc0510c681d7d303120418e3cc13120218061880c2d72f2202087872180a160a090a0418b9c30710c8010a090a0418e3cc1310c701\",\n+\t\tPayloads: []*types.SigningPayload{\n+\t\t\t{\n+\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\tAddress: \"0.0.123352\",\n+\t\t\t\t},\n+\t\t\t\tBytes: expectedDecodedBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\t// here we do not assert the whole response object to equal the expected one, because invocation of this method appends a unique timestamp to the result, thus making the signed TX and Bytes unique and non-assertable.\n+\tassert.Equal(t, expectedPayloadsResponse.Payloads[0].AccountIdentifier.Address, res.Payloads[0].AccountIdentifier.Address)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2NTY3OA==", "bodyText": "constructionSubmitSignedTransaction", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r510565678", "createdAt": "2020-10-23T02:54:23Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTxHash = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTxHash   = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHash       = \"InvalidTxHash\"\n+\tunmarshableTxHash   = \"0x6767\"\n+\tpublicKeyBytes      = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(txHash string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: txHash,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = invalidTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleInvalidTxHashConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidTxHashConstructionCombineRequest.UnsignedTransaction = unmarshableTxHash\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidTxHashConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\ttxIdentifierHash := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTxHash)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: txIdentifierHash},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHash)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTxHash, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTxHash, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(unmarshableTxHash, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\texpectedDecodedBytes, _ := hex.DecodeString(unmarshableTxHash)\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\texpectedPayloadsResponse := &types.ConstructionPayloadsResponse{\n+\t\tUnsignedTransaction: \"0x1a00223d0a140a0c08faf3b5fc0510c681d7d303120418e3cc13120218061880c2d72f2202087872180a160a090a0418b9c30710c8010a090a0418e3cc1310c701\",\n+\t\tPayloads: []*types.SigningPayload{\n+\t\t\t{\n+\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\tAddress: \"0.0.123352\",\n+\t\t\t\t},\n+\t\t\t\tBytes: expectedDecodedBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\t// here we do not assert the whole response object to equal the expected one, because invocation of this method appends a unique timestamp to the result, thus making the signed TX and Bytes unique and non-assertable.\n+\tassert.Equal(t, expectedPayloadsResponse.Payloads[0].AccountIdentifier.Address, res.Payloads[0].AccountIdentifier.Address)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionPayloadsThrowsWhenInvalidOperationsSum(t *testing.T) {\n+\t// given:\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123321\", \"1000\"),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.IsType(t, &types.Error{}, e)\n+}\n+\n+func TestConstructionPayloadsThrowsWhenInvalidAccount(t *testing.T) {\n+\t// given:\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"23321\", \"1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"23321\", \"-1000\"),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidAccount], e)\n+}\n+\n+func TestConstructionSubmitThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionSubmitRequest := &types.ConstructionSubmitRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: invalidTxHash,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionSubmit(nil, exampleConstructionSubmitRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionSubmitThrowsWhenUnmarshalBinaryFails(t *testing.T) {\n+\tconstructionSubmitTxHash := \"0xfc2267c53ef8a27e2ab65f0a6b5e5607ba33b9c8c8f7304d8cb4a77aee19107d\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86dc63ba21f1d0722be1b0b26b53222445f34dc2"}, "originalPosition": 424}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb16f83ec27d75aa13c2bef03fa8a92e5969758d", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fb16f83ec27d75aa13c2bef03fa8a92e5969758d", "committedDate": "2020-10-26T09:47:24Z", "message": "PR comments resolution\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ec6babb5be3914b3f04699b85390beacd0635b8", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6ec6babb5be3914b3f04699b85390beacd0635b8", "committedDate": "2020-10-26T11:03:45Z", "message": "Merge pull request #160 from LimeChain/tests/construction-api-unit-tests-rework\n\nPR comments resolution"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDc3MDQ0", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#pullrequestreview-517077044", "createdAt": "2020-10-26T18:45:47Z", "commit": {"oid": "6ec6babb5be3914b3f04699b85390beacd0635b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo0NTo0OFrOHodn9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxODo0NTo0OFrOHodn9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE5MDQ1NQ==", "bodyText": "it's about the implementation of ConstructionPayloads not the test case:\nshould ConstructionPayloads fail early when supplied with an empty Operations slice?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#discussion_r512190455", "createdAt": "2020-10-26T18:45:48Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/construction/construction_service_test.go", "diffHunk": "@@ -0,0 +1,461 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package construction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tvalidUnsignedTx   = \"0x1a00223d0a140a0c0891d0fef905109688f3a701120418d8c307120218061880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tvalidSignedTx     = \"0x1a660a640a20d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade1a40967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tinvalidTxHexStr   = \"InvalidTxHexString\"\n+\tcorruptedTxHexStr = \"0x6767\"\n+\tpublicKeyBytes    = \"d25025bad248dbd4c6ca704eefba7ab4f3e3f48089fa5f20e4e1d10303f97ade\"\n+)\n+\n+func dummyConstructionCombineRequest() *types.ConstructionCombineRequest {\n+\tunsignedTxHash := \"0x1a00223c0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\tsigningPayloadBytes := \"967f26876ad492cc27b4c384dc962f443bcc9be33cbb7add3844bc864de047340e7a78c0fbaf40ab10948dc570bbc25edb505f112d0926dffb65c93199e6d507\"\n+\tsignatureBytes := \"0a130a0b08c7af94fa0510f7d9fc76120418d8c307120218041880c2d72f2202087872180a160a090a0418d8c30710cf0f0a090a0418fec40710d00f\"\n+\n+\treturn dummyConstructionCombineRequestWith(\n+\t\tunsignedTxHash,\n+\t\tsigningPayloadBytes,\n+\t\tpublicKeyBytes,\n+\t\tsignatureBytes,\n+\t)\n+}\n+\n+func dummyConstructionPreprocessRequest(valid bool) *types.ConstructionPreprocessRequest {\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\tif !valid {\n+\t\toperations = append(\n+\t\t\toperations,\n+\t\t\tdummyOperation(3, \"CRYPTOTRANSFER\", \"123532\", \"-5000\"),\n+\t\t)\n+\t}\n+\n+\treturn &types.ConstructionPreprocessRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tOperations:        operations,\n+\t}\n+}\n+\n+func dummyConstructionCombineRequestWith(unsignedTxHash, signingPayloadBytes, publicKeyBytes, signatureBytes string) *types.ConstructionCombineRequest {\n+\tdecodedSigningPayloadBytes, e1 := hex.DecodeString(signingPayloadBytes)\n+\tdecodedPublicKeyBytes, e2 := hex.DecodeString(publicKeyBytes)\n+\tdecodedSignatureBytes, e3 := hex.DecodeString(signatureBytes)\n+\n+\tif e1 != nil || e2 != nil || e3 != nil {\n+\t\treturn nil\n+\t}\n+\n+\treturn &types.ConstructionCombineRequest{\n+\t\tNetworkIdentifier:   networkIdentifier(),\n+\t\tUnsignedTransaction: unsignedTxHash,\n+\t\tSignatures: []*types.Signature{\n+\t\t\t{\n+\t\t\t\tSigningPayload: &types.SigningPayload{\n+\t\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\t\tAddress:  \"0.0.123352\",\n+\t\t\t\t\t\tMetadata: nil,\n+\t\t\t\t\t},\n+\t\t\t\t\tBytes:         decodedSigningPayloadBytes,\n+\t\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\t},\n+\t\t\t\tPublicKey: &types.PublicKey{\n+\t\t\t\t\tBytes:     decodedPublicKeyBytes,\n+\t\t\t\t\tCurveType: \"edwards25519\",\n+\t\t\t\t},\n+\t\t\t\tSignatureType: \"ed25519\",\n+\t\t\t\tBytes:         decodedSignatureBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func dummyOperation(index int64, transferType, account, amount string) *types.Operation {\n+\treturn &types.Operation{\n+\t\tOperationIdentifier: &types.OperationIdentifier{\n+\t\t\tIndex: index,\n+\t\t},\n+\t\tType: transferType,\n+\t\tAccount: &types.AccountIdentifier{\n+\t\t\tAddress: account,\n+\t\t},\n+\t\tAmount: &types.Amount{\n+\t\t\tValue: amount,\n+\t\t\tCurrency: &types.Currency{\n+\t\t\t\tSymbol:   \"HBAR\",\n+\t\t\t\tDecimals: 8,\n+\t\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\t\"issuer\": \"Hedera\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t}\n+}\n+\n+func networkIdentifier() *types.NetworkIdentifier {\n+\treturn &types.NetworkIdentifier{\n+\t\tBlockchain: \"SomeBlockchain\",\n+\t\tNetwork:    \"SomeNetwork\",\n+\t\tSubNetworkIdentifier: &types.SubNetworkIdentifier{\n+\t\t\tNetwork: \"SomeSubNetwork\",\n+\t\t},\n+\t}\n+}\n+\n+func dummyConstructionHashRequest(signedTx string) *types.ConstructionHashRequest {\n+\treturn &types.ConstructionHashRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSignedTransaction: signedTx,\n+\t}\n+}\n+\n+func dummyConstructionParseRequest(txHash string, signed bool) *types.ConstructionParseRequest {\n+\treturn &types.ConstructionParseRequest{\n+\t\tNetworkIdentifier: networkIdentifier(),\n+\t\tSigned:            signed,\n+\t\tTransaction:       txHash,\n+\t}\n+}\n+\n+func dummyPayloadsRequest(operations []*types.Operation) *types.ConstructionPayloadsRequest {\n+\treturn &types.ConstructionPayloadsRequest{\n+\t\tOperations: operations,\n+\t}\n+}\n+\n+func TestNewConstructionAPIService(t *testing.T) {\n+\tassert.IsType(t, &ConstructionAPIService{}, NewConstructionAPIService())\n+}\n+\n+func TestConstructionCombine(t *testing.T) {\n+\t// given:\n+\texpectedConstructionCombineResponse := &types.ConstructionCombineResponse{\n+\t\tSignedTransaction: validSignedTx,\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, dummyConstructionCombineRequest())\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionCombineResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionCombineThrowsWithMultipleSignatures(t *testing.T) {\n+\t// given:\n+\texampleConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleConstructionCombineRequest.Signatures = []*types.Signature{\n+\t\t{}, {},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.MultipleSignaturesPresent], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleCorruptedTxHexStrConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleCorruptedTxHexStrConstructionCombineRequest.UnsignedTransaction = invalidTxHexStr\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleCorruptedTxHexStrConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// given:\n+\texampleCorruptedTxHexStrConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleCorruptedTxHexStrConstructionCombineRequest.UnsignedTransaction = corruptedTxHexStr\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleCorruptedTxHexStrConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionCombineThrowsWithInvalidPublicKey(t *testing.T) {\n+\t// given:\n+\texampleInvalidPublicKeyConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidPublicKeyConstructionCombineRequest.Signatures[0].PublicKey = &types.PublicKey{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidPublicKeyConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidPublicKey], e)\n+}\n+\n+func TestConstructionCombineThrowsWhenSignatureIsNotVerified(t *testing.T) {\n+\t// given:\n+\texampleInvalidSigningPayloadConstructionCombineRequest := dummyConstructionCombineRequest()\n+\texampleInvalidSigningPayloadConstructionCombineRequest.Signatures[0].SigningPayload = &types.SigningPayload{}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionCombine(nil, exampleInvalidSigningPayloadConstructionCombineRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.InvalidSignatureVerification], e)\n+}\n+\n+func TestConstructionDerive(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionDerive(nil, nil)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.NotImplemented], e)\n+}\n+\n+func TestConstructionHash(t *testing.T) {\n+\t// given:\n+\tvalidSignedTransaction := \"0x9768d458c755befcda5c6fca07e9f7693b94c429f9c414b0cea07163c402ddd44d1108f89b190d0dcabc423a3d45696d\"\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(validSignedTx)\n+\texpectedConstructHashResponse := &types.TransactionIdentifierResponse{\n+\t\tTransactionIdentifier: &types.TransactionIdentifier{Hash: validSignedTransaction},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructHashResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionHashThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// given:\n+\texampleConstructionHashRequest := dummyConstructionHashRequest(invalidTxHexStr)\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionHash(nil, exampleConstructionHashRequest)\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionMetadata(t *testing.T) {\n+\t// given:\n+\texpectedResponse := &types.ConstructionMetadataResponse{\n+\t\tMetadata: make(map[string]interface{}),\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionMetadata(nil, nil)\n+\n+\t// then:\n+\tassert.Equal(t, expectedResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParse(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validUnsignedTx, false)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseSigned(t *testing.T) {\n+\t// given:\n+\texampleConstructionParseRequest := dummyConstructionParseRequest(validSignedTx, true)\n+\texpectedConstructionParseResponse := &types.ConstructionParseResponse{\n+\t\tOperations: []*types.Operation{\n+\t\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t\t},\n+\t\tAccountIdentifierSigners: []*types.AccountIdentifier{\n+\t\t\t{\n+\t\t\t\tAddress: publicKeyBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, exampleConstructionParseRequest)\n+\n+\t// then:\n+\tassert.Equal(t, expectedConstructionParseResponse, res)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionParseThrowsWhenDecodeStringFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(invalidTxHexStr, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionDecodeFailed], e)\n+}\n+\n+func TestConstructionParseThrowsWhenUnmarshallFails(t *testing.T) {\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionParse(nil, dummyConstructionParseRequest(corruptedTxHexStr, false))\n+\n+\t// then:\n+\tassert.Nil(t, res)\n+\tassert.Equal(t, errors.Errors[errors.TransactionUnmarshallingFailed], e)\n+}\n+\n+func TestConstructionPayloads(t *testing.T) {\n+\t// given:\n+\tvar expectedNilBytes []byte\n+\toperations := []*types.Operation{\n+\t\tdummyOperation(0, \"CRYPTOTRANSFER\", \"0.0.123352\", \"-1000\"),\n+\t\tdummyOperation(1, \"CRYPTOTRANSFER\", \"0.0.123518\", \"1000\"),\n+\t}\n+\texpectedPayloadsResponse := &types.ConstructionPayloadsResponse{\n+\t\tUnsignedTransaction: \"0x1a00223d0a140a0c08faf3b5fc0510c681d7d303120418e3cc13120218061880c2d72f2202087872180a160a090a0418b9c30710c8010a090a0418e3cc1310c701\",\n+\t\tPayloads: []*types.SigningPayload{\n+\t\t\t{\n+\t\t\t\tAccountIdentifier: &types.AccountIdentifier{\n+\t\t\t\t\tAddress: \"0.0.123352\",\n+\t\t\t\t},\n+\t\t\t\tBytes: expectedNilBytes,\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\t// when:\n+\tres, e := NewConstructionAPIService().ConstructionPayloads(nil, dummyPayloadsRequest(operations))\n+\n+\t// then:\n+\t// here we do not assert the whole response object to equal the expected one, because invocation of this method appends a unique timestamp to the result, thus making the signed TX and Bytes unique and non-assertable.\n+\tassert.Equal(t, expectedPayloadsResponse.Payloads[0].AccountIdentifier.Address, res.Payloads[0].AccountIdentifier.Address)\n+\tassert.Nil(t, e)\n+}\n+\n+func TestConstructionPayloadsThrowsWhenInvalidOperationsSum(t *testing.T) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ec6babb5be3914b3f04699b85390beacd0635b8"}, "originalPosition": 379}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "060f18aba582baf4eeb16ba616f1f9136775b1e6", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/060f18aba582baf4eeb16ba616f1f9136775b1e6", "committedDate": "2020-10-27T08:46:12Z", "message": "Additional test cases\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec2cff11116136e77eb6672c6d45c263e63d649d", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ec2cff11116136e77eb6672c6d45c263e63d649d", "committedDate": "2020-10-27T08:49:37Z", "message": "Additional test cases\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66c210b7bd5804107d819174cca5347fb75c1110", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/66c210b7bd5804107d819174cca5347fb75c1110", "committedDate": "2020-10-27T08:50:50Z", "message": "Additional test cases\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d725ee6898e005e934dbb3116ab1ed67821b82e7", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d725ee6898e005e934dbb3116ab1ed67821b82e7", "committedDate": "2020-10-27T08:55:37Z", "message": "Additional test cases\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8d5c3f4bd5ef963239f18a063b1e6fa900db5e5", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d8d5c3f4bd5ef963239f18a063b1e6fa900db5e5", "committedDate": "2020-10-27T09:16:03Z", "message": "Merge pull request #161 from LimeChain/tests/construction-api-unit-tests-rework\n\nAdditional test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f7c2fd9951145bc13465fed071aec55c06a6f51", "author": {"user": {"login": "georgiyazovaliiski", "name": "Georgi Yazovaliyski"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0f7c2fd9951145bc13465fed071aec55c06a6f51", "committedDate": "2020-10-27T13:58:10Z", "message": "renaming\n\nSigned-off-by: Georgi Yazovaliyski <georgi.yazovaliiski@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3OTc1NjU1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1169#pullrequestreview-517975655", "createdAt": "2020-10-27T17:36:20Z", "commit": {"oid": "0f7c2fd9951145bc13465fed071aec55c06a6f51"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3636, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}