{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NzEzNTY4", "number": 639, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjozNTo0MFrODtnOQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjozNjoyMlrODtnPYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTU1MTM5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/domain/RecordItemTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjozNTo0MFrOF_JBmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjozNTo0MFrOF_JBmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1MjQ3NA==", "bodyText": "Nit: Use assert4j chaining. You also don't need helper testException method with this approach, imo:\nassertThatThrownBy(() -> { throw new IllegalArgumentException(\"boom!\"); })\n                     .isInstanceOf(IllegalArgumentException.class)\n                     .hasMessageContaining(\"boom\");", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/639#discussion_r401752474", "createdAt": "2020-04-01T16:35:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/domain/RecordItemTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.hedera.mirror.importer.parser.domain;\n+\n+/*\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.protobuf.ByteString;\n+\n+import com.hedera.mirror.importer.exception.ParserException;\n+import com.hedera.mirror.importer.parser.record.transactionhandler.AbstractTransactionHandlerTest;\n+\n+import com.hederahashgraph.api.proto.java.SignatureMap;\n+import com.hederahashgraph.api.proto.java.SignaturePair;\n+import com.hederahashgraph.api.proto.java.Transaction;\n+import com.hederahashgraph.api.proto.java.TransactionBody;\n+import com.hederahashgraph.api.proto.java.TransactionReceipt;\n+import com.hederahashgraph.api.proto.java.TransactionRecord;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class RecordItemTest extends AbstractTransactionHandlerTest {\n+\n+    private static final Transaction DEFAULT_TRANSACTION = Transaction.newBuilder()\n+            .setBodyBytes(TransactionBody.getDefaultInstance().toByteString())\n+            .build();\n+    private static final byte[] DEFAULT_TRANSACTION_BYTES = DEFAULT_TRANSACTION.toByteArray();\n+    private static final TransactionRecord DEFAULT_RECORD = TransactionRecord.getDefaultInstance();\n+    private static final byte[] DEFAULT_RECORD_BYTES = DEFAULT_RECORD.toByteArray();\n+\n+    // 'body' and 'bodyBytes' feilds left empty\n+    private static final Transaction TRANSACTION = Transaction.newBuilder()\n+            .setSigMap(SignatureMap.newBuilder()\n+                    .addSigPair(SignaturePair.newBuilder()\n+                            .setEd25519(ByteString.copyFromUtf8(\"ed25519\"))\n+                            .setPubKeyPrefix(ByteString.copyFromUtf8(\"pubKeyPrefix\"))\n+                            .build())\n+                    .build())\n+            .build();\n+\n+    private static final TransactionBody TRANSACTION_BODY = TransactionBody.newBuilder()\n+            .setTransactionFee(10L)\n+            .setMemo(\"memo\")\n+            .build();\n+\n+    private static final TransactionRecord TRANSACTION_RECORD = TransactionRecord.newBuilder()\n+            .setReceipt(TransactionReceipt.newBuilder().setStatusValue(22).build())\n+            .setMemo(\"memo\")\n+            .build();\n+\n+    @Test\n+    public void testBadTransactionBytesThrowException() {\n+        testException(new byte[] {0x0, 0x1}, DEFAULT_RECORD_BYTES, RecordItem.BAD_TRANSACTION_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testBadRecordBytesThrowException() {\n+        testException(DEFAULT_TRANSACTION_BYTES, new byte[] {0x0, 0x1}, RecordItem.BAD_RECORD_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testTransactionBytesWithoutTransactionBodyThrowException() {\n+        testException(Transaction.newBuilder().build().toByteArray(),\n+                DEFAULT_RECORD_BYTES, RecordItem.BAD_TRANSACTION_BODY_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testWithBody() {\n+        Transaction transaction = TRANSACTION.toBuilder().setBody(TRANSACTION_BODY).build();\n+        RecordItem recordItem = new RecordItem(transaction.toByteArray(), TRANSACTION_RECORD.toByteArray());\n+        assertRecordItem(transaction, recordItem);\n+    }\n+\n+    @Test\n+    public void testWithBodyBytes() {\n+        Transaction transaction = TRANSACTION.toBuilder().setBodyBytes(TRANSACTION_BODY.toByteString()).build();\n+        RecordItem recordItem = new RecordItem(transaction.toByteArray(), TRANSACTION_RECORD.toByteArray());\n+        assertRecordItem(transaction, recordItem);\n+    }\n+\n+    private void testException(byte[] transactionBytes, byte[] recordBytes, String expectedMessage) {\n+        Exception exception = assertThrows(ParserException.class, () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7b56bc860c77ea2a507c9965dd0a6c86e995520"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTU1NDI1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/domain/RecordItemTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjozNjoyMlrOF_JDfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjozNjoyMlrOF_JDfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1Mjk1OA==", "bodyText": "nit: Recommend always using assert4j assertThat() for cleaner approach, consistency with other code and ability to chain", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/639#discussion_r401752958", "createdAt": "2020-04-01T16:36:22Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/domain/RecordItemTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.hedera.mirror.importer.parser.domain;\n+\n+/*\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.protobuf.ByteString;\n+\n+import com.hedera.mirror.importer.exception.ParserException;\n+import com.hedera.mirror.importer.parser.record.transactionhandler.AbstractTransactionHandlerTest;\n+\n+import com.hederahashgraph.api.proto.java.SignatureMap;\n+import com.hederahashgraph.api.proto.java.SignaturePair;\n+import com.hederahashgraph.api.proto.java.Transaction;\n+import com.hederahashgraph.api.proto.java.TransactionBody;\n+import com.hederahashgraph.api.proto.java.TransactionReceipt;\n+import com.hederahashgraph.api.proto.java.TransactionRecord;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class RecordItemTest extends AbstractTransactionHandlerTest {\n+\n+    private static final Transaction DEFAULT_TRANSACTION = Transaction.newBuilder()\n+            .setBodyBytes(TransactionBody.getDefaultInstance().toByteString())\n+            .build();\n+    private static final byte[] DEFAULT_TRANSACTION_BYTES = DEFAULT_TRANSACTION.toByteArray();\n+    private static final TransactionRecord DEFAULT_RECORD = TransactionRecord.getDefaultInstance();\n+    private static final byte[] DEFAULT_RECORD_BYTES = DEFAULT_RECORD.toByteArray();\n+\n+    // 'body' and 'bodyBytes' feilds left empty\n+    private static final Transaction TRANSACTION = Transaction.newBuilder()\n+            .setSigMap(SignatureMap.newBuilder()\n+                    .addSigPair(SignaturePair.newBuilder()\n+                            .setEd25519(ByteString.copyFromUtf8(\"ed25519\"))\n+                            .setPubKeyPrefix(ByteString.copyFromUtf8(\"pubKeyPrefix\"))\n+                            .build())\n+                    .build())\n+            .build();\n+\n+    private static final TransactionBody TRANSACTION_BODY = TransactionBody.newBuilder()\n+            .setTransactionFee(10L)\n+            .setMemo(\"memo\")\n+            .build();\n+\n+    private static final TransactionRecord TRANSACTION_RECORD = TransactionRecord.newBuilder()\n+            .setReceipt(TransactionReceipt.newBuilder().setStatusValue(22).build())\n+            .setMemo(\"memo\")\n+            .build();\n+\n+    @Test\n+    public void testBadTransactionBytesThrowException() {\n+        testException(new byte[] {0x0, 0x1}, DEFAULT_RECORD_BYTES, RecordItem.BAD_TRANSACTION_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testBadRecordBytesThrowException() {\n+        testException(DEFAULT_TRANSACTION_BYTES, new byte[] {0x0, 0x1}, RecordItem.BAD_RECORD_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testTransactionBytesWithoutTransactionBodyThrowException() {\n+        testException(Transaction.newBuilder().build().toByteArray(),\n+                DEFAULT_RECORD_BYTES, RecordItem.BAD_TRANSACTION_BODY_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testWithBody() {\n+        Transaction transaction = TRANSACTION.toBuilder().setBody(TRANSACTION_BODY).build();\n+        RecordItem recordItem = new RecordItem(transaction.toByteArray(), TRANSACTION_RECORD.toByteArray());\n+        assertRecordItem(transaction, recordItem);\n+    }\n+\n+    @Test\n+    public void testWithBodyBytes() {\n+        Transaction transaction = TRANSACTION.toBuilder().setBodyBytes(TRANSACTION_BODY.toByteString()).build();\n+        RecordItem recordItem = new RecordItem(transaction.toByteArray(), TRANSACTION_RECORD.toByteArray());\n+        assertRecordItem(transaction, recordItem);\n+    }\n+\n+    private void testException(byte[] transactionBytes, byte[] recordBytes, String expectedMessage) {\n+        Exception exception = assertThrows(ParserException.class, () -> {\n+            new RecordItem(transactionBytes, recordBytes);\n+        });\n+        assertEquals(expectedMessage, exception.getMessage());\n+    }\n+\n+    private void assertRecordItem(Transaction transaction, RecordItem recordItem) {\n+        assertEquals(transaction, recordItem.getTransaction());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7b56bc860c77ea2a507c9965dd0a6c86e995520"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1269, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}