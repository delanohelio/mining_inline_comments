{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzMjU0OTky", "number": 1076, "title": "Add topic messages and stateproof to monitor", "bodyText": "Detailed description:\n\nAdd topic message tests to monitor\nAdd stateproof tests to monitor\nAdd freshness threshold configuration for balance, topic message, and transaction\nAdd intervalMultiplier for tests to run less frequently to reduce cost\n\nWhich issue(s) this PR fixes:\nFixes #410\nFixes #667\nSpecial notes for your reviewer:\nThe topic message tests require an existing topic id of the target environment configured before running the backend.\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-09-25T17:35:18Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076", "merged": true, "mergeCommit": {"oid": "ba6b89260e757750f93e198822a4d9d1ca6a29f3"}, "closed": true, "closedAt": "2020-09-30T14:20:34Z", "author": {"login": "xin-hedera"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLej5nAH2gAyNDkzMjU0OTkyOmU2MTZjNDAxMGU0NzQ3NTUwYjIwODNhMWIxNThmZDFjYzczMWM3YzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNwa0LgFqTQ5ODk4NDA0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e616c4010e4747550b2083a1b158fd1cc731c7c6", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e616c4010e4747550b2083a1b158fd1cc731c7c6", "committedDate": "2020-09-22T21:06:46Z", "message": "stateproof: download record file from the node used for download and verification in importer\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7db5d3e4dfbb083d4b51ad471bc5f887df942a5f", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7db5d3e4dfbb083d4b51ad471bc5f887df942a5f", "committedDate": "2020-09-23T16:38:06Z", "message": "fix record file name in description of stateproof-09-no-record-file-found-from-0.0.4.spec.json\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5188ef05ecd58b961be666f98f200f1a554833df", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5188ef05ecd58b961be666f98f200f1a554833df", "committedDate": "2020-09-23T21:22:46Z", "message": "add stateproof tests\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58d105411213d700d489e8fef1ef6de55e4e9a63", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/58d105411213d700d489e8fef1ef6de55e4e9a63", "committedDate": "2020-09-24T17:59:42Z", "message": "topic message tests\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f37bf4f0d28eacba8c837ece2360ab0b10346232", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f37bf4f0d28eacba8c837ece2360ab0b10346232", "committedDate": "2020-09-24T20:13:59Z", "message": "topic messages: validate if the topic id exists / is of type \"topic\"\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ce79db19a868d1a32e5f5b78fdb629e9d94b83c", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5ce79db19a868d1a32e5f5b78fdb629e9d94b83c", "committedDate": "2020-09-24T20:14:37Z", "message": "Merge branch 'stateproof-download-record-file-from-stored-node' into monitor-topics-state-proof-tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77bb243a65925bf235bd5f67972768ce69d9dfd7", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/77bb243a65925bf235bd5f67972768ce69d9dfd7", "committedDate": "2020-09-24T20:15:09Z", "message": "Merge branch 'master' into monitor-topics-state-proof-tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b04fab88dbb5e0b0431c645b97f168d6ebe3f0cb", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/b04fab88dbb5e0b0431c645b97f168d6ebe3f0cb", "committedDate": "2020-09-24T20:16:57Z", "message": "cleanup\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8192d06206fd46089aa19f6961f0bb75112d78e6", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8192d06206fd46089aa19f6961f0bb75112d78e6", "committedDate": "2020-09-24T21:05:03Z", "message": "test topic messages with sequence number filter\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3a1f298bcfa9cf3cc3fb197ced0cade6734149c", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c3a1f298bcfa9cf3cc3fb197ced0cade6734149c", "committedDate": "2020-09-25T15:31:40Z", "message": "update doc and sample json configuration\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "506b28fa887f97986161d905f321941fd0c65a8b", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/506b28fa887f97986161d905f321941fd0c65a8b", "committedDate": "2020-09-25T15:41:01Z", "message": "clean up\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f6d7fa60cd1be3a8e0345f94f70ffb807120b02", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9f6d7fa60cd1be3a8e0345f94f70ffb807120b02", "committedDate": "2020-09-25T15:46:22Z", "message": "use expected status or 'any'\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzMyMjc0", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#pullrequestreview-497732274", "createdAt": "2020-09-28T17:06:16Z", "commit": {"oid": "9f6d7fa60cd1be3a8e0345f94f70ffb807120b02"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzowNjoxN1rOHZH1qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzoxMjo1MlrOHZIDsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwNDg3Mw==", "bodyText": "We don't need to add negative tests to the monitor. Unit tests are sufficient to test those.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#discussion_r496104873", "createdAt": "2020-09-28T17:06:17Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rest/monitoring/monitor_apis/topicmessage_tests.js", "diffHunk": "@@ -0,0 +1,389 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+'use strict';\n+\n+const config = require('./config');\n+const {\n+  checkAPIResponseError,\n+  checkRespObjDefined,\n+  checkRespArrayLength,\n+  checkMandatoryParams,\n+  checkConsensusTimestampOrder,\n+  getAPIResponse,\n+  getUrl,\n+  testRunner,\n+  CheckRunner,\n+} = require('./utils');\n+\n+const resource = 'topic';\n+const resourceLimit = config[resource].limit;\n+const {topicId} = config[resource];\n+const jsonRespKey = 'messages';\n+const mandatoryParams = [\n+  'consensus_timestamp',\n+  'topic_id',\n+  'message',\n+  'running_hash',\n+  'running_hash_version',\n+  'sequence_number',\n+];\n+\n+const topicMessagesPath = (id, sequence = undefined) => {\n+  const path = `/topics/${id}/messages`;\n+  if (sequence === undefined) {\n+    return path;\n+  }\n+\n+  return `${path}/${sequence}`;\n+};\n+\n+const checkSequenceNumberOrder = (messages, option) => {\n+  const errorMessage = (asc, previous, current) => {\n+    const order = asc ? 'ascending' : 'descending';\n+    return `topic message sequence is not in ${order} order / contiguous: previous - ${previous}, current - ${current}`;\n+  };\n+\n+  const {asc} = option;\n+  let previous = 0;\n+  for (const message of messages) {\n+    const sequence = message.sequence_number;\n+    if (previous !== 0) {\n+      if ((asc && sequence !== previous + 1) || (!asc && sequence >= previous + 1)) {\n+        return {passed: false, message: errorMessage(asc, previous, sequence)};\n+      }\n+    }\n+\n+    previous = sequence;\n+  }\n+\n+  return {passed: true};\n+};\n+\n+const checkSingleField = (elements, option) => {\n+  const {expected, getActual, message} = option;\n+  const element = Array.isArray(elements) ? elements[0] : elements;\n+  const actual = getActual(element);\n+  if (actual !== expected) {\n+    return {\n+      passed: false,\n+      message: message(actual, expected),\n+    };\n+  }\n+\n+  return {passed: true};\n+};\n+\n+/**\n+ * Verifies /topics/:topicId/messages\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessages = async (server) => {\n+  let url = getUrl(server, topicMessagesPath(topicId), {limit: resourceLimit});\n+  let messages = await getAPIResponse(url, jsonRespKey);\n+\n+  const checkRunner = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: resourceLimit,\n+      message: (elements, limit) => `messages.length of ${elements.length} is less than limit ${limit}`,\n+    })\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .withCheckSpec(checkConsensusTimestampOrder, {asc: true})\n+    .withCheckSpec(checkSequenceNumberOrder, {asc: true});\n+  let result = checkRunner.run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId), {limit: resourceLimit, order: 'desc'});\n+  messages = await getAPIResponse(url, jsonRespKey);\n+\n+  result = checkRunner\n+    .resetCheckSpec(checkConsensusTimestampOrder, {asc: false})\n+    .resetCheckSpec(checkSequenceNumberOrder, {asc: false})\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: `Successfully called topics for ${topicId} and performed order check`,\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/:topicId/messages?sequencenumber\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesBySequenceNumberFilter = async (server) => {\n+  let url = getUrl(server, topicMessagesPath(topicId), {sequencenumber: 1});\n+  let messages = await getAPIResponse(url, jsonRespKey);\n+\n+  let result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: 1,\n+      message: (elements) => `messages.length of ${elements.length} was expected to be 1`,\n+    })\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .withCheckSpec(checkSingleField, {\n+      expected: 1,\n+      getActual: (element) => element.sequence_number,\n+      message: (actual, expected) => `sequence number ${actual} was expected to be ${expected}`,\n+    })\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId), {sequencenumber: ['gte:1', 'lte:3']});\n+  messages = await getAPIResponse(url, jsonRespKey);\n+\n+  result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: 3,\n+      message: (elements) => `messages.length of ${elements.length} was expected to be 3`,\n+    })\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId), {sequencenumber: ['gte:3', 'lt:3']});\n+  messages = await getAPIResponse(url, jsonRespKey);\n+\n+  result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: 0,\n+      message: (elements) => `messages.length of ${elements.length} was expected to be 0`,\n+    })\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId), {sequencenumber: 'a'});\n+  messages = await getAPIResponse(url, jsonRespKey);\n+\n+  result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 400}).run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: 'Successfully called topics with sequencenumber filter',\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/0.0.2/messages returns 400\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesForNonTopicEntityId = async (server) => {\n+  const url = getUrl(server, topicMessagesPath('0.0.2'), {limit: resourceLimit});\n+  const resp = await getAPIResponse(url);\n+\n+  const result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 400}).run(resp);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: 'Successfully called topics on non-topic entity id 0.0.2 and got expected 400',\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/:topicId/messages with non-existing topic ID returns 404\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesForNonExistingTopicId = async (server) => {\n+  const nonExistingTopicId = `${config.shard + 1}.0.1930`;\n+  const url = getUrl(server, topicMessagesPath(nonExistingTopicId), {limit: resourceLimit});\n+  const resp = await getAPIResponse(url);\n+\n+  const result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 404}).run(resp);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: `Successfully called topics on non-existing topic ID ${nonExistingTopicId} and got expected 404`,\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/:topicId/messages/:sequencenumber\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesByTopicIDAndSequenceNumberPath = async (server) => {\n+  let url = getUrl(server, topicMessagesPath(topicId, 1));\n+  let message = await getAPIResponse(url);\n+\n+  let result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId, 0));\n+  message = await getAPIResponse(url);\n+\n+  result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 400}).run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId, -1));\n+  message = await getAPIResponse(url);\n+\n+  result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 400}).run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: `Successfully called topics for ${topicId} and message sequence number 1`,\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/messages/:consensusTimestamp\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesByConsensusTimestamp = async (server) => {\n+  let url = getUrl(server, topicMessagesPath(topicId), {limit: resourceLimit});\n+  const messages = await getAPIResponse(url, jsonRespKey);\n+\n+  let result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: resourceLimit,\n+      message: (elements, limit) => `messages.length of ${elements.length} is less than limit ${limit}`,\n+    })\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  const consensusTimestamp = messages[0].consensus_timestamp;\n+  url = getUrl(server, `/topics/messages/${consensusTimestamp}`);\n+  let message = await getAPIResponse(url);\n+\n+  result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'message is undefined'})\n+    .withCheckSpec(checkSingleField, {\n+      expected: consensusTimestamp,\n+      getActual: (element) => element.consensus_timestamp,\n+      message: (actual, expected) => `consensus timestamp ${actual} was expected to be ${expected}`,\n+    })\n+    .run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, '/topics/messages/0');\n+  message = await getAPIResponse(url);\n+\n+  result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 404}).run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: `Successfully called topics with consensus timestamp`,\n+  };\n+};\n+\n+/**\n+ * Run all topic message tests in an asynchronous fashion waiting for all tests to complete\n+ *\n+ * @param {String} server API host endpoint\n+ * @param {Object} classResults shared class results object capturing tests for given endpoint\n+ */\n+const runTests = async (server, classResults) => {\n+  const tests = [];\n+  const runTest = testRunner(server, classResults);\n+  tests.push(runTest(getTopicMessages));\n+  tests.push(runTest(getTopicMessagesBySequenceNumberFilter));\n+  tests.push(runTest(getTopicMessagesForNonTopicEntityId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f6d7fa60cd1be3a8e0345f94f70ffb807120b02"}, "originalPosition": 379}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEwODQ2Ng==", "bodyText": "We should have an optional (controlled via a property) freshness check for messages like we do for the endpoints.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#discussion_r496108466", "createdAt": "2020-09-28T17:12:52Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rest/monitoring/monitor_apis/topicmessage_tests.js", "diffHunk": "@@ -0,0 +1,389 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+'use strict';\n+\n+const config = require('./config');\n+const {\n+  checkAPIResponseError,\n+  checkRespObjDefined,\n+  checkRespArrayLength,\n+  checkMandatoryParams,\n+  checkConsensusTimestampOrder,\n+  getAPIResponse,\n+  getUrl,\n+  testRunner,\n+  CheckRunner,\n+} = require('./utils');\n+\n+const resource = 'topic';\n+const resourceLimit = config[resource].limit;\n+const {topicId} = config[resource];\n+const jsonRespKey = 'messages';\n+const mandatoryParams = [\n+  'consensus_timestamp',\n+  'topic_id',\n+  'message',\n+  'running_hash',\n+  'running_hash_version',\n+  'sequence_number',\n+];\n+\n+const topicMessagesPath = (id, sequence = undefined) => {\n+  const path = `/topics/${id}/messages`;\n+  if (sequence === undefined) {\n+    return path;\n+  }\n+\n+  return `${path}/${sequence}`;\n+};\n+\n+const checkSequenceNumberOrder = (messages, option) => {\n+  const errorMessage = (asc, previous, current) => {\n+    const order = asc ? 'ascending' : 'descending';\n+    return `topic message sequence is not in ${order} order / contiguous: previous - ${previous}, current - ${current}`;\n+  };\n+\n+  const {asc} = option;\n+  let previous = 0;\n+  for (const message of messages) {\n+    const sequence = message.sequence_number;\n+    if (previous !== 0) {\n+      if ((asc && sequence !== previous + 1) || (!asc && sequence >= previous + 1)) {\n+        return {passed: false, message: errorMessage(asc, previous, sequence)};\n+      }\n+    }\n+\n+    previous = sequence;\n+  }\n+\n+  return {passed: true};\n+};\n+\n+const checkSingleField = (elements, option) => {\n+  const {expected, getActual, message} = option;\n+  const element = Array.isArray(elements) ? elements[0] : elements;\n+  const actual = getActual(element);\n+  if (actual !== expected) {\n+    return {\n+      passed: false,\n+      message: message(actual, expected),\n+    };\n+  }\n+\n+  return {passed: true};\n+};\n+\n+/**\n+ * Verifies /topics/:topicId/messages\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessages = async (server) => {\n+  let url = getUrl(server, topicMessagesPath(topicId), {limit: resourceLimit});\n+  let messages = await getAPIResponse(url, jsonRespKey);\n+\n+  const checkRunner = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: resourceLimit,\n+      message: (elements, limit) => `messages.length of ${elements.length} is less than limit ${limit}`,\n+    })\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .withCheckSpec(checkConsensusTimestampOrder, {asc: true})\n+    .withCheckSpec(checkSequenceNumberOrder, {asc: true});\n+  let result = checkRunner.run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId), {limit: resourceLimit, order: 'desc'});\n+  messages = await getAPIResponse(url, jsonRespKey);\n+\n+  result = checkRunner\n+    .resetCheckSpec(checkConsensusTimestampOrder, {asc: false})\n+    .resetCheckSpec(checkSequenceNumberOrder, {asc: false})\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: `Successfully called topics for ${topicId} and performed order check`,\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/:topicId/messages?sequencenumber\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesBySequenceNumberFilter = async (server) => {\n+  let url = getUrl(server, topicMessagesPath(topicId), {sequencenumber: 1});\n+  let messages = await getAPIResponse(url, jsonRespKey);\n+\n+  let result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: 1,\n+      message: (elements) => `messages.length of ${elements.length} was expected to be 1`,\n+    })\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .withCheckSpec(checkSingleField, {\n+      expected: 1,\n+      getActual: (element) => element.sequence_number,\n+      message: (actual, expected) => `sequence number ${actual} was expected to be ${expected}`,\n+    })\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId), {sequencenumber: ['gte:1', 'lte:3']});\n+  messages = await getAPIResponse(url, jsonRespKey);\n+\n+  result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: 3,\n+      message: (elements) => `messages.length of ${elements.length} was expected to be 3`,\n+    })\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId), {sequencenumber: ['gte:3', 'lt:3']});\n+  messages = await getAPIResponse(url, jsonRespKey);\n+\n+  result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: 0,\n+      message: (elements) => `messages.length of ${elements.length} was expected to be 0`,\n+    })\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId), {sequencenumber: 'a'});\n+  messages = await getAPIResponse(url, jsonRespKey);\n+\n+  result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 400}).run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: 'Successfully called topics with sequencenumber filter',\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/0.0.2/messages returns 400\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesForNonTopicEntityId = async (server) => {\n+  const url = getUrl(server, topicMessagesPath('0.0.2'), {limit: resourceLimit});\n+  const resp = await getAPIResponse(url);\n+\n+  const result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 400}).run(resp);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: 'Successfully called topics on non-topic entity id 0.0.2 and got expected 400',\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/:topicId/messages with non-existing topic ID returns 404\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesForNonExistingTopicId = async (server) => {\n+  const nonExistingTopicId = `${config.shard + 1}.0.1930`;\n+  const url = getUrl(server, topicMessagesPath(nonExistingTopicId), {limit: resourceLimit});\n+  const resp = await getAPIResponse(url);\n+\n+  const result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 404}).run(resp);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: `Successfully called topics on non-existing topic ID ${nonExistingTopicId} and got expected 404`,\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/:topicId/messages/:sequencenumber\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesByTopicIDAndSequenceNumberPath = async (server) => {\n+  let url = getUrl(server, topicMessagesPath(topicId, 1));\n+  let message = await getAPIResponse(url);\n+\n+  let result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId, 0));\n+  message = await getAPIResponse(url);\n+\n+  result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 400}).run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, topicMessagesPath(topicId, -1));\n+  message = await getAPIResponse(url);\n+\n+  result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 400}).run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: `Successfully called topics for ${topicId} and message sequence number 1`,\n+  };\n+};\n+\n+/**\n+ * Verifies /topics/messages/:consensusTimestamp\n+ *\n+ * @param {String} server API host endpoint\n+ * @return {{url: String, passed: boolean, message: String}}\n+ */\n+const getTopicMessagesByConsensusTimestamp = async (server) => {\n+  let url = getUrl(server, topicMessagesPath(topicId), {limit: resourceLimit});\n+  const messages = await getAPIResponse(url, jsonRespKey);\n+\n+  let result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'messages is undefined'})\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: resourceLimit,\n+      message: (elements, limit) => `messages.length of ${elements.length} is less than limit ${limit}`,\n+    })\n+    .withCheckSpec(checkMandatoryParams, {\n+      params: mandatoryParams,\n+      message: 'topic message object is missing some mandatory fields',\n+    })\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  const consensusTimestamp = messages[0].consensus_timestamp;\n+  url = getUrl(server, `/topics/messages/${consensusTimestamp}`);\n+  let message = await getAPIResponse(url);\n+\n+  result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespObjDefined, {message: 'message is undefined'})\n+    .withCheckSpec(checkSingleField, {\n+      expected: consensusTimestamp,\n+      getActual: (element) => element.consensus_timestamp,\n+      message: (actual, expected) => `consensus timestamp ${actual} was expected to be ${expected}`,\n+    })\n+    .run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  url = getUrl(server, '/topics/messages/0');\n+  message = await getAPIResponse(url);\n+\n+  result = new CheckRunner().withCheckSpec(checkAPIResponseError, {expectHttpError: true, status: 404}).run(message);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: `Successfully called topics with consensus timestamp`,\n+  };\n+};\n+\n+/**\n+ * Run all topic message tests in an asynchronous fashion waiting for all tests to complete\n+ *\n+ * @param {String} server API host endpoint\n+ * @param {Object} classResults shared class results object capturing tests for given endpoint\n+ */\n+const runTests = async (server, classResults) => {\n+  const tests = [];\n+  const runTest = testRunner(server, classResults);\n+  tests.push(runTest(getTopicMessages));\n+  tests.push(runTest(getTopicMessagesBySequenceNumberFilter));\n+  tests.push(runTest(getTopicMessagesForNonTopicEntityId));\n+  tests.push(runTest(getTopicMessagesForNonExistingTopicId));\n+  tests.push(runTest(getTopicMessagesByTopicIDAndSequenceNumberPath));\n+  tests.push(runTest(getTopicMessagesByConsensusTimestamp));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f6d7fa60cd1be3a8e0345f94f70ffb807120b02"}, "originalPosition": 382}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NzQ4NzA1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#pullrequestreview-497748705", "createdAt": "2020-09-28T17:28:46Z", "commit": {"oid": "9f6d7fa60cd1be3a8e0345f94f70ffb807120b02"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b261f6b9dfaba45047b1ce898ccb766f5200b9e", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6b261f6b9dfaba45047b1ce898ccb766f5200b9e", "committedDate": "2020-09-28T22:31:49Z", "message": "make freshness threshold configuration, remove negative tests\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a79b938cfbee42916ab75a458a3100465561eb7", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7a79b938cfbee42916ab75a458a3100465561eb7", "committedDate": "2020-09-29T15:23:49Z", "message": "allow configure stateproof tests to run every interval * intervalMultiplier seconds to reduce cost\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NjM3Nzg1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#pullrequestreview-498637785", "createdAt": "2020-09-29T15:50:58Z", "commit": {"oid": "6b261f6b9dfaba45047b1ce898ccb766f5200b9e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTo1MToxMFrOHZ0pJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNjowMTo0OFrOHZ1VcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzODk0OQ==", "bodyText": "Wrong endpoint", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#discussion_r496838949", "createdAt": "2020-09-29T15:51:10Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rest/monitoring/monitor_apis/topicmessage_tests.js", "diffHunk": "@@ -365,6 +321,38 @@ const getTopicMessagesByConsensusTimestamp = async (server) => {\n   };\n };\n \n+/**\n+ * Verfiy the freshness of the latest topic message returned by the api\n+ * @param {String} server API host endpoint\n+ */\n+const checkTopicMessageFreshness = async (server) => {\n+  const {freshnessThreshold} = config[resource];\n+  const url = getUrl(server, topicMessagesPath(topicId), {limit: 1, order: 'desc'});\n+  const messages = await getAPIResponse(url, jsonRespKey);\n+\n+  const result = new CheckRunner()\n+    .withCheckSpec(checkAPIResponseError)\n+    .withCheckSpec(checkRespArrayLength, {\n+      limit: 1,\n+      message: (elements) => `messages.length of ${elements.length} was expected to be 1`,\n+    })\n+    .withCheckSpec(checkRespDataFreshness, {\n+      timestamp: (message) => message.consensus_timestamp,\n+      threshold: freshnessThreshold,\n+      message: (delta) => `balance was stale, ${delta} seconds old`,\n+    })\n+    .run(messages);\n+  if (!result.passed) {\n+    return {url, ...result};\n+  }\n+\n+  return {\n+    url,\n+    passed: true,\n+    message: `Successfully retrieved balance from with ${freshnessThreshold} seconds ago`,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b261f6b9dfaba45047b1ce898ccb766f5200b9e"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg0NjkxNw==", "bodyText": "Looks like the intervalMultiplier works for every resource, not just stateproof. We should add it to docs and json for every type and put a default of 1 and make it required.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#discussion_r496846917", "createdAt": "2020-09-29T15:58:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rest/monitoring/monitor_apis/monitor_tests.js", "diffHunk": "@@ -20,33 +20,62 @@\n \n 'use strict';\n \n-const accountTests = require('./account_tests');\n-const balanceTests = require('./balance_tests');\n-const transactionTests = require('./transaction_tests');\n-const stateproofTests = require('./stateproof_tests');\n-const topicmessageTests = require('./topicmessage_tests');\n+const {getServerCurrentResults} = require('./common');\n+const config = require('./config');\n const utils = require('./utils');\n \n+const allTestModules = [\n+  require('./account_tests'),\n+  require('./balance_tests'),\n+  require('./transaction_tests'),\n+  require('./stateproof_tests'),\n+  require('./topicmessage_tests'),\n+];\n+\n+const counters = {};\n+\n /**\n  * Run node based tests against api endpoint\n- * Each class manages its tests and returns a class rsults object\n- * A single combined result object covering transaction, accounts and balances is returned\n- * @param {String} server API host endpoint\n+ * Each class manages its tests and returns a class results object\n+ * A single combined result object covering all test resources is returned\n+ *\n+ * @param {String} name server name\n+ * @param {String} address server address in the format of http://ip:port\n  * @return {Object} results object capturing tests for given endpoint\n  */\n-const runTests = (server) => {\n-  if (undefined === server) {\n-    console.log(`server is undefined, skipping ....`);\n-    return;\n+const runTests = (name, address) => {\n+  const counter = name in counters ? counters[name] : 0;\n+  const skippedResource = [];\n+  const testModules = allTestModules.filter((testModule) => {\n+    const {intervalMultiplier} = config[testModule.resource];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a79b938cfbee42916ab75a458a3100465561eb7"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg1MDI4OQ==", "bodyText": "Can we make it such that this is optional? Either if not provided it doesn't run the applicable tests or it picks the most recent topic in topic_messages one time at startup. I'm thinking if we ever add monitor to CI or when we run it locally we want it to work out of the box with minimal config.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#discussion_r496850289", "createdAt": "2020-09-29T16:01:48Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rest/monitoring/README.md", "diffHunk": "@@ -31,6 +31,7 @@ A dashboard polls the above-mentioned APIs and displays the results.\n ### Requirements\n \n -   [ ] List of addresses of Hedera mirror nodes that you want to monitor\n+-   [ ] An existing topic ID of the target Hedera Mirrornode environment", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a79b938cfbee42916ab75a458a3100465561eb7"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c50a878e750fddacfb246f01e4cf45eef674259b", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c50a878e750fddacfb246f01e4cf45eef674259b", "committedDate": "2020-09-29T19:14:36Z", "message": "address review comments\n\n- freshnessThreshold of 0 disables freshness check\n- add intervalMultiplier to every resource with default of 1, except for stateproof it's 10; document it\n- make topic.topicId optional; if not set, all topic message tests will be skipped\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc0ed4ae332121030ca2d7720c9e7b7883ff39ea", "author": {"user": {"login": "xin-hedera", "name": "Xin Li"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/dc0ed4ae332121030ca2d7720c9e7b7883ff39ea", "committedDate": "2020-09-29T19:25:16Z", "message": "make intervalMultiplier required\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4OTMyMzc1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#pullrequestreview-498932375", "createdAt": "2020-09-29T22:15:41Z", "commit": {"oid": "dc0ed4ae332121030ca2d7720c9e7b7883ff39ea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4OTg0MDQy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1076#pullrequestreview-498984042", "createdAt": "2020-09-29T23:02:59Z", "commit": {"oid": "dc0ed4ae332121030ca2d7720c9e7b7883ff39ea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3557, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}