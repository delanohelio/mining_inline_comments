{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2OTkzOTcw", "number": 1235, "title": "Add version migrations to fix entity type mismatches in db", "bodyText": "Detailed description:\nCurrently mirror node will create entities that don't exist even on failed transactions.\nWe should create entities only on the 5 create transactions and accounts in the record transfer list\n\nAdd sql migration v1.31.2 that removes all entities above max entity id observed by transactions table\nAdd logic to sql migration to update t_transaction_types with relating entityTypes for a transaction\nAdd logic to sql migration to scan for entities who's entity type doesn't match expected type and update them\nAdd migration test class to verify migration cases\n\nWhich issue(s) this PR fixes:\nFixes #1201\nSpecial notes for your reviewer:\nVerified logic in dev environment based on test net data.\nMigration takes just under 1/. mins for t_entities table of size 79,300 and transaction table size 10,6572,222\nMigration log below\n...\nUPDATE 4\nTime: 80767.893 ms (01:20.768)\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-11-06T21:44:12Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235", "merged": true, "mergeCommit": {"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd"}, "closed": true, "closedAt": "2020-11-12T21:26:44Z", "author": {"login": "Nana-EC"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABda5tGbgBqjM5NzUzNzM4MDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdb5VaXAFqTUyOTUwNjUyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "185d71b1bc5df6f86b4a0171f33a5d945ab1041a", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/185d71b1bc5df6f86b4a0171f33a5d945ab1041a", "committedDate": "2020-11-06T21:39:06Z", "message": "Add version migrations to fix entity type mismatches in db\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}, "afterCommit": {"oid": "3159528dcbfc9d4a3b175de51b30401257205662", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3159528dcbfc9d4a3b175de51b30401257205662", "committedDate": "2020-11-09T19:08:45Z", "message": "Cleaned up\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NTU4NTM2", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-527558536", "createdAt": "2020-11-10T19:56:19Z", "commit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1NjoxOVrOHwtVag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDoxOTowOVrOHwuGpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNjQ1OA==", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void verifyEntityTypeMigrationInValidEntities() throws Exception {\n          \n          \n            \n                void verifyEntityTypeMigrationInvalidEntities() throws Exception {", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520836458", "createdAt": "2020-11-10T19:56:19Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n+    @Resource\n+    private V1_31_1__Entity_Type_Mismatch migration;\n+\n+    @Resource\n+    private DataSource dataSource;\n+\n+    @Resource\n+    private EntityRepository entityRepository;\n+\n+    @Resource\n+    private MirrorProperties mirrorProperties;\n+\n+    @Resource\n+    private TransactionRepository transactionRepository;\n+\n+    @Resource\n+    private FlywayMigrationProperties flywayMigrationProperties;\n+\n+    @BeforeEach\n+    void before() {\n+        mirrorProperties.setStartDate(Instant.EPOCH);\n+        mirrorProperties.setEndDate(Instant.EPOCH.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationEmpty() throws Exception {\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(0, entityRepository.count());\n+        assertEquals(0, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n+        entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n+        entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n+        entityRepository.insertEntityId(entityId(4, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(5, EntityTypeEnum.TOKEN));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(5, entityRepository.count());\n+        assertEquals(5, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntities() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzODcwNQ==", "bodyText": "Nit: I'm wondering if the variable name could be enhanced a little, I had to read the SQL to really understand the sentiment but I'm failing to come up with something better.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520838705", "createdAt": "2020-11-10T20:00:13Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MzMyMw==", "bodyText": "Nit: not sure how you feel about ternary operators, but this method could be replaced with one I believe.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return expectedEntityType.getId();\n          \n          \n            \n                    return expectedEntityType.getId() == currentEntityType ? 0 :  expectedEntityType.getId();", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520843323", "createdAt": "2020-11-10T20:08:25Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NTM2Ng==", "bodyText": "I understand incrementing the entity id cap by 1, I'm not sure I understand incrementing the timestamp cap though, if the cap is already set to the current time.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520845366", "createdAt": "2020-11-10T20:12:01Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NjgzNQ==", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void verifyEntityTypeMigrationInValidEntitiesMultiBatch() throws Exception {\n          \n          \n            \n                void verifyEntityTypeMigrationInvalidEntitiesMultiBatch() throws Exception {", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520846835", "createdAt": "2020-11-10T20:14:48Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n+    @Resource\n+    private V1_31_1__Entity_Type_Mismatch migration;\n+\n+    @Resource\n+    private DataSource dataSource;\n+\n+    @Resource\n+    private EntityRepository entityRepository;\n+\n+    @Resource\n+    private MirrorProperties mirrorProperties;\n+\n+    @Resource\n+    private TransactionRepository transactionRepository;\n+\n+    @Resource\n+    private FlywayMigrationProperties flywayMigrationProperties;\n+\n+    @BeforeEach\n+    void before() {\n+        mirrorProperties.setStartDate(Instant.EPOCH);\n+        mirrorProperties.setEndDate(Instant.EPOCH.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationEmpty() throws Exception {\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(0, entityRepository.count());\n+        assertEquals(0, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n+        entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n+        entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n+        entityRepository.insertEntityId(entityId(4, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(5, EntityTypeEnum.TOKEN));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(5, entityRepository.count());\n+        assertEquals(5, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        EntityId typeMismatchedAccountEntityId = entityId(1, EntityTypeEnum.TOPIC);\n+        EntityId typeMismatchedContractEntityId = entityId(2, EntityTypeEnum.TOKEN);\n+        EntityId typeMismatchedFileEntityId = entityId(3, EntityTypeEnum.CONTRACT);\n+        EntityId typeMismatchedTopicEntityId = entityId(4, EntityTypeEnum.ACCOUNT);\n+        EntityId typeMismatchedTokenEntityId = entityId(5, EntityTypeEnum.FILE);\n+        entityRepository.insertEntityId(typeMismatchedAccountEntityId);\n+        entityRepository.insertEntityId(typeMismatchedContractEntityId);\n+        entityRepository.insertEntityId(typeMismatchedFileEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTopicEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTokenEntityId);\n+        entityRepository.insertEntityId(entityId(50, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(100, EntityTypeEnum.TOPIC));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionList\n+                .add(transaction(70, 50, EntityTypeEnum.TOPIC, ResponseCodeEnum.INVALID_TOPIC_ID,\n+                        TransactionTypeEnum.CONSENSUSSUBMITMESSAGE));\n+        transactionList\n+                .add(transaction(80, 100, EntityTypeEnum.TOPIC, ResponseCodeEnum.TOPIC_EXPIRED,\n+                        TransactionTypeEnum.CONSENSUSSUBMITMESSAGE));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(7, entityRepository.count());\n+        assertEquals(7, transactionRepository.count());\n+\n+        assertAll(\n+                () -> assertThat(entityRepository.findById(typeMismatchedAccountEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.ACCOUNT.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedContractEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.CONTRACT.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedFileEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.FILE.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedTopicEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.TOPIC.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedTokenEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.TOKEN.getId())\n+        );\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntitiesMultiBatch() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0OTA2Mw==", "bodyText": "I'm a little confused on not checking these last two in any of the invalid tests.  I'm sure it's a use case I'm just not understanding.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520849063", "createdAt": "2020-11-10T20:19:09Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n+    @Resource\n+    private V1_31_1__Entity_Type_Mismatch migration;\n+\n+    @Resource\n+    private DataSource dataSource;\n+\n+    @Resource\n+    private EntityRepository entityRepository;\n+\n+    @Resource\n+    private MirrorProperties mirrorProperties;\n+\n+    @Resource\n+    private TransactionRepository transactionRepository;\n+\n+    @Resource\n+    private FlywayMigrationProperties flywayMigrationProperties;\n+\n+    @BeforeEach\n+    void before() {\n+        mirrorProperties.setStartDate(Instant.EPOCH);\n+        mirrorProperties.setEndDate(Instant.EPOCH.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationEmpty() throws Exception {\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(0, entityRepository.count());\n+        assertEquals(0, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n+        entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n+        entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n+        entityRepository.insertEntityId(entityId(4, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(5, EntityTypeEnum.TOKEN));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(5, entityRepository.count());\n+        assertEquals(5, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        EntityId typeMismatchedAccountEntityId = entityId(1, EntityTypeEnum.TOPIC);\n+        EntityId typeMismatchedContractEntityId = entityId(2, EntityTypeEnum.TOKEN);\n+        EntityId typeMismatchedFileEntityId = entityId(3, EntityTypeEnum.CONTRACT);\n+        EntityId typeMismatchedTopicEntityId = entityId(4, EntityTypeEnum.ACCOUNT);\n+        EntityId typeMismatchedTokenEntityId = entityId(5, EntityTypeEnum.FILE);\n+        entityRepository.insertEntityId(typeMismatchedAccountEntityId);\n+        entityRepository.insertEntityId(typeMismatchedContractEntityId);\n+        entityRepository.insertEntityId(typeMismatchedFileEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTopicEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTokenEntityId);\n+        entityRepository.insertEntityId(entityId(50, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(100, EntityTypeEnum.TOPIC));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODQ3OTU3", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-526847957", "createdAt": "2020-11-10T04:41:04Z", "commit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNDo0MTowNFrOHwLf5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMToxODowM1rOHwv9bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MjA4Ng==", "bodyText": "Is this used somewhere?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520282086", "createdAt": "2020-11-10T04:41:04Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java", "diffHunk": "@@ -34,4 +34,14 @@\n     TOKEN(5);\n \n     private final int id;\n+\n+    public static EntityTypeEnum fromId(int id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzE1Mw==", "bodyText": "Why not continue chaining and avoid the temporary entitiesIterableAssert variable?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520283153", "createdAt": "2020-11-10T04:45:16Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java", "diffHunk": "@@ -365,11 +366,13 @@ protected void assertEntities(EntityId... entityIds) {\n             return;\n         }\n \n-        assertEquals(entityIds.length, entityRepository.count());\n+        IterableAssert<Entities> entitiesIterableAssert = assertThat(entityRepository.findAll())\n+                .hasSize(entityIds.length)\n+                .allMatch(entity -> entity.getId() > 0)\n+                .allMatch(entity -> entity.getEntityTypeId() != null);\n \n-        // verify entities\n-        for (EntityId entityId : entityIds) {\n-            assertThat(entityRepository.findById(entityId.getId())).isPresent();\n-        }\n+        entitiesIterableAssert", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5ODk1NQ==", "bodyText": "This doesn't work here. Nor should you have transactions within the larger flyway transaction as it would leave the database in an inconsistent state.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520798955", "createdAt": "2020-11-10T18:55:54Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNDc1OQ==", "bodyText": "You should move non join statements to a where clause for clarity. They produce the same query plan for inner joins either way.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520834759", "createdAt": "2020-11-10T19:53:11Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzE2NA==", "bodyText": "Just inject a JdbcOperations instead of the DataSource.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520837164", "createdAt": "2020-11-10T19:57:34Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDA1Mw==", "bodyText": "Both these repositories are unused and should be removed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520864053", "createdAt": "2020-11-10T20:47:48Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDc0NQ==", "bodyText": "Don't think we need to denote Nullable on non-API/internal methods", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520864745", "createdAt": "2020-11-10T20:49:09Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2ODExNQ==", "bodyText": "What's the point of backing up if we're going to drop it at the end? If something goes wrong the transaction will rollback.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520868115", "createdAt": "2020-11-10T20:55:37Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3Mzk3NQ==", "bodyText": "I'm not convinced this is correct. I believe we should be deleting anything above the max for only successful transaction results. Below results for mainnet indicate everything above 58743 should be deleted:\nselect max(entity_id) as max, result from transaction where entity_id is not null group by result order by result asc;\n  max   | result\n--------+--------\n  45009 |      4\n  56708 |      7\n  51273 |     10\n  45009 |     11\n  40319 |     15\n  58743 |     22\n  24586 |     30\n  54356 |     33\n  22922 |     34\n  55762 |     68\n  35316 |     72\n  40790 |     78\n    112 |    105\n  15602 |    106\n  40941 |    111\n 211228 |    150\n  40127 |    158\n(17 rows)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520873975", "createdAt": "2020-11-10T21:06:50Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/resources/db/migration/V1.31.0__remove_invalid_entities.sql", "diffHunk": "@@ -0,0 +1,10 @@\n+-------------------\n+-- Fix entity type mismatches\n+-------------------\n+\n+-- Backup t_entities prior to type mismatch fix\n+create table t_entities_archive as table t_entities;\n+\n+--- Delete entities above the max entity id witnessed by transactions\n+delete from t_entities where id > (select max(entity_id) from transaction where entity_id is not null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NTk1Nw==", "bodyText": "Don't need to hardcode to seconds, can just log.info(\"{}\", stopwatch) and it will automatically use the biggest duration unit.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520875957", "createdAt": "2020-11-10T21:10:58Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzI0NA==", "bodyText": "Each of these is a full table scan since it doesn't use indexes. You can just do a single query with a group by. You can then use having to remove rows equal to zero and have a single throw statement.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520877244", "createdAt": "2020-11-10T21:13:26Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n+        return entityIdType;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 292}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3OTQ2OQ==", "bodyText": "Why do we need to confirm no entity mismatch unless the database migration has a bug? If it there is a bug in the migration do we really want to block/fail the deployment? We haven't done this in any previous migration", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520879469", "createdAt": "2020-11-10T21:18:03Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n+        return entityIdType;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 290}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjQ5NTMw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-527649530", "createdAt": "2020-11-10T22:11:39Z", "commit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjoxMTozOVrOHwxnfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMjo0NDowNlrOHwyiGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNjYyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    ps.setLong(1, entityIdType.correctedEntityTypeId);\n          \n          \n            \n                                    ps.setInt(1, entityIdType.correctedEntityTypeId);", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520906623", "createdAt": "2020-11-10T22:11:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNzM2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private final long correctedEntityTypeId;\n          \n          \n            \n                    private final long entityId;\n          \n          \n            \n                    private final long initialEntityTypeId;\n          \n          \n            \n                    private final long transactionType;\n          \n          \n            \n                    private final int correctedEntityTypeId;\n          \n          \n            \n                    private final long entityId;\n          \n          \n            \n                    private final int initialEntityTypeId;\n          \n          \n            \n                    private final int transactionType;", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520907360", "createdAt": "2020-11-10T22:13:02Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n+        return entityIdType;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n+                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n+        if (accountMismatchCount > 0) {\n+            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n+        }\n+\n+        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n+                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n+        if (contractMismatchCount > 0) {\n+            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n+        }\n+\n+        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n+                .getProtoId(), EntityTypeEnum.FILE.getId());\n+        if (fileMismatchCount > 0) {\n+            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n+        }\n+\n+        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n+                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n+        if (topicMismatchCount > 0) {\n+            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n+        }\n+\n+        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n+                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n+        if (tokenMismatchCount > 0) {\n+            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n+        }\n+    }\n+\n+    @Data\n+    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n+    private class EntityIdType {\n+        private final long consensusTimestamp;\n+        private final long correctedEntityTypeId;\n+        private final long entityId;\n+        private final long initialEntityTypeId;\n+        private final long transactionType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA==", "bodyText": "nit: order by consensus_ns desc is redundant since there won't be duplicate entity IDs in those successful create transactions", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520914134", "createdAt": "2020-11-10T22:27:13Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMTYyNQ==", "bodyText": "these are already updated in getTypeMismatchedEntity and it's also possible updating them here would cause some rows to be reprocessed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520921625", "createdAt": "2020-11-10T22:44:06Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e"}, "originalPosition": 216}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "committedDate": "2020-11-09T19:34:15Z", "message": "Renamed sql migration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}, "afterCommit": {"oid": "268b341265e3640631a626897a9ac82ccd2adbb6", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/268b341265e3640631a626897a9ac82ccd2adbb6", "committedDate": "2020-11-11T06:09:05Z", "message": "Addressed feedback 2\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NDA3OTQ3", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-528407947", "createdAt": "2020-11-11T17:56:10Z", "commit": {"oid": "cafde28e9dae6c38fdeb67588e2c12d3397b8007"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNzo1NjoxMVrOHxYL-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxODowMjozNVrOHxYbWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzODU1NA==", "bodyText": "I'm generally hesitant to use default values, like I'm assuming the boolean continueSearch is being defaulted to false without it being stated anywhere.  That could just be a personal preference though.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521538554", "createdAt": "2020-11-11T17:56:11Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n+            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n+            \"limit ?\";\n+    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    private AtomicLong entityIdCap;\n+    private AtomicLong timestampCap;\n+    private AtomicLong entityTransactionCount;\n+    private AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        if (getMismatchCount() == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n+        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n+        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n+        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n+                .get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchSearchResult.isContinueSearch()) {\n+            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n+                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n+            }\n+\n+            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n+                    .get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the count of entity type mismatches found across all entities\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n+     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return new TypeMismatchSearchResult();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cafde28e9dae6c38fdeb67588e2c12d3397b8007"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0MjQ4OQ==", "bodyText": "Is there a reason to do the granular type mismatch checks ((t.type = 8 and e.fk_entity_type_id <> 2), etc) in the count SQL but not here?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521542489", "createdAt": "2020-11-11T18:02:35Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n+            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cafde28e9dae6c38fdeb67588e2c12d3397b8007"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NDQwMzI5", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-528440329", "createdAt": "2020-11-11T18:42:18Z", "commit": {"oid": "cafde28e9dae6c38fdeb67588e2c12d3397b8007"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxODo0MjoxOFrOHxZwAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQyMDoxODo0N1rOHxc0jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDE2Mw==", "bodyText": "private", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521564163", "createdAt": "2020-11-11T18:42:18Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n+            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n+            \"limit ?\";\n+    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    private AtomicLong entityIdCap;\n+    private AtomicLong timestampCap;\n+    private AtomicLong entityTransactionCount;\n+    private AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        if (getMismatchCount() == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n+        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n+        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n+        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n+                .get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchSearchResult.isContinueSearch()) {\n+            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n+                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n+            }\n+\n+            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n+                    .get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the count of entity type mismatches found across all entities\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n+     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return new TypeMismatchSearchResult();\n+        }\n+\n+        // remove nulls\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+\n+        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param typeMismatchedEntities List of mismatched entities\n+     * @return\n+     */\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cafde28e9dae6c38fdeb67588e2c12d3397b8007"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2ODE3NQ==", "bodyText": "You'll need a custom cleanup.sql that's a copy of current sql so this doesn't break in the future.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521568175", "createdAt": "2020-11-11T18:49:51Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.1\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cafde28e9dae6c38fdeb67588e2c12d3397b8007"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc1Nw==", "bodyText": "Why are we limiting to these certain types here and in the search SQL? It should be all transaction types that are associated with one of the entity types. For example, a CONSENSUSUPDATETOPIC can certainly return an INVALID_TOPIC_ID.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521609757", "createdAt": "2020-11-11T20:09:18Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cafde28e9dae6c38fdeb67588e2c12d3397b8007"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMTIxNA==", "bodyText": "If we later add new transaction types but someone runs this migration after that point, it would miss those types. Perhaps we should auto-generate this SQL from the enums? Also, it would be less brittle and hard to understand.\nThat is, add an optional EntityTypeEnum field to TransactionTypeEnum that groups transactions types per which entity they are associated with. Then generate the SQL using that info.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521611214", "createdAt": "2020-11-11T20:12:10Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cafde28e9dae6c38fdeb67588e2c12d3397b8007"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNDQ3OA==", "bodyText": "We should use a DB cursor instead of using this complicated keyset pagination approach with stateful Atomics. The updating can be batched but the querying should not be.\nBesides being harder to understand and making the class stateful, this query will be slower since it's joining an un-indexed field. Keyset pagination only makes sense when using index fields. I ran this query in mainnet and a single page took a few minutes.\nThis would also allow you to reuse the sql that compares the entity type with the transaction type. It would also make the verification query completely unnecessary as it's the same SQL.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521614478", "createdAt": "2020-11-11T20:18:47Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cafde28e9dae6c38fdeb67588e2c12d3397b8007"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NDE1NjEy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-529415612", "createdAt": "2020-11-12T19:22:08Z", "commit": {"oid": "c8d5ee67a51ba66ad9a9a56aa3a35e779def1132"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9cd402f6d7192e23001ae1682fce95a6173eb0d5", "committedDate": "2020-11-12T19:27:48Z", "message": "Add version migrations to fix entity type mismatches in db\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88f9d4a81c84f67f52a94920adca590bcb2ecb32", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/88f9d4a81c84f67f52a94920adca590bcb2ecb32", "committedDate": "2020-11-12T19:27:48Z", "message": "Cleaned up\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7ca3eadb88f6c7187cd4d0450fe98d3e75ab2d9", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f7ca3eadb88f6c7187cd4d0450fe98d3e75ab2d9", "committedDate": "2020-11-12T19:27:48Z", "message": "Renamed sql migration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9c2cb723b1f5f8b275748fad84d9d9809162606", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e9c2cb723b1f5f8b275748fad84d9d9809162606", "committedDate": "2020-11-12T19:27:48Z", "message": "Addressed feedback 1\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d689050d99226ce8472b047bbe2d7456c88b25b", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3d689050d99226ce8472b047bbe2d7456c88b25b", "committedDate": "2020-11-12T19:27:48Z", "message": "Addressed feedback 2\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f8fd323edb4583b79f3f5907f01a353a806cb33", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8f8fd323edb4583b79f3f5907f01a353a806cb33", "committedDate": "2020-11-12T19:27:48Z", "message": "Cleaned up object rename leftover\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7968b291b082964abae72b59aef354d392895d0b", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7968b291b082964abae72b59aef354d392895d0b", "committedDate": "2020-11-12T19:27:48Z", "message": "Fix code smells\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "committedDate": "2020-11-12T19:27:48Z", "message": "Substitued java magration for sql migration w cte. Added entity_type to t_transaction_types\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "committedDate": "2020-11-12T19:30:06Z", "message": "Updated migration number\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c8d5ee67a51ba66ad9a9a56aa3a35e779def1132", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c8d5ee67a51ba66ad9a9a56aa3a35e779def1132", "committedDate": "2020-11-12T05:32:10Z", "message": "Substitued java magration for sql migration w cte. Added entity_type to t_transaction_types\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}, "afterCommit": {"oid": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "committedDate": "2020-11-12T19:30:06Z", "message": "Updated migration number\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NDI5ODk0", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-529429894", "createdAt": "2020-11-12T19:35:28Z", "commit": {"oid": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTozNToyOFrOHyLABg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTozNToyOFrOHyLABg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MTA3OA==", "bodyText": "This class name no longer matches the sql name", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r522371078", "createdAt": "2020-11-12T19:35:28Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.io.File;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.jdbc.core.JdbcOperations;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.1\")\n+class V_1_31_2__Entity_Type_MismatchTest extends IntegrationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb54c5cd7c18de9194a270cf03f86315c332e3b7", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cb54c5cd7c18de9194a270cf03f86315c332e3b7", "committedDate": "2020-11-12T20:30:47Z", "message": "Renamed test class to match sql\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NDc1MTUx", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-529475151", "createdAt": "2020-11-12T20:33:15Z", "commit": {"oid": "cb54c5cd7c18de9194a270cf03f86315c332e3b7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NDc2MjA0", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-529476204", "createdAt": "2020-11-12T20:34:52Z", "commit": {"oid": "cb54c5cd7c18de9194a270cf03f86315c332e3b7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTA2NTIy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#pullrequestreview-529506522", "createdAt": "2020-11-12T21:21:10Z", "commit": {"oid": "cb54c5cd7c18de9194a270cf03f86315c332e3b7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3493, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}