{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NzEyNzgz", "number": 1302, "title": "Add gRPC and REST subscriber to monitor", "bodyText": "Detailed description:\n\nAdd gRPC API subscription to validate HCS message stream\nAdd REST API subscription to validate transactions show up via /api/v1/transactions/{transactionId}\nAdd hedera.mirror.monitor.subscribe metric to track end to end latency\nAdd mirror node host configuration with defaults for common environments\nAdd new testnet node 0.0.7\nAdd support for completing a scenario while another continues\nAdd support for retrieving a percentage of record or receipts\nChange monitor flow from Spring Integration to Project Reactor for backpressure support and easier development\nFix busy loop when all publish scenarios complete\nFix error prone timestamp extraction by removing unnecessary base64 encoding\nFix inaccurate HCS message size generation\nFix the GitHub Actions warning git checkout HEAD^2 is no longer necessary\nFix gRPC topic subscription printing Subscribing: twice\nFix replacer not updating monitor docker image\nImprove slow startup by deferring connection to main nodes until later\nImprove publisher performance by caching fields, disabling SDK retry and using round robin instead of random for connection selection\n\nWhich issue(s) this PR fixes:\nFixes #1217\nSpecial notes for your reviewer:\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-11-30T17:54:13Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302", "merged": true, "mergeCommit": {"oid": "85f30d0aaca6ead3949a722027cb8af2453dc8d4"}, "closed": true, "closedAt": "2020-12-03T20:34:56Z", "author": {"login": "steven-sheehy"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdhyorKgFqTU0MTQ1MTY2Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdipPiEAFqTU0NDQwNDE2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNDUxNjYy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-541451662", "createdAt": "2020-12-01T02:52:35Z", "commit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMjo1MjozNVrOH8WJcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNDo0OTozNVrOH8YFRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQ3NQ==", "bodyText": "nit: should this rather be not equal?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533039475", "createdAt": "2020-12-01T02:52:35Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/common/Utility.java", "diffHunk": "@@ -30,12 +31,25 @@\n @UtilityClass\n public class Utility {\n \n+    public static Long getDecodedTimestamp(byte[] bytes) {\n+        if (bytes == null || bytes.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] decoded = Base64.getDecoder().decode(bytes);\n+        if (decoded.length < Long.BYTES) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3MDI2MQ==", "bodyText": "nit: I think we should start to make it a practice of commenting on multi stage reactive flows.\nThey tend to be the places where order is important and where logic is swapped in and out.\nSo it would help for future management to be clear on the choices applied here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533070261", "createdAt": "2020-12-01T04:46:05Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/config/MonitorConfiguration.java", "diffHunk": "@@ -48,12 +48,17 @@\n     @Resource\n     private TransactionPublisher transactionPublisher;\n \n+    @Resource\n+    private Subscriber subscriber;\n+\n     @Bean\n-    IntegrationFlow publishFlow() {\n-        return IntegrationFlows\n-                .from(new ReactiveMessageSourceProducer(() -> new GenericMessage<>(transactionGenerator.next())))\n-                .channel(c -> c.executor(Executors.newFixedThreadPool(publishProperties.getConnections())))\n-                .handle(PublishRequest.class, (p, h) -> transactionPublisher.publish(p))\n-                .nullChannel();\n+    Disposable publishSubscribe() {\n+        return Flux.<PublishRequest>generate(sink -> sink.next(transactionGenerator.next()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA3MTE3NA==", "bodyText": "This should be moved outside of the for loop and checked once right?\nSince properties doesn't change per scenario and if properties.isEnabled() is false it doesn't matter whether the scenarios are enabled.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533071174", "createdAt": "2020-12-01T04:49:35Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/generator/CompositeTransactionGenerator.java", "diffHunk": "@@ -46,22 +81,18 @@ public CompositeTransactionGenerator(PublishProperties properties) {\n                 .reduce(0.0, (x, y) -> x + y);\n \n         for (ScenarioProperties scenarioProperties : properties.getScenarios()) {\n-            if (scenarioProperties.isEnabled()) {\n+            if (properties.isEnabled() && scenarioProperties.isEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjk0ODM2", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-541294836", "createdAt": "2020-11-30T21:07:07Z", "commit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMTowNzowN1rOH8N3Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNTowMDoyNFrOH8w-TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMzcwMg==", "bodyText": "Is this just to avoid creating the Instant object?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r532903702", "createdAt": "2020-11-30T21:07:07Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/common/Utility.java", "diffHunk": "@@ -30,12 +31,25 @@\n @UtilityClass\n public class Utility {\n \n+    public static Long getDecodedTimestamp(byte[] bytes) {\n+        if (bytes == null || bytes.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] decoded = Base64.getDecoder().decode(bytes);\n+        if (decoded.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] timestampBytes = Arrays.copyOfRange(decoded, 0, Long.BYTES);\n+        return Longs.fromByteArray(timestampBytes);\n+    }\n+\n     public static String getEncodedTimestamp() {\n-        return Base64.getEncoder().encodeToString(Longs.toByteArray(Instant.now().toEpochMilli()));\n+        return Base64.getEncoder().encodeToString(Longs.toByteArray(System.currentTimeMillis()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3NjY2OQ==", "bodyText": "Is there a reason to set the receipt here if it's already set in init()?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533476669", "createdAt": "2020-12-01T14:57:34Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-monitor/src/test/java/com/hedera/mirror/monitor/generator/ConfigurableTransactionGeneratorTest.java", "diffHunk": "@@ -84,6 +95,76 @@ void reachedDuration() {\n                 .hasMessageContaining(\"Reached publish duration\");\n     }\n \n+    @Test\n+    void receiptDisabled() {\n+        properties.setReceipt(0);\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            assertThat(generator.get().next())\n+                    .extracting(PublishRequest::isReceipt)\n+                    .isEqualTo(false);\n+        }\n+    }\n+\n+    @Test\n+    void receiptEnabled() {\n+        properties.setReceipt(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ3ODk4OQ==", "bodyText": "Same thing, is there a reason to set the record to the same value set in the init?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533478989", "createdAt": "2020-12-01T15:00:24Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-monitor/src/test/java/com/hedera/mirror/monitor/generator/ConfigurableTransactionGeneratorTest.java", "diffHunk": "@@ -84,6 +95,76 @@ void reachedDuration() {\n                 .hasMessageContaining(\"Reached publish duration\");\n     }\n \n+    @Test\n+    void receiptDisabled() {\n+        properties.setReceipt(0);\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            assertThat(generator.get().next())\n+                    .extracting(PublishRequest::isReceipt)\n+                    .isEqualTo(false);\n+        }\n+    }\n+\n+    @Test\n+    void receiptEnabled() {\n+        properties.setReceipt(100);\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            assertThat(generator.get().next())\n+                    .extracting(PublishRequest::isReceipt)\n+                    .isEqualTo(true);\n+        }\n+    }\n+\n+    @Test\n+    void receiptPercent() {\n+        properties.setReceipt(1);\n+        Multiset<Boolean> receipts = HashMultiset.create();\n+\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            receipts.add(generator.get().next().isReceipt());\n+        }\n+\n+        assertThat((int) (receipts.count(true) * 100.0 / SAMPLE_SIZE))\n+                .isNotNegative()\n+                .isNotZero()\n+                .isCloseTo(properties.getReceipt(), within((int) (SAMPLE_SIZE * 0.05)));\n+    }\n+\n+    @Test\n+    void recordDisabled() {\n+        properties.setRecord(0);\n+        for (int i = 0; i < SAMPLE_SIZE; ++i) {\n+            assertThat(generator.get().next())\n+                    .extracting(PublishRequest::isRecord)\n+                    .isEqualTo(false);\n+        }\n+    }\n+\n+    @Test\n+    void recordEnabled() {\n+        properties.setRecord(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMDM4NDMy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-542038432", "createdAt": "2020-12-01T15:49:39Z", "commit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNTo0OTozOVrOH8zYtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNzowODowNlrOH83BWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxODUxOA==", "bodyText": "can catch IllegalArgumentException which is thrown if bytes has fewer than 8 elements", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533518518", "createdAt": "2020-12-01T15:49:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/common/Utility.java", "diffHunk": "@@ -30,12 +31,25 @@\n @UtilityClass\n public class Utility {\n \n+    public static Long getDecodedTimestamp(byte[] bytes) {\n+        if (bytes == null || bytes.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] decoded = Base64.getDecoder().decode(bytes);\n+        if (decoded.length < Long.BYTES) {\n+            return null;\n+        }\n+\n+        byte[] timestampBytes = Arrays.copyOfRange(decoded, 0, Long.BYTES);\n+        return Longs.fromByteArray(timestampBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU1Mzk0MA==", "bodyText": "double acquire for the first PublishRequest, is this intended?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533553940", "createdAt": "2020-12-01T16:35:16Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/generator/ConfigurableTransactionGenerator.java", "diffHunk": "@@ -42,30 +42,44 @@ public ConfigurableTransactionGenerator(ScenarioProperties properties) {\n         this.properties = properties;\n         this.transactionSupplier = convert(properties);\n         this.rateLimiter = RateLimiter.create(properties.getTps());\n-        remaining = new AtomicLong(properties.getLimit() > 0 ? properties.getLimit() : Long.MAX_VALUE);\n+        remaining = new AtomicLong(properties.getLimit());\n         stopTime = System.nanoTime() + properties.getDuration().toNanos();\n         builder = PublishRequest.builder()\n-                .record(properties.isRecord())\n-                .receipt(properties.isReceipt())\n+                .logResponse(properties.isLogResponse())\n                 .type(properties.getType());\n-        log.info(\"Initializing scenario: {}\", properties);\n+        rateLimiter.acquire();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2MzE0MQ==", "bodyText": "this is percent + 1 out of 100  when percent is not 0 or 100. (count % 100) < percent should work and no special handling of 0 and 100 is needed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533563141", "createdAt": "2020-12-01T16:47:34Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/generator/ConfigurableTransactionGenerator.java", "diffHunk": "@@ -42,30 +42,44 @@ public ConfigurableTransactionGenerator(ScenarioProperties properties) {\n         this.properties = properties;\n         this.transactionSupplier = convert(properties);\n         this.rateLimiter = RateLimiter.create(properties.getTps());\n-        remaining = new AtomicLong(properties.getLimit() > 0 ? properties.getLimit() : Long.MAX_VALUE);\n+        remaining = new AtomicLong(properties.getLimit());\n         stopTime = System.nanoTime() + properties.getDuration().toNanos();\n         builder = PublishRequest.builder()\n-                .record(properties.isRecord())\n-                .receipt(properties.isReceipt())\n+                .logResponse(properties.isLogResponse())\n                 .type(properties.getType());\n-        log.info(\"Initializing scenario: {}\", properties);\n+        rateLimiter.acquire();\n     }\n \n     @Override\n     public PublishRequest next() {\n-        if (remaining.getAndDecrement() <= 0) {\n-            throw new ScenarioException(\"Reached publish limit of \" + properties.getLimit());\n+        rateLimiter.acquire();\n+        long count = remaining.getAndDecrement();\n+\n+        if (count <= 0) {\n+            throw new ScenarioException(properties, \"Reached publish limit of \" + properties.getLimit());\n         }\n \n         if (stopTime - System.nanoTime() <= 0) {\n-            throw new ScenarioException(\"Reached publish duration of \" + properties.getDuration());\n+            throw new ScenarioException(properties, \"Reached publish duration of \" + properties.getDuration());\n         }\n \n-        rateLimiter.acquire();\n-        return builder.transactionBuilder(transactionSupplier.get()).build();\n+        return builder.receipt(shouldGenerate(properties.getReceipt(), count))\n+                .record(shouldGenerate(properties.getRecord(), count))\n+                .transactionBuilder(transactionSupplier.get())\n+                .build();\n     }\n \n     private TransactionSupplier<?> convert(ScenarioProperties p) {\n         return new ObjectMapper().convertValue(p.getProperties(), p.getType().getSupplier());\n     }\n+\n+    private boolean shouldGenerate(int percent, long count) {\n+        if (percent <= 0) {\n+            return false;\n+        } else if (percent >= 100) {\n+            return true;\n+        } else {\n+            return (count % 100) <= percent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3MjQyNw==", "bodyText": "subscriberProperties.getLimit() - counter.get() can be negative when subscriberProperties.getLimit() is 0 and counter is not 0\nlimit should be set 0 if getLimit() is 0; otherwise it should be set to getLimit() - counter.get()", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533572427", "createdAt": "2020-12-01T17:00:03Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/subscribe/GrpcSubscriber.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package com.hedera.mirror.monitor.subscribe;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static io.grpc.Status.Code.INVALID_ARGUMENT;\n+import static io.grpc.Status.Code.NOT_FOUND;\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ConcurrentHashMultiset;\n+import com.google.common.collect.Multiset;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Timer;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.PreDestroy;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.math3.util.Precision;\n+\n+import com.hedera.datagenerator.common.Utility;\n+import com.hedera.datagenerator.sdk.supplier.TransactionType;\n+import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n+import com.hedera.hashgraph.sdk.mirror.MirrorClient;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicQuery;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicResponse;\n+import com.hedera.hashgraph.sdk.mirror.MirrorSubscriptionHandle;\n+import com.hedera.mirror.monitor.MonitorProperties;\n+import com.hedera.mirror.monitor.publish.PublishResponse;\n+\n+@Log4j2\n+public class GrpcSubscriber implements Subscriber {\n+\n+    private final MonitorProperties monitorProperties;\n+    private final GrpcSubscriberProperties subscriberProperties;\n+    private final Timer timer;\n+\n+    private final MirrorClient mirrorClient;\n+    private final AtomicLong counter;\n+    private final AtomicLong retries;\n+    private final Stopwatch stopwatch;\n+    private final Multiset<String> errors;\n+    private final ScheduledFuture<?> statusThread;\n+\n+    private MirrorSubscriptionHandle subscription;\n+    private volatile MirrorConsensusTopicResponse lastReceived;\n+    private Instant endTime;\n+\n+    GrpcSubscriber(MeterRegistry meterRegistry, MonitorProperties monitorProperties,\n+                   GrpcSubscriberProperties subscriberProperties) {\n+        this.monitorProperties = monitorProperties;\n+        this.subscriberProperties = subscriberProperties;\n+        this.counter = new AtomicLong(0L);\n+        this.retries = new AtomicLong(0L);\n+        stopwatch = Stopwatch.createStarted();\n+        errors = ConcurrentHashMultiset.create();\n+        this.timer = Timer.builder(\"hedera.mirror.monitor.subscribe\")\n+                .tag(\"api\", \"grpc\")\n+                .tag(\"type\", TransactionType.CONSENSUS_SUBMIT_MESSAGE.toString())\n+                .register(meterRegistry);\n+\n+        statusThread = Executors.newSingleThreadScheduledExecutor()\n+                .scheduleWithFixedDelay(this::status, 5, 5, TimeUnit.SECONDS);\n+\n+        log.info(\"Connecting to mirror node {}\", monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+        this.mirrorClient = new MirrorClient(monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+        resubscribe();\n+    }\n+\n+    private void onNext(MirrorConsensusTopicResponse topicResponse) {\n+        log.trace(\"Received message #{} with timestamp {}\", topicResponse.sequenceNumber,\n+                topicResponse.consensusTimestamp);\n+\n+        if (lastReceived != null) {\n+            long expected = lastReceived.sequenceNumber + 1;\n+            if (topicResponse.sequenceNumber != expected) {\n+                log.warn(\"Expected sequence number {} but received {}\", expected, topicResponse.sequenceNumber);\n+            }\n+        }\n+\n+        Long timestamp = Utility.getDecodedTimestamp(topicResponse.message);\n+        if (timestamp == null || timestamp <= 0 || timestamp >= System.currentTimeMillis()) {\n+            log.warn(\"Invalid timestamp in message: {}\", timestamp);\n+            return;\n+        }\n+\n+        long latency = System.currentTimeMillis() - timestamp;\n+        timer.record(latency, TimeUnit.MILLISECONDS);\n+        this.lastReceived = topicResponse;\n+        counter.incrementAndGet();\n+    }\n+\n+    private void onError(Throwable t) {\n+        log.error(\"Error subscribing: \", t);\n+        errors.add(getStatusCode(t).name());\n+\n+        if (shouldRetry(t)) {\n+            long delayMillis = retries.get() * subscriberProperties.getDelayMultiplier().toMillis();\n+            Duration retry = Duration.ofMillis(Math.min(delayMillis, subscriberProperties.getDelayMax().toMillis()));\n+            log.info(\"Retrying in {}s\", retry.toSeconds());\n+            Uninterruptibles.sleepUninterruptibly(retry);\n+            resubscribe();\n+        } else {\n+            close();\n+        }\n+    }\n+\n+    private boolean shouldRetry(Throwable t) {\n+        Status.Code code = getStatusCode(t);\n+\n+        if (code == INVALID_ARGUMENT || code == NOT_FOUND) {\n+            return false;\n+        }\n+\n+        return retries.incrementAndGet() < subscriberProperties.getRetries();\n+    }\n+\n+    private Status.Code getStatusCode(Throwable t) {\n+        if (t instanceof StatusRuntimeException) {\n+            return ((StatusRuntimeException) t).getStatus().getCode();\n+        }\n+        return Status.Code.UNKNOWN;\n+    }\n+\n+    @Override\n+    public void onPublish(PublishResponse response) {\n+        // Ignore for now\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        try {\n+            log.info(\"Closing mirror node connection to {}\", monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+            subscription.unsubscribe();\n+            mirrorClient.close(1, TimeUnit.SECONDS);\n+            statusThread.cancel(true);\n+        } catch (Exception e) {\n+            // Ignore\n+        }\n+    }\n+\n+    private synchronized void resubscribe() {\n+        MirrorConsensusTopicQuery mirrorConsensusTopicQuery = new MirrorConsensusTopicQuery();\n+        mirrorConsensusTopicQuery.setTopicId(ConsensusTopicId.fromString(subscriberProperties.getTopicId()));\n+        mirrorConsensusTopicQuery.setLimit(Math.min(0, subscriberProperties.getLimit() - counter.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU3ODA3NQ==", "bodyText": "endTime should stay the same when it's calculated based on duration; it should not be the current startTime + duration when retrying", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r533578075", "createdAt": "2020-12-01T17:08:06Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/subscribe/GrpcSubscriber.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package com.hedera.mirror.monitor.subscribe;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static io.grpc.Status.Code.INVALID_ARGUMENT;\n+import static io.grpc.Status.Code.NOT_FOUND;\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ConcurrentHashMultiset;\n+import com.google.common.collect.Multiset;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Timer;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.PreDestroy;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.math3.util.Precision;\n+\n+import com.hedera.datagenerator.common.Utility;\n+import com.hedera.datagenerator.sdk.supplier.TransactionType;\n+import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n+import com.hedera.hashgraph.sdk.mirror.MirrorClient;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicQuery;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicResponse;\n+import com.hedera.hashgraph.sdk.mirror.MirrorSubscriptionHandle;\n+import com.hedera.mirror.monitor.MonitorProperties;\n+import com.hedera.mirror.monitor.publish.PublishResponse;\n+\n+@Log4j2\n+public class GrpcSubscriber implements Subscriber {\n+\n+    private final MonitorProperties monitorProperties;\n+    private final GrpcSubscriberProperties subscriberProperties;\n+    private final Timer timer;\n+\n+    private final MirrorClient mirrorClient;\n+    private final AtomicLong counter;\n+    private final AtomicLong retries;\n+    private final Stopwatch stopwatch;\n+    private final Multiset<String> errors;\n+    private final ScheduledFuture<?> statusThread;\n+\n+    private MirrorSubscriptionHandle subscription;\n+    private volatile MirrorConsensusTopicResponse lastReceived;\n+    private Instant endTime;\n+\n+    GrpcSubscriber(MeterRegistry meterRegistry, MonitorProperties monitorProperties,\n+                   GrpcSubscriberProperties subscriberProperties) {\n+        this.monitorProperties = monitorProperties;\n+        this.subscriberProperties = subscriberProperties;\n+        this.counter = new AtomicLong(0L);\n+        this.retries = new AtomicLong(0L);\n+        stopwatch = Stopwatch.createStarted();\n+        errors = ConcurrentHashMultiset.create();\n+        this.timer = Timer.builder(\"hedera.mirror.monitor.subscribe\")\n+                .tag(\"api\", \"grpc\")\n+                .tag(\"type\", TransactionType.CONSENSUS_SUBMIT_MESSAGE.toString())\n+                .register(meterRegistry);\n+\n+        statusThread = Executors.newSingleThreadScheduledExecutor()\n+                .scheduleWithFixedDelay(this::status, 5, 5, TimeUnit.SECONDS);\n+\n+        log.info(\"Connecting to mirror node {}\", monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+        this.mirrorClient = new MirrorClient(monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+        resubscribe();\n+    }\n+\n+    private void onNext(MirrorConsensusTopicResponse topicResponse) {\n+        log.trace(\"Received message #{} with timestamp {}\", topicResponse.sequenceNumber,\n+                topicResponse.consensusTimestamp);\n+\n+        if (lastReceived != null) {\n+            long expected = lastReceived.sequenceNumber + 1;\n+            if (topicResponse.sequenceNumber != expected) {\n+                log.warn(\"Expected sequence number {} but received {}\", expected, topicResponse.sequenceNumber);\n+            }\n+        }\n+\n+        Long timestamp = Utility.getDecodedTimestamp(topicResponse.message);\n+        if (timestamp == null || timestamp <= 0 || timestamp >= System.currentTimeMillis()) {\n+            log.warn(\"Invalid timestamp in message: {}\", timestamp);\n+            return;\n+        }\n+\n+        long latency = System.currentTimeMillis() - timestamp;\n+        timer.record(latency, TimeUnit.MILLISECONDS);\n+        this.lastReceived = topicResponse;\n+        counter.incrementAndGet();\n+    }\n+\n+    private void onError(Throwable t) {\n+        log.error(\"Error subscribing: \", t);\n+        errors.add(getStatusCode(t).name());\n+\n+        if (shouldRetry(t)) {\n+            long delayMillis = retries.get() * subscriberProperties.getDelayMultiplier().toMillis();\n+            Duration retry = Duration.ofMillis(Math.min(delayMillis, subscriberProperties.getDelayMax().toMillis()));\n+            log.info(\"Retrying in {}s\", retry.toSeconds());\n+            Uninterruptibles.sleepUninterruptibly(retry);\n+            resubscribe();\n+        } else {\n+            close();\n+        }\n+    }\n+\n+    private boolean shouldRetry(Throwable t) {\n+        Status.Code code = getStatusCode(t);\n+\n+        if (code == INVALID_ARGUMENT || code == NOT_FOUND) {\n+            return false;\n+        }\n+\n+        return retries.incrementAndGet() < subscriberProperties.getRetries();\n+    }\n+\n+    private Status.Code getStatusCode(Throwable t) {\n+        if (t instanceof StatusRuntimeException) {\n+            return ((StatusRuntimeException) t).getStatus().getCode();\n+        }\n+        return Status.Code.UNKNOWN;\n+    }\n+\n+    @Override\n+    public void onPublish(PublishResponse response) {\n+        // Ignore for now\n+    }\n+\n+    @PreDestroy\n+    public void close() {\n+        try {\n+            log.info(\"Closing mirror node connection to {}\", monitorProperties.getMirrorNode().getGrpc().getEndpoint());\n+            subscription.unsubscribe();\n+            mirrorClient.close(1, TimeUnit.SECONDS);\n+            statusThread.cancel(true);\n+        } catch (Exception e) {\n+            // Ignore\n+        }\n+    }\n+\n+    private synchronized void resubscribe() {\n+        MirrorConsensusTopicQuery mirrorConsensusTopicQuery = new MirrorConsensusTopicQuery();\n+        mirrorConsensusTopicQuery.setTopicId(ConsensusTopicId.fromString(subscriberProperties.getTopicId()));\n+        mirrorConsensusTopicQuery.setLimit(Math.min(0, subscriberProperties.getLimit() - counter.get()));\n+\n+        Instant startTime = lastReceived != null ? lastReceived.consensusTimestamp.plusNanos(1) : subscriberProperties\n+                .getStartTime();\n+        startTime = Objects.requireNonNullElseGet(startTime, Instant::now);\n+        mirrorConsensusTopicQuery.setStartTime(startTime);\n+\n+        if (endTime != null) {\n+            mirrorConsensusTopicQuery.setEndTime(endTime);\n+        } else {\n+            Duration duration = subscriberProperties.getDuration();\n+            if (duration != null) {\n+                endTime = startTime.plus(duration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd3daf0add549d45a9f77739dbcae82d6ab515eb"}, "originalPosition": 183}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMjgyODEy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-543282812", "createdAt": "2020-12-02T22:15:21Z", "commit": {"oid": "00c75885a18e47f15900ddc2a054ce588d48fce9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjoxNToyMVrOH9wZlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjoxNToyMVrOH9wZlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxODE2Ng==", "bodyText": "This class was removed as a result of removing the manual bean validation.  It can be added back for the message size check, just a heads up that there may be conflicts.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r534518166", "createdAt": "2020-12-02T22:15:21Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/sdk/supplier/TransactionSupplierException.java", "diffHunk": "@@ -27,4 +27,8 @@\n     public TransactionSupplierException(TransactionSupplier transactionSupplier, List<String> requiredFields) {\n         super(String.format(MESSAGE, transactionSupplier.getClass().getSimpleName(), requiredFields));\n     }\n+\n+    public TransactionSupplierException(String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00c75885a18e47f15900ddc2a054ce588d48fce9"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMjg0ODA2", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-543284806", "createdAt": "2020-12-02T22:18:50Z", "commit": {"oid": "00c75885a18e47f15900ddc2a054ce588d48fce9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjoxODo1MFrOH9wf0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjoxODo1MFrOH9wf0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxOTc2MA==", "bodyText": "Thank you, I think this will really help going forward.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r534519760", "createdAt": "2020-12-02T22:18:50Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/config/MonitorConfiguration.java", "diffHunk": "@@ -51,6 +51,14 @@\n     @Resource\n     private Subscriber subscriber;\n \n+    /**\n+     * Constructs a reactive flow for publishing and subscribing to transactions. The transaction generator will run on\n+     * a single thread and generate transactions as fast as possible. Next, a parallel Flux will concurrently publish\n+     * those transactions to the main nodes. Finally, a subscriber will receive every published transaction response and\n+     * validate whether that transaction was received by the mirror node APIs.\n+     *\n+     * @return the subscribed flux\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00c75885a18e47f15900ddc2a054ce588d48fce9"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMjg1NzA5", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-543285709", "createdAt": "2020-12-02T22:20:25Z", "commit": {"oid": "00c75885a18e47f15900ddc2a054ce588d48fce9"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9621b376c4eb2d2d33db79c3d0d9a12767d614af", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9621b376c4eb2d2d33db79c3d0d9a12767d614af", "committedDate": "2020-12-02T22:44:44Z", "message": "Various publish improvements to monitor\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bcd5eec2790a60f68d0f362a09cc0e69f692958", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9bcd5eec2790a60f68d0f362a09cc0e69f692958", "committedDate": "2020-12-02T22:44:45Z", "message": "Add gRPC and REST subscriber to monitor\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36aae4d6232c3def44a0dc80e622f5acd910560d", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/36aae4d6232c3def44a0dc80e622f5acd910560d", "committedDate": "2020-12-02T22:44:45Z", "message": "Fix the build and normalize retry properties\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0470742b11e645efb03083103c0660a2ff213ce2", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0470742b11e645efb03083103c0660a2ff213ce2", "committedDate": "2020-12-02T22:47:37Z", "message": "Address review feedback\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c63d64c64f3dbe54cf1495ddd2ea7008a8b340fa", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c63d64c64f3dbe54cf1495ddd2ea7008a8b340fa", "committedDate": "2020-12-02T23:20:17Z", "message": "Fix code smells and add a RestSubscriberTest\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00c75885a18e47f15900ddc2a054ce588d48fce9", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/00c75885a18e47f15900ddc2a054ce588d48fce9", "committedDate": "2020-12-01T19:59:06Z", "message": "Address review feedback\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}, "afterCommit": {"oid": "c63d64c64f3dbe54cf1495ddd2ea7008a8b340fa", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c63d64c64f3dbe54cf1495ddd2ea7008a8b340fa", "committedDate": "2020-12-02T23:20:17Z", "message": "Fix code smells and add a RestSubscriberTest\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01880b383ec27021a68274335aab1db00281e55f", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/01880b383ec27021a68274335aab1db00281e55f", "committedDate": "2020-12-03T15:03:48Z", "message": "Fix test\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d419f11ef05f813385d17d154fa251bb45efe0e5", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d419f11ef05f813385d17d154fa251bb45efe0e5", "committedDate": "2020-12-03T15:44:08Z", "message": "Fix test again\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTYzMzcw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-544163370", "createdAt": "2020-12-03T16:44:15Z", "commit": {"oid": "d419f11ef05f813385d17d154fa251bb45efe0e5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo0NDoxNVrOH-mIEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo0NDoxNVrOH-mIEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODQxNg==", "bodyText": "Nit: Should this be marked final if the intent is to never allow retries?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535398416", "createdAt": "2020-12-03T16:44:15Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/sdk/supplier/consensus/ConsensusSubmitMessageTransactionSupplier.java", "diffHunk": "@@ -21,55 +21,72 @@\n  */\n \n import com.google.common.primitives.Longs;\n+import java.nio.charset.StandardCharsets;\n import java.security.SecureRandom;\n-import java.time.Instant;\n import javax.validation.constraints.Min;\n import javax.validation.constraints.NotBlank;\n import lombok.Data;\n-import org.apache.commons.lang3.RandomStringUtils;\n+import lombok.Getter;\n+import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.StringUtils;\n \n-import com.hedera.datagenerator.common.Utility;\n import com.hedera.datagenerator.sdk.supplier.TransactionSupplier;\n+import com.hedera.hashgraph.sdk.HederaThrowable;\n import com.hedera.hashgraph.sdk.consensus.ConsensusMessageSubmitTransaction;\n import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n \n @Data\n public class ConsensusSubmitMessageTransactionSupplier implements TransactionSupplier<ConsensusMessageSubmitTransaction> {\n \n-    private static final SecureRandom RANDOM = new SecureRandom();\n-\n     @Min(1)\n     private long maxTransactionFee = 1_000_000;\n \n     private String message = StringUtils.EMPTY;\n \n-    @Min(1)\n+    @Min(8)\n     private int messageSize = 256;\n \n+    private boolean retry = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d419f11ef05f813385d17d154fa251bb45efe0e5"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTIxODU4", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-544121858", "createdAt": "2020-12-03T16:07:27Z", "commit": {"oid": "d419f11ef05f813385d17d154fa251bb45efe0e5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjowNzoyN1rOH-kVCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo1Mzo1NFrOH-msrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2ODk2OQ==", "bodyText": "nit: think we should set a max on message size?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535368969", "createdAt": "2020-12-03T16:07:27Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-datagenerator/src/main/java/com/hedera/datagenerator/sdk/supplier/consensus/ConsensusSubmitMessageTransactionSupplier.java", "diffHunk": "@@ -21,55 +21,72 @@\n  */\n \n import com.google.common.primitives.Longs;\n+import java.nio.charset.StandardCharsets;\n import java.security.SecureRandom;\n-import java.time.Instant;\n import javax.validation.constraints.Min;\n import javax.validation.constraints.NotBlank;\n import lombok.Data;\n-import org.apache.commons.lang3.RandomStringUtils;\n+import lombok.Getter;\n+import org.apache.commons.lang3.ArrayUtils;\n import org.apache.commons.lang3.StringUtils;\n \n-import com.hedera.datagenerator.common.Utility;\n import com.hedera.datagenerator.sdk.supplier.TransactionSupplier;\n+import com.hedera.hashgraph.sdk.HederaThrowable;\n import com.hedera.hashgraph.sdk.consensus.ConsensusMessageSubmitTransaction;\n import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n \n @Data\n public class ConsensusSubmitMessageTransactionSupplier implements TransactionSupplier<ConsensusMessageSubmitTransaction> {\n \n-    private static final SecureRandom RANDOM = new SecureRandom();\n-\n     @Min(1)\n     private long maxTransactionFee = 1_000_000;\n \n     private String message = StringUtils.EMPTY;\n \n-    @Min(1)\n+    @Min(8)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d419f11ef05f813385d17d154fa251bb45efe0e5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3NzE5MQ==", "bodyText": "q: Do you think the Node Properties would be better located in a config file for easier on the fly modifications should a need arise. That way no code hotfix is needed.\nAll be it I guess should that need arise you could temporarily use the OTHER network and configure it as needed even in the case of test/main/preview net.\nFigured might make it more flexible in config file than java file.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535377191", "createdAt": "2020-12-03T16:17:45Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/HederaNetwork.java", "diffHunk": "@@ -65,7 +74,8 @@\n                 new NodeProperties(\"0.0.3\", \"0.testnet.hedera.com\"),\n                 new NodeProperties(\"0.0.4\", \"1.testnet.hedera.com\"),\n                 new NodeProperties(\"0.0.5\", \"2.testnet.hedera.com\"),\n-                new NodeProperties(\"0.0.6\", \"3.testnet.hedera.com\")\n+                new NodeProperties(\"0.0.6\", \"3.testnet.hedera.com\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d419f11ef05f813385d17d154fa251bb45efe0e5"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQwNzc5MA==", "bodyText": "nit: at most loads probably negligible but might be more accurate to get system mills at start of method and use here.\nJust removing the case of added time if this process is moving slow", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#discussion_r535407790", "createdAt": "2020-12-03T16:53:54Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-monitor/src/main/java/com/hedera/mirror/monitor/subscribe/GrpcSubscriber.java", "diffHunk": "@@ -0,0 +1,205 @@\n+package com.hedera.mirror.monitor.subscribe;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static io.grpc.Status.Code.INVALID_ARGUMENT;\n+import static io.grpc.Status.Code.NOT_FOUND;\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.common.collect.ConcurrentHashMultiset;\n+import com.google.common.collect.Multiset;\n+import com.google.common.util.concurrent.Uninterruptibles;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Timer;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.PreDestroy;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.math3.util.Precision;\n+\n+import com.hedera.datagenerator.common.Utility;\n+import com.hedera.datagenerator.sdk.supplier.TransactionType;\n+import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n+import com.hedera.hashgraph.sdk.mirror.MirrorClient;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicQuery;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicResponse;\n+import com.hedera.hashgraph.sdk.mirror.MirrorSubscriptionHandle;\n+import com.hedera.mirror.monitor.MonitorProperties;\n+import com.hedera.mirror.monitor.publish.PublishResponse;\n+\n+@Log4j2\n+public class GrpcSubscriber implements Subscriber {\n+\n+    private final MonitorProperties monitorProperties;\n+    private final GrpcSubscriberProperties subscriberProperties;\n+    private final Timer timer;\n+\n+    private final MirrorClient mirrorClient;\n+    private final AtomicLong counter;\n+    private final AtomicLong retries;\n+    private final Stopwatch stopwatch;\n+    private final Multiset<String> errors;\n+    private final ScheduledFuture<?> statusThread;\n+\n+    private MirrorSubscriptionHandle subscription;\n+    private volatile MirrorConsensusTopicResponse lastReceived;\n+    private Instant endTime;\n+\n+    GrpcSubscriber(MeterRegistry meterRegistry, MonitorProperties monitorProperties,\n+                   GrpcSubscriberProperties subscriberProperties) {\n+        this.monitorProperties = monitorProperties;\n+        this.subscriberProperties = subscriberProperties;\n+        this.counter = new AtomicLong(0L);\n+        this.retries = new AtomicLong(0L);\n+        stopwatch = Stopwatch.createStarted();\n+        errors = ConcurrentHashMultiset.create();\n+        this.timer = Timer.builder(METRIC_NAME)\n+                .tag(\"api\", \"grpc\")\n+                .tag(\"type\", TransactionType.CONSENSUS_SUBMIT_MESSAGE.toString())\n+                .register(meterRegistry);\n+\n+        statusThread = Executors.newSingleThreadScheduledExecutor()\n+                .scheduleWithFixedDelay(this::status, 5, 5, TimeUnit.SECONDS);\n+\n+        String endpoint = monitorProperties.getMirrorNode().getGrpc().getEndpoint();\n+        log.info(\"Connecting to mirror node {}\", endpoint);\n+        this.mirrorClient = new MirrorClient(endpoint);\n+        resubscribe();\n+    }\n+\n+    private void onNext(MirrorConsensusTopicResponse topicResponse) {\n+        counter.incrementAndGet();\n+        log.trace(\"Received message #{} with timestamp {}\", topicResponse.sequenceNumber,\n+                topicResponse.consensusTimestamp);\n+\n+        if (lastReceived != null) {\n+            long expected = lastReceived.sequenceNumber + 1;\n+            if (topicResponse.sequenceNumber != expected) {\n+                log.warn(\"Expected sequence number {} but received {}\", expected, topicResponse.sequenceNumber);\n+            }\n+        }\n+\n+        this.lastReceived = topicResponse;\n+        Long timestamp = Utility.getTimestamp(topicResponse.message);\n+\n+        if (timestamp == null || timestamp <= 0 || timestamp >= System.currentTimeMillis()) {\n+            log.warn(\"Invalid timestamp in message: {}\", timestamp);\n+            return;\n+        }\n+\n+        long latency = System.currentTimeMillis() - timestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d419f11ef05f813385d17d154fa251bb45efe0e5"}, "originalPosition": 117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58a208484d2f7414d930780efbb66ff6df27e150", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/58a208484d2f7414d930780efbb66ff6df27e150", "committedDate": "2020-12-03T18:12:25Z", "message": "Fix 404 not retrying\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MjQ1NjM2", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-544245636", "createdAt": "2020-12-03T18:14:29Z", "commit": {"oid": "58a208484d2f7414d930780efbb66ff6df27e150"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac1550ec3299ce340e84aaeea23f51719848b034", "author": {"user": {"login": "steven-sheehy", "name": "Steven Sheehy"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ac1550ec3299ce340e84aaeea23f51719848b034", "committedDate": "2020-12-03T18:20:07Z", "message": "Review feedback\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MzYwNDQ4", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-544360448", "createdAt": "2020-12-03T19:59:24Z", "commit": {"oid": "ac1550ec3299ce340e84aaeea23f51719848b034"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NDA0MTY0", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1302#pullrequestreview-544404164", "createdAt": "2020-12-03T20:33:44Z", "commit": {"oid": "ac1550ec3299ce340e84aaeea23f51719848b034"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3379, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}