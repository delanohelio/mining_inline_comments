{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNTM2MzA5", "number": 561, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjo0NToxMlrODjWSXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNzowNDoyOFrODjWfxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzkxOTAwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSMAPITopicSampler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjo0NToxMlrOFvGzmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODozMjo0NVrOFvtC1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODkwNA==", "bodyText": "Did quick diff: https://www.diffchecker.com/syb1aEXH\nWe can easily share the code here.\npublic abstract class SamplerResult<T> {\n   ...\n  private T last;\n  ...\n  abstract Instant getConsensusTimestamp(T t);\n  abstract long getSequenceNumber(T t);\n}", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r384938904", "createdAt": "2020-02-27T06:45:12Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSMAPITopicSampler.java", "diffHunk": "@@ -0,0 +1,197 @@\n+package com.hedera.mirror.grpc.jmeter.sampler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.TextFormat;\n+import com.hederahashgraph.api.proto.java.TopicID;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n+import com.hedera.hashgraph.sdk.mirror.MirrorClient;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicQuery;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicResponse;\n+import com.hedera.hashgraph.sdk.mirror.MirrorSubscriptionHandle;\n+import com.hedera.mirror.api.proto.ConsensusTopicQuery;\n+import com.hedera.mirror.grpc.jmeter.props.MessageListener;\n+import com.hedera.mirror.grpc.util.ProtoUtil;\n+\n+@Log4j2\n+public class HCSMAPITopicSampler implements HCSTopicSampler {\n+\n+    private final ConsensusTopicQuery request;\n+    private final MirrorClient mirrorClient;\n+    private final MirrorConsensusTopicQuery mirrorConsensusTopicQuery;\n+\n+    public HCSMAPITopicSampler(ConsensusTopicQuery request, String mirrorNodeAddress) {\n+        this.request = request;\n+        mirrorClient = new MirrorClient(Objects.requireNonNull(mirrorNodeAddress));\n+        log.info(\"Setup MirrorClient at {}} for request {}\", TextFormat.shortDebugString(request), mirrorNodeAddress);\n+\n+        TopicID topicID = request.getTopicID();\n+        mirrorConsensusTopicQuery = new MirrorConsensusTopicQuery()\n+                .setTopicId(new ConsensusTopicId(topicID.getShardNum(), topicID.getRealmNum(), topicID.getTopicNum()))\n+                .setStartTime(ProtoUtil.fromTimestamp(request.getConsensusStartTime()));\n+\n+        if (request.hasConsensusEndTime()) {\n+            mirrorConsensusTopicQuery.setEndTime(ProtoUtil.fromTimestamp(request.getConsensusEndTime()));\n+        }\n+\n+        if (request.getLimit() > 0) {\n+            mirrorConsensusTopicQuery.setLimit(request.getLimit());\n+        }\n+    }\n+\n+    /**\n+     * Runs single load test thread by calling gRPC Consensus service subscribeTopic endpoint. Success is dependant on\n+     * StreamObserver observing the expected count for historic and incoming messages in the allotted time Returns\n+     * SamplerResult to client\n+     *\n+     * @param messageListener listener properties\n+     * @return Sampler result representing success and observed message counts\n+     */\n+    @Override\n+    public HCSSamplerResult subscribeTopic(MessageListener messageListener) {\n+        log.info(\"Subscribing to topic using MAPI with {}, {}\", () -> TextFormat\n+                .shortDebugString(request), () -> messageListener);\n+\n+        CountDownLatch historicMessagesLatch = new CountDownLatch(messageListener.getHistoricMessagesCount());\n+        CountDownLatch incomingMessagesLatch = new CountDownLatch(messageListener.getFutureMessagesCount());\n+        TopicID topicId = request.getTopicID();\n+        SamplerResult result = new SamplerResult(topicId.getRealmNum(), topicId\n+                .getTopicNum());\n+\n+        SubscriptionResponse subscriptionResponse = new SubscriptionResponse();\n+        MirrorSubscriptionHandle subscription = null;\n+        List<MirrorConsensusTopicResponse> messages = new ArrayList<>();\n+\n+        try {\n+            subscription = mirrorConsensusTopicQuery\n+                    .subscribe(mirrorClient,\n+                            resp -> {\n+                                result.onNext(resp);\n+                                if (result.isHistorical()) {\n+                                    historicMessagesLatch.countDown();\n+                                } else {\n+                                    incomingMessagesLatch.countDown();\n+                                }\n+                            },\n+                            subscriptionResponse::handleThrowable);\n+\n+            subscriptionResponse.setSubscription(subscription);\n+\n+            // await some new messages\n+            if (!historicMessagesLatch.await(messageListener.getMessagesLatchWaitSeconds(), TimeUnit.SECONDS)) {\n+                log.error(\"Historic messages latch count is {}, did not reach zero\", historicMessagesLatch.getCount());\n+                result.setSuccess(false);\n+            }\n+\n+            log.info(\"{} Historic messages obtained in {} ({}/s)\", result.getHistoricalMessageCount(), result\n+                    .getStopwatch(), result.getMessageRate());\n+\n+            if (historicMessagesLatch.getCount() == 0 && !incomingMessagesLatch\n+                    .await(messageListener.getMessagesLatchWaitSeconds(), TimeUnit.SECONDS)) {\n+                log.error(\"incomingMessagesLatch count is {}, did not reach zero\", incomingMessagesLatch.getCount());\n+                result.setSuccess(false);\n+            }\n+\n+            log.info(\"Observed {} historic and {} incoming messages in {} ({}/s): {}\", result\n+                    .getHistoricalMessageCount(), result.getIncomingMessageCount(), result.getStopwatch(), result\n+                    .getMessageRate(), result.isSuccess() ? \"success\" : \"failed\");\n+        } catch (Exception ex) {\n+            log.error(\"Error subscribing to topic\", ex);\n+            throw ex;\n+        } finally {\n+            if (subscription != null) {\n+                subscription.unsubscribe();\n+                log.info(\"Unsubscribed from {}\", subscription);\n+            }\n+\n+            HCSSamplerResult.HCSSamplerResultBuilder builder = HCSSamplerResult.builder()\n+                    .historicalMessageCount(result.historicalMessageCount)\n+                    .incomingMessageCount(result.incomingMessageCount)\n+                    .realmNum(result.realmNum)\n+                    .success(result.success)\n+                    .topicNum(result.topicNum);\n+\n+            if (result.last != null) {\n+                builder.lastConcensusTimestamp(result.last.consensusTimestamp)\n+                        .lastSequenceNumber(result.last.sequenceNumber);\n+            }\n+\n+            return builder.build();\n+        }\n+    }\n+\n+    @Data\n+    public class SamplerResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU2NTM5OA==", "bodyText": "Yeah was thinking about how to share stuff better, hence being in WIP.\nThis is a good suggestions thanks", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r385565398", "createdAt": "2020-02-28T08:32:45Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSMAPITopicSampler.java", "diffHunk": "@@ -0,0 +1,197 @@\n+package com.hedera.mirror.grpc.jmeter.sampler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.TextFormat;\n+import com.hederahashgraph.api.proto.java.TopicID;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.hashgraph.sdk.consensus.ConsensusTopicId;\n+import com.hedera.hashgraph.sdk.mirror.MirrorClient;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicQuery;\n+import com.hedera.hashgraph.sdk.mirror.MirrorConsensusTopicResponse;\n+import com.hedera.hashgraph.sdk.mirror.MirrorSubscriptionHandle;\n+import com.hedera.mirror.api.proto.ConsensusTopicQuery;\n+import com.hedera.mirror.grpc.jmeter.props.MessageListener;\n+import com.hedera.mirror.grpc.util.ProtoUtil;\n+\n+@Log4j2\n+public class HCSMAPITopicSampler implements HCSTopicSampler {\n+\n+    private final ConsensusTopicQuery request;\n+    private final MirrorClient mirrorClient;\n+    private final MirrorConsensusTopicQuery mirrorConsensusTopicQuery;\n+\n+    public HCSMAPITopicSampler(ConsensusTopicQuery request, String mirrorNodeAddress) {\n+        this.request = request;\n+        mirrorClient = new MirrorClient(Objects.requireNonNull(mirrorNodeAddress));\n+        log.info(\"Setup MirrorClient at {}} for request {}\", TextFormat.shortDebugString(request), mirrorNodeAddress);\n+\n+        TopicID topicID = request.getTopicID();\n+        mirrorConsensusTopicQuery = new MirrorConsensusTopicQuery()\n+                .setTopicId(new ConsensusTopicId(topicID.getShardNum(), topicID.getRealmNum(), topicID.getTopicNum()))\n+                .setStartTime(ProtoUtil.fromTimestamp(request.getConsensusStartTime()));\n+\n+        if (request.hasConsensusEndTime()) {\n+            mirrorConsensusTopicQuery.setEndTime(ProtoUtil.fromTimestamp(request.getConsensusEndTime()));\n+        }\n+\n+        if (request.getLimit() > 0) {\n+            mirrorConsensusTopicQuery.setLimit(request.getLimit());\n+        }\n+    }\n+\n+    /**\n+     * Runs single load test thread by calling gRPC Consensus service subscribeTopic endpoint. Success is dependant on\n+     * StreamObserver observing the expected count for historic and incoming messages in the allotted time Returns\n+     * SamplerResult to client\n+     *\n+     * @param messageListener listener properties\n+     * @return Sampler result representing success and observed message counts\n+     */\n+    @Override\n+    public HCSSamplerResult subscribeTopic(MessageListener messageListener) {\n+        log.info(\"Subscribing to topic using MAPI with {}, {}\", () -> TextFormat\n+                .shortDebugString(request), () -> messageListener);\n+\n+        CountDownLatch historicMessagesLatch = new CountDownLatch(messageListener.getHistoricMessagesCount());\n+        CountDownLatch incomingMessagesLatch = new CountDownLatch(messageListener.getFutureMessagesCount());\n+        TopicID topicId = request.getTopicID();\n+        SamplerResult result = new SamplerResult(topicId.getRealmNum(), topicId\n+                .getTopicNum());\n+\n+        SubscriptionResponse subscriptionResponse = new SubscriptionResponse();\n+        MirrorSubscriptionHandle subscription = null;\n+        List<MirrorConsensusTopicResponse> messages = new ArrayList<>();\n+\n+        try {\n+            subscription = mirrorConsensusTopicQuery\n+                    .subscribe(mirrorClient,\n+                            resp -> {\n+                                result.onNext(resp);\n+                                if (result.isHistorical()) {\n+                                    historicMessagesLatch.countDown();\n+                                } else {\n+                                    incomingMessagesLatch.countDown();\n+                                }\n+                            },\n+                            subscriptionResponse::handleThrowable);\n+\n+            subscriptionResponse.setSubscription(subscription);\n+\n+            // await some new messages\n+            if (!historicMessagesLatch.await(messageListener.getMessagesLatchWaitSeconds(), TimeUnit.SECONDS)) {\n+                log.error(\"Historic messages latch count is {}, did not reach zero\", historicMessagesLatch.getCount());\n+                result.setSuccess(false);\n+            }\n+\n+            log.info(\"{} Historic messages obtained in {} ({}/s)\", result.getHistoricalMessageCount(), result\n+                    .getStopwatch(), result.getMessageRate());\n+\n+            if (historicMessagesLatch.getCount() == 0 && !incomingMessagesLatch\n+                    .await(messageListener.getMessagesLatchWaitSeconds(), TimeUnit.SECONDS)) {\n+                log.error(\"incomingMessagesLatch count is {}, did not reach zero\", incomingMessagesLatch.getCount());\n+                result.setSuccess(false);\n+            }\n+\n+            log.info(\"Observed {} historic and {} incoming messages in {} ({}/s): {}\", result\n+                    .getHistoricalMessageCount(), result.getIncomingMessageCount(), result.getStopwatch(), result\n+                    .getMessageRate(), result.isSuccess() ? \"success\" : \"failed\");\n+        } catch (Exception ex) {\n+            log.error(\"Error subscribing to topic\", ex);\n+            throw ex;\n+        } finally {\n+            if (subscription != null) {\n+                subscription.unsubscribe();\n+                log.info(\"Unsubscribed from {}\", subscription);\n+            }\n+\n+            HCSSamplerResult.HCSSamplerResultBuilder builder = HCSSamplerResult.builder()\n+                    .historicalMessageCount(result.historicalMessageCount)\n+                    .incomingMessageCount(result.incomingMessageCount)\n+                    .realmNum(result.realmNum)\n+                    .success(result.success)\n+                    .topicNum(result.topicNum);\n+\n+            if (result.last != null) {\n+                builder.lastConcensusTimestamp(result.last.consensusTimestamp)\n+                        .lastSequenceNumber(result.last.sequenceNumber);\n+            }\n+\n+            return builder.build();\n+        }\n+    }\n+\n+    @Data\n+    public class SamplerResult {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODkwNA=="}, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzkyNzE0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSDirectStubTopicSampler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjo1MDoxMlrOFvG4gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODo1MTo0OVrOFvthcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MDE2Mw==", "bodyText": "duplicate comment. can be shared by moving to interface's method.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r384940163", "createdAt": "2020-02-27T06:50:12Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSDirectStubTopicSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.hedera.mirror.grpc.jmeter.sampler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.TextFormat;\n+import com.hederahashgraph.api.proto.java.Timestamp;\n+import com.hederahashgraph.api.proto.java.TopicID;\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+import java.time.Instant;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.api.proto.ConsensusServiceGrpc;\n+import com.hedera.mirror.api.proto.ConsensusTopicQuery;\n+import com.hedera.mirror.api.proto.ConsensusTopicResponse;\n+import com.hedera.mirror.grpc.jmeter.props.MessageListener;\n+\n+/**\n+ * A test client that will make requests of the Consensus service from the Consensus server\n+ */\n+@Log4j2\n+public class HCSDirectStubTopicSampler implements HCSTopicSampler {\n+\n+    private final ManagedChannel channel;\n+    private final ConsensusServiceGrpc.ConsensusServiceStub asyncStub;\n+    private final ConsensusTopicQuery request;\n+    private boolean canShutdownChannel = true;\n+\n+    public HCSDirectStubTopicSampler(String host, int port, ConsensusTopicQuery request) {\n+        this(ManagedChannelBuilder.forAddress(host, port).usePlaintext(), request);\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannelBuilder<?> channelBuilder, ConsensusTopicQuery request) {\n+        channel = channelBuilder.build();\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannel channel, ConsensusTopicQuery request) {\n+        // prevent channel shutdown in shared case\n+        canShutdownChannel = false;\n+        this.channel = channel;\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3MzIzMw==", "bodyText": "Overloaded the constructor", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r385573233", "createdAt": "2020-02-28T08:51:49Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSDirectStubTopicSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.hedera.mirror.grpc.jmeter.sampler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.TextFormat;\n+import com.hederahashgraph.api.proto.java.Timestamp;\n+import com.hederahashgraph.api.proto.java.TopicID;\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+import java.time.Instant;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.api.proto.ConsensusServiceGrpc;\n+import com.hedera.mirror.api.proto.ConsensusTopicQuery;\n+import com.hedera.mirror.api.proto.ConsensusTopicResponse;\n+import com.hedera.mirror.grpc.jmeter.props.MessageListener;\n+\n+/**\n+ * A test client that will make requests of the Consensus service from the Consensus server\n+ */\n+@Log4j2\n+public class HCSDirectStubTopicSampler implements HCSTopicSampler {\n+\n+    private final ManagedChannel channel;\n+    private final ConsensusServiceGrpc.ConsensusServiceStub asyncStub;\n+    private final ConsensusTopicQuery request;\n+    private boolean canShutdownChannel = true;\n+\n+    public HCSDirectStubTopicSampler(String host, int port, ConsensusTopicQuery request) {\n+        this(ManagedChannelBuilder.forAddress(host, port).usePlaintext(), request);\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannelBuilder<?> channelBuilder, ConsensusTopicQuery request) {\n+        channel = channelBuilder.build();\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannel channel, ConsensusTopicQuery request) {\n+        // prevent channel shutdown in shared case\n+        canShutdownChannel = false;\n+        this.channel = channel;\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MDE2Mw=="}, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MzkzNDY3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSDirectStubTopicSampler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjo1NDozM1rOFvG9KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODo1NjozN1rOFvtpng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MTM1Mw==", "bodyText": "duplicate. can be shared in SamplerResult#printStatus", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r384941353", "createdAt": "2020-02-27T06:54:33Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSDirectStubTopicSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.hedera.mirror.grpc.jmeter.sampler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.TextFormat;\n+import com.hederahashgraph.api.proto.java.Timestamp;\n+import com.hederahashgraph.api.proto.java.TopicID;\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+import java.time.Instant;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.api.proto.ConsensusServiceGrpc;\n+import com.hedera.mirror.api.proto.ConsensusTopicQuery;\n+import com.hedera.mirror.api.proto.ConsensusTopicResponse;\n+import com.hedera.mirror.grpc.jmeter.props.MessageListener;\n+\n+/**\n+ * A test client that will make requests of the Consensus service from the Consensus server\n+ */\n+@Log4j2\n+public class HCSDirectStubTopicSampler implements HCSTopicSampler {\n+\n+    private final ManagedChannel channel;\n+    private final ConsensusServiceGrpc.ConsensusServiceStub asyncStub;\n+    private final ConsensusTopicQuery request;\n+    private boolean canShutdownChannel = true;\n+\n+    public HCSDirectStubTopicSampler(String host, int port, ConsensusTopicQuery request) {\n+        this(ManagedChannelBuilder.forAddress(host, port).usePlaintext(), request);\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannelBuilder<?> channelBuilder, ConsensusTopicQuery request) {\n+        channel = channelBuilder.build();\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannel channel, ConsensusTopicQuery request) {\n+        // prevent channel shutdown in shared case\n+        canShutdownChannel = false;\n+        this.channel = channel;\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Runs single load test thread by calling gRPC Consensus service subscribeTopic endpoint. Success is dependant on\n+     * StreamObserver observing the expected count for historic and incoming messages in the allotted time Returns\n+     * SamplerResult to client\n+     *\n+     * @param messageListener listener properties\n+     * @return Sampler result representing success and observed message counts\n+     */\n+    @Override\n+    public HCSSamplerResult subscribeTopic(MessageListener messageListener) throws InterruptedException {\n+        log.info(\"Subscribing to topic with {}, {}\", () -> TextFormat.shortDebugString(request), () -> messageListener);\n+\n+        CountDownLatch historicMessagesLatch = new CountDownLatch(messageListener.getHistoricMessagesCount());\n+        CountDownLatch incomingMessagesLatch = new CountDownLatch(messageListener.getFutureMessagesCount());\n+        TopicID topicId = request.getTopicID();\n+        SamplerResult result = new SamplerResult(topicId.getRealmNum(), topicId.getTopicNum());\n+        StreamObserver<ConsensusTopicResponse> responseObserver = new StreamObserver<>() {\n+\n+            @Override\n+            public void onNext(ConsensusTopicResponse response) {\n+                result.onNext(response);\n+\n+                if (result.isHistorical()) {\n+                    historicMessagesLatch.countDown();\n+                } else {\n+                    incomingMessagesLatch.countDown();\n+                }\n+            }\n+\n+            @SneakyThrows\n+            @Override\n+            public void onError(Throwable t) {\n+                log.error(\"Error in ConsensusTopicResponse StreamObserver\", t);\n+                throw t;\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+                log.info(\"Observed {} historic and {} incoming messages in {} ({}/s): {}\", result", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NTMyNg==", "bodyText": "Moved to abstract class", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r385575326", "createdAt": "2020-02-28T08:56:37Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSDirectStubTopicSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.hedera.mirror.grpc.jmeter.sampler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.TextFormat;\n+import com.hederahashgraph.api.proto.java.Timestamp;\n+import com.hederahashgraph.api.proto.java.TopicID;\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+import java.time.Instant;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.api.proto.ConsensusServiceGrpc;\n+import com.hedera.mirror.api.proto.ConsensusTopicQuery;\n+import com.hedera.mirror.api.proto.ConsensusTopicResponse;\n+import com.hedera.mirror.grpc.jmeter.props.MessageListener;\n+\n+/**\n+ * A test client that will make requests of the Consensus service from the Consensus server\n+ */\n+@Log4j2\n+public class HCSDirectStubTopicSampler implements HCSTopicSampler {\n+\n+    private final ManagedChannel channel;\n+    private final ConsensusServiceGrpc.ConsensusServiceStub asyncStub;\n+    private final ConsensusTopicQuery request;\n+    private boolean canShutdownChannel = true;\n+\n+    public HCSDirectStubTopicSampler(String host, int port, ConsensusTopicQuery request) {\n+        this(ManagedChannelBuilder.forAddress(host, port).usePlaintext(), request);\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannelBuilder<?> channelBuilder, ConsensusTopicQuery request) {\n+        channel = channelBuilder.build();\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannel channel, ConsensusTopicQuery request) {\n+        // prevent channel shutdown in shared case\n+        canShutdownChannel = false;\n+        this.channel = channel;\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Runs single load test thread by calling gRPC Consensus service subscribeTopic endpoint. Success is dependant on\n+     * StreamObserver observing the expected count for historic and incoming messages in the allotted time Returns\n+     * SamplerResult to client\n+     *\n+     * @param messageListener listener properties\n+     * @return Sampler result representing success and observed message counts\n+     */\n+    @Override\n+    public HCSSamplerResult subscribeTopic(MessageListener messageListener) throws InterruptedException {\n+        log.info(\"Subscribing to topic with {}, {}\", () -> TextFormat.shortDebugString(request), () -> messageListener);\n+\n+        CountDownLatch historicMessagesLatch = new CountDownLatch(messageListener.getHistoricMessagesCount());\n+        CountDownLatch incomingMessagesLatch = new CountDownLatch(messageListener.getFutureMessagesCount());\n+        TopicID topicId = request.getTopicID();\n+        SamplerResult result = new SamplerResult(topicId.getRealmNum(), topicId.getTopicNum());\n+        StreamObserver<ConsensusTopicResponse> responseObserver = new StreamObserver<>() {\n+\n+            @Override\n+            public void onNext(ConsensusTopicResponse response) {\n+                result.onNext(response);\n+\n+                if (result.isHistorical()) {\n+                    historicMessagesLatch.countDown();\n+                } else {\n+                    incomingMessagesLatch.countDown();\n+                }\n+            }\n+\n+            @SneakyThrows\n+            @Override\n+            public void onError(Throwable t) {\n+                log.error(\"Error in ConsensusTopicResponse StreamObserver\", t);\n+                throw t;\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+                log.info(\"Observed {} historic and {} incoming messages in {} ({}/s): {}\", result", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MTM1Mw=="}, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzk0MDUyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSDirectStubTopicSampler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNjo1NzoyNFrOFvHAlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODo1Njo0OVrOFvtqCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MjIzMA==", "bodyText": "from this line to 147, there is lot of common code. Please share code.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r384942230", "createdAt": "2020-02-27T06:57:24Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSDirectStubTopicSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.hedera.mirror.grpc.jmeter.sampler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.TextFormat;\n+import com.hederahashgraph.api.proto.java.Timestamp;\n+import com.hederahashgraph.api.proto.java.TopicID;\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+import java.time.Instant;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.api.proto.ConsensusServiceGrpc;\n+import com.hedera.mirror.api.proto.ConsensusTopicQuery;\n+import com.hedera.mirror.api.proto.ConsensusTopicResponse;\n+import com.hedera.mirror.grpc.jmeter.props.MessageListener;\n+\n+/**\n+ * A test client that will make requests of the Consensus service from the Consensus server\n+ */\n+@Log4j2\n+public class HCSDirectStubTopicSampler implements HCSTopicSampler {\n+\n+    private final ManagedChannel channel;\n+    private final ConsensusServiceGrpc.ConsensusServiceStub asyncStub;\n+    private final ConsensusTopicQuery request;\n+    private boolean canShutdownChannel = true;\n+\n+    public HCSDirectStubTopicSampler(String host, int port, ConsensusTopicQuery request) {\n+        this(ManagedChannelBuilder.forAddress(host, port).usePlaintext(), request);\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannelBuilder<?> channelBuilder, ConsensusTopicQuery request) {\n+        channel = channelBuilder.build();\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannel channel, ConsensusTopicQuery request) {\n+        // prevent channel shutdown in shared case\n+        canShutdownChannel = false;\n+        this.channel = channel;\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Runs single load test thread by calling gRPC Consensus service subscribeTopic endpoint. Success is dependant on\n+     * StreamObserver observing the expected count for historic and incoming messages in the allotted time Returns\n+     * SamplerResult to client\n+     *\n+     * @param messageListener listener properties\n+     * @return Sampler result representing success and observed message counts\n+     */\n+    @Override\n+    public HCSSamplerResult subscribeTopic(MessageListener messageListener) throws InterruptedException {\n+        log.info(\"Subscribing to topic with {}, {}\", () -> TextFormat.shortDebugString(request), () -> messageListener);\n+\n+        CountDownLatch historicMessagesLatch = new CountDownLatch(messageListener.getHistoricMessagesCount());\n+        CountDownLatch incomingMessagesLatch = new CountDownLatch(messageListener.getFutureMessagesCount());\n+        TopicID topicId = request.getTopicID();\n+        SamplerResult result = new SamplerResult(topicId.getRealmNum(), topicId.getTopicNum());\n+        StreamObserver<ConsensusTopicResponse> responseObserver = new StreamObserver<>() {\n+\n+            @Override\n+            public void onNext(ConsensusTopicResponse response) {\n+                result.onNext(response);\n+\n+                if (result.isHistorical()) {\n+                    historicMessagesLatch.countDown();\n+                } else {\n+                    incomingMessagesLatch.countDown();\n+                }\n+            }\n+\n+            @SneakyThrows\n+            @Override\n+            public void onError(Throwable t) {\n+                log.error(\"Error in ConsensusTopicResponse StreamObserver\", t);\n+                throw t;\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+                log.info(\"Observed {} historic and {} incoming messages in {} ({}/s): {}\", result\n+                        .getHistoricalMessageCount(), result.getIncomingMessageCount(), result.getStopwatch(), result\n+                        .getMessageRate(), result.isSuccess() ? \"success\" : \"failed\");\n+            }\n+        };\n+\n+        try {\n+            asyncStub.subscribeTopic(request, responseObserver);\n+\n+            // await some new messages\n+            if (!historicMessagesLatch.await(messageListener.getMessagesLatchWaitSeconds(), TimeUnit.SECONDS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NTQzNQ==", "bodyText": "Done", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r385575435", "createdAt": "2020-02-28T08:56:49Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/sampler/HCSDirectStubTopicSampler.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.hedera.mirror.grpc.jmeter.sampler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.TextFormat;\n+import com.hederahashgraph.api.proto.java.Timestamp;\n+import com.hederahashgraph.api.proto.java.TopicID;\n+import io.grpc.ManagedChannel;\n+import io.grpc.ManagedChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+import java.time.Instant;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import lombok.Data;\n+import lombok.SneakyThrows;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.api.proto.ConsensusServiceGrpc;\n+import com.hedera.mirror.api.proto.ConsensusTopicQuery;\n+import com.hedera.mirror.api.proto.ConsensusTopicResponse;\n+import com.hedera.mirror.grpc.jmeter.props.MessageListener;\n+\n+/**\n+ * A test client that will make requests of the Consensus service from the Consensus server\n+ */\n+@Log4j2\n+public class HCSDirectStubTopicSampler implements HCSTopicSampler {\n+\n+    private final ManagedChannel channel;\n+    private final ConsensusServiceGrpc.ConsensusServiceStub asyncStub;\n+    private final ConsensusTopicQuery request;\n+    private boolean canShutdownChannel = true;\n+\n+    public HCSDirectStubTopicSampler(String host, int port, ConsensusTopicQuery request) {\n+        this(ManagedChannelBuilder.forAddress(host, port).usePlaintext(), request);\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannelBuilder<?> channelBuilder, ConsensusTopicQuery request) {\n+        channel = channelBuilder.build();\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    public HCSDirectStubTopicSampler(ManagedChannel channel, ConsensusTopicQuery request) {\n+        // prevent channel shutdown in shared case\n+        canShutdownChannel = false;\n+        this.channel = channel;\n+        asyncStub = ConsensusServiceGrpc.newStub(channel);\n+        this.request = request;\n+    }\n+\n+    /**\n+     * Runs single load test thread by calling gRPC Consensus service subscribeTopic endpoint. Success is dependant on\n+     * StreamObserver observing the expected count for historic and incoming messages in the allotted time Returns\n+     * SamplerResult to client\n+     *\n+     * @param messageListener listener properties\n+     * @return Sampler result representing success and observed message counts\n+     */\n+    @Override\n+    public HCSSamplerResult subscribeTopic(MessageListener messageListener) throws InterruptedException {\n+        log.info(\"Subscribing to topic with {}, {}\", () -> TextFormat.shortDebugString(request), () -> messageListener);\n+\n+        CountDownLatch historicMessagesLatch = new CountDownLatch(messageListener.getHistoricMessagesCount());\n+        CountDownLatch incomingMessagesLatch = new CountDownLatch(messageListener.getFutureMessagesCount());\n+        TopicID topicId = request.getTopicID();\n+        SamplerResult result = new SamplerResult(topicId.getRealmNum(), topicId.getTopicNum());\n+        StreamObserver<ConsensusTopicResponse> responseObserver = new StreamObserver<>() {\n+\n+            @Override\n+            public void onNext(ConsensusTopicResponse response) {\n+                result.onNext(response);\n+\n+                if (result.isHistorical()) {\n+                    historicMessagesLatch.countDown();\n+                } else {\n+                    incomingMessagesLatch.countDown();\n+                }\n+            }\n+\n+            @SneakyThrows\n+            @Override\n+            public void onError(Throwable t) {\n+                log.error(\"Error in ConsensusTopicResponse StreamObserver\", t);\n+                throw t;\n+            }\n+\n+            @Override\n+            public void onCompleted() {\n+                log.info(\"Observed {} historic and {} incoming messages in {} ({}/s): {}\", result\n+                        .getHistoricalMessageCount(), result.getIncomingMessageCount(), result.getStopwatch(), result\n+                        .getMessageRate(), result.isSuccess() ? \"success\" : \"failed\");\n+            }\n+        };\n+\n+        try {\n+            asyncStub.subscribeTopic(request, responseObserver);\n+\n+            // await some new messages\n+            if (!historicMessagesLatch.await(messageListener.getMessagesLatchWaitSeconds(), TimeUnit.SECONDS)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MjIzMA=="}, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Mzk1MzM0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/handler/PropertiesHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwNzowNDoyOFrOFvHImQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODo1Njo1N1rOFvtqSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0NDI4MQ==", "bodyText": "class comment on need of custom configuration parsing (probably dumb question since am new to these parts of code :) ). But also probably something anyone new would wonder \ud83e\udd14", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r384944281", "createdAt": "2020-02-27T07:04:28Z", "author": {"login": "apeksharma"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/handler/PropertiesHandler.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.hedera.mirror.grpc.jmeter.handler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.jmeter.protocol.java.sampler.JavaSamplerContext;\n+\n+@Log4j2\n+public class PropertiesHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NTQ5OQ==", "bodyText": "Done", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/561#discussion_r385575499", "createdAt": "2020-02-28T08:56:57Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-grpc/src/test/java/com/hedera/mirror/grpc/jmeter/handler/PropertiesHandler.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.hedera.mirror.grpc.jmeter.handler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.jmeter.protocol.java.sampler.JavaSamplerContext;\n+\n+@Log4j2\n+public class PropertiesHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0NDI4MQ=="}, "originalCommit": {"oid": "ca62d3828020c5d7830c82c8eb3b1e488b36eb3e"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1185, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}