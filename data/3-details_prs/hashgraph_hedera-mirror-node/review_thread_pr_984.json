{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNTU3NDQ2", "number": 984, "reviewThreads": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjowOTozOVrOEcJAsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjozMToyNVrOEszNDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTQzMjE4OnYy", "diffSide": "RIGHT", "path": "docker-compose.yml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjowOTozOVrOHGfWrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjo1OTozNFrOHfIpoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NzIxNA==", "bodyText": "Should switch this to use remote tags before merge to master to be consistent", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r476567214", "createdAt": "2020-08-25T16:09:39Z", "author": {"login": "steven-sheehy"}, "path": "docker-compose.yml", "diffHunk": "@@ -46,3 +46,18 @@ services:\n     tty: true\n     ports:\n       - 5551:5551\n+\n+  rosetta:\n+    build:\n+      context: ./hedera-mirror-rosetta\n+      dockerfile: ./Dockerfile", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQwOTYzMw==", "bodyText": "Yes, you are right Steven. At some point, once the hedera-mirror-rosetta is deployed in the mirrornode gcr, this build should be changed to image.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502409633", "createdAt": "2020-10-09T12:59:34Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "docker-compose.yml", "diffHunk": "@@ -46,3 +46,18 @@ services:\n     tty: true\n     ports:\n       - 5551:5551\n+\n+  rosetta:\n+    build:\n+      context: ./hedera-mirror-rosetta\n+      dockerfile: ./Dockerfile", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NzIxNA=="}, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTUwMDUwOnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjoyNjoyM1rOHGgBhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMzozOTozOVrOHfKIqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3ODE4Mg==", "bodyText": "The mirror node can support multiple realms and only hardcodes the shard. If possible, this should be removed and the code made to support multiple realms.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r476578182", "createdAt": "2020-08-25T16:26:23Z", "author": {"login": "steven-sheehy"}, "path": "docs/configuration.md", "diffHunk": "@@ -176,3 +176,30 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.rest.stateproof.streams.network`          | DEMO                    | Which Hedera network to use. Can be either `DEMO`, `MAINNET`, `TESTNET` or `OTHER`             |\n | `hedera.mirror.rest.stateproof.streams.region`           | us-east-1               | The region associated with the bucket                                                          |\n | `hedera.mirror.rest.stateproof.streams.secretKey`        | \"\"                      | The cloud storage secret key                                                                   |\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+\n+The following table lists the available properties along with thteir default values.\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.2                     | The version of the Rosetta interface the implementation adheres to                           |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_api_pass         | The database password the processor uses to connect. **Should be changed from default**        |\n+| `hedera.mirror.rosetta.db.port`                         | 5432                    | The port used to connect to the database                                                       |\n+| `hedera.mirror.rosetta.db.username`                     | mirror_api              | The username the processor uses to connect to the database                                     |\n+| `hedera.mirror.rosetta.nodeVersion`                     | 0                       | The default canonical version of the node runtime                                              |\n+| `hedera.mirror.rosetta.port`                            | 5700                    | The REST API port                                                                              |\n+| `hedera.mirror.rosetta.network`                         | DEMO                    | Which Hedera network to use. Can be either `DEMO`, `MAINNET`, `TESTNET` or `OTHER`             |\n+| `hedera.mirror.rosetta.shard`                           | 0                       | The default shard number that this mirror node participates in                                 |\n+| `hedera.mirror.rosetta.realm`                           | 0                       | The default realm number within the shard                                                      |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQzMzk2Mw==", "bodyText": "We will have to discuss this topic and think about how the Rosetta API can support multiple realms as-well (if possible).", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502433963", "createdAt": "2020-10-09T13:39:39Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "docs/configuration.md", "diffHunk": "@@ -176,3 +176,30 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.rest.stateproof.streams.network`          | DEMO                    | Which Hedera network to use. Can be either `DEMO`, `MAINNET`, `TESTNET` or `OTHER`             |\n | `hedera.mirror.rest.stateproof.streams.region`           | us-east-1               | The region associated with the bucket                                                          |\n | `hedera.mirror.rest.stateproof.streams.secretKey`        | \"\"                      | The cloud storage secret key                                                                   |\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+\n+The following table lists the available properties along with thteir default values.\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.2                     | The version of the Rosetta interface the implementation adheres to                           |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_api_pass         | The database password the processor uses to connect. **Should be changed from default**        |\n+| `hedera.mirror.rosetta.db.port`                         | 5432                    | The port used to connect to the database                                                       |\n+| `hedera.mirror.rosetta.db.username`                     | mirror_api              | The username the processor uses to connect to the database                                     |\n+| `hedera.mirror.rosetta.nodeVersion`                     | 0                       | The default canonical version of the node runtime                                              |\n+| `hedera.mirror.rosetta.port`                            | 5700                    | The REST API port                                                                              |\n+| `hedera.mirror.rosetta.network`                         | DEMO                    | Which Hedera network to use. Can be either `DEMO`, `MAINNET`, `TESTNET` or `OTHER`             |\n+| `hedera.mirror.rosetta.shard`                           | 0                       | The default shard number that this mirror node participates in                                 |\n+| `hedera.mirror.rosetta.realm`                           | 0                       | The default realm number within the shard                                                      |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3ODE4Mg=="}, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTUyNDY4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/services/entity-id-codec/entity_id_codec.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjozMjoxMlrOHGgQeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjozMjoxMlrOHGgQeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4MjAwOQ==", "bodyText": "This name is too generic. Prefer EntityId like Java code.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r476582009", "createdAt": "2020-08-25T16:32:12Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/app/domain/services/entity-id-codec/entity_id_codec.go", "diffHunk": "@@ -0,0 +1,46 @@\n+package entity_id_codec\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+const (\n+\tshardBits  int   = 15\n+\trealmBits  int   = 16\n+\tnumberBits int   = 32\n+\tshardMask  int64 = (int64(1) << shardBits) - 1\n+\trealmMask  int64 = (int64(1) << realmBits) - 1\n+\tnumberMask int64 = (int64(1) << numberBits) - 1\n+)\n+\n+// DecodedData returns the decoded data from the DB ID\n+type DecodedData struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTUzMjgwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/types/account.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjozNDowOVrOHGgVrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjozNDowOVrOHGgVrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4MzM0Mg==", "bodyText": "Can we reuse the EntityId to store this?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r476583342", "createdAt": "2020-08-25T16:34:09Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/app/domain/types/account.go", "diffHunk": "@@ -0,0 +1,81 @@\n+package types\n+\n+import (\n+\t\"fmt\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/services/entity-id-codec\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+)\n+\n+// Account is domain level struct used to represent Rosetta Account\n+type Account struct {\n+\tShard  int64", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTU0NTg0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/services/entity-id-codec/entity_id_codec.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjozNzo0MFrOHGgeCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjozNzo0MFrOHGgeCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4NTQ4Mw==", "bodyText": "It is preferred to not use underscores in package names per Go guidelines. Recommend entityid", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r476585483", "createdAt": "2020-08-25T16:37:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/app/domain/services/entity-id-codec/entity_id_codec.go", "diffHunk": "@@ -0,0 +1,46 @@\n+package entity_id_codec", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTU2OTExOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/types/account.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjo0Mzo0OFrOHGgsgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNjo0Mzo0OFrOHGgsgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4OTE4Ng==", "bodyText": "Would be better if these from/to string methods were centralized in EntityId. Reason is you might need File, Topic or Smart Contract entity IDs or to use the account ID outside of the Account domain", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r476589186", "createdAt": "2020-08-25T16:43:48Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/app/domain/types/account.go", "diffHunk": "@@ -0,0 +1,81 @@\n+package types\n+\n+import (\n+\t\"fmt\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/services/entity-id-codec\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+)\n+\n+// Account is domain level struct used to represent Rosetta Account\n+type Account struct {\n+\tShard  int64\n+\tRealm  int64\n+\tNumber int64\n+}\n+\n+// NewAccountFromEncodedID - creates new instance of Account struct\n+func NewAccountFromEncodedID(encodedID int64) (*Account, error) {\n+\td, err := entity_id_codec.Decode(encodedID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &Account{\n+\t\tShard:  d.ShardNum,\n+\t\tRealm:  d.RealmNum,\n+\t\tNumber: d.EntityNum,\n+\t}, err\n+}\n+\n+// ComputeEncodedID - returns the encoded ID from the Shard, Realm and Number\n+func (a *Account) ComputeEncodedID() (int64, error) {\n+\treturn entity_id_codec.Encode(a.Shard, a.Realm, a.Number)\n+}\n+\n+// FormatToString - returns the string representation of the account\n+func (a *Account) FormatToString() string {\n+\treturn fmt.Sprintf(\"%d.%d.%d\", a.Shard, a.Realm, a.Number)\n+}\n+\n+// FromRosettaAccount populates domain type Account from Rosetta type Account\n+func FromRosettaAccount(rAccount *rTypes.AccountIdentifier) (*Account, *rTypes.Error) {\n+\treturn AccountFromString(rAccount.Address)\n+}\n+\n+// ToRosettaAccount returns Rosetta type Account from the current domain type Account\n+func (a *Account) ToRosettaAccount() *rTypes.AccountIdentifier {\n+\treturn &rTypes.AccountIdentifier{\n+\t\tAddress: a.FormatToString(),\n+\t}\n+}\n+\n+// AccountFromString populates domain type Account from String Account\n+func AccountFromString(account string) (*Account, *rTypes.Error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTY2MTUyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/types/amount.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzowODo0MFrOHGhnmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzowODo0MFrOHGhnmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwNDMxMw==", "bodyText": "Perhaps for consistency it would be better to name all these similar methods across domains the same? That is FromRosetta() and ToRosetta() instead of hardcoding the type on the end.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r476604313", "createdAt": "2020-08-25T17:08:40Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/app/domain/types/amount.go", "diffHunk": "@@ -0,0 +1,32 @@\n+package types\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/config\"\n+\t\"strconv\"\n+)\n+\n+type Amount struct {\n+\tValue int64\n+}\n+\n+// FromRosettaAmount populates domain type Amount from Rosetta type Amount\n+func FromRosettaAmount(rAmount *rTypes.Amount) (*Amount, *rTypes.Error) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3OTY5MjQyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/config/application.yml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNzoxNjoxN1rOHGh6vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMToyNzoyMFrOHfF0RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwOTIxNQ==", "bodyText": "See related comment in docs/configuration.md", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r476609215", "createdAt": "2020-08-25T17:16:17Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/config/application.yml", "diffHunk": "@@ -0,0 +1,17 @@\n+# This file contains application defaults and shouldn't be modified. See docs/configuration.md for how to override.\n+hedera:\n+  mirror:\n+    rosetta:\n+      apiVersion: 1.4.2\n+      db:\n+        host: 127.0.0.1\n+        name: mirror_node\n+        password: mirror_node_pass\n+        port: 5432\n+        username: mirror_node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2MzIwNA==", "bodyText": "Already addressed here,  will be added in a separate PR.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502363204", "createdAt": "2020-10-09T11:27:20Z", "author": {"login": "failfmi"}, "path": "hedera-mirror-rosetta/config/application.yml", "diffHunk": "@@ -0,0 +1,17 @@\n+# This file contains application defaults and shouldn't be modified. See docs/configuration.md for how to override.\n+hedera:\n+  mirror:\n+    rosetta:\n+      apiVersion: 1.4.2\n+      db:\n+        host: 127.0.0.1\n+        name: mirror_node\n+        password: mirror_node_pass\n+        port: 5432\n+        username: mirror_node", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwOTIxNQ=="}, "originalCommit": {"oid": "b0f7dee84496230d33fd80d0b2f883f4755bf157"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDg5NzMzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/Dockerfile", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjo1MDozOVrOHHU83A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo1OTowMlrOHbOjPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ0NTM0MA==", "bodyText": "can use alpine to reduce image size (~90MB vs ~25MB). also change the build image to golang:1.13-alpine", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r477445340", "createdAt": "2020-08-26T16:50:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/Dockerfile", "diffHunk": "@@ -0,0 +1,10 @@\n+FROM golang:1.13 as build\n+WORKDIR /tmp/src/hedera-mirror-rosetta\n+COPY . .\n+RUN go build -o main ./cmd\n+\n+FROM ubuntu:latest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eb29d348df306a5f9d56c1d83a3a705983f4954"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMTk5Nw==", "bodyText": "You are right @xin-hedera. Unfortunately, Rosetta highly recommends the usage of ubuntu-based images.\nLink to resource: https://www.rosetta-api.org/docs/node_deployment.html#ubuntu-image-compatibility", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r498311997", "createdAt": "2020-10-01T14:59:02Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/Dockerfile", "diffHunk": "@@ -0,0 +1,10 @@\n+FROM golang:1.13 as build\n+WORKDIR /tmp/src/hedera-mirror-rosetta\n+COPY . .\n+RUN go build -o main ./cmd\n+\n+FROM ubuntu:latest", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ0NTM0MA=="}, "originalCommit": {"oid": "3eb29d348df306a5f9d56c1d83a3a705983f4954"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NDg5ODQ0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/Dockerfile", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjo1MTowMVrOHHU9ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxNjo1MTowMVrOHHU9ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ0NTUzOQ==", "bodyText": "is it necessary to copy the source code? looks like only config/application.yml is needed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r477445539", "createdAt": "2020-08-26T16:51:01Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/Dockerfile", "diffHunk": "@@ -0,0 +1,10 @@\n+FROM golang:1.13 as build\n+WORKDIR /tmp/src/hedera-mirror-rosetta\n+COPY . .\n+RUN go build -o main ./cmd\n+\n+FROM ubuntu:latest\n+WORKDIR $GOPATH/src/hedera-mirror-rosetta\n+COPY --from=build /tmp/src/hedera-mirror-rosetta/main .\n+COPY . .", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3eb29d348df306a5f9d56c1d83a3a705983f4954"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTI2NzQ2OnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToxNjo0M1rOHIVMAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToxNjo0M1rOHIVMAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5Nzc5NQ==", "bodyText": "default mirror_api_pass is different than the value in config/application.yaml", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478497795", "createdAt": "2020-08-27T15:16:43Z", "author": {"login": "xin-hedera"}, "path": "docs/configuration.md", "diffHunk": "@@ -176,3 +176,32 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.rest.stateproof.streams.network`          | DEMO                    | Which Hedera network to use. Can be either `DEMO`, `MAINNET`, `TESTNET` or `OTHER`             |\n | `hedera.mirror.rest.stateproof.streams.region`           | us-east-1               | The region associated with the bucket                                                          |\n | `hedera.mirror.rest.stateproof.streams.secretKey`        | \"\"                      | The cloud storage secret key                                                                   |\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+3. Environment variables that start with `HEDERA_MIRROR_ROSETTA_` (e.g. `HEDERA_MIRROR_ROSETTA_API_VERSION=1.4.2`)\n+\n+The following table lists the available properties along with their default values.\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.2                     | The version of the Rosetta interface the implementation adheres to                           |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_api_pass         | The database password the processor uses to connect. **Should be changed from default**        |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTI2NzcyOnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToxNjo0NVrOHIVMKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToxNjo0NVrOHIVMKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5NzgzMg==", "bodyText": "default mirror_api is different than the value in config/application.yaml", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478497832", "createdAt": "2020-08-27T15:16:45Z", "author": {"login": "xin-hedera"}, "path": "docs/configuration.md", "diffHunk": "@@ -176,3 +176,32 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.rest.stateproof.streams.network`          | DEMO                    | Which Hedera network to use. Can be either `DEMO`, `MAINNET`, `TESTNET` or `OTHER`             |\n | `hedera.mirror.rest.stateproof.streams.region`           | us-east-1               | The region associated with the bucket                                                          |\n | `hedera.mirror.rest.stateproof.streams.secretKey`        | \"\"                      | The cloud storage secret key                                                                   |\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+3. Environment variables that start with `HEDERA_MIRROR_ROSETTA_` (e.g. `HEDERA_MIRROR_ROSETTA_API_VERSION=1.4.2`)\n+\n+The following table lists the available properties along with their default values.\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.2                     | The version of the Rosetta interface the implementation adheres to                           |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_api_pass         | The database password the processor uses to connect. **Should be changed from default**        |\n+| `hedera.mirror.rosetta.db.port`                         | 5432                    | The port used to connect to the database                                                       |\n+| `hedera.mirror.rosetta.db.username`                     | mirror_api              | The username the processor uses to connect to the database                                     |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTI3NDg0OnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToxODoyOVrOHIVQ0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToxODoyOVrOHIVQ0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQ5OTAyNg==", "bodyText": "network not in alphabetical order, should be placed before nodeVersion", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478499026", "createdAt": "2020-08-27T15:18:29Z", "author": {"login": "xin-hedera"}, "path": "docs/configuration.md", "diffHunk": "@@ -176,3 +176,32 @@ value, it is recommended to only populate overridden properties in the custom `a\n | `hedera.mirror.rest.stateproof.streams.network`          | DEMO                    | Which Hedera network to use. Can be either `DEMO`, `MAINNET`, `TESTNET` or `OTHER`             |\n | `hedera.mirror.rest.stateproof.streams.region`           | us-east-1               | The region associated with the bucket                                                          |\n | `hedera.mirror.rest.stateproof.streams.secretKey`        | \"\"                      | The cloud storage secret key                                                                   |\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+3. Environment variables that start with `HEDERA_MIRROR_ROSETTA_` (e.g. `HEDERA_MIRROR_ROSETTA_API_VERSION=1.4.2`)\n+\n+The following table lists the available properties along with their default values.\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.2                     | The version of the Rosetta interface the implementation adheres to                           |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_api_pass         | The database password the processor uses to connect. **Should be changed from default**        |\n+| `hedera.mirror.rosetta.db.port`                         | 5432                    | The port used to connect to the database                                                       |\n+| `hedera.mirror.rosetta.db.username`                     | mirror_api              | The username the processor uses to connect to the database                                     |\n+| `hedera.mirror.rosetta.nodeVersion`                     | 0                       | The default canonical version of the node runtime                                              |\n+| `hedera.mirror.rosetta.online`                          | true                    | The default online mode of the Rosetta interface                                               |\n+| `hedera.mirror.rosetta.port`                            | 5700                    | The REST API port                                                                              |\n+| `hedera.mirror.rosetta.network`                         | DEMO                    | Which Hedera network to use. Can be either `DEMO`, `MAINNET`, `TESTNET` or `OTHER`             |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTI4ODQ3OnYy", "diffSide": "RIGHT", "path": "docs/rosetta-server.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyMTozNFrOHIVZew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNToyMTozNFrOHIVZew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwMTI0Mw==", "bodyText": "persistance -> persistence", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478501243", "createdAt": "2020-08-27T15:21:34Z", "author": {"login": "xin-hedera"}, "path": "docs/rosetta-server.md", "diffHunk": "@@ -0,0 +1,17 @@\n+# Overview\n+The rosetta server is a REST API complying with the Rosetta API Specification [Rosetta API Specification](https://www.rosetta-api.org/docs/welcome.html). This server enables exchanges (ex. Coinbase) to be able to integrate and work with Hedera Hashgraph. The server is written in Golang and is largely based on [rosetta-sdk-go](https://github.com/coinbase/rosetta-sdk-go).\n+Its main job is to respond to the Rosetta Specified requests, to the extent allowed by Hedera, while fetching information from the mirror node database.\n+\n+## Architecture\n+![Hedera Mirror Node Rosetta API](images/rosetta-server.png)\n+The server is largely based on [rosetta-sdk-go](https://github.com/coinbase/rosetta-sdk-go) provided by Rosetta. It takes care of significant part of the entity model definitions and some of the API work. It assumes the request and response models provided by Rosetta.\n+\n+As General structure the Rosetta API server has 4 main components.\n+### Domain models\n+These are models internal to the system allowing for safe and easy serialization and passing off information. These are ultimately converted to/from Rosetta models or are marshaled from Database records.\n+### Domain Repositories\n+These are repositories used for fetching data from the Mirror node database and Marshaling it into the Domain Models. They are providing an abstraction into the persistance layer and allowing the Services to request the necessary data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTc0NTMyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/account/account.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNzoxNjozNVrOHIZ2-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwODowMTowOFrOHeSfbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU3NDMzMA==", "bodyText": "suggested optimization:\nSELECT * FROM account_balance\nWHERE\n  account_realm_num=? AND\n  account_num=? AND\n  consensus_timestamp <= ?\nORDER BY consensus_timestamp DESC\nLIMIT 1;", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478574330", "createdAt": "2020-08-27T17:16:35Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/account/account.go", "diffHunk": "@@ -0,0 +1,72 @@\n+package account\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistance/postgres/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBeforeConsensusEnd string = \"consensus_timestamp = (SELECT MAX(consensus_timestamp) FROM %s WHERE consensus_timestamp <= %d)\"\n+\tbalanceChangeBetween          string = \"select sum(amount::bigint) as value, count(consensus_timestamp) as number_of_transfers from %s where consensus_timestamp > %d and consensus_timestamp <= %d and entity_id = %d\"\n+)\n+\n+type accountBalance struct {\n+\tConsensusTimestamp int64 `gorm:\"type:bigint;primary_key\"`\n+\tBalance            int64 `gorm:\"type:bigint\"`\n+\tAccountRealmNum    int16 `gorm:\"type:smallint;primary_key\"`\n+\tAccountNum         int32 `gorm:\"type:integer;primary_key\"`\n+}\n+\n+type balanceChange struct {\n+\tValue             int64 `gorm:\"type:bigint\"`\n+\tNumberOfTransfers int64 `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name of the accountBalance to be `account_balance`\n+func (accountBalance) TableName() string {\n+\treturn \"account_balance\"\n+}\n+\n+// AccountRepository struct that has connection to the Database\n+type AccountRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewAccountRepository creates an instance of a TransactionRepository struct. Populates the transaction types and statuses on init\n+func NewAccountRepository(dbClient *gorm.DB) *AccountRepository {\n+\treturn &AccountRepository{\n+\t\tdbClient: dbClient,\n+\t}\n+}\n+\n+// RetrieveBalanceAtBlock returns the balance of the account at a given block (provided by consensusEnd timestamp).\n+// balance = balanceAtLatestBalanceSnapshot + balanceChangeBetweenSnapshotAndBlock\n+func (ar *AccountRepository) RetrieveBalanceAtBlock(addressStr string, consensusEnd int64) (*types.Amount, *rTypes.Error) {\n+\tacc, err := types.AccountFromString(addressStr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tentityID, err1 := acc.ComputeEncodedID()\n+\tif err1 != nil {\n+\t\treturn nil, errors.Errors[errors.InvalidAccount]\n+\t}\n+\n+\t// gets the most recent balance before block\n+\tab := &accountBalance{}\n+\tif ar.dbClient.Where(&accountBalance{AccountRealmNum: int16(acc.Realm), AccountNum: int32(acc.Number)}).Where(fmt.Sprintf(whereClauseBeforeConsensusEnd, ab.TableName(), consensusEnd)).Find(&ab).RecordNotFound() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMjI4Nw==", "bodyText": "Using the suggested optimisation we:\n\ndecreased planning time with 25%\ndecreased execution time with 25%", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r501522287", "createdAt": "2020-10-08T08:01:08Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/account/account.go", "diffHunk": "@@ -0,0 +1,72 @@\n+package account\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistance/postgres/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBeforeConsensusEnd string = \"consensus_timestamp = (SELECT MAX(consensus_timestamp) FROM %s WHERE consensus_timestamp <= %d)\"\n+\tbalanceChangeBetween          string = \"select sum(amount::bigint) as value, count(consensus_timestamp) as number_of_transfers from %s where consensus_timestamp > %d and consensus_timestamp <= %d and entity_id = %d\"\n+)\n+\n+type accountBalance struct {\n+\tConsensusTimestamp int64 `gorm:\"type:bigint;primary_key\"`\n+\tBalance            int64 `gorm:\"type:bigint\"`\n+\tAccountRealmNum    int16 `gorm:\"type:smallint;primary_key\"`\n+\tAccountNum         int32 `gorm:\"type:integer;primary_key\"`\n+}\n+\n+type balanceChange struct {\n+\tValue             int64 `gorm:\"type:bigint\"`\n+\tNumberOfTransfers int64 `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name of the accountBalance to be `account_balance`\n+func (accountBalance) TableName() string {\n+\treturn \"account_balance\"\n+}\n+\n+// AccountRepository struct that has connection to the Database\n+type AccountRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewAccountRepository creates an instance of a TransactionRepository struct. Populates the transaction types and statuses on init\n+func NewAccountRepository(dbClient *gorm.DB) *AccountRepository {\n+\treturn &AccountRepository{\n+\t\tdbClient: dbClient,\n+\t}\n+}\n+\n+// RetrieveBalanceAtBlock returns the balance of the account at a given block (provided by consensusEnd timestamp).\n+// balance = balanceAtLatestBalanceSnapshot + balanceChangeBetweenSnapshotAndBlock\n+func (ar *AccountRepository) RetrieveBalanceAtBlock(addressStr string, consensusEnd int64) (*types.Amount, *rTypes.Error) {\n+\tacc, err := types.AccountFromString(addressStr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tentityID, err1 := acc.ComputeEncodedID()\n+\tif err1 != nil {\n+\t\treturn nil, errors.Errors[errors.InvalidAccount]\n+\t}\n+\n+\t// gets the most recent balance before block\n+\tab := &accountBalance{}\n+\tif ar.dbClient.Where(&accountBalance{AccountRealmNum: int16(acc.Realm), AccountNum: int32(acc.Number)}).Where(fmt.Sprintf(whereClauseBeforeConsensusEnd, ab.TableName(), consensusEnd)).Find(&ab).RecordNotFound() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU3NDMzMA=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjA4OTMzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODo1NjoyOVrOHIdOTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzoyNzo1MFrOHdGYKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYyOTQ1NQ==", "bodyText": "this query is very costly. latest block's index (0-based) can be select count(*)-1 from record_file;\nwe should also further optimize the query, it takes about 690ms on testnet db with about 3150,000 rows and original one with rank and subquery costs ~7000ms", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478629455", "createdAt": "2020-08-27T18:56:29Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI3NTI0Mw==", "bodyText": "We've updated the query to use count approach and not rank. Though we weren't able to benchmark it on a full testnet db yet.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500275243", "createdAt": "2020-10-06T13:27:50Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYyOTQ1NQ=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjEwMDc2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxODo1OTo1MFrOHIdVVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzoyODowNVrOHdGY7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzMTI1NA==", "bodyText": "SELECT count(*)-1\nFROM record_file\nWHERE consensus_end <= (SELECT consensus_end FROM record_file WHERE file_hash = ?)\n\nwe should also further optimize the query.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478631254", "createdAt": "2020-08-27T18:59:50Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI3NTQzOA==", "bodyText": "We've updated the query to use count approach and not rank. Though we weren't able to benchmark it on a full testnet db yet.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500275438", "createdAt": "2020-10-06T13:28:05Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYzMTI1NA=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjIwNDEwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozMTowMFrOHIeU0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozMTowMFrOHIeU0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0NzUwNA==", "bodyText": "Order(\"consensus_end asc\"), there is index on consensus_end but not consensus_start", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478647504", "createdAt": "2020-08-27T19:31:00Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`\n+)\n+\n+type recordFile struct {\n+\tID             int64  `gorm:\"type:bigint;primary_key\"`\n+\tName           string `gorm:\"size:250\"`\n+\tLoadStart      int64  `gorm:\"type:bigint\"`\n+\tLoadEnd        int64  `gorm:\"type:bigint\"`\n+\tFileHash       string `gorm:\"size:96\"`\n+\tPrevHash       string `gorm:\"size:96\"`\n+\tConsensusStart int64  `gorm:\"type:bigint\"`\n+\tConsensusEnd   int64  `gorm:\"type:bigint\"`\n+\tRank           int64  `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name to be `record_file`\n+func (recordFile) TableName() string {\n+\treturn \"record_file\"\n+}\n+\n+// BlockRepository struct that has connection to the Database\n+type BlockRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewBlockRepository creates an instance of a BlockRepository struct\n+func NewBlockRepository(dbClient *gorm.DB) *BlockRepository {\n+\treturn &BlockRepository{dbClient: dbClient}\n+}\n+\n+// FindByIndex retrieves a block by given Index\n+func (br *BlockRepository) FindByIndex(index int64) (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Order(\"consensus_start asc\").Offset(index).First(rf).RecordNotFound() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjIxOTUwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozNTo0NlrOHIeedw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozNTo0NlrOHIeedw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0OTk3NQ==", "bodyText": "no need to query db for parent. parent's filehash is rf.PrevHash and parent's index is rf's index - 1", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478649975", "createdAt": "2020-08-27T19:35:46Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`\n+)\n+\n+type recordFile struct {\n+\tID             int64  `gorm:\"type:bigint;primary_key\"`\n+\tName           string `gorm:\"size:250\"`\n+\tLoadStart      int64  `gorm:\"type:bigint\"`\n+\tLoadEnd        int64  `gorm:\"type:bigint\"`\n+\tFileHash       string `gorm:\"size:96\"`\n+\tPrevHash       string `gorm:\"size:96\"`\n+\tConsensusStart int64  `gorm:\"type:bigint\"`\n+\tConsensusEnd   int64  `gorm:\"type:bigint\"`\n+\tRank           int64  `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name to be `record_file`\n+func (recordFile) TableName() string {\n+\treturn \"record_file\"\n+}\n+\n+// BlockRepository struct that has connection to the Database\n+type BlockRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewBlockRepository creates an instance of a BlockRepository struct\n+func NewBlockRepository(dbClient *gorm.DB) *BlockRepository {\n+\treturn &BlockRepository{dbClient: dbClient}\n+}\n+\n+// FindByIndex retrieves a block by given Index\n+func (br *BlockRepository) FindByIndex(index int64) (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Order(\"consensus_start asc\").Offset(index).First(rf).RecordNotFound() {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\n+\tparentRf, err := br.constructParentRecordFile(rf)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjIyMjk2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozNjo1MVrOHIeglg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozNjo1MVrOHIeglg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MDUxOA==", "bodyText": "same, no need to query db for parent's hash and index", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478650518", "createdAt": "2020-08-27T19:36:51Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`\n+)\n+\n+type recordFile struct {\n+\tID             int64  `gorm:\"type:bigint;primary_key\"`\n+\tName           string `gorm:\"size:250\"`\n+\tLoadStart      int64  `gorm:\"type:bigint\"`\n+\tLoadEnd        int64  `gorm:\"type:bigint\"`\n+\tFileHash       string `gorm:\"size:96\"`\n+\tPrevHash       string `gorm:\"size:96\"`\n+\tConsensusStart int64  `gorm:\"type:bigint\"`\n+\tConsensusEnd   int64  `gorm:\"type:bigint\"`\n+\tRank           int64  `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name to be `record_file`\n+func (recordFile) TableName() string {\n+\treturn \"record_file\"\n+}\n+\n+// BlockRepository struct that has connection to the Database\n+type BlockRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewBlockRepository creates an instance of a BlockRepository struct\n+func NewBlockRepository(dbClient *gorm.DB) *BlockRepository {\n+\treturn &BlockRepository{dbClient: dbClient}\n+}\n+\n+// FindByIndex retrieves a block by given Index\n+func (br *BlockRepository) FindByIndex(index int64) (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Order(\"consensus_start asc\").Offset(index).First(rf).RecordNotFound() {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &types.Block{\n+\t\tIndex:               index,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByHash retrieves a block by a given Hash\n+func (br *BlockRepository) FindByHash(hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjIyNDk1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozNzoyNlrOHIehvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTozNzoyNlrOHIehvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MDgxNQ==", "bodyText": "no need to query db for parent", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478650815", "createdAt": "2020-08-27T19:37:26Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`\n+)\n+\n+type recordFile struct {\n+\tID             int64  `gorm:\"type:bigint;primary_key\"`\n+\tName           string `gorm:\"size:250\"`\n+\tLoadStart      int64  `gorm:\"type:bigint\"`\n+\tLoadEnd        int64  `gorm:\"type:bigint\"`\n+\tFileHash       string `gorm:\"size:96\"`\n+\tPrevHash       string `gorm:\"size:96\"`\n+\tConsensusStart int64  `gorm:\"type:bigint\"`\n+\tConsensusEnd   int64  `gorm:\"type:bigint\"`\n+\tRank           int64  `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name to be `record_file`\n+func (recordFile) TableName() string {\n+\treturn \"record_file\"\n+}\n+\n+// BlockRepository struct that has connection to the Database\n+type BlockRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewBlockRepository creates an instance of a BlockRepository struct\n+func NewBlockRepository(dbClient *gorm.DB) *BlockRepository {\n+\treturn &BlockRepository{dbClient: dbClient}\n+}\n+\n+// FindByIndex retrieves a block by given Index\n+func (br *BlockRepository) FindByIndex(index int64) (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Order(\"consensus_start asc\").Offset(index).First(rf).RecordNotFound() {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &types.Block{\n+\t\tIndex:               index,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByHash retrieves a block by a given Hash\n+func (br *BlockRepository) FindByHash(hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               rf.Rank - 1,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByIdentifier retrieves a block by Index && Hash\n+func (br *BlockRepository) FindByIdentifier(index int64, hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif rf.Rank-1 != index {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjI0MDE4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0MjoxNlrOHIerJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzoyMzo0MlrOHdGL5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MzIyMw==", "bodyText": "nit: genesis block is the first in record_file order by consensus_end asc, it's faster", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478653223", "createdAt": "2020-08-27T19:42:16Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`\n+)\n+\n+type recordFile struct {\n+\tID             int64  `gorm:\"type:bigint;primary_key\"`\n+\tName           string `gorm:\"size:250\"`\n+\tLoadStart      int64  `gorm:\"type:bigint\"`\n+\tLoadEnd        int64  `gorm:\"type:bigint\"`\n+\tFileHash       string `gorm:\"size:96\"`\n+\tPrevHash       string `gorm:\"size:96\"`\n+\tConsensusStart int64  `gorm:\"type:bigint\"`\n+\tConsensusEnd   int64  `gorm:\"type:bigint\"`\n+\tRank           int64  `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name to be `record_file`\n+func (recordFile) TableName() string {\n+\treturn \"record_file\"\n+}\n+\n+// BlockRepository struct that has connection to the Database\n+type BlockRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewBlockRepository creates an instance of a BlockRepository struct\n+func NewBlockRepository(dbClient *gorm.DB) *BlockRepository {\n+\treturn &BlockRepository{dbClient: dbClient}\n+}\n+\n+// FindByIndex retrieves a block by given Index\n+func (br *BlockRepository) FindByIndex(index int64) (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Order(\"consensus_start asc\").Offset(index).First(rf).RecordNotFound() {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &types.Block{\n+\t\tIndex:               index,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByHash retrieves a block by a given Hash\n+func (br *BlockRepository) FindByHash(hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               rf.Rank - 1,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByIdentifier retrieves a block by Index && Hash\n+func (br *BlockRepository) FindByIdentifier(index int64, hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif rf.Rank-1 != index {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               rf.Rank - 1,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// RetrieveGenesis retrieves the genesis block\n+func (br *BlockRepository) RetrieveGenesis() (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Where(&recordFile{PrevHash: genesisPreviousHash}).Find(rf).RecordNotFound() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxOTgwNQ==", "bodyText": "Initially, I wanted to do the query as you suggest, but then I thought that a mirror node can be run to sync record files after timestamp X, so theoretically someone might be running mirror node, not synced from the genesis record file but later point in time. At that point the RetrieveGenesis won't be returning the actual genesis \"block\" (record file) of the network, but rather the first synced \"block\" (record file).\nWe are mitigating this problem by specifying the PrevHash to be 0000..", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r498819805", "createdAt": "2020-10-02T13:26:18Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`\n+)\n+\n+type recordFile struct {\n+\tID             int64  `gorm:\"type:bigint;primary_key\"`\n+\tName           string `gorm:\"size:250\"`\n+\tLoadStart      int64  `gorm:\"type:bigint\"`\n+\tLoadEnd        int64  `gorm:\"type:bigint\"`\n+\tFileHash       string `gorm:\"size:96\"`\n+\tPrevHash       string `gorm:\"size:96\"`\n+\tConsensusStart int64  `gorm:\"type:bigint\"`\n+\tConsensusEnd   int64  `gorm:\"type:bigint\"`\n+\tRank           int64  `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name to be `record_file`\n+func (recordFile) TableName() string {\n+\treturn \"record_file\"\n+}\n+\n+// BlockRepository struct that has connection to the Database\n+type BlockRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewBlockRepository creates an instance of a BlockRepository struct\n+func NewBlockRepository(dbClient *gorm.DB) *BlockRepository {\n+\treturn &BlockRepository{dbClient: dbClient}\n+}\n+\n+// FindByIndex retrieves a block by given Index\n+func (br *BlockRepository) FindByIndex(index int64) (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Order(\"consensus_start asc\").Offset(index).First(rf).RecordNotFound() {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &types.Block{\n+\t\tIndex:               index,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByHash retrieves a block by a given Hash\n+func (br *BlockRepository) FindByHash(hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               rf.Rank - 1,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByIdentifier retrieves a block by Index && Hash\n+func (br *BlockRepository) FindByIdentifier(index int64, hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif rf.Rank-1 != index {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               rf.Rank - 1,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// RetrieveGenesis retrieves the genesis block\n+func (br *BlockRepository) RetrieveGenesis() (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Where(&recordFile{PrevHash: genesisPreviousHash}).Find(rf).RecordNotFound() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MzIyMw=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI3MjEwMQ==", "bodyText": "This problem is reproduced in a couple of other queries. We have created an issue in order to address this bug.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500272101", "createdAt": "2020-10-06T13:23:42Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`\n+)\n+\n+type recordFile struct {\n+\tID             int64  `gorm:\"type:bigint;primary_key\"`\n+\tName           string `gorm:\"size:250\"`\n+\tLoadStart      int64  `gorm:\"type:bigint\"`\n+\tLoadEnd        int64  `gorm:\"type:bigint\"`\n+\tFileHash       string `gorm:\"size:96\"`\n+\tPrevHash       string `gorm:\"size:96\"`\n+\tConsensusStart int64  `gorm:\"type:bigint\"`\n+\tConsensusEnd   int64  `gorm:\"type:bigint\"`\n+\tRank           int64  `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name to be `record_file`\n+func (recordFile) TableName() string {\n+\treturn \"record_file\"\n+}\n+\n+// BlockRepository struct that has connection to the Database\n+type BlockRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewBlockRepository creates an instance of a BlockRepository struct\n+func NewBlockRepository(dbClient *gorm.DB) *BlockRepository {\n+\treturn &BlockRepository{dbClient: dbClient}\n+}\n+\n+// FindByIndex retrieves a block by given Index\n+func (br *BlockRepository) FindByIndex(index int64) (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Order(\"consensus_start asc\").Offset(index).First(rf).RecordNotFound() {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &types.Block{\n+\t\tIndex:               index,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByHash retrieves a block by a given Hash\n+func (br *BlockRepository) FindByHash(hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               rf.Rank - 1,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByIdentifier retrieves a block by Index && Hash\n+func (br *BlockRepository) FindByIdentifier(index int64, hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif rf.Rank-1 != index {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               rf.Rank - 1,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// RetrieveGenesis retrieves the genesis block\n+func (br *BlockRepository) RetrieveGenesis() (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Where(&recordFile{PrevHash: genesisPreviousHash}).Find(rf).RecordNotFound() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MzIyMw=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjI0OTY2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0NTowOFrOHIexNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0NTowOFrOHIexNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1NDc3Mw==", "bodyText": "no need to query parent from db just for its index and hash", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478654773", "createdAt": "2020-08-27T19:45:08Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/block/block.go", "diffHunk": "@@ -0,0 +1,173 @@\n+package block\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestAddRank - Selects row with the latest consensus_start and adds additional info about the position of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t// The information about the position is used as Block Index\n+\tselectLatestAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE consensus_start = (SELECT MAX(consensus_start) FROM %s)`\n+\t// selectByHashAddRank - Selects the row with a given file_hash and adds additional info about the poistion of that row (in terms of order by consensus_start) using the \"rank\" and \"OVER\".\n+\t//The information about the position is used as Block Index\n+\tselectByHashAddRank string = `SELECT * FROM (SELECT *, rank() OVER (ORDER BY consensus_start asc) FROM %s) AS res WHERE res.file_hash ='%s'`\n+)\n+\n+type recordFile struct {\n+\tID             int64  `gorm:\"type:bigint;primary_key\"`\n+\tName           string `gorm:\"size:250\"`\n+\tLoadStart      int64  `gorm:\"type:bigint\"`\n+\tLoadEnd        int64  `gorm:\"type:bigint\"`\n+\tFileHash       string `gorm:\"size:96\"`\n+\tPrevHash       string `gorm:\"size:96\"`\n+\tConsensusStart int64  `gorm:\"type:bigint\"`\n+\tConsensusEnd   int64  `gorm:\"type:bigint\"`\n+\tRank           int64  `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name to be `record_file`\n+func (recordFile) TableName() string {\n+\treturn \"record_file\"\n+}\n+\n+// BlockRepository struct that has connection to the Database\n+type BlockRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewBlockRepository creates an instance of a BlockRepository struct\n+func NewBlockRepository(dbClient *gorm.DB) *BlockRepository {\n+\treturn &BlockRepository{dbClient: dbClient}\n+}\n+\n+// FindByIndex retrieves a block by given Index\n+func (br *BlockRepository) FindByIndex(index int64) (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Order(\"consensus_start asc\").Offset(index).First(rf).RecordNotFound() {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &types.Block{\n+\t\tIndex:               index,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByHash retrieves a block by a given Hash\n+func (br *BlockRepository) FindByHash(hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               rf.Rank - 1,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// FindByIdentifier retrieves a block by Index && Hash\n+func (br *BlockRepository) FindByIdentifier(index int64, hash string) (*types.Block, *rTypes.Error) {\n+\trf, err := br.findRecordFileByHash(hash)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif rf.Rank-1 != index {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\tparentRf, err := br.constructParentRecordFile(rf)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               rf.Rank - 1,\n+\t\tHash:                rf.FileHash,\n+\t\tParentIndex:         parentRf.Rank - 1,\n+\t\tParentHash:          parentRf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// RetrieveGenesis retrieves the genesis block\n+func (br *BlockRepository) RetrieveGenesis() (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Where(&recordFile{PrevHash: genesisPreviousHash}).Find(rf).RecordNotFound() {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\n+\treturn &types.Block{\n+\t\tIndex:               0,\n+\t\tHash:                rf.FileHash,\n+\t\tConsensusStartNanos: rf.ConsensusStart,\n+\t\tConsensusEndNanos:   rf.ConsensusEnd,\n+\t}, nil\n+}\n+\n+// RetrieveLatest retrieves the latest block\n+func (br *BlockRepository) RetrieveLatest() (*types.Block, *rTypes.Error) {\n+\trf := &recordFile{}\n+\tif br.dbClient.Raw(fmt.Sprintf(selectLatestAddRank, rf.TableName(), rf.TableName())).Scan(rf).RecordNotFound() {\n+\t\treturn nil, errors.Errors[errors.BlockNotFound]\n+\t}\n+\n+\tparentRf, err := br.constructParentRecordFile(rf)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjM1NDM1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/addressbook/entry/entry.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDoxNjozOFrOHIfwsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwODozNjo0OVrOHc7yaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3MTAyNQ==", "bodyText": "should really panic?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478671025", "createdAt": "2020-08-27T20:16:38Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/addressbook/entry/entry.go", "diffHunk": "@@ -0,0 +1,88 @@\n+package entry\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\tlatestAddressBookEntries = \"SELECT abe.* FROM %s AS abe JOIN %s AS ab ON ab.start_consensus_timestamp = abe.consensus_timestamp WHERE ab.end_consensus_timestamp IS NULL\"\n+)\n+\n+const (\n+\ttableNameAddressBook      = \"address_book\"\n+\ttableNameAddressBookEntry = \"address_book_entry\"\n+)\n+\n+type addressBookEntry struct {\n+\tId                 int32  `gorm:\"type:integer;primary_key\"`\n+\tConsensusTimestamp int64  `gorm:\"type:bigint\"`\n+\tIp                 string `gorm:\"size:128\"`\n+\tPort               int32  `gorm:\"type:integer\"`\n+\tMemo               string `gorm:\"size:128\"`\n+\tPublicKey          string `gorm:\"size:1024\"`\n+\tNodeId             *int64 `gorm:\"type:bigint\"`\n+\tNodeAccountId      int64  `gorm:\"type:bigint\"`\n+\tNodeCertHash       []byte `gorm:\"type:bytea\"`\n+}\n+\n+func (addressBookEntry) TableName() string {\n+\treturn tableNameAddressBookEntry\n+}\n+\n+// AddressBookEntryRepository struct that has connection to the Database\n+type AddressBookEntryRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// Entries return all found Address Book Entries\n+func (aber *AddressBookEntryRepository) Entries() (*types.AddressBookEntries, *rTypes.Error) {\n+\tdbEntries := aber.retrieveEntries()\n+\n+\tentries := make([]*types.AddressBookEntry, len(dbEntries))\n+\tfor i, e := range dbEntries {\n+\t\tentries[i] = &types.AddressBookEntry{\n+\t\t\tPeerId: e.getPeerId(),\n+\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\"ip\":   e.Ip,\n+\t\t\t\t\"port\": e.Port,\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn &types.AddressBookEntries{\n+\t\tEntries: entries}, nil\n+}\n+\n+func (abe *addressBookEntry) getPeerId() *types.Account {\n+\tif abe.NodeId == nil {\n+\t\tacc, err := types.AccountFromString(abe.Memo)\n+\t\tif err != nil {\n+\t\t\tpanic(fmt.Sprintf(errors.CreateAccountDbIdFailed, abe.Memo))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEwMTczNg==", "bodyText": "You are right. Changing it to throwing Internal Server Errors", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500101736", "createdAt": "2020-10-06T08:36:49Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/addressbook/entry/entry.go", "diffHunk": "@@ -0,0 +1,88 @@\n+package entry\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\tlatestAddressBookEntries = \"SELECT abe.* FROM %s AS abe JOIN %s AS ab ON ab.start_consensus_timestamp = abe.consensus_timestamp WHERE ab.end_consensus_timestamp IS NULL\"\n+)\n+\n+const (\n+\ttableNameAddressBook      = \"address_book\"\n+\ttableNameAddressBookEntry = \"address_book_entry\"\n+)\n+\n+type addressBookEntry struct {\n+\tId                 int32  `gorm:\"type:integer;primary_key\"`\n+\tConsensusTimestamp int64  `gorm:\"type:bigint\"`\n+\tIp                 string `gorm:\"size:128\"`\n+\tPort               int32  `gorm:\"type:integer\"`\n+\tMemo               string `gorm:\"size:128\"`\n+\tPublicKey          string `gorm:\"size:1024\"`\n+\tNodeId             *int64 `gorm:\"type:bigint\"`\n+\tNodeAccountId      int64  `gorm:\"type:bigint\"`\n+\tNodeCertHash       []byte `gorm:\"type:bytea\"`\n+}\n+\n+func (addressBookEntry) TableName() string {\n+\treturn tableNameAddressBookEntry\n+}\n+\n+// AddressBookEntryRepository struct that has connection to the Database\n+type AddressBookEntryRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// Entries return all found Address Book Entries\n+func (aber *AddressBookEntryRepository) Entries() (*types.AddressBookEntries, *rTypes.Error) {\n+\tdbEntries := aber.retrieveEntries()\n+\n+\tentries := make([]*types.AddressBookEntry, len(dbEntries))\n+\tfor i, e := range dbEntries {\n+\t\tentries[i] = &types.AddressBookEntry{\n+\t\t\tPeerId: e.getPeerId(),\n+\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\"ip\":   e.Ip,\n+\t\t\t\t\"port\": e.Port,\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn &types.AddressBookEntries{\n+\t\tEntries: entries}, nil\n+}\n+\n+func (abe *addressBookEntry) getPeerId() *types.Account {\n+\tif abe.NodeId == nil {\n+\t\tacc, err := types.AccountFromString(abe.Memo)\n+\t\tif err != nil {\n+\t\t\tpanic(fmt.Sprintf(errors.CreateAccountDbIdFailed, abe.Memo))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3MTAyNQ=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjM1NTAyOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/addressbook/entry/entry.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDoxNjo0OFrOHIfxCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwODozNjo1N1rOHc7yuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3MTExNQ==", "bodyText": "same as above", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478671115", "createdAt": "2020-08-27T20:16:48Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/addressbook/entry/entry.go", "diffHunk": "@@ -0,0 +1,88 @@\n+package entry\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\tlatestAddressBookEntries = \"SELECT abe.* FROM %s AS abe JOIN %s AS ab ON ab.start_consensus_timestamp = abe.consensus_timestamp WHERE ab.end_consensus_timestamp IS NULL\"\n+)\n+\n+const (\n+\ttableNameAddressBook      = \"address_book\"\n+\ttableNameAddressBookEntry = \"address_book_entry\"\n+)\n+\n+type addressBookEntry struct {\n+\tId                 int32  `gorm:\"type:integer;primary_key\"`\n+\tConsensusTimestamp int64  `gorm:\"type:bigint\"`\n+\tIp                 string `gorm:\"size:128\"`\n+\tPort               int32  `gorm:\"type:integer\"`\n+\tMemo               string `gorm:\"size:128\"`\n+\tPublicKey          string `gorm:\"size:1024\"`\n+\tNodeId             *int64 `gorm:\"type:bigint\"`\n+\tNodeAccountId      int64  `gorm:\"type:bigint\"`\n+\tNodeCertHash       []byte `gorm:\"type:bytea\"`\n+}\n+\n+func (addressBookEntry) TableName() string {\n+\treturn tableNameAddressBookEntry\n+}\n+\n+// AddressBookEntryRepository struct that has connection to the Database\n+type AddressBookEntryRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// Entries return all found Address Book Entries\n+func (aber *AddressBookEntryRepository) Entries() (*types.AddressBookEntries, *rTypes.Error) {\n+\tdbEntries := aber.retrieveEntries()\n+\n+\tentries := make([]*types.AddressBookEntry, len(dbEntries))\n+\tfor i, e := range dbEntries {\n+\t\tentries[i] = &types.AddressBookEntry{\n+\t\t\tPeerId: e.getPeerId(),\n+\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\"ip\":   e.Ip,\n+\t\t\t\t\"port\": e.Port,\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn &types.AddressBookEntries{\n+\t\tEntries: entries}, nil\n+}\n+\n+func (abe *addressBookEntry) getPeerId() *types.Account {\n+\tif abe.NodeId == nil {\n+\t\tacc, err := types.AccountFromString(abe.Memo)\n+\t\tif err != nil {\n+\t\t\tpanic(fmt.Sprintf(errors.CreateAccountDbIdFailed, abe.Memo))\n+\t\t}\n+\t\treturn acc\n+\t}\n+\n+\tdecoded, err := types.NewAccountFromEncodedID(*abe.NodeId)\n+\tif err != nil {\n+\t\tpanic(fmt.Sprintf(errors.CreateAccountDbIdFailed, abe.NodeId))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEwMTgxNw==", "bodyText": "You are right. Changing it to throwing Internal Server Errors", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500101817", "createdAt": "2020-10-06T08:36:57Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/addressbook/entry/entry.go", "diffHunk": "@@ -0,0 +1,88 @@\n+package entry\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\tlatestAddressBookEntries = \"SELECT abe.* FROM %s AS abe JOIN %s AS ab ON ab.start_consensus_timestamp = abe.consensus_timestamp WHERE ab.end_consensus_timestamp IS NULL\"\n+)\n+\n+const (\n+\ttableNameAddressBook      = \"address_book\"\n+\ttableNameAddressBookEntry = \"address_book_entry\"\n+)\n+\n+type addressBookEntry struct {\n+\tId                 int32  `gorm:\"type:integer;primary_key\"`\n+\tConsensusTimestamp int64  `gorm:\"type:bigint\"`\n+\tIp                 string `gorm:\"size:128\"`\n+\tPort               int32  `gorm:\"type:integer\"`\n+\tMemo               string `gorm:\"size:128\"`\n+\tPublicKey          string `gorm:\"size:1024\"`\n+\tNodeId             *int64 `gorm:\"type:bigint\"`\n+\tNodeAccountId      int64  `gorm:\"type:bigint\"`\n+\tNodeCertHash       []byte `gorm:\"type:bytea\"`\n+}\n+\n+func (addressBookEntry) TableName() string {\n+\treturn tableNameAddressBookEntry\n+}\n+\n+// AddressBookEntryRepository struct that has connection to the Database\n+type AddressBookEntryRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// Entries return all found Address Book Entries\n+func (aber *AddressBookEntryRepository) Entries() (*types.AddressBookEntries, *rTypes.Error) {\n+\tdbEntries := aber.retrieveEntries()\n+\n+\tentries := make([]*types.AddressBookEntry, len(dbEntries))\n+\tfor i, e := range dbEntries {\n+\t\tentries[i] = &types.AddressBookEntry{\n+\t\t\tPeerId: e.getPeerId(),\n+\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\"ip\":   e.Ip,\n+\t\t\t\t\"port\": e.Port,\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn &types.AddressBookEntries{\n+\t\tEntries: entries}, nil\n+}\n+\n+func (abe *addressBookEntry) getPeerId() *types.Account {\n+\tif abe.NodeId == nil {\n+\t\tacc, err := types.AccountFromString(abe.Memo)\n+\t\tif err != nil {\n+\t\t\tpanic(fmt.Sprintf(errors.CreateAccountDbIdFailed, abe.Memo))\n+\t\t}\n+\t\treturn acc\n+\t}\n+\n+\tdecoded, err := types.NewAccountFromEncodedID(*abe.NodeId)\n+\tif err != nil {\n+\t\tpanic(fmt.Sprintf(errors.CreateAccountDbIdFailed, abe.NodeId))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3MTExNQ=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjQxMDA4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/addressbook/entry/entry.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDozNDozOVrOHIgTYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjozODoxOVrOHdkj-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3OTkwNg==", "bodyText": "node addresses are parsed from two files in network, with file id 101 and 102 respectively. The major difference:\n\n\n\nfile id\nIP & Port\nPublic Key\n\n\n\n\n101\nY\nN\n\n\n102\nN\nY\n\n\n\nwe need to aggregate the info", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478679906", "createdAt": "2020-08-27T20:34:39Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/addressbook/entry/entry.go", "diffHunk": "@@ -0,0 +1,88 @@\n+package entry\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\tlatestAddressBookEntries = \"SELECT abe.* FROM %s AS abe JOIN %s AS ab ON ab.start_consensus_timestamp = abe.consensus_timestamp WHERE ab.end_consensus_timestamp IS NULL\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2OTc4Ng==", "bodyText": "Public Key is not needed anywhere (even in metadata examples, provided by Rosetta).", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500769786", "createdAt": "2020-10-07T06:38:19Z", "author": {"login": "failfmi"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/addressbook/entry/entry.go", "diffHunk": "@@ -0,0 +1,88 @@\n+package entry\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\tlatestAddressBookEntries = \"SELECT abe.* FROM %s AS abe JOIN %s AS ab ON ab.start_consensus_timestamp = abe.consensus_timestamp WHERE ab.end_consensus_timestamp IS NULL\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3OTkwNg=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjQzMjYwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDo0MTo0NlrOHIghAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMDo0MTo0NlrOHIghAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY4MzM5NQ==", "bodyText": "nit: rename to transactionResult for consistency", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478683395", "createdAt": "2020-08-27T20:41:46Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,211 @@\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistance/postgres/types\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (%s)\"\n+)\n+\n+type transaction struct {\n+\tConsensusNS          int64  `gorm:\"type:bigint;primary_key\"`\n+\tType                 int    `gorm:\"type:smallint\"`\n+\tResult               int    `gorm:\"type:smallint\"`\n+\tPayerAccountID       int64  `gorm:\"type:bigint\"`\n+\tValidStartNS         int64  `gorm:\"type:bigint\"`\n+\tValidDurationSeconds int64  `gorm:\"type:bigint\"`\n+\tNodeAccountID        int64  `gorm:\"type:bigint\"`\n+\tEntityID             int64  `gorm:\"type:bigint\"`\n+\tInitialBalance       int64  `gorm:\"type:bigint\"`\n+\tMaxFee               int64  `gorm:\"type:bigint\"`\n+\tChargedTxFee         int64  `gorm:\"type:bigint\"`\n+\tMemo                 []byte `gorm:\"type:bytea\"`\n+\tTransactionHash      []byte `gorm:\"type:bytea\"`\n+\tTransactionBytes     []byte `gorm:\"type:bytea\"`\n+}\n+\n+type transactionType struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tName    string `gorm:\"size:30\"`\n+}\n+\n+type transactionStatus struct {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjQ5MjA1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTowMDozMVrOHIhGCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMToyMDo1NVrOHcYkXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5Mjg3NA==", "bodyText": "can this query return nothing? if so  t will be with all fields to default value", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478692874", "createdAt": "2020-08-27T21:00:31Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,211 @@\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistance/postgres/types\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (%s)\"\n+)\n+\n+type transaction struct {\n+\tConsensusNS          int64  `gorm:\"type:bigint;primary_key\"`\n+\tType                 int    `gorm:\"type:smallint\"`\n+\tResult               int    `gorm:\"type:smallint\"`\n+\tPayerAccountID       int64  `gorm:\"type:bigint\"`\n+\tValidStartNS         int64  `gorm:\"type:bigint\"`\n+\tValidDurationSeconds int64  `gorm:\"type:bigint\"`\n+\tNodeAccountID        int64  `gorm:\"type:bigint\"`\n+\tEntityID             int64  `gorm:\"type:bigint\"`\n+\tInitialBalance       int64  `gorm:\"type:bigint\"`\n+\tMaxFee               int64  `gorm:\"type:bigint\"`\n+\tChargedTxFee         int64  `gorm:\"type:bigint\"`\n+\tMemo                 []byte `gorm:\"type:bytea\"`\n+\tTransactionHash      []byte `gorm:\"type:bytea\"`\n+\tTransactionBytes     []byte `gorm:\"type:bytea\"`\n+}\n+\n+type transactionType struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tName    string `gorm:\"size:30\"`\n+}\n+\n+type transactionStatus struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tResult  string `gorm:\"size:100\"`\n+}\n+\n+// TableName - Set table name of the Transactions to be `record_file`\n+func (transaction) TableName() string {\n+\treturn \"transaction\"\n+}\n+\n+// TableName - Set table name of the Transaction Types to be `t_transaction_types`\n+func (transactionType) TableName() string {\n+\treturn \"t_transaction_types\"\n+}\n+\n+// TableName - Set table name of the Transaction Statuses to be `t_transaction_results`\n+func (transactionStatus) TableName() string {\n+\treturn \"t_transaction_results\"\n+}\n+\n+func (t *transaction) getHashString() string {\n+\treturn hexUtils.SafeAddHexPrefix(hex.EncodeToString(t.TransactionHash))\n+}\n+\n+// TransactionRepository struct that has connection to the Database\n+type TransactionRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewTransactionRepository creates an instance of a TransactionRepository struct. Populates the transaction types and statuses on init\n+func NewTransactionRepository(dbClient *gorm.DB) *TransactionRepository {\n+\treturn &TransactionRepository{dbClient: dbClient}\n+}\n+\n+// Types returns map of all Transaction Types\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Types() map[int]string {\n+\ttypesArray := tr.retrieveTransactionTypes()\n+\ttMap := make(map[int]string)\n+\tfor _, t := range typesArray {\n+\t\ttMap[t.ProtoID] = t.Name\n+\t}\n+\treturn tMap\n+}\n+\n+// Statuses returns map of all Transaction Statuses\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Statuses() map[int]string {\n+\tstatusesArray := tr.retrieveTransactionStatuses()\n+\tsMap := make(map[int]string)\n+\tfor _, s := range statusesArray {\n+\t\tsMap[s.ProtoID] = s.Result\n+\t}\n+\treturn sMap\n+}\n+\n+func (tr *TransactionRepository) TypesAsArray() []string {\n+\treturn maphelper.GetStringValuesFromIntStringMap(tr.Types())\n+}\n+\n+// FindByTimestamp retrieves Transaction by given timestamp\n+func (tr *TransactionRepository) FindByTimestamp(timestamp int64) *types.Transaction {\n+\tt := transaction{}\n+\ttr.dbClient.Find(&t, timestamp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyNDcwMQ==", "bodyText": "Actually, the FindByTimestamp is no longer used, so I will remove it altogether.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r499524701", "createdAt": "2020-10-05T11:20:55Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,211 @@\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistance/postgres/types\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (%s)\"\n+)\n+\n+type transaction struct {\n+\tConsensusNS          int64  `gorm:\"type:bigint;primary_key\"`\n+\tType                 int    `gorm:\"type:smallint\"`\n+\tResult               int    `gorm:\"type:smallint\"`\n+\tPayerAccountID       int64  `gorm:\"type:bigint\"`\n+\tValidStartNS         int64  `gorm:\"type:bigint\"`\n+\tValidDurationSeconds int64  `gorm:\"type:bigint\"`\n+\tNodeAccountID        int64  `gorm:\"type:bigint\"`\n+\tEntityID             int64  `gorm:\"type:bigint\"`\n+\tInitialBalance       int64  `gorm:\"type:bigint\"`\n+\tMaxFee               int64  `gorm:\"type:bigint\"`\n+\tChargedTxFee         int64  `gorm:\"type:bigint\"`\n+\tMemo                 []byte `gorm:\"type:bytea\"`\n+\tTransactionHash      []byte `gorm:\"type:bytea\"`\n+\tTransactionBytes     []byte `gorm:\"type:bytea\"`\n+}\n+\n+type transactionType struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tName    string `gorm:\"size:30\"`\n+}\n+\n+type transactionStatus struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tResult  string `gorm:\"size:100\"`\n+}\n+\n+// TableName - Set table name of the Transactions to be `record_file`\n+func (transaction) TableName() string {\n+\treturn \"transaction\"\n+}\n+\n+// TableName - Set table name of the Transaction Types to be `t_transaction_types`\n+func (transactionType) TableName() string {\n+\treturn \"t_transaction_types\"\n+}\n+\n+// TableName - Set table name of the Transaction Statuses to be `t_transaction_results`\n+func (transactionStatus) TableName() string {\n+\treturn \"t_transaction_results\"\n+}\n+\n+func (t *transaction) getHashString() string {\n+\treturn hexUtils.SafeAddHexPrefix(hex.EncodeToString(t.TransactionHash))\n+}\n+\n+// TransactionRepository struct that has connection to the Database\n+type TransactionRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewTransactionRepository creates an instance of a TransactionRepository struct. Populates the transaction types and statuses on init\n+func NewTransactionRepository(dbClient *gorm.DB) *TransactionRepository {\n+\treturn &TransactionRepository{dbClient: dbClient}\n+}\n+\n+// Types returns map of all Transaction Types\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Types() map[int]string {\n+\ttypesArray := tr.retrieveTransactionTypes()\n+\ttMap := make(map[int]string)\n+\tfor _, t := range typesArray {\n+\t\ttMap[t.ProtoID] = t.Name\n+\t}\n+\treturn tMap\n+}\n+\n+// Statuses returns map of all Transaction Statuses\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Statuses() map[int]string {\n+\tstatusesArray := tr.retrieveTransactionStatuses()\n+\tsMap := make(map[int]string)\n+\tfor _, s := range statusesArray {\n+\t\tsMap[s.ProtoID] = s.Result\n+\t}\n+\treturn sMap\n+}\n+\n+func (tr *TransactionRepository) TypesAsArray() []string {\n+\treturn maphelper.GetStringValuesFromIntStringMap(tr.Types())\n+}\n+\n+// FindByTimestamp retrieves Transaction by given timestamp\n+func (tr *TransactionRepository) FindByTimestamp(timestamp int64) *types.Transaction {\n+\tt := transaction{}\n+\ttr.dbClient.Find(&t, timestamp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5Mjg3NA=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjQ5NzA4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTowMjowMlrOHIhJBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTowMjowMlrOHIhJBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY5MzYzOQ==", "bodyText": "the constraint in fact is start must not after end. the error message and the constraint do not match", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478693639", "createdAt": "2020-08-27T21:02:02Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,211 @@\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistance/postgres/types\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (%s)\"\n+)\n+\n+type transaction struct {\n+\tConsensusNS          int64  `gorm:\"type:bigint;primary_key\"`\n+\tType                 int    `gorm:\"type:smallint\"`\n+\tResult               int    `gorm:\"type:smallint\"`\n+\tPayerAccountID       int64  `gorm:\"type:bigint\"`\n+\tValidStartNS         int64  `gorm:\"type:bigint\"`\n+\tValidDurationSeconds int64  `gorm:\"type:bigint\"`\n+\tNodeAccountID        int64  `gorm:\"type:bigint\"`\n+\tEntityID             int64  `gorm:\"type:bigint\"`\n+\tInitialBalance       int64  `gorm:\"type:bigint\"`\n+\tMaxFee               int64  `gorm:\"type:bigint\"`\n+\tChargedTxFee         int64  `gorm:\"type:bigint\"`\n+\tMemo                 []byte `gorm:\"type:bytea\"`\n+\tTransactionHash      []byte `gorm:\"type:bytea\"`\n+\tTransactionBytes     []byte `gorm:\"type:bytea\"`\n+}\n+\n+type transactionType struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tName    string `gorm:\"size:30\"`\n+}\n+\n+type transactionStatus struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tResult  string `gorm:\"size:100\"`\n+}\n+\n+// TableName - Set table name of the Transactions to be `record_file`\n+func (transaction) TableName() string {\n+\treturn \"transaction\"\n+}\n+\n+// TableName - Set table name of the Transaction Types to be `t_transaction_types`\n+func (transactionType) TableName() string {\n+\treturn \"t_transaction_types\"\n+}\n+\n+// TableName - Set table name of the Transaction Statuses to be `t_transaction_results`\n+func (transactionStatus) TableName() string {\n+\treturn \"t_transaction_results\"\n+}\n+\n+func (t *transaction) getHashString() string {\n+\treturn hexUtils.SafeAddHexPrefix(hex.EncodeToString(t.TransactionHash))\n+}\n+\n+// TransactionRepository struct that has connection to the Database\n+type TransactionRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewTransactionRepository creates an instance of a TransactionRepository struct. Populates the transaction types and statuses on init\n+func NewTransactionRepository(dbClient *gorm.DB) *TransactionRepository {\n+\treturn &TransactionRepository{dbClient: dbClient}\n+}\n+\n+// Types returns map of all Transaction Types\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Types() map[int]string {\n+\ttypesArray := tr.retrieveTransactionTypes()\n+\ttMap := make(map[int]string)\n+\tfor _, t := range typesArray {\n+\t\ttMap[t.ProtoID] = t.Name\n+\t}\n+\treturn tMap\n+}\n+\n+// Statuses returns map of all Transaction Statuses\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Statuses() map[int]string {\n+\tstatusesArray := tr.retrieveTransactionStatuses()\n+\tsMap := make(map[int]string)\n+\tfor _, s := range statusesArray {\n+\t\tsMap[s.ProtoID] = s.Result\n+\t}\n+\treturn sMap\n+}\n+\n+func (tr *TransactionRepository) TypesAsArray() []string {\n+\treturn maphelper.GetStringValuesFromIntStringMap(tr.Types())\n+}\n+\n+// FindByTimestamp retrieves Transaction by given timestamp\n+func (tr *TransactionRepository) FindByTimestamp(timestamp int64) *types.Transaction {\n+\tt := transaction{}\n+\ttr.dbClient.Find(&t, timestamp)\n+\treturn tr.constructTransaction([]transaction{t})\n+}\n+\n+// FindBetween retrieves all Transactions between the provided start and end timestamp\n+func (tr *TransactionRepository) FindBetween(start int64, end int64) ([]*types.Transaction, *rTypes.Error) {\n+\tif start > end {\n+\t\treturn nil, errors.Errors[errors.StartMustBeBeforeEnd]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjUzOTg3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMToxNTo1MVrOHIhjHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMToxNTo1MVrOHIhjHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcwMDMxOQ==", "bodyText": "query the transaction by hash from transaction table\ncheck if transaction.consensus_ns is in range [consensusStart, consensusEnd]", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478700319", "createdAt": "2020-08-27T21:15:51Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,211 @@\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistance/postgres/types\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (%s)\"\n+)\n+\n+type transaction struct {\n+\tConsensusNS          int64  `gorm:\"type:bigint;primary_key\"`\n+\tType                 int    `gorm:\"type:smallint\"`\n+\tResult               int    `gorm:\"type:smallint\"`\n+\tPayerAccountID       int64  `gorm:\"type:bigint\"`\n+\tValidStartNS         int64  `gorm:\"type:bigint\"`\n+\tValidDurationSeconds int64  `gorm:\"type:bigint\"`\n+\tNodeAccountID        int64  `gorm:\"type:bigint\"`\n+\tEntityID             int64  `gorm:\"type:bigint\"`\n+\tInitialBalance       int64  `gorm:\"type:bigint\"`\n+\tMaxFee               int64  `gorm:\"type:bigint\"`\n+\tChargedTxFee         int64  `gorm:\"type:bigint\"`\n+\tMemo                 []byte `gorm:\"type:bytea\"`\n+\tTransactionHash      []byte `gorm:\"type:bytea\"`\n+\tTransactionBytes     []byte `gorm:\"type:bytea\"`\n+}\n+\n+type transactionType struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tName    string `gorm:\"size:30\"`\n+}\n+\n+type transactionStatus struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tResult  string `gorm:\"size:100\"`\n+}\n+\n+// TableName - Set table name of the Transactions to be `record_file`\n+func (transaction) TableName() string {\n+\treturn \"transaction\"\n+}\n+\n+// TableName - Set table name of the Transaction Types to be `t_transaction_types`\n+func (transactionType) TableName() string {\n+\treturn \"t_transaction_types\"\n+}\n+\n+// TableName - Set table name of the Transaction Statuses to be `t_transaction_results`\n+func (transactionStatus) TableName() string {\n+\treturn \"t_transaction_results\"\n+}\n+\n+func (t *transaction) getHashString() string {\n+\treturn hexUtils.SafeAddHexPrefix(hex.EncodeToString(t.TransactionHash))\n+}\n+\n+// TransactionRepository struct that has connection to the Database\n+type TransactionRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewTransactionRepository creates an instance of a TransactionRepository struct. Populates the transaction types and statuses on init\n+func NewTransactionRepository(dbClient *gorm.DB) *TransactionRepository {\n+\treturn &TransactionRepository{dbClient: dbClient}\n+}\n+\n+// Types returns map of all Transaction Types\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Types() map[int]string {\n+\ttypesArray := tr.retrieveTransactionTypes()\n+\ttMap := make(map[int]string)\n+\tfor _, t := range typesArray {\n+\t\ttMap[t.ProtoID] = t.Name\n+\t}\n+\treturn tMap\n+}\n+\n+// Statuses returns map of all Transaction Statuses\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Statuses() map[int]string {\n+\tstatusesArray := tr.retrieveTransactionStatuses()\n+\tsMap := make(map[int]string)\n+\tfor _, s := range statusesArray {\n+\t\tsMap[s.ProtoID] = s.Result\n+\t}\n+\treturn sMap\n+}\n+\n+func (tr *TransactionRepository) TypesAsArray() []string {\n+\treturn maphelper.GetStringValuesFromIntStringMap(tr.Types())\n+}\n+\n+// FindByTimestamp retrieves Transaction by given timestamp\n+func (tr *TransactionRepository) FindByTimestamp(timestamp int64) *types.Transaction {\n+\tt := transaction{}\n+\ttr.dbClient.Find(&t, timestamp)\n+\treturn tr.constructTransaction([]transaction{t})\n+}\n+\n+// FindBetween retrieves all Transactions between the provided start and end timestamp\n+func (tr *TransactionRepository) FindBetween(start int64, end int64) ([]*types.Transaction, *rTypes.Error) {\n+\tif start > end {\n+\t\treturn nil, errors.Errors[errors.StartMustBeBeforeEnd]\n+\t}\n+\tvar transactions []transaction\n+\ttr.dbClient.Where(whereClauseBetweenConsensus, start, end).Find(&transactions)\n+\n+\tsameHashMap := make(map[string][]transaction)\n+\tfor _, t := range transactions {\n+\t\th := t.getHashString()\n+\t\tsameHashMap[h] = append(sameHashMap[h], t)\n+\t}\n+\tres := make([]*types.Transaction, 0, len(sameHashMap))\n+\tfor _, sameHashTransactions := range sameHashMap {\n+\t\tres = append(res, tr.constructTransaction(sameHashTransactions))\n+\t}\n+\treturn res, nil\n+}\n+\n+// FindByHashInBlock retrieves a transaction by Hash\n+func (tr *TransactionRepository) FindByHashInBlock(hashStr string, consensusStart int64, consensusEnd int64) (*types.Transaction, *rTypes.Error) {\n+\tvar transactions []transaction\n+\ttransactionHash, err := hex.DecodeString(hexUtils.SafeRemoveHexPrefix(hashStr))\n+\tif err != nil {\n+\t\treturn nil, errors.Errors[errors.InvalidTransactionIdentifier]\n+\t}\n+\ttr.dbClient.Where(whereClauseBetweenConsensus, consensusStart, consensusEnd).Where(&transaction{TransactionHash: transactionHash}).Find(&transactions)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjU3NTI1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMToyODowOFrOHIh41Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwODozNzoxMVrOHc7zNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcwNTg3Nw==", "bodyText": "should we panic?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478705877", "createdAt": "2020-08-27T21:28:08Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,211 @@\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistance/postgres/types\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (%s)\"\n+)\n+\n+type transaction struct {\n+\tConsensusNS          int64  `gorm:\"type:bigint;primary_key\"`\n+\tType                 int    `gorm:\"type:smallint\"`\n+\tResult               int    `gorm:\"type:smallint\"`\n+\tPayerAccountID       int64  `gorm:\"type:bigint\"`\n+\tValidStartNS         int64  `gorm:\"type:bigint\"`\n+\tValidDurationSeconds int64  `gorm:\"type:bigint\"`\n+\tNodeAccountID        int64  `gorm:\"type:bigint\"`\n+\tEntityID             int64  `gorm:\"type:bigint\"`\n+\tInitialBalance       int64  `gorm:\"type:bigint\"`\n+\tMaxFee               int64  `gorm:\"type:bigint\"`\n+\tChargedTxFee         int64  `gorm:\"type:bigint\"`\n+\tMemo                 []byte `gorm:\"type:bytea\"`\n+\tTransactionHash      []byte `gorm:\"type:bytea\"`\n+\tTransactionBytes     []byte `gorm:\"type:bytea\"`\n+}\n+\n+type transactionType struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tName    string `gorm:\"size:30\"`\n+}\n+\n+type transactionStatus struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tResult  string `gorm:\"size:100\"`\n+}\n+\n+// TableName - Set table name of the Transactions to be `record_file`\n+func (transaction) TableName() string {\n+\treturn \"transaction\"\n+}\n+\n+// TableName - Set table name of the Transaction Types to be `t_transaction_types`\n+func (transactionType) TableName() string {\n+\treturn \"t_transaction_types\"\n+}\n+\n+// TableName - Set table name of the Transaction Statuses to be `t_transaction_results`\n+func (transactionStatus) TableName() string {\n+\treturn \"t_transaction_results\"\n+}\n+\n+func (t *transaction) getHashString() string {\n+\treturn hexUtils.SafeAddHexPrefix(hex.EncodeToString(t.TransactionHash))\n+}\n+\n+// TransactionRepository struct that has connection to the Database\n+type TransactionRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewTransactionRepository creates an instance of a TransactionRepository struct. Populates the transaction types and statuses on init\n+func NewTransactionRepository(dbClient *gorm.DB) *TransactionRepository {\n+\treturn &TransactionRepository{dbClient: dbClient}\n+}\n+\n+// Types returns map of all Transaction Types\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Types() map[int]string {\n+\ttypesArray := tr.retrieveTransactionTypes()\n+\ttMap := make(map[int]string)\n+\tfor _, t := range typesArray {\n+\t\ttMap[t.ProtoID] = t.Name\n+\t}\n+\treturn tMap\n+}\n+\n+// Statuses returns map of all Transaction Statuses\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Statuses() map[int]string {\n+\tstatusesArray := tr.retrieveTransactionStatuses()\n+\tsMap := make(map[int]string)\n+\tfor _, s := range statusesArray {\n+\t\tsMap[s.ProtoID] = s.Result\n+\t}\n+\treturn sMap\n+}\n+\n+func (tr *TransactionRepository) TypesAsArray() []string {\n+\treturn maphelper.GetStringValuesFromIntStringMap(tr.Types())\n+}\n+\n+// FindByTimestamp retrieves Transaction by given timestamp\n+func (tr *TransactionRepository) FindByTimestamp(timestamp int64) *types.Transaction {\n+\tt := transaction{}\n+\ttr.dbClient.Find(&t, timestamp)\n+\treturn tr.constructTransaction([]transaction{t})\n+}\n+\n+// FindBetween retrieves all Transactions between the provided start and end timestamp\n+func (tr *TransactionRepository) FindBetween(start int64, end int64) ([]*types.Transaction, *rTypes.Error) {\n+\tif start > end {\n+\t\treturn nil, errors.Errors[errors.StartMustBeBeforeEnd]\n+\t}\n+\tvar transactions []transaction\n+\ttr.dbClient.Where(whereClauseBetweenConsensus, start, end).Find(&transactions)\n+\n+\tsameHashMap := make(map[string][]transaction)\n+\tfor _, t := range transactions {\n+\t\th := t.getHashString()\n+\t\tsameHashMap[h] = append(sameHashMap[h], t)\n+\t}\n+\tres := make([]*types.Transaction, 0, len(sameHashMap))\n+\tfor _, sameHashTransactions := range sameHashMap {\n+\t\tres = append(res, tr.constructTransaction(sameHashTransactions))\n+\t}\n+\treturn res, nil\n+}\n+\n+// FindByHashInBlock retrieves a transaction by Hash\n+func (tr *TransactionRepository) FindByHashInBlock(hashStr string, consensusStart int64, consensusEnd int64) (*types.Transaction, *rTypes.Error) {\n+\tvar transactions []transaction\n+\ttransactionHash, err := hex.DecodeString(hexUtils.SafeRemoveHexPrefix(hashStr))\n+\tif err != nil {\n+\t\treturn nil, errors.Errors[errors.InvalidTransactionIdentifier]\n+\t}\n+\ttr.dbClient.Where(whereClauseBetweenConsensus, consensusStart, consensusEnd).Where(&transaction{TransactionHash: transactionHash}).Find(&transactions)\n+\tif len(transactions) == 0 {\n+\t\treturn nil, errors.Errors[errors.TransactionNotFound]\n+\t}\n+\n+\treturn tr.constructTransaction(transactions), nil\n+}\n+\n+func (tr *TransactionRepository) findCryptoTransfers(timestamps []int64) []dbTypes.CryptoTransfer {\n+\tvar cryptoTransfers []dbTypes.CryptoTransfer\n+\ttimestampsStr := intsToString(timestamps)\n+\ttr.dbClient.Where(fmt.Sprintf(whereTimestampsInConsensusTimestamp, timestampsStr)).Find(&cryptoTransfers)\n+\treturn cryptoTransfers\n+}\n+\n+func (tr *TransactionRepository) retrieveTransactionTypes() []transactionType {\n+\tvar transactionTypes []transactionType\n+\ttr.dbClient.Find(&transactionTypes)\n+\treturn transactionTypes\n+}\n+\n+func (tr *TransactionRepository) retrieveTransactionStatuses() []transactionStatus {\n+\tvar statuses []transactionStatus\n+\ttr.dbClient.Find(&statuses)\n+\treturn statuses\n+}\n+\n+func (tr *TransactionRepository) constructTransaction(sameHashTransactions []transaction) *types.Transaction {\n+\ttResult := &types.Transaction{Hash: sameHashTransactions[0].getHashString()}\n+\n+\ttransactionsMap := make(map[int64]transaction)\n+\ttimestamps := make([]int64, len(sameHashTransactions))\n+\tfor i, t := range sameHashTransactions {\n+\t\ttransactionsMap[t.ConsensusNS] = t\n+\t\ttimestamps[i] = t.ConsensusNS\n+\t}\n+\tcryptoTransfers := tr.findCryptoTransfers(timestamps)\n+\toperations := tr.constructOperations(cryptoTransfers, transactionsMap)\n+\ttResult.Operations = operations\n+\n+\treturn tResult\n+}\n+\n+func (tr *TransactionRepository) constructOperations(cryptoTransfers []dbTypes.CryptoTransfer, transactionsMap map[int64]transaction) []*types.Operation {\n+\ttransactionTypes := tr.Types()\n+\ttransactionStatuses := tr.Statuses()\n+\n+\toperations := make([]*types.Operation, len(cryptoTransfers))\n+\tfor i, ct := range cryptoTransfers {\n+\t\ta := constructAccount(ct.EntityID)\n+\t\toperationType := transactionTypes[transactionsMap[ct.ConsensusTimestamp].Type]\n+\t\toperationStatus := transactionStatuses[transactionsMap[ct.ConsensusTimestamp].Result]\n+\t\toperations[i] = &types.Operation{Index: int64(i), Type: operationType, Status: operationStatus, Account: a, Amount: &types.Amount{Value: ct.Amount}}\n+\t}\n+\treturn operations\n+}\n+\n+func constructAccount(encodedID int64) *types.Account {\n+\tacc, err := types.NewAccountFromEncodedID(encodedID)\n+\tif err != nil {\n+\t\tpanic(fmt.Sprintf(errors.CreateAccountDbIdFailed, encodedID))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEwMTk0Mg==", "bodyText": "You are right. Changing it to throwing Internal Server Errors", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500101942", "createdAt": "2020-10-06T08:37:11Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,211 @@\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistance/postgres/types\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (%s)\"\n+)\n+\n+type transaction struct {\n+\tConsensusNS          int64  `gorm:\"type:bigint;primary_key\"`\n+\tType                 int    `gorm:\"type:smallint\"`\n+\tResult               int    `gorm:\"type:smallint\"`\n+\tPayerAccountID       int64  `gorm:\"type:bigint\"`\n+\tValidStartNS         int64  `gorm:\"type:bigint\"`\n+\tValidDurationSeconds int64  `gorm:\"type:bigint\"`\n+\tNodeAccountID        int64  `gorm:\"type:bigint\"`\n+\tEntityID             int64  `gorm:\"type:bigint\"`\n+\tInitialBalance       int64  `gorm:\"type:bigint\"`\n+\tMaxFee               int64  `gorm:\"type:bigint\"`\n+\tChargedTxFee         int64  `gorm:\"type:bigint\"`\n+\tMemo                 []byte `gorm:\"type:bytea\"`\n+\tTransactionHash      []byte `gorm:\"type:bytea\"`\n+\tTransactionBytes     []byte `gorm:\"type:bytea\"`\n+}\n+\n+type transactionType struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tName    string `gorm:\"size:30\"`\n+}\n+\n+type transactionStatus struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tResult  string `gorm:\"size:100\"`\n+}\n+\n+// TableName - Set table name of the Transactions to be `record_file`\n+func (transaction) TableName() string {\n+\treturn \"transaction\"\n+}\n+\n+// TableName - Set table name of the Transaction Types to be `t_transaction_types`\n+func (transactionType) TableName() string {\n+\treturn \"t_transaction_types\"\n+}\n+\n+// TableName - Set table name of the Transaction Statuses to be `t_transaction_results`\n+func (transactionStatus) TableName() string {\n+\treturn \"t_transaction_results\"\n+}\n+\n+func (t *transaction) getHashString() string {\n+\treturn hexUtils.SafeAddHexPrefix(hex.EncodeToString(t.TransactionHash))\n+}\n+\n+// TransactionRepository struct that has connection to the Database\n+type TransactionRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewTransactionRepository creates an instance of a TransactionRepository struct. Populates the transaction types and statuses on init\n+func NewTransactionRepository(dbClient *gorm.DB) *TransactionRepository {\n+\treturn &TransactionRepository{dbClient: dbClient}\n+}\n+\n+// Types returns map of all Transaction Types\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Types() map[int]string {\n+\ttypesArray := tr.retrieveTransactionTypes()\n+\ttMap := make(map[int]string)\n+\tfor _, t := range typesArray {\n+\t\ttMap[t.ProtoID] = t.Name\n+\t}\n+\treturn tMap\n+}\n+\n+// Statuses returns map of all Transaction Statuses\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Statuses() map[int]string {\n+\tstatusesArray := tr.retrieveTransactionStatuses()\n+\tsMap := make(map[int]string)\n+\tfor _, s := range statusesArray {\n+\t\tsMap[s.ProtoID] = s.Result\n+\t}\n+\treturn sMap\n+}\n+\n+func (tr *TransactionRepository) TypesAsArray() []string {\n+\treturn maphelper.GetStringValuesFromIntStringMap(tr.Types())\n+}\n+\n+// FindByTimestamp retrieves Transaction by given timestamp\n+func (tr *TransactionRepository) FindByTimestamp(timestamp int64) *types.Transaction {\n+\tt := transaction{}\n+\ttr.dbClient.Find(&t, timestamp)\n+\treturn tr.constructTransaction([]transaction{t})\n+}\n+\n+// FindBetween retrieves all Transactions between the provided start and end timestamp\n+func (tr *TransactionRepository) FindBetween(start int64, end int64) ([]*types.Transaction, *rTypes.Error) {\n+\tif start > end {\n+\t\treturn nil, errors.Errors[errors.StartMustBeBeforeEnd]\n+\t}\n+\tvar transactions []transaction\n+\ttr.dbClient.Where(whereClauseBetweenConsensus, start, end).Find(&transactions)\n+\n+\tsameHashMap := make(map[string][]transaction)\n+\tfor _, t := range transactions {\n+\t\th := t.getHashString()\n+\t\tsameHashMap[h] = append(sameHashMap[h], t)\n+\t}\n+\tres := make([]*types.Transaction, 0, len(sameHashMap))\n+\tfor _, sameHashTransactions := range sameHashMap {\n+\t\tres = append(res, tr.constructTransaction(sameHashTransactions))\n+\t}\n+\treturn res, nil\n+}\n+\n+// FindByHashInBlock retrieves a transaction by Hash\n+func (tr *TransactionRepository) FindByHashInBlock(hashStr string, consensusStart int64, consensusEnd int64) (*types.Transaction, *rTypes.Error) {\n+\tvar transactions []transaction\n+\ttransactionHash, err := hex.DecodeString(hexUtils.SafeRemoveHexPrefix(hashStr))\n+\tif err != nil {\n+\t\treturn nil, errors.Errors[errors.InvalidTransactionIdentifier]\n+\t}\n+\ttr.dbClient.Where(whereClauseBetweenConsensus, consensusStart, consensusEnd).Where(&transaction{TransactionHash: transactionHash}).Find(&transactions)\n+\tif len(transactions) == 0 {\n+\t\treturn nil, errors.Errors[errors.TransactionNotFound]\n+\t}\n+\n+\treturn tr.constructTransaction(transactions), nil\n+}\n+\n+func (tr *TransactionRepository) findCryptoTransfers(timestamps []int64) []dbTypes.CryptoTransfer {\n+\tvar cryptoTransfers []dbTypes.CryptoTransfer\n+\ttimestampsStr := intsToString(timestamps)\n+\ttr.dbClient.Where(fmt.Sprintf(whereTimestampsInConsensusTimestamp, timestampsStr)).Find(&cryptoTransfers)\n+\treturn cryptoTransfers\n+}\n+\n+func (tr *TransactionRepository) retrieveTransactionTypes() []transactionType {\n+\tvar transactionTypes []transactionType\n+\ttr.dbClient.Find(&transactionTypes)\n+\treturn transactionTypes\n+}\n+\n+func (tr *TransactionRepository) retrieveTransactionStatuses() []transactionStatus {\n+\tvar statuses []transactionStatus\n+\ttr.dbClient.Find(&statuses)\n+\treturn statuses\n+}\n+\n+func (tr *TransactionRepository) constructTransaction(sameHashTransactions []transaction) *types.Transaction {\n+\ttResult := &types.Transaction{Hash: sameHashTransactions[0].getHashString()}\n+\n+\ttransactionsMap := make(map[int64]transaction)\n+\ttimestamps := make([]int64, len(sameHashTransactions))\n+\tfor i, t := range sameHashTransactions {\n+\t\ttransactionsMap[t.ConsensusNS] = t\n+\t\ttimestamps[i] = t.ConsensusNS\n+\t}\n+\tcryptoTransfers := tr.findCryptoTransfers(timestamps)\n+\toperations := tr.constructOperations(cryptoTransfers, transactionsMap)\n+\ttResult.Operations = operations\n+\n+\treturn tResult\n+}\n+\n+func (tr *TransactionRepository) constructOperations(cryptoTransfers []dbTypes.CryptoTransfer, transactionsMap map[int64]transaction) []*types.Operation {\n+\ttransactionTypes := tr.Types()\n+\ttransactionStatuses := tr.Statuses()\n+\n+\toperations := make([]*types.Operation, len(cryptoTransfers))\n+\tfor i, ct := range cryptoTransfers {\n+\t\ta := constructAccount(ct.EntityID)\n+\t\toperationType := transactionTypes[transactionsMap[ct.ConsensusTimestamp].Type]\n+\t\toperationStatus := transactionStatuses[transactionsMap[ct.ConsensusTimestamp].Result]\n+\t\toperations[i] = &types.Operation{Index: int64(i), Type: operationType, Status: operationStatus, Account: a, Amount: &types.Amount{Value: ct.Amount}}\n+\t}\n+\treturn operations\n+}\n+\n+func constructAccount(encodedID int64) *types.Account {\n+\tacc, err := types.NewAccountFromEncodedID(encodedID)\n+\tif err != nil {\n+\t\tpanic(fmt.Sprintf(errors.CreateAccountDbIdFailed, encodedID))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcwNTg3Nw=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjYzODM0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/types/account.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTo1MDowMlrOHIieEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTo1MDowMlrOHIieEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcxNTQxMQ==", "bodyText": "nit: can rename to String so Account implements the Stringer interface", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478715411", "createdAt": "2020-08-27T21:50:02Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/domain/types/account.go", "diffHunk": "@@ -0,0 +1,81 @@\n+package types\n+\n+import (\n+\t\"fmt\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/services/entity-id-codec\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+)\n+\n+// Account is domain level struct used to represent Rosetta Account\n+type Account struct {\n+\tShard  int64\n+\tRealm  int64\n+\tNumber int64\n+}\n+\n+// NewAccountFromEncodedID - creates new instance of Account struct\n+func NewAccountFromEncodedID(encodedID int64) (*Account, error) {\n+\td, err := entity_id_codec.Decode(encodedID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &Account{\n+\t\tShard:  d.ShardNum,\n+\t\tRealm:  d.RealmNum,\n+\t\tNumber: d.EntityNum,\n+\t}, err\n+}\n+\n+// ComputeEncodedID - returns the encoded ID from the Shard, Realm and Number\n+func (a *Account) ComputeEncodedID() (int64, error) {\n+\treturn entity_id_codec.Encode(a.Shard, a.Realm, a.Number)\n+}\n+\n+// FormatToString - returns the string representation of the account\n+func (a *Account) FormatToString() string {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjY1NDEwOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/types/account.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTo1NToyMVrOHIindA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTo1NToyMVrOHIindA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcxNzgxMg==", "bodyText": "strconv.parseInt for int64", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478717812", "createdAt": "2020-08-27T21:55:21Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/domain/types/account.go", "diffHunk": "@@ -0,0 +1,81 @@\n+package types\n+\n+import (\n+\t\"fmt\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/services/entity-id-codec\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+)\n+\n+// Account is domain level struct used to represent Rosetta Account\n+type Account struct {\n+\tShard  int64\n+\tRealm  int64\n+\tNumber int64\n+}\n+\n+// NewAccountFromEncodedID - creates new instance of Account struct\n+func NewAccountFromEncodedID(encodedID int64) (*Account, error) {\n+\td, err := entity_id_codec.Decode(encodedID)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &Account{\n+\t\tShard:  d.ShardNum,\n+\t\tRealm:  d.RealmNum,\n+\t\tNumber: d.EntityNum,\n+\t}, err\n+}\n+\n+// ComputeEncodedID - returns the encoded ID from the Shard, Realm and Number\n+func (a *Account) ComputeEncodedID() (int64, error) {\n+\treturn entity_id_codec.Encode(a.Shard, a.Realm, a.Number)\n+}\n+\n+// FormatToString - returns the string representation of the account\n+func (a *Account) FormatToString() string {\n+\treturn fmt.Sprintf(\"%d.%d.%d\", a.Shard, a.Realm, a.Number)\n+}\n+\n+// FromRosettaAccount populates domain type Account from Rosetta type Account\n+func FromRosettaAccount(rAccount *rTypes.AccountIdentifier) (*Account, *rTypes.Error) {\n+\treturn AccountFromString(rAccount.Address)\n+}\n+\n+// ToRosettaAccount returns Rosetta type Account from the current domain type Account\n+func (a *Account) ToRosettaAccount() *rTypes.AccountIdentifier {\n+\treturn &rTypes.AccountIdentifier{\n+\t\tAddress: a.FormatToString(),\n+\t}\n+}\n+\n+// AccountFromString populates domain type Account from String Account\n+func AccountFromString(account string) (*Account, *rTypes.Error) {\n+\tinputs := strings.Split(account, \".\")\n+\tif len(inputs) != 3 {\n+\t\treturn nil, errors.Errors[errors.InvalidAccount]\n+\t}\n+\n+\tshard, err := strconv.Atoi(inputs[0])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjY1OTY0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/types/amount.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTo1NzoyN1rOHIiqzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMTo1NzoyN1rOHIiqzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcxODY3MA==", "bodyText": "strconv.parseInt for int64", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478718670", "createdAt": "2020-08-27T21:57:27Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/domain/types/amount.go", "diffHunk": "@@ -0,0 +1,32 @@\n+package types\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/config\"\n+\t\"strconv\"\n+)\n+\n+type Amount struct {\n+\tValue int64\n+}\n+\n+// FromRosettaAmount populates domain type Amount from Rosetta type Amount\n+func FromRosettaAmount(rAmount *rTypes.Amount) (*Amount, *rTypes.Error) {\n+\tamount, err := strconv.Atoi(rAmount.Value)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjY4MzIzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/types/block.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjowNjoxNFrOHIi4sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMTo1NzowNlrOHdCxLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyMjIyNA==", "bodyText": "rosetta block index is not consensus start of a record file", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478722224", "createdAt": "2020-08-27T22:06:14Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/domain/types/block.go", "diffHunk": "@@ -0,0 +1,66 @@\n+package types\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"time\"\n+)\n+\n+// Block is domain level struct used to represent Block conceptual mapping in Hedera\n+type Block struct {\n+\tIndex               int64\n+\tHash                string\n+\tConsensusStartNanos int64\n+\tConsensusEndNanos   int64\n+\tParentIndex         int64\n+\tParentHash          string\n+\tTransactions        []*Transaction\n+}\n+\n+// FromRosettaBlock populates domain type Block from Rosetta type Block\n+func FromRosettaBlock(rBlock *rTypes.Block) (*Block, *rTypes.Error) {\n+\ttransactions := make([]*Transaction, len(rBlock.Transactions))\n+\tfor i, rosettaT := range rBlock.Transactions {\n+\t\tt, err := FromRosettaTransaction(rosettaT)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ttransactions[i] = t\n+\t}\n+\n+\treturn &Block{\n+\t\tIndex:               rBlock.BlockIdentifier.Index,\n+\t\tHash:                hex.SafeRemoveHexPrefix(rBlock.BlockIdentifier.Hash),\n+\t\tConsensusStartNanos: rBlock.BlockIdentifier.Index,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIxNjEwOA==", "bodyText": "yes, you are right. It is a leftover from the previous version of the code.\nWe are removing the FromRosetta* functionality, because:\n\nIt is unused\nWe cannot directly map Rosetta Block model to the Internal representation of a Block, because of the ConsensusStartNanos and ConsensusEndNanos", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500216108", "createdAt": "2020-10-06T11:57:06Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/domain/types/block.go", "diffHunk": "@@ -0,0 +1,66 @@\n+package types\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"time\"\n+)\n+\n+// Block is domain level struct used to represent Block conceptual mapping in Hedera\n+type Block struct {\n+\tIndex               int64\n+\tHash                string\n+\tConsensusStartNanos int64\n+\tConsensusEndNanos   int64\n+\tParentIndex         int64\n+\tParentHash          string\n+\tTransactions        []*Transaction\n+}\n+\n+// FromRosettaBlock populates domain type Block from Rosetta type Block\n+func FromRosettaBlock(rBlock *rTypes.Block) (*Block, *rTypes.Error) {\n+\ttransactions := make([]*Transaction, len(rBlock.Transactions))\n+\tfor i, rosettaT := range rBlock.Transactions {\n+\t\tt, err := FromRosettaTransaction(rosettaT)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ttransactions[i] = t\n+\t}\n+\n+\treturn &Block{\n+\t\tIndex:               rBlock.BlockIdentifier.Index,\n+\t\tHash:                hex.SafeRemoveHexPrefix(rBlock.BlockIdentifier.Hash),\n+\t\tConsensusStartNanos: rBlock.BlockIdentifier.Index,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyMjIyNA=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjY4OTQ1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/domain/types/block.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjowODo1MFrOHIi8bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMTo1NzoxM1rOHdCxXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyMzE4Mg==", "bodyText": "rosetta timestamp is in millisecond", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478723182", "createdAt": "2020-08-27T22:08:50Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/domain/types/block.go", "diffHunk": "@@ -0,0 +1,66 @@\n+package types\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"time\"\n+)\n+\n+// Block is domain level struct used to represent Block conceptual mapping in Hedera\n+type Block struct {\n+\tIndex               int64\n+\tHash                string\n+\tConsensusStartNanos int64\n+\tConsensusEndNanos   int64\n+\tParentIndex         int64\n+\tParentHash          string\n+\tTransactions        []*Transaction\n+}\n+\n+// FromRosettaBlock populates domain type Block from Rosetta type Block\n+func FromRosettaBlock(rBlock *rTypes.Block) (*Block, *rTypes.Error) {\n+\ttransactions := make([]*Transaction, len(rBlock.Transactions))\n+\tfor i, rosettaT := range rBlock.Transactions {\n+\t\tt, err := FromRosettaTransaction(rosettaT)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ttransactions[i] = t\n+\t}\n+\n+\treturn &Block{\n+\t\tIndex:               rBlock.BlockIdentifier.Index,\n+\t\tHash:                hex.SafeRemoveHexPrefix(rBlock.BlockIdentifier.Hash),\n+\t\tConsensusStartNanos: rBlock.BlockIdentifier.Index,\n+\t\tConsensusEndNanos:   rBlock.Timestamp,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIxNjE1Nw==", "bodyText": "addressed in the upper comment", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500216157", "createdAt": "2020-10-06T11:57:13Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/domain/types/block.go", "diffHunk": "@@ -0,0 +1,66 @@\n+package types\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"time\"\n+)\n+\n+// Block is domain level struct used to represent Block conceptual mapping in Hedera\n+type Block struct {\n+\tIndex               int64\n+\tHash                string\n+\tConsensusStartNanos int64\n+\tConsensusEndNanos   int64\n+\tParentIndex         int64\n+\tParentHash          string\n+\tTransactions        []*Transaction\n+}\n+\n+// FromRosettaBlock populates domain type Block from Rosetta type Block\n+func FromRosettaBlock(rBlock *rTypes.Block) (*Block, *rTypes.Error) {\n+\ttransactions := make([]*Transaction, len(rBlock.Transactions))\n+\tfor i, rosettaT := range rBlock.Transactions {\n+\t\tt, err := FromRosettaTransaction(rosettaT)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\ttransactions[i] = t\n+\t}\n+\n+\treturn &Block{\n+\t\tIndex:               rBlock.BlockIdentifier.Index,\n+\t\tHash:                hex.SafeRemoveHexPrefix(rBlock.BlockIdentifier.Hash),\n+\t\tConsensusStartNanos: rBlock.BlockIdentifier.Index,\n+\t\tConsensusEndNanos:   rBlock.Timestamp,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyMzE4Mg=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjcwODM4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistance/postgres/types/common.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxNjowOVrOHIjHHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMjozODoyMVrOHdERiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNTkxOQ==", "bodyText": "q: why is the file named common and in package types?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478725919", "createdAt": "2020-08-27T22:16:09Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/types/common.go", "diffHunk": "@@ -0,0 +1,12 @@\n+package types", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI0MDc3OQ==", "bodyText": "Changed the folder to common along with the package. The name of the file was changed to types as this is the Go idiomatic way of handling common types.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500240779", "createdAt": "2020-10-06T12:38:21Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/persistance/postgres/types/common.go", "diffHunk": "@@ -0,0 +1,12 @@\n+package types", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNTkxOQ=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjcyNTQ2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/commons.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoyMzoyMFrOHIjRPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMjozOTo0MlrOHdEVKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyODUxMA==", "bodyText": "will panic if bIdentifier.Index is nil", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478728510", "createdAt": "2020-08-27T22:23:20Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/commons.go", "diffHunk": "@@ -0,0 +1,36 @@\n+package services\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/repositories\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+)\n+\n+// Commons - Struct implementing common functionalities used by more than 1 service\n+type Commons struct {\n+\tblockRepo       repositories.BlockRepository\n+\ttransactionRepo repositories.TransactionRepository\n+}\n+\n+// NewCommons - Service containing common functions that are shared between other services\n+func NewCommons(blockRepo repositories.BlockRepository, transactionRepo repositories.TransactionRepository) Commons {\n+\treturn Commons{\n+\t\tblockRepo:       blockRepo,\n+\t\ttransactionRepo: transactionRepo,\n+\t}\n+}\n+\n+func (c *Commons) RetrieveBlock(bIdentifier *rTypes.PartialBlockIdentifier) (*types.Block, *rTypes.Error) {\n+\tif bIdentifier.Hash != nil && bIdentifier.Index != nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)\n+\t\treturn c.blockRepo.FindByIdentifier(*bIdentifier.Index, h)\n+\t} else if bIdentifier.Hash == nil {\n+\t\treturn c.blockRepo.FindByIndex(*bIdentifier.Index)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI0MTcwNQ==", "bodyText": "The Rosetta SDK validates the input and such use-case is not possible in the current implementation. Although relying on SDK validation makes this function vulnerable and not future proof. I've changed the code so that the issue is fixed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500241705", "createdAt": "2020-10-06T12:39:42Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/services/commons.go", "diffHunk": "@@ -0,0 +1,36 @@\n+package services\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/repositories\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+)\n+\n+// Commons - Struct implementing common functionalities used by more than 1 service\n+type Commons struct {\n+\tblockRepo       repositories.BlockRepository\n+\ttransactionRepo repositories.TransactionRepository\n+}\n+\n+// NewCommons - Service containing common functions that are shared between other services\n+func NewCommons(blockRepo repositories.BlockRepository, transactionRepo repositories.TransactionRepository) Commons {\n+\treturn Commons{\n+\t\tblockRepo:       blockRepo,\n+\t\ttransactionRepo: transactionRepo,\n+\t}\n+}\n+\n+func (c *Commons) RetrieveBlock(bIdentifier *rTypes.PartialBlockIdentifier) (*types.Block, *rTypes.Error) {\n+\tif bIdentifier.Hash != nil && bIdentifier.Index != nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)\n+\t\treturn c.blockRepo.FindByIdentifier(*bIdentifier.Index, h)\n+\t} else if bIdentifier.Hash == nil {\n+\t\treturn c.blockRepo.FindByIndex(*bIdentifier.Index)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyODUxMA=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjcyNjIzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/commons.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoyMzo0MlrOHIjRtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMjozOTo1MVrOHdEVjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyODYzMQ==", "bodyText": "will panic if bIdentifier.Hash is nil", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478728631", "createdAt": "2020-08-27T22:23:42Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/commons.go", "diffHunk": "@@ -0,0 +1,36 @@\n+package services\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/repositories\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+)\n+\n+// Commons - Struct implementing common functionalities used by more than 1 service\n+type Commons struct {\n+\tblockRepo       repositories.BlockRepository\n+\ttransactionRepo repositories.TransactionRepository\n+}\n+\n+// NewCommons - Service containing common functions that are shared between other services\n+func NewCommons(blockRepo repositories.BlockRepository, transactionRepo repositories.TransactionRepository) Commons {\n+\treturn Commons{\n+\t\tblockRepo:       blockRepo,\n+\t\ttransactionRepo: transactionRepo,\n+\t}\n+}\n+\n+func (c *Commons) RetrieveBlock(bIdentifier *rTypes.PartialBlockIdentifier) (*types.Block, *rTypes.Error) {\n+\tif bIdentifier.Hash != nil && bIdentifier.Index != nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)\n+\t\treturn c.blockRepo.FindByIdentifier(*bIdentifier.Index, h)\n+\t} else if bIdentifier.Hash == nil {\n+\t\treturn c.blockRepo.FindByIndex(*bIdentifier.Index)\n+\t} else if bIdentifier.Index == nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI0MTgwNg==", "bodyText": "addressed in the upper comment", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500241806", "createdAt": "2020-10-06T12:39:51Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/services/commons.go", "diffHunk": "@@ -0,0 +1,36 @@\n+package services\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/repositories\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+)\n+\n+// Commons - Struct implementing common functionalities used by more than 1 service\n+type Commons struct {\n+\tblockRepo       repositories.BlockRepository\n+\ttransactionRepo repositories.TransactionRepository\n+}\n+\n+// NewCommons - Service containing common functions that are shared between other services\n+func NewCommons(blockRepo repositories.BlockRepository, transactionRepo repositories.TransactionRepository) Commons {\n+\treturn Commons{\n+\t\tblockRepo:       blockRepo,\n+\t\ttransactionRepo: transactionRepo,\n+\t}\n+}\n+\n+func (c *Commons) RetrieveBlock(bIdentifier *rTypes.PartialBlockIdentifier) (*types.Block, *rTypes.Error) {\n+\tif bIdentifier.Hash != nil && bIdentifier.Index != nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)\n+\t\treturn c.blockRepo.FindByIdentifier(*bIdentifier.Index, h)\n+\t} else if bIdentifier.Hash == nil {\n+\t\treturn c.blockRepo.FindByIndex(*bIdentifier.Index)\n+\t} else if bIdentifier.Index == nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyODYzMQ=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjcyNzU1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/services/commons.go", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoyNDoxNlrOHIjSdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzoyMDowNFrOHdGBIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyODgyMg==", "bodyText": "is this branch ever reachable?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478728822", "createdAt": "2020-08-27T22:24:16Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/services/commons.go", "diffHunk": "@@ -0,0 +1,36 @@\n+package services\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/repositories\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+)\n+\n+// Commons - Struct implementing common functionalities used by more than 1 service\n+type Commons struct {\n+\tblockRepo       repositories.BlockRepository\n+\ttransactionRepo repositories.TransactionRepository\n+}\n+\n+// NewCommons - Service containing common functions that are shared between other services\n+func NewCommons(blockRepo repositories.BlockRepository, transactionRepo repositories.TransactionRepository) Commons {\n+\treturn Commons{\n+\t\tblockRepo:       blockRepo,\n+\t\ttransactionRepo: transactionRepo,\n+\t}\n+}\n+\n+func (c *Commons) RetrieveBlock(bIdentifier *rTypes.PartialBlockIdentifier) (*types.Block, *rTypes.Error) {\n+\tif bIdentifier.Hash != nil && bIdentifier.Index != nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)\n+\t\treturn c.blockRepo.FindByIdentifier(*bIdentifier.Index, h)\n+\t} else if bIdentifier.Hash == nil {\n+\t\treturn c.blockRepo.FindByIndex(*bIdentifier.Index)\n+\t} else if bIdentifier.Index == nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)\n+\t\treturn c.blockRepo.FindByHash(h)\n+\t} else {\n+\t\treturn c.blockRepo.RetrieveLatest()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI2OTM0NQ==", "bodyText": "addressed in the upper comment", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r500269345", "createdAt": "2020-10-06T13:20:04Z", "author": {"login": "Daniel-K-Ivanov"}, "path": "hedera-mirror-rosetta/app/services/commons.go", "diffHunk": "@@ -0,0 +1,36 @@\n+package services\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/repositories\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+)\n+\n+// Commons - Struct implementing common functionalities used by more than 1 service\n+type Commons struct {\n+\tblockRepo       repositories.BlockRepository\n+\ttransactionRepo repositories.TransactionRepository\n+}\n+\n+// NewCommons - Service containing common functions that are shared between other services\n+func NewCommons(blockRepo repositories.BlockRepository, transactionRepo repositories.TransactionRepository) Commons {\n+\treturn Commons{\n+\t\tblockRepo:       blockRepo,\n+\t\ttransactionRepo: transactionRepo,\n+\t}\n+}\n+\n+func (c *Commons) RetrieveBlock(bIdentifier *rTypes.PartialBlockIdentifier) (*types.Block, *rTypes.Error) {\n+\tif bIdentifier.Hash != nil && bIdentifier.Index != nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)\n+\t\treturn c.blockRepo.FindByIdentifier(*bIdentifier.Index, h)\n+\t} else if bIdentifier.Hash == nil {\n+\t\treturn c.blockRepo.FindByIndex(*bIdentifier.Index)\n+\t} else if bIdentifier.Index == nil {\n+\t\th := hex.SafeRemoveHexPrefix(*bIdentifier.Hash)\n+\t\treturn c.blockRepo.FindByHash(h)\n+\t} else {\n+\t\treturn c.blockRepo.RetrieveLatest()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyODgyMg=="}, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjkxODIwOnYy", "diffSide": "RIGHT", "path": "Dockerfile", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMzo1NjoyM1rOHIlDfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMzo1NjoyM1rOHIlDfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1Nzc1OQ==", "bodyText": "Do this file and other related files have to be in the top level directory to comply with Rosetta requirement? If no, it's better to move these files to a sub folder in hedera-mirror-rosetta.\nDo we need hedera-mirror-grpc and hedera-mirror-rest in this all-in-one docker image? hedera-mirror-rosetta does not depend on them.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r478757759", "createdAt": "2020-08-27T23:56:23Z", "author": {"login": "xin-hedera"}, "path": "Dockerfile", "diffHunk": "@@ -0,0 +1,98 @@\n+# ------------------------------  Rosetta  ------------------------------- #", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62d8f0ab02f9f63a99a84508d1b6ced7c5dae12a"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzQ1MTc5OnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDo0MjoyOVrOHevqqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMTo0NTo1MFrOHfGU7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMDI5Nw==", "bodyText": "We should probably create a rosetta username for the rosetta component - mirror_rosetta.\nSo far each component has used a separate name i.e importer (mirror_node). REST (mirror_api), GRPC (mirror_grpc)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502000297", "createdAt": "2020-10-08T20:42:29Z", "author": {"login": "Nana-EC"}, "path": "docs/configuration.md", "diffHunk": "@@ -242,3 +242,33 @@ hedera:\n           secretKey: <secretKey>\n           bucketName: 'hedera-stable-testnet-streams-2020-08-27'\n ```\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+3. Environment variables that start with `HEDERA_MIRROR_ROSETTA_` (e.g. `HEDERA_MIRROR_ROSETTA_API_VERSION=1.4.2`)\n+\n+The following table lists the available properties along with their default values.\n+\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.4                   | The version of the Rosetta interface the implementation adheres to                             |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_node_pass        | The database password the processor uses to connect. **Should be changed from default**        |\n+| `hedera.mirror.rosetta.db.port`                         | 5432                    | The port used to connect to the database                                                       |\n+| `hedera.mirror.rosetta.db.username`                     | mirror_node             | The username the processor uses to connect to the database                                     |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM3MTU2Nw==", "bodyText": "#984 (comment)", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502371567", "createdAt": "2020-10-09T11:45:50Z", "author": {"login": "failfmi"}, "path": "docs/configuration.md", "diffHunk": "@@ -242,3 +242,33 @@ hedera:\n           secretKey: <secretKey>\n           bucketName: 'hedera-stable-testnet-streams-2020-08-27'\n ```\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+3. Environment variables that start with `HEDERA_MIRROR_ROSETTA_` (e.g. `HEDERA_MIRROR_ROSETTA_API_VERSION=1.4.2`)\n+\n+The following table lists the available properties along with their default values.\n+\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.4                   | The version of the Rosetta interface the implementation adheres to                             |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_node_pass        | The database password the processor uses to connect. **Should be changed from default**        |\n+| `hedera.mirror.rosetta.db.port`                         | 5432                    | The port used to connect to the database                                                       |\n+| `hedera.mirror.rosetta.db.username`                     | mirror_node             | The username the processor uses to connect to the database                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMDI5Nw=="}, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzQ2OTE3OnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDo0NzowNFrOHev0oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDo0NzowNFrOHev0oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMjg0OQ==", "bodyText": "We recently added PREVIEWNET to the list. Should be noted in this doc so you can update it later", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502002849", "createdAt": "2020-10-08T20:47:04Z", "author": {"login": "Nana-EC"}, "path": "docs/configuration.md", "diffHunk": "@@ -242,3 +242,33 @@ hedera:\n           secretKey: <secretKey>\n           bucketName: 'hedera-stable-testnet-streams-2020-08-27'\n ```\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+3. Environment variables that start with `HEDERA_MIRROR_ROSETTA_` (e.g. `HEDERA_MIRROR_ROSETTA_API_VERSION=1.4.2`)\n+\n+The following table lists the available properties along with their default values.\n+\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.4                   | The version of the Rosetta interface the implementation adheres to                             |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_node_pass        | The database password the processor uses to connect. **Should be changed from default**        |\n+| `hedera.mirror.rosetta.db.port`                         | 5432                    | The port used to connect to the database                                                       |\n+| `hedera.mirror.rosetta.db.username`                     | mirror_node             | The username the processor uses to connect to the database                                     |\n+| `hedera.mirror.rosetta.network`                         | DEMO                    | Which Hedera network to use. Can be either `DEMO`, `MAINNET`, `TESTNET` or `OTHER`             |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzYzOTI4OnYy", "diffSide": "RIGHT", "path": "docs/configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMTo0MjozNlrOHexbwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMToyNzo0NlrOHfF0_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyOTI0OA==", "bodyText": "Rosetta should use its own read only database user. e.g. mirror_rosetta / mirror_rosetta_pass", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502029248", "createdAt": "2020-10-08T21:42:36Z", "author": {"login": "steven-sheehy"}, "path": "docs/configuration.md", "diffHunk": "@@ -242,3 +242,33 @@ hedera:\n           secretKey: <secretKey>\n           bucketName: 'hedera-stable-testnet-streams-2020-08-27'\n ```\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+3. Environment variables that start with `HEDERA_MIRROR_ROSETTA_` (e.g. `HEDERA_MIRROR_ROSETTA_API_VERSION=1.4.2`)\n+\n+The following table lists the available properties along with their default values.\n+\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.4                   | The version of the Rosetta interface the implementation adheres to                             |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_node_pass        | The database password the processor uses to connect. **Should be changed from default**        |\n+| `hedera.mirror.rosetta.db.port`                         | 5432                    | The port used to connect to the database                                                       |\n+| `hedera.mirror.rosetta.db.username`                     | mirror_node             | The username the processor uses to connect to the database                                     |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2MzM5MA==", "bodyText": "Same comment as above", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502363390", "createdAt": "2020-10-09T11:27:46Z", "author": {"login": "failfmi"}, "path": "docs/configuration.md", "diffHunk": "@@ -242,3 +242,33 @@ hedera:\n           secretKey: <secretKey>\n           bucketName: 'hedera-stable-testnet-streams-2020-08-27'\n ```\n+\n+\n+## Rosetta API\n+\n+The Rosetta API supports loading configuration from YAML. By default, it loads a file named\n+`application.yml` in each of the search paths (see below).\n+The configuration is loaded in the following order with the latter configuration overwriting (technically recursively\n+merged into) the current configuration:\n+\n+1. `./config/application.yml`\n+2. `./application.yml`\n+3. Environment variables that start with `HEDERA_MIRROR_ROSETTA_` (e.g. `HEDERA_MIRROR_ROSETTA_API_VERSION=1.4.2`)\n+\n+The following table lists the available properties along with their default values.\n+\n+| Name                                                    | Default                 | Description                                                                                    |\n+| ------------------------------------------------------- | ----------------------- | ---------------------------------------------------------------------------------------------- |\n+| `hedera.mirror.rosetta.apiVersion`                      | 1.4.4                   | The version of the Rosetta interface the implementation adheres to                             |\n+| `hedera.mirror.rosetta.db.host`                         | 127.0.0.1               | The IP or hostname used to connect to the database                                             |\n+| `hedera.mirror.rosetta.db.name`                         | mirror_node             | The name of the database                                                                       |\n+| `hedera.mirror.rosetta.db.password`                     | mirror_node_pass        | The database password the processor uses to connect. **Should be changed from default**        |\n+| `hedera.mirror.rosetta.db.port`                         | 5432                    | The port used to connect to the database                                                       |\n+| `hedera.mirror.rosetta.db.username`                     | mirror_node             | The username the processor uses to connect to the database                                     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyOTI0OA=="}, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzY3MDU4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistence/postgres/account/account.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMTo1Mzo1N1rOHexuiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMTo1Mzo1N1rOHexuiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNDA1OQ==", "bodyText": "Would prefer not having postgres in package names. We will probably be switching to TimeScaleDB in the near future.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502034059", "createdAt": "2020-10-08T21:53:57Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/app/persistence/postgres/account/account.go", "diffHunk": "@@ -0,0 +1,95 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package account\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistence/postgres/common\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzY3Njk1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistence/postgres/addressbook/entry/entry.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMTo1NjowOVrOHexyJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMTo1NjowOVrOHexyJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNDk4MA==", "bodyText": "Why do we need to sprintf these instead of hardcoding the table names in the query or using prepared statements?  I'm sure code scanners will complain of SQL injection.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502034980", "createdAt": "2020-10-08T21:56:09Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/app/persistence/postgres/addressbook/entry/entry.go", "diffHunk": "@@ -0,0 +1,115 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package entry\n+\n+import (\n+\t\"fmt\"\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+\t\"log\"\n+)\n+\n+const (\n+\tlatestAddressBookEntries = \"SELECT abe.* FROM %s AS abe JOIN %s AS ab ON ab.start_consensus_timestamp = abe.consensus_timestamp WHERE ab.end_consensus_timestamp IS NULL\"\n+)\n+\n+const (\n+\ttableNameAddressBook      = \"address_book\"\n+\ttableNameAddressBookEntry = \"address_book_entry\"\n+)\n+\n+type addressBookEntry struct {\n+\tId                 int32  `gorm:\"type:integer;primary_key\"`\n+\tConsensusTimestamp int64  `gorm:\"type:bigint\"`\n+\tIp                 string `gorm:\"size:128\"`\n+\tPort               int32  `gorm:\"type:integer\"`\n+\tMemo               string `gorm:\"size:128\"`\n+\tPublicKey          string `gorm:\"size:1024\"`\n+\tNodeId             *int64 `gorm:\"type:bigint\"`\n+\tNodeAccountId      int64  `gorm:\"type:bigint\"`\n+\tNodeCertHash       []byte `gorm:\"type:bytea\"`\n+}\n+\n+func (addressBookEntry) TableName() string {\n+\treturn tableNameAddressBookEntry\n+}\n+\n+// AddressBookEntryRepository struct that has connection to the Database\n+type AddressBookEntryRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// Entries return all found Address Book Entries\n+func (aber *AddressBookEntryRepository) Entries() (*types.AddressBookEntries, *rTypes.Error) {\n+\tdbEntries := aber.retrieveEntries()\n+\n+\tentries := make([]*types.AddressBookEntry, len(dbEntries))\n+\tfor i, e := range dbEntries {\n+\t\tpeerId, err := e.getPeerId()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tentries[i] = &types.AddressBookEntry{\n+\t\t\tPeerId: peerId,\n+\t\t\tMetadata: map[string]interface{}{\n+\t\t\t\t\"ip\":   e.Ip,\n+\t\t\t\t\"port\": e.Port,\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn &types.AddressBookEntries{\n+\t\tEntries: entries}, nil\n+}\n+\n+func (abe *addressBookEntry) getPeerId() (*types.Account, *rTypes.Error) {\n+\tif abe.NodeId == nil {\n+\t\tacc, err := types.AccountFromString(abe.Memo)\n+\t\tif err != nil {\n+\t\t\tlog.Printf(errors.CreateAccountDbIdFailed, abe.Memo)\n+\t\t\treturn nil, errors.Errors[errors.InternalServerError]\n+\t\t}\n+\t\treturn acc, nil\n+\t}\n+\n+\tdecoded, err := types.NewAccountFromEncodedID(*abe.NodeId)\n+\tif err != nil {\n+\t\tlog.Printf(errors.CreateAccountDbIdFailed, abe.NodeId)\n+\t\treturn nil, errors.Errors[errors.InternalServerError]\n+\t}\n+\n+\treturn decoded, nil\n+}\n+\n+func (aber *AddressBookEntryRepository) retrieveEntries() []addressBookEntry {\n+\tvar entries []addressBookEntry\n+\taber.dbClient.Raw(fmt.Sprintf(latestAddressBookEntries, tableNameAddressBookEntry, tableNameAddressBook)).Scan(&entries)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzY5NTI0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistence/postgres/transaction/transaction.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjowMjo0MlrOHex8wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjowMjo0MlrOHex8wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzNzY5OA==", "bodyText": "Use prepared statements", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502037698", "createdAt": "2020-10-08T22:02:42Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/app/persistence/postgres/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,255 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistence/postgres/common\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"log\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (%s)\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzcwMzIzOnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/go.mod", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjowNTozNlrOHeyBKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMTozODozNVrOHfGH3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzODgyNg==", "bodyText": "Will these changes be ported to the sdk?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502038826", "createdAt": "2020-10-08T22:05:36Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/go.mod", "diffHunk": "@@ -0,0 +1,21 @@\n+module github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta\n+\n+go 1.13\n+\n+require (\n+\tgithub.com/caarlos0/env/v6 v6.3.0\n+\tgithub.com/coinbase/rosetta-cli v0.5.7 // indirect\n+\tgithub.com/coinbase/rosetta-sdk-go v0.4.9\n+\tgithub.com/hashgraph/hedera-sdk-go v0.9.1\n+\tgithub.com/jinzhu/gorm v1.9.16\n+\tgithub.com/lib/pq v1.8.0 // indirect\n+\tgithub.com/sqs/goreturns v0.0.0-20181028201513-538ac6014518 // indirect\n+\tgolang.org/x/crypto v0.0.0-20201002094018-c90954cbb977 // indirect\n+\tgolang.org/x/net v0.0.0-20200930145003-4acb6c075d10 // indirect\n+\tgolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f // indirect\n+\tgoogle.golang.org/genproto v0.0.0-20201001141541-efaab9d3c4f7 // indirect\n+\tgoogle.golang.org/grpc v1.32.0 // indirect\n+\tgopkg.in/yaml.v2 v2.3.0\n+)\n+\n+replace github.com/hashgraph/hedera-sdk-go v0.9.1 => github.com/limechain/hedera-sdk-go v0.9.2-0.20200825132925-ccbc4019e257", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2ODIyMQ==", "bodyText": "There's an ongoing PR, will be removed after merged.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502368221", "createdAt": "2020-10-09T11:38:35Z", "author": {"login": "failfmi"}, "path": "hedera-mirror-rosetta/go.mod", "diffHunk": "@@ -0,0 +1,21 @@\n+module github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta\n+\n+go 1.13\n+\n+require (\n+\tgithub.com/caarlos0/env/v6 v6.3.0\n+\tgithub.com/coinbase/rosetta-cli v0.5.7 // indirect\n+\tgithub.com/coinbase/rosetta-sdk-go v0.4.9\n+\tgithub.com/hashgraph/hedera-sdk-go v0.9.1\n+\tgithub.com/jinzhu/gorm v1.9.16\n+\tgithub.com/lib/pq v1.8.0 // indirect\n+\tgithub.com/sqs/goreturns v0.0.0-20181028201513-538ac6014518 // indirect\n+\tgolang.org/x/crypto v0.0.0-20201002094018-c90954cbb977 // indirect\n+\tgolang.org/x/net v0.0.0-20200930145003-4acb6c075d10 // indirect\n+\tgolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f // indirect\n+\tgoogle.golang.org/genproto v0.0.0-20201001141541-efaab9d3c4f7 // indirect\n+\tgoogle.golang.org/grpc v1.32.0 // indirect\n+\tgopkg.in/yaml.v2 v2.3.0\n+)\n+\n+replace github.com/hashgraph/hedera-sdk-go v0.9.1 => github.com/limechain/hedera-sdk-go v0.9.2-0.20200825132925-ccbc4019e257", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAzODgyNg=="}, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzcxNzY4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/build/Dockerfile", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoxMToxNlrOHeyJcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODowMTozMFrOHe_O1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0MDk0Nw==", "bodyText": "Should these references to limechain git repo be changed before merge?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502040947", "createdAt": "2020-10-08T22:11:16Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/build/Dockerfile", "diffHunk": "@@ -0,0 +1,93 @@\n+# This Dockerfile configuration is used to build\n+# Importer, Rosetta and PostgreSQL into one image\n+# and run the services using supervisord\n+\n+# ------------------------------  Rosetta  ------------------------------- #\n+FROM golang:1.13 as rosetta-builder\n+WORKDIR /tmp\n+RUN git clone https://github.com/LimeChain/hedera-mirror-node.git", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI1NTMxOQ==", "bodyText": "Yes, before merged to master", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502255319", "createdAt": "2020-10-09T08:01:30Z", "author": {"login": "failfmi"}, "path": "hedera-mirror-rosetta/build/Dockerfile", "diffHunk": "@@ -0,0 +1,93 @@\n+# This Dockerfile configuration is used to build\n+# Importer, Rosetta and PostgreSQL into one image\n+# and run the services using supervisord\n+\n+# ------------------------------  Rosetta  ------------------------------- #\n+FROM golang:1.13 as rosetta-builder\n+WORKDIR /tmp\n+RUN git clone https://github.com/LimeChain/hedera-mirror-node.git", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0MDk0Nw=="}, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzcyMTE1OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/build/Dockerfile", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoxMjo0N1rOHeyLgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoxMjo0N1rOHeyLgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0MTQ3Mw==", "bodyText": "Shouldn't hardcode versions. Can this be changed to use wildcards?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502041473", "createdAt": "2020-10-08T22:12:47Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/build/Dockerfile", "diffHunk": "@@ -0,0 +1,93 @@\n+# This Dockerfile configuration is used to build\n+# Importer, Rosetta and PostgreSQL into one image\n+# and run the services using supervisord\n+\n+# ------------------------------  Rosetta  ------------------------------- #\n+FROM golang:1.13 as rosetta-builder\n+WORKDIR /tmp\n+RUN git clone https://github.com/LimeChain/hedera-mirror-node.git\n+WORKDIR /tmp/hedera-mirror-node/hedera-mirror-rosetta\n+RUN go build -o rosetta-executable ./cmd\n+\n+# ---------------------------- Importer/GRPC ----------------------------- #\n+FROM openjdk:11.0 as java-builder\n+\n+RUN apt-get update && apt-get install -y git\n+RUN git clone https://github.com/LimeChain/hedera-mirror-node.git\n+RUN cd hedera-mirror-node && ./mvnw clean package -DskipTests\n+\n+# ######################################################################## #\n+# --------------------------- Runner Container --------------------------- #\n+# ######################################################################## #\n+\n+FROM ubuntu:18.04 as runner\n+\n+# ---------------------- Install Deps & PosgreSQL ------------------------ #\n+# Add the PostgreSQL PGP key to verify their Debian packages.\n+# It should be the same key as https://www.postgresql.org/media/keys/ACCC4CF8.asc\n+RUN apt-get update && apt-get install -y gnupg\n+RUN apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8\n+\n+# Add PostgreSQL's repository. It contains the most recent stable release\n+#  of PostgreSQL.\n+RUN echo \"deb http://apt.postgresql.org/pub/repos/apt/ precise-pgdg main\" > /etc/apt/sources.list.d/pgdg.list\n+\n+# Install PostgreSQL 9.6, supervisor, git and openjdk-11\n+ARG DEBIAN_FRONTEND=noninteractive\n+RUN apt-get update && apt-get install -y postgresql-9.6 postgresql-client-9.6 postgresql-contrib-9.6 supervisor git openjdk-11-jdk-headless curl\n+\n+# ---------------------------- Install yq ----------------------------- #\n+RUN apt-key adv --keyserver keyserver.ubuntu.com --recv-keys CC86BB64\n+RUN apt-get install -y software-properties-common\n+RUN add-apt-repository ppa:rmescandon/yq\n+RUN apt update\n+RUN apt install yq -y\n+\n+USER root\n+\n+# Create Volume PostgreSQL directory and Change default PostgreSQL directory\n+RUN mkdir -p /data/db\n+RUN chown postgres /data/db\n+RUN chmod 700 /data/db\n+RUN mv /var/lib/postgresql/9.6/main /data/db/main\n+RUN ln -s /data/db/main /var/lib/postgresql/9.6/main\n+\n+# ---------------------------  Supervisord  --------------------------- #\n+\n+# Clone the Repo\n+RUN git clone https://github.com/LimeChain/hedera-mirror-node.git\n+\n+USER postgres\n+\n+# Init db script\n+RUN /etc/init.d/postgresql start &&\\\n+    createdb mirror_node &&\\\n+    psql --command \"create user mirror_node with SUPERUSER password 'mirror_node_pass'\"&&\\\n+    POSTGRES_DB=mirror_node /hedera-mirror-node/hedera-mirror-grpc/scripts/db/init.sh\n+\n+# And add ``listen_addresses`` to ``/etc/postgresql/9.6/main/postgresql.conf``\n+RUN echo \"listen_addresses='*'\" >> /etc/postgresql/9.6/main/postgresql.conf\n+# Allow PG Admin access\n+RUN echo \"host    all             all             172.17.0.1/16           trust\" >> /etc/postgresql/9.6/main/pg_hba.conf\n+\n+USER root\n+\n+# Create Volume importer directory\n+RUN mkdir -p /data/data\n+RUN ln -s /data/data /hedera-mirror-node\n+\n+# Copy the Rosetta Executable from the Rosetta Builder stage\n+WORKDIR /var/rosetta\n+COPY --from=rosetta-builder /tmp/hedera-mirror-node/hedera-mirror-rosetta/rosetta-executable .\n+COPY --from=rosetta-builder /tmp/hedera-mirror-node/hedera-mirror-rosetta/config/application.yml ./config/application.yml\n+\n+# Copy the Importer Jar and Config from the Java-Builder stage\n+WORKDIR /var/importer\n+COPY --from=java-builder /hedera-mirror-node/hedera-mirror-importer/target/hedera-mirror-importer-0.19.0-rc1-exec.jar ./hedera-mirror-importer.jar", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mzc0MTc0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/build/run_supervisord.sh", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoyMToyNlrOHeyX_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjoyMToyNlrOHeyX_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA0NDY3MA==", "bodyText": "Do we need to manually map these env variables to yaml? Doesn't the go config support reading from env variable as well?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502044670", "createdAt": "2020-10-08T22:21:26Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-rosetta/build/run_supervisord.sh", "diffHunk": "@@ -0,0 +1,47 @@\n+#!/bin/bash\n+\n+function run_offline_mode() {\n+  supervisord --configuration supervisord-offline.conf\n+}\n+\n+function run_online_mode() {\n+  if [[ -n \"$HEDERA_MIRROR_IMPORTER_DOWNLOADER_ACCESS_KEY\" ]]; then\n+    yq write -i application.yml hedera.mirror.importer.downloader.accessKey $HEDERA_MIRROR_IMPORTER_DOWNLOADER_ACCESS_KEY", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzgxMTU4OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/build/Dockerfile", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMjo1MTowMVrOHezCRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwODowOTowOVrOHe_eUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1NTQ5Mw==", "bodyText": "Should all the git clones now refer to the mirror node repo under hashgraph and not the one under LimeChain?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502055493", "createdAt": "2020-10-08T22:51:01Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-rosetta/build/Dockerfile", "diffHunk": "@@ -0,0 +1,93 @@\n+# This Dockerfile configuration is used to build\n+# Importer, Rosetta and PostgreSQL into one image\n+# and run the services using supervisord\n+\n+# ------------------------------  Rosetta  ------------------------------- #\n+FROM golang:1.13 as rosetta-builder\n+WORKDIR /tmp\n+RUN git clone https://github.com/LimeChain/hedera-mirror-node.git", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI1OTI4Mw==", "bodyText": "Yes, just before merging to hashgraph:master.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502259283", "createdAt": "2020-10-09T08:09:09Z", "author": {"login": "failfmi"}, "path": "hedera-mirror-rosetta/build/Dockerfile", "diffHunk": "@@ -0,0 +1,93 @@\n+# This Dockerfile configuration is used to build\n+# Importer, Rosetta and PostgreSQL into one image\n+# and run the services using supervisord\n+\n+# ------------------------------  Rosetta  ------------------------------- #\n+FROM golang:1.13 as rosetta-builder\n+WORKDIR /tmp\n+RUN git clone https://github.com/LimeChain/hedera-mirror-node.git", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA1NTQ5Mw=="}, "originalCommit": {"oid": "95b030dd24bd1720d25b2598281d0c642c5354e5"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NjY3NDY2OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistence/block/block.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNTowODoyNFrOHfN8YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNTowODoyNFrOHfN8YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5NjM1Mg==", "bodyText": "rd.prev_hash is not selected", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502496352", "createdAt": "2020-10-09T15:08:24Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistence/block/block.go", "diffHunk": "@@ -0,0 +1,172 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package block\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestWithIndex - Selects row with the latest consensus_end and adds additional info about the position of that row using count.\n+\t// The information about the position is used as Block Index\n+\tselectLatestWithIndex string = `SELECT rd.file_hash,\n+                                           rd.consensus_start,\n+                                           rd.consensus_end,\n+                                           rcd_index.block_index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba697b88b21824a84e96190cfb47fb417ef4dfd6"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NjY3OTY3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistence/block/block.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNTowOToxNFrOHfN_Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNTowOToxNFrOHfN_Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ5NzAzMA==", "bodyText": "same as above", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502497030", "createdAt": "2020-10-09T15:09:14Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistence/block/block.go", "diffHunk": "@@ -0,0 +1,172 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package block\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const genesisPreviousHash = \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n+\n+const (\n+\t// selectLatestWithIndex - Selects row with the latest consensus_end and adds additional info about the position of that row using count.\n+\t// The information about the position is used as Block Index\n+\tselectLatestWithIndex string = `SELECT rd.file_hash,\n+                                           rd.consensus_start,\n+                                           rd.consensus_end,\n+                                           rcd_index.block_index\n+                                    FROM   (SELECT *\n+                                            FROM   record_file\n+                                            WHERE  consensus_end = (SELECT MAX(consensus_end)\n+                                                                    FROM   record_file)) AS rd,\n+                                           (SELECT COUNT(*) - 1 AS block_index\n+                                            FROM   record_file) AS rcd_index`\n+\n+\t// selectByHashWithIndex - Selects the row with a given file_hash and adds additional info about the position of that row using count.\n+\t//The information about the position is used as Block Index\n+\tselectByHashWithIndex string = `SELECT rd.file_hash,\n+                                           rd.consensus_start,\n+                                           rd.consensus_end,\n+                                           rcd.block_index", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba697b88b21824a84e96190cfb47fb417ef4dfd6"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NjY5OTg5OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistence/transaction/transaction.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNToxNDoxNVrOHfOLiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNToxNDoxNVrOHfOLiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwMDIzNQ==", "bodyText": "potential sql injection", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502500235", "createdAt": "2020-10-09T15:14:15Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistence/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,255 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\t\"fmt\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistence/common\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"log\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (%s)\"\n+)\n+\n+type transaction struct {\n+\tConsensusNS          int64  `gorm:\"type:bigint;primary_key\"`\n+\tType                 int    `gorm:\"type:smallint\"`\n+\tResult               int    `gorm:\"type:smallint\"`\n+\tPayerAccountID       int64  `gorm:\"type:bigint\"`\n+\tValidStartNS         int64  `gorm:\"type:bigint\"`\n+\tValidDurationSeconds int64  `gorm:\"type:bigint\"`\n+\tNodeAccountID        int64  `gorm:\"type:bigint\"`\n+\tEntityID             int64  `gorm:\"type:bigint\"`\n+\tInitialBalance       int64  `gorm:\"type:bigint\"`\n+\tMaxFee               int64  `gorm:\"type:bigint\"`\n+\tChargedTxFee         int64  `gorm:\"type:bigint\"`\n+\tMemo                 []byte `gorm:\"type:bytea\"`\n+\tTransactionHash      []byte `gorm:\"type:bytea\"`\n+\tTransactionBytes     []byte `gorm:\"type:bytea\"`\n+}\n+\n+type transactionType struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tName    string `gorm:\"size:30\"`\n+}\n+\n+type transactionResult struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tResult  string `gorm:\"size:100\"`\n+}\n+\n+// TableName - Set table name of the Transactions to be `record_file`\n+func (transaction) TableName() string {\n+\treturn \"transaction\"\n+}\n+\n+// TableName - Set table name of the Transaction Types to be `t_transaction_types`\n+func (transactionType) TableName() string {\n+\treturn \"t_transaction_types\"\n+}\n+\n+// TableName - Set table name of the Transaction Results to be `t_transaction_results`\n+func (transactionResult) TableName() string {\n+\treturn \"t_transaction_results\"\n+}\n+\n+func (t *transaction) getHashString() string {\n+\treturn hexUtils.SafeAddHexPrefix(hex.EncodeToString(t.TransactionHash))\n+}\n+\n+// TransactionRepository struct that has connection to the Database\n+type TransactionRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewTransactionRepository creates an instance of a TransactionRepository struct\n+func NewTransactionRepository(dbClient *gorm.DB) *TransactionRepository {\n+\treturn &TransactionRepository{dbClient: dbClient}\n+}\n+\n+// Types returns map of all Transaction Types\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Types() map[int]string {\n+\ttypesArray := tr.retrieveTransactionTypes()\n+\ttMap := make(map[int]string)\n+\tfor _, t := range typesArray {\n+\t\ttMap[t.ProtoID] = t.Name\n+\t}\n+\treturn tMap\n+}\n+\n+// Statuses returns map of all Transaction Results\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Statuses() map[int]string {\n+\trArray := tr.retrieveTransactionResults()\n+\trMap := make(map[int]string)\n+\tfor _, s := range rArray {\n+\t\trMap[s.ProtoID] = s.Result\n+\t}\n+\treturn rMap\n+}\n+\n+func (tr *TransactionRepository) TypesAsArray() []string {\n+\treturn maphelper.GetStringValuesFromIntStringMap(tr.Types())\n+}\n+\n+// FindBetween retrieves all Transactions between the provided start and end timestamp\n+func (tr *TransactionRepository) FindBetween(start int64, end int64) ([]*types.Transaction, *rTypes.Error) {\n+\tif start > end {\n+\t\treturn nil, errors.Errors[errors.StartMustNotBeAfterEnd]\n+\t}\n+\tvar transactions []transaction\n+\ttr.dbClient.Where(whereClauseBetweenConsensus, start, end).Find(&transactions)\n+\n+\tsameHashMap := make(map[string][]transaction)\n+\tfor _, t := range transactions {\n+\t\th := t.getHashString()\n+\t\tsameHashMap[h] = append(sameHashMap[h], t)\n+\t}\n+\tres := make([]*types.Transaction, 0, len(sameHashMap))\n+\tfor _, sameHashTransactions := range sameHashMap {\n+\t\ttransaction, err := tr.constructTransaction(sameHashTransactions)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tres = append(res, transaction)\n+\t}\n+\treturn res, nil\n+}\n+\n+// FindByHashInBlock retrieves a transaction by Hash\n+func (tr *TransactionRepository) FindByHashInBlock(hashStr string, consensusStart int64, consensusEnd int64) (*types.Transaction, *rTypes.Error) {\n+\tvar transactions []transaction\n+\ttransactionHash, err := hex.DecodeString(hexUtils.SafeRemoveHexPrefix(hashStr))\n+\tif err != nil {\n+\t\treturn nil, errors.Errors[errors.InvalidTransactionIdentifier]\n+\t}\n+\ttr.dbClient.Where(&transaction{TransactionHash: transactionHash}).Find(&transactions)\n+\ttransactions = filterTransactionsForRange(transactions, consensusStart, consensusEnd)\n+\n+\tif len(transactions) == 0 {\n+\t\treturn nil, errors.Errors[errors.TransactionNotFound]\n+\t}\n+\n+\ttransaction, err1 := tr.constructTransaction(transactions)\n+\tif err1 != nil {\n+\t\treturn nil, err1\n+\t}\n+\treturn transaction, nil\n+}\n+\n+// filterTransactionsForRange - Filters the passed transactions. If the ConnsensusNS is not in the given [consensusStart; consensusEnd] range, the transaction is removed from the list\n+func filterTransactionsForRange(transactions []transaction, consensusStart int64, consensusEnd int64) []transaction {\n+\tvar length int\n+\tfor _, t := range transactions {\n+\t\tif t.ConsensusNS < consensusStart || t.ConsensusNS > consensusEnd {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttransactions[length] = t\n+\t\tlength++\n+\t}\n+\treturn transactions[:length]\n+}\n+\n+func (tr *TransactionRepository) findCryptoTransfers(timestamps []int64) []dbTypes.CryptoTransfer {\n+\tvar cryptoTransfers []dbTypes.CryptoTransfer\n+\ttimestampsStr := intsToString(timestamps)\n+\ttr.dbClient.Where(fmt.Sprintf(whereTimestampsInConsensusTimestamp, timestampsStr)).Find(&cryptoTransfers)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba697b88b21824a84e96190cfb47fb417ef4dfd6"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Njc1MDk0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistence/account/account.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNToyNjo0OFrOHfOqiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNToyNjo0OFrOHfOqiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwODE3MQ==", "bodyText": "there is a recent change to account_balance table which replaces account_realm_num and account_num with a new column account_id which is in the encoded form", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r502508171", "createdAt": "2020-10-09T15:26:48Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistence/account/account.go", "diffHunk": "@@ -0,0 +1,98 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package account\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\tbalanceChangeBetween string = `SELECT\n+                                        SUM(amount::bigint) AS value,\n+                                        COUNT(consensus_timestamp) AS number_of_transfers\n+                                   FROM crypto_transfer\n+                                   WHERE consensus_timestamp > ?\n+                                        AND consensus_timestamp <= ?\n+                                        AND entity_id = ?`\n+)\n+\n+type accountBalance struct {\n+\tConsensusTimestamp int64 `gorm:\"type:bigint;primary_key\"`\n+\tBalance            int64 `gorm:\"type:bigint\"`\n+\tAccountRealmNum    int16 `gorm:\"type:smallint;primary_key\"`\n+\tAccountNum         int32 `gorm:\"type:integer;primary_key\"`\n+}\n+\n+type balanceChange struct {\n+\tValue             int64 `gorm:\"type:bigint\"`\n+\tNumberOfTransfers int64 `gorm:\"type:bigint\"`\n+}\n+\n+// TableName - Set table name of the accountBalance to be `account_balance`\n+func (accountBalance) TableName() string {\n+\treturn \"account_balance\"\n+}\n+\n+// AccountRepository struct that has connection to the Database\n+type AccountRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewAccountRepository creates an instance of a TransactionRepository struct. Populates the transaction types and statuses on init\n+func NewAccountRepository(dbClient *gorm.DB) *AccountRepository {\n+\treturn &AccountRepository{\n+\t\tdbClient: dbClient,\n+\t}\n+}\n+\n+// RetrieveBalanceAtBlock returns the balance of the account at a given block (provided by consensusEnd timestamp).\n+// balance = balanceAtLatestBalanceSnapshot + balanceChangeBetweenSnapshotAndBlock\n+func (ar *AccountRepository) RetrieveBalanceAtBlock(addressStr string, consensusEnd int64) (*types.Amount, *rTypes.Error) {\n+\tacc, err := types.AccountFromString(addressStr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tentityID, err1 := acc.ComputeEncodedID()\n+\tif err1 != nil {\n+\t\treturn nil, errors.Errors[errors.InvalidAccount]\n+\t}\n+\n+\t// gets the most recent balance before block\n+\tab := &accountBalance{}\n+\tif ar.dbClient.\n+\t\tWhere(\"account_realm_num=? AND account_num=? AND consensus_timestamp <= ?\", int16(acc.RealmNum), int32(acc.EntityNum), consensusEnd).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8edd553140f10a6b2c2e457cb17eab309b00b0b4"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDAzODM0OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistence/addressbook/entry/entry.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMTo1NTo1MlrOHgOhOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMTo1NTo1MlrOHgOhOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1NDM2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tNodeId             *int64 `gorm:\"type:bigint\"`\n          \n          \n            \n            \tNodeId             int64 `gorm:\"type:bigint\"`", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r503554363", "createdAt": "2020-10-12T21:55:52Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistence/addressbook/entry/entry.go", "diffHunk": "@@ -0,0 +1,106 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package entry\n+\n+import (\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/jinzhu/gorm\"\n+\t\"log\"\n+)\n+\n+const (\n+\tlatestAddressBookEntries = `SELECT abe.* FROM address_book_entry AS abe\n+\t\t                        JOIN address_book AS ab\n+                                ON ab.start_consensus_timestamp = abe.consensus_timestamp\n+                                WHERE ab.end_consensus_timestamp IS NULL`\n+)\n+\n+const (\n+\ttableNameAddressBookEntry = \"address_book_entry\"\n+)\n+\n+type addressBookEntry struct {\n+\tId                 int32  `gorm:\"type:integer;primary_key\"`\n+\tConsensusTimestamp int64  `gorm:\"type:bigint\"`\n+\tIp                 string `gorm:\"size:128\"`\n+\tPort               int32  `gorm:\"type:integer\"`\n+\tMemo               string `gorm:\"size:128\"`\n+\tPublicKey          string `gorm:\"size:1024\"`\n+\tNodeId             *int64 `gorm:\"type:bigint\"`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec80a2ad205def99d1bacc8e6f45e756f4d4140"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDA5NjQ3OnYy", "diffSide": "RIGHT", "path": "hedera-mirror-rosetta/app/persistence/transaction/transaction.go", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjoyMTozNlrOHgPDgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjoyMTozNlrOHgPDgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU2MzEzNg==", "bodyText": "should combine the consensus timestamp range constraint into the DB query", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r503563136", "createdAt": "2020-10-12T22:21:36Z", "author": {"login": "xin-hedera"}, "path": "hedera-mirror-rosetta/app/persistence/transaction/transaction.go", "diffHunk": "@@ -0,0 +1,254 @@\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ *\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+package transaction\n+\n+import (\n+\t\"encoding/hex\"\n+\tdbTypes \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/persistence/common\"\n+\thexUtils \"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/hex\"\n+\t\"log\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\trTypes \"github.com/coinbase/rosetta-sdk-go/types\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/errors\"\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/tools/maphelper\"\n+\n+\t\"github.com/hashgraph/hedera-mirror-node/hedera-mirror-rosetta/app/domain/types\"\n+\t\"github.com/jinzhu/gorm\"\n+)\n+\n+const (\n+\twhereClauseBetweenConsensus         string = \"consensus_ns >= ? AND consensus_ns <= ?\"\n+\twhereTimestampsInConsensusTimestamp string = \"consensus_timestamp IN (?)\"\n+)\n+\n+type transaction struct {\n+\tConsensusNS          int64  `gorm:\"type:bigint;primary_key\"`\n+\tType                 int    `gorm:\"type:smallint\"`\n+\tResult               int    `gorm:\"type:smallint\"`\n+\tPayerAccountID       int64  `gorm:\"type:bigint\"`\n+\tValidStartNS         int64  `gorm:\"type:bigint\"`\n+\tValidDurationSeconds int64  `gorm:\"type:bigint\"`\n+\tNodeAccountID        int64  `gorm:\"type:bigint\"`\n+\tEntityID             int64  `gorm:\"type:bigint\"`\n+\tInitialBalance       int64  `gorm:\"type:bigint\"`\n+\tMaxFee               int64  `gorm:\"type:bigint\"`\n+\tChargedTxFee         int64  `gorm:\"type:bigint\"`\n+\tMemo                 []byte `gorm:\"type:bytea\"`\n+\tTransactionHash      []byte `gorm:\"type:bytea\"`\n+\tTransactionBytes     []byte `gorm:\"type:bytea\"`\n+}\n+\n+type transactionType struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tName    string `gorm:\"size:30\"`\n+}\n+\n+type transactionResult struct {\n+\tProtoID int    `gorm:\"type:integer;primary_key\"`\n+\tResult  string `gorm:\"size:100\"`\n+}\n+\n+// TableName - Set table name of the Transactions to be `record_file`\n+func (transaction) TableName() string {\n+\treturn \"transaction\"\n+}\n+\n+// TableName - Set table name of the Transaction Types to be `t_transaction_types`\n+func (transactionType) TableName() string {\n+\treturn \"t_transaction_types\"\n+}\n+\n+// TableName - Set table name of the Transaction Results to be `t_transaction_results`\n+func (transactionResult) TableName() string {\n+\treturn \"t_transaction_results\"\n+}\n+\n+func (t *transaction) getHashString() string {\n+\treturn hexUtils.SafeAddHexPrefix(hex.EncodeToString(t.TransactionHash))\n+}\n+\n+// TransactionRepository struct that has connection to the Database\n+type TransactionRepository struct {\n+\tdbClient *gorm.DB\n+}\n+\n+// NewTransactionRepository creates an instance of a TransactionRepository struct\n+func NewTransactionRepository(dbClient *gorm.DB) *TransactionRepository {\n+\treturn &TransactionRepository{dbClient: dbClient}\n+}\n+\n+// Types returns map of all Transaction Types\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Types() map[int]string {\n+\ttypesArray := tr.retrieveTransactionTypes()\n+\ttMap := make(map[int]string)\n+\tfor _, t := range typesArray {\n+\t\ttMap[t.ProtoID] = t.Name\n+\t}\n+\treturn tMap\n+}\n+\n+// Statuses returns map of all Transaction Results\n+// TODO implement cache instead of retrieving this everytime form DB\n+func (tr *TransactionRepository) Statuses() map[int]string {\n+\trArray := tr.retrieveTransactionResults()\n+\trMap := make(map[int]string)\n+\tfor _, s := range rArray {\n+\t\trMap[s.ProtoID] = s.Result\n+\t}\n+\treturn rMap\n+}\n+\n+func (tr *TransactionRepository) TypesAsArray() []string {\n+\treturn maphelper.GetStringValuesFromIntStringMap(tr.Types())\n+}\n+\n+// FindBetween retrieves all Transactions between the provided start and end timestamp\n+func (tr *TransactionRepository) FindBetween(start int64, end int64) ([]*types.Transaction, *rTypes.Error) {\n+\tif start > end {\n+\t\treturn nil, errors.Errors[errors.StartMustNotBeAfterEnd]\n+\t}\n+\tvar transactions []transaction\n+\ttr.dbClient.Where(whereClauseBetweenConsensus, start, end).Find(&transactions)\n+\n+\tsameHashMap := make(map[string][]transaction)\n+\tfor _, t := range transactions {\n+\t\th := t.getHashString()\n+\t\tsameHashMap[h] = append(sameHashMap[h], t)\n+\t}\n+\tres := make([]*types.Transaction, 0, len(sameHashMap))\n+\tfor _, sameHashTransactions := range sameHashMap {\n+\t\ttransaction, err := tr.constructTransaction(sameHashTransactions)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tres = append(res, transaction)\n+\t}\n+\treturn res, nil\n+}\n+\n+// FindByHashInBlock retrieves a transaction by Hash\n+func (tr *TransactionRepository) FindByHashInBlock(hashStr string, consensusStart int64, consensusEnd int64) (*types.Transaction, *rTypes.Error) {\n+\tvar transactions []transaction\n+\ttransactionHash, err := hex.DecodeString(hexUtils.SafeRemoveHexPrefix(hashStr))\n+\tif err != nil {\n+\t\treturn nil, errors.Errors[errors.InvalidTransactionIdentifier]\n+\t}\n+\ttr.dbClient.Where(&transaction{TransactionHash: transactionHash}).Find(&transactions)\n+\ttransactions = filterTransactionsForRange(transactions, consensusStart, consensusEnd)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec80a2ad205def99d1bacc8e6f45e756f4d4140"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDExNzI0OnYy", "diffSide": "RIGHT", "path": ".github/workflows/rosetta-validation.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjozMToyNVrOHgPPlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjozMToyNVrOHgPPlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU2NjIyOA==", "bodyText": "nit: setting startDate for 'DEMO' network is no longer needed, PR #1091 now sets startDate to EPOCH", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/984#discussion_r503566228", "createdAt": "2020-10-12T22:31:25Z", "author": {"login": "xin-hedera"}, "path": ".github/workflows/rosetta-validation.yml", "diffHunk": "@@ -0,0 +1,25 @@\n+name: Rosetta Validation\n+\n+on:\n+  - pull_request\n+\n+jobs:\n+  validate:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Override Mirror Node Importer StartDate\n+      uses: mikefarah/yq@3.4.0\n+      with:\n+        cmd: yq write -i application.yml hedera.mirror.importer.startDate 2019-10-11T00:00:00.000000Z", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec80a2ad205def99d1bacc8e6f45e756f4d4140"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1602, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}