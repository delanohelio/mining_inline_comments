{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0OTQ3NzAw", "number": 1340, "title": "Addressbook migration", "bodyText": "Detailed description:\nStreamline address book migration logic to increase code sharing, testing but also allow for migration of file_data -> address_book to occur on demand when needed.\n\nAdd a migrate() method to the AddressBookService interface\nMove migration logic from V1_28_1__Address_Book to AddressBookServiceImpl\nRemove V1_28_1__Address_Book in favor of on demand AddressBookServiceImpl.migrate()\nAdd a MirrorBaseJavaMigration abstract class to hold shared java migration logic. In this case add a skipMigrationVersion() that ensures migrations prior to baseline are not run. This is in anticipation of v2 db schemas where v1 should not be run\nUpdate V1_11_6__Missing_Entities  to extend MirrorBaseJavaMigration\nUpdate FileDataRepository w findAddressBooksInRange() which was original sql migration query\nUpdate AddressBookServiceImpl.getCurrent() to handle empty table case and call inner migration logic to bootstrap initial filesystem/classpath address book as well as bring in historic addressBooks\nUpdate AddressBookServiceImpl.update() to ensure address_book` table is populated prior to adding any new address books\nUpdate tests that allowed for no address book after calling getCurrent() or update() no initial address book given each test clears the results of migrations\n\nWhich issue(s) this PR fixes:\nFixes #\nSpecial notes for your reviewer:\nThis is fallout from comments on PR #1319 and also some desired improvements.\nI would like to get this in first to reduce foot print of above PR\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-12-09T06:42:35Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340", "merged": true, "mergeCommit": {"oid": "1a4a50745e61b41b54bf7e150b37bbc063b47d48"}, "closed": true, "closedAt": "2020-12-11T05:03:48Z", "author": {"login": "Nana-EC"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkXw9SAH2gAyNTM0OTQ3NzAwOmI5Mzg0M2IxYWNlNDUxNTg2ZDg2MGExNTgyM2MwYjFkYmVhMGQ3ODk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdk_2JKAFqTU0OTc4NjI4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b93843b1ace451586d860a15823c0b1dbea0d789", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/b93843b1ace451586d860a15823c0b1dbea0d789", "committedDate": "2020-12-09T05:19:48Z", "message": "Move AddressBook Migration Logic to AddresBookService\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b3c8b38afdb440d6be9a02c25d4fe87e0b26de5", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0b3c8b38afdb440d6be9a02c25d4fe87e0b26de5", "committedDate": "2020-12-09T06:31:46Z", "message": "Added tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/301311eec0205bdc6811defa7d8e7fa651418eff", "committedDate": "2020-12-09T07:30:51Z", "message": "Expand startupWithOtherNetwork test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6ee6783bfe6f52c2dd40359bf19a654f3226e39", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f6ee6783bfe6f52c2dd40359bf19a654f3226e39", "committedDate": "2020-12-09T18:13:51Z", "message": "Fix tests and clean up AddressBookServiceImpl migration flow\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NDI2MDcy", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#pullrequestreview-548426072", "createdAt": "2020-12-09T17:31:11Z", "commit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzozMToxMVrOICguoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzo0NDo1NFrOICha9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwNDI4OQ==", "bodyText": "q: Would it be better to just call getCurrent() here and utilize ADDRESS_BOOK_102_CACHE_NAME cache and share the code.\nThis would only ever get called for every 101 or 102 file transaction so it's a minimal impact on db calls.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539504289", "createdAt": "2020-12-09T17:31:11Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -82,6 +97,11 @@ public void update(FileData fileData) {\n             return;\n         }\n \n+        // ensure address_book table is populated with at least bootstrap addressBook prior to additions\n+        if (shouldMigrate()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxMTk2OA==", "bodyText": "move synchronized to getInitialAddressBookFileData() as the file is the resource we want to synchronize on", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539511968", "createdAt": "2020-12-09T17:39:44Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public synchronized void migrate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxMjY5OQ==", "bodyText": "Update this to call parse so there's no circular behavior here. Add byte size check", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539512699", "createdAt": "2020-12-09T17:40:45Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +303,89 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Check whether address book migration should be run based on if flag has been set and if table is empty\n+     *\n+     * @return Whether to run address book migration\n+     */\n+    private boolean shouldMigrate() {\n+        if (hasAddressBooks) {\n+            return false;\n+        }\n+\n+        hasAddressBooks = addressBookRepository.count() > 0;\n+        return !hasAddressBooks;\n+    }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table\n+     */\n+    private void parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000; //\n+        List<FileData> fileDataList = fileDataRepository\n+                .findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        while (!CollectionUtils.isEmpty(fileDataList)) {\n+            log.info(\"Retrieved {} file_data rows for address book processing\", fileDataList.size());\n+            fileDataList.forEach(fileData -> {\n+                // call normal address book file transaction parsing flow to parse and ingest address book contents\n+                update(fileData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxMzgyMA==", "bodyText": "Original order of steps was off.\nParser logic would add an item to the address_book prior to adding the file_data item.\nUpdate for correctness", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539513820", "createdAt": "2020-12-09T17:42:17Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImplTest.java", "diffHunk": "@@ -95,12 +109,16 @@ private static NodeAddressBook addressBook(int size) {\n         return builder.build();\n     }\n \n-    private void update(byte[] contents, long consensusTimeStamp, boolean is102) {\n+    private FileData store(byte[] contents, long consensusTimeStamp, boolean is102) {\n         EntityId entityId = is102 ? AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID :\n                 AddressBookServiceImpl.ADDRESS_BOOK_101_ENTITY_ID;\n         FileData fileData = new FileData(consensusTimeStamp, contents, entityId, TransactionTypeEnum.FILEUPDATE\n                 .getProtoId());\n-        fileDataRepository.save(fileData);\n+        return fileDataRepository.save(fileData);\n+    }\n+\n+    private void update(byte[] contents, long consensusTimeStamp, boolean is102) {\n+        FileData fileData = store(contents, consensusTimeStamp, is102);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxNTYzNw==", "bodyText": "Update by reverting back to using Bean for addressBookService and using a custom AddressBookService instance in the startupWithOtherNetwork() where it's needed", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539515637", "createdAt": "2020-12-09T17:44:54Z", "author": {"login": "Nana-EC"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImplTest.java", "diffHunk": "@@ -113,18 +131,34 @@ private void append(byte[] contents, long consensusTimeStamp, boolean is102) {\n         addressBookService.update(fileData);\n     }\n \n+    @BeforeAll\n+    static void setupAll() throws IOException {\n+        Path addressBookPath = ResourceUtils.getFile(\"classpath:addressbook/testnet\").toPath();\n+        initialAddressBookBytes = Files.readAllBytes(addressBookPath);\n+    }\n+\n     @BeforeEach\n     void setup() {\n-        mirrorProperties = new MirrorProperties();\n-        mirrorProperties.setDataPath(dataPath);\n+        addressBookService = new AddressBookServiceImpl(addressBookRepository, fileDataRepository, mirrorProperties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d89285c4a28e536483b7ea21b730d733444c4fb", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7d89285c4a28e536483b7ea21b730d733444c4fb", "committedDate": "2020-12-09T18:30:38Z", "message": "Cleaned up some comments and added startupWithOtherNetworkIncorrectInitialAddressBookPath test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NDUyNTQx", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#pullrequestreview-548452541", "createdAt": "2020-12-09T17:59:55Z", "commit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzo1OTo1NVrOICiEHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo1Nzo0OFrOICm0yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyNjE3Mg==", "bodyText": "This can fail if the schema changes and should be removed. The AddressBookService.migrate() always uses the latest schema but when this is ran with an older schema it can fail for the same reasons we don't use Repository classes in Java migrations. If we can remove the entire class and it doesn't break things for current deployments, that would be even better.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539526172", "createdAt": "2020-12-09T17:59:55Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_28_1__Address_Book.java", "diffHunk": "@@ -21,115 +21,32 @@\n  */\n \n import com.google.common.base.Stopwatch;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.List;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n import javax.inject.Named;\n-import javax.sql.DataSource;\n import lombok.extern.log4j.Log4j2;\n-import org.apache.commons.io.IOUtils;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n import org.flywaydb.core.api.migration.Context;\n import org.springframework.context.annotation.Lazy;\n-import org.springframework.core.io.ClassPathResource;\n-import org.springframework.core.io.Resource;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.util.CollectionUtils;\n \n-import com.hedera.mirror.importer.MirrorProperties;\n import com.hedera.mirror.importer.addressbook.AddressBookService;\n-import com.hedera.mirror.importer.addressbook.AddressBookServiceImpl;\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.FileData;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.util.EntityIdEndec;\n \n @Log4j2\n @Named\n-public class V1_28_1__Address_Book extends BaseJavaMigration {\n+public class V1_28_1__Address_Book extends MirrorBaseJavaMigration {\n     private final AddressBookService addressBookService;\n-    private final MirrorProperties mirrorProperties;\n-    private final DataSource dataSource;\n-    private final String FILE_DATA_SQL = \"select * from file_data where consensus_timestamp > ? and entity_id \" +\n-            \"in (101, 102) order by consensus_timestamp asc limit ?\";\n-    private JdbcTemplate jdbcTemplate;\n \n-    public V1_28_1__Address_Book(MirrorProperties mirrorProperties, @Lazy AddressBookService addressBookService,\n-                                 DataSource dataSource) {\n+    public V1_28_1__Address_Book(@Lazy AddressBookService addressBookService) {\n         this.addressBookService = addressBookService;\n-        this.mirrorProperties = mirrorProperties;\n-        this.dataSource = dataSource;\n     }\n \n     @Override\n-    public void migrate(Context context) throws Exception {\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n-        AtomicLong fileDataEntries = new AtomicLong(0);\n-        byte[] addressBookBytes;\n-\n-        // retrieve bootstrap address book from filesystem or classpath\n-        try {\n-            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n-            if (initialAddressBook != null) {\n-                addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n-                        initialAddressBook);\n-            } else {\n-                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                Resource resource = new ClassPathResource(resourcePath, getClass());\n-                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n-            }\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n-        }\n-\n-        FileData bootStrapFileData = new FileData(0L, addressBookBytes,\n-                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n-                TransactionTypeEnum.FILECREATE.getProtoId());\n-        addressBookService.update(bootStrapFileData);\n-        fileDataEntries.incrementAndGet();\n-\n-        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n-        int pageSize = 1000; // option to parameterize this\n-        List<FileData> fileDataList = getLatestFileData(currentConsensusTimestamp.get(), pageSize);\n-        while (!CollectionUtils.isEmpty(fileDataList)) {\n-            fileDataList.forEach(fileData -> {\n-                // call normal address book file transaction parsing flow to parse and ingest address book contents\n-                addressBookService.update(fileData);\n-                fileDataEntries.incrementAndGet();\n-                currentConsensusTimestamp.set(fileData.getConsensusTimestamp());\n-            });\n-\n-            fileDataList = getLatestFileData(currentConsensusTimestamp.get(), pageSize);\n+    public void migrate(Context context) {\n+        if (skipMigrationVersion(getVersion(), context.getConfiguration())) {\n+            return;\n         }\n-        log.info(\"Migration processed {} in {} ms\", fileDataEntries.get(), stopwatch.elapsed(TimeUnit.MILLISECONDS));\n-    }\n \n-    private List<FileData> getLatestFileData(long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve file_data rows after {} ns with page size {}\", consensusTimestamp, pageSize);\n-        List<FileData> fileDataList = jdbcTemplate.query(\n-                FILE_DATA_SQL,\n-                new Object[] {consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public FileData mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return new FileData(rs.getLong(\"consensus_timestamp\"),\n-                                rs.getBytes(\"file_data\"),\n-                                EntityIdEndec.decode(rs.getInt(\"entity_id\"), EntityTypeEnum.FILE),\n-                                rs.getInt(\"transaction_type\"));\n-                    }\n-                });\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        addressBookService.migrate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyODE4OA==", "bodyText": "It would be more encapsulated if the parent class implemented migrate(context) and contained this skip logic while child classes implement an abstract void doMigrate().", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539528188", "createdAt": "2020-12-09T18:02:48Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_11_6__Missing_Entities.java", "diffHunk": "@@ -54,14 +53,18 @@\n     // break it.\n     // Correct way is to not use repositories and construct manually: new JdbcTemplate(context.getConnection())\n     public V1_11_6__Missing_Entities(MirrorProperties mirrorProperties, @Lazy EntityRepository entityRepository,\n-            @Lazy JdbcOperations jdbcOperations) {\n+                                     @Lazy JdbcOperations jdbcOperations) {\n         this.mirrorProperties = mirrorProperties;\n         this.entityRepository = entityRepository;\n         this.jdbcOperations = jdbcOperations;\n     }\n \n     @Override\n     public void migrate(Context context) throws Exception {\n+        if (skipMigrationVersion(getVersion(), context.getConfiguration())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyOTc5NA==", "bodyText": "Don't think @Named has any effect here and can be removed.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539529794", "createdAt": "2020-12-09T18:05:14Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+\n+@Log4j2\n+@Named", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzMDUwOQ==", "bodyText": "Doesn't need to be public or in the interface due to my other comment.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539530509", "createdAt": "2020-12-09T18:06:19Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public synchronized void migrate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NzU0Ng==", "bodyText": "This whole migrate methods needs to be synchronized and it needs to recheck if the address book table is empty before continuing in case a race condition caused someone else to migrate after it checked the db but before it got the lock.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539557546", "createdAt": "2020-12-09T18:46:15Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public void migrate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6ee6783bfe6f52c2dd40359bf19a654f3226e39"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDg0MQ==", "bodyText": "I think it can actually just call migrate() directly (remove shouldMigrate()) with my request to add a db check inside migrate to solve a race condition. As you state, 101/102 files are extremely rare and a synchronized block is in comparison quite fast.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539560841", "createdAt": "2020-12-09T18:51:00Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -82,6 +97,11 @@ public void update(FileData fileData) {\n             return;\n         }\n \n+        // ensure address_book table is populated with at least bootstrap addressBook prior to additions\n+        if (shouldMigrate()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwNDI4OQ=="}, "originalCommit": {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5ODkxNQ==", "bodyText": "migrate() needs to be in a transaction to be functionally equivalent to the flyway approach. What's less clear if it's okay to put @Transactional on the public methods of this class and let it join outer transactions or it requires its own inner transaction via TransactionTemplate. I'm thinking the latter.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539598915", "createdAt": "2020-12-09T19:49:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public void migrate() {\n+        log.debug(\"Searching for address book on file system\");\n+        AddressBook addressBook = buildAddressBook(getInitialAddressBookFileData());\n+        addressBook = addressBookRepository.save(addressBook);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d89285c4a28e536483b7ea21b730d733444c4fb"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMTcwMg==", "bodyText": "Technically buildAddressBook() has the potential to return null. Why not reuse parse() method?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539601702", "createdAt": "2020-12-09T19:53:52Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public void migrate() {\n+        log.debug(\"Searching for address book on file system\");\n+        AddressBook addressBook = buildAddressBook(getInitialAddressBookFileData());\n+        addressBook = addressBookRepository.save(addressBook);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d89285c4a28e536483b7ea21b730d733444c4fb"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDE2OA==", "bodyText": "This method seems unnecessary. You've already retrieved all the data at some point inside the migrate() method. Just have it keep track of which is the latest and return that so the signature becomes:\nprivate synchronized AddressBook migrate() {\n...\n}", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539604168", "createdAt": "2020-12-09T19:57:48Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +303,92 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Check whether address book migration should be run based on if flag has been set and if table is empty\n+     *\n+     * @return Whether to run address book migration\n+     */\n+    private boolean shouldMigrate() {\n+        if (hasAddressBooks) {\n+            return false;\n+        }\n+\n+        hasAddressBooks = addressBookRepository.count() > 0;\n+        return !hasAddressBooks;\n+    }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private synchronized FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table\n+     */\n+    private void parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000; //\n+        List<FileData> fileDataList = fileDataRepository\n+                .findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        while (!CollectionUtils.isEmpty(fileDataList)) {\n+            log.info(\"Retrieved {} file_data rows for address book processing\", fileDataList.size());\n+            fileDataList.forEach(fileData -> {\n+                if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                    // call normal address book file transaction parsing flow to parse and ingest address book contents\n+                    parse(fileData);\n+                    fileDataEntries.incrementAndGet();\n+                }\n+\n+                currentConsensusTimestamp.set(fileData.getConsensusTimestamp());\n+            });\n+\n+            fileDataList = fileDataRepository.findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        }\n+\n+        log.info(\"Processed {} historic address books\", fileDataEntries.get());\n+    }\n+\n+    /**\n+     * Run address book migration logic and return the latest addressBook 102 object\n+     *\n+     * @param consensusTimestamp time stamp reference to get latest address book\n+     * @return\n+     */\n+    private AddressBook migrateAndRetrieveLatestAddressBook(long consensusTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d89285c4a28e536483b7ea21b730d733444c4fb"}, "originalPosition": 229}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cdffe7dde417a6ebbe7ce6d716995aa12bf11c1", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3cdffe7dde417a6ebbe7ce6d716995aa12bf11c1", "committedDate": "2020-12-09T22:12:11Z", "message": "Address feedback on reuse, migrations and fixed tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NjU3NDA0", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#pullrequestreview-548657404", "createdAt": "2020-12-09T22:13:29Z", "commit": {"oid": "7d89285c4a28e536483b7ea21b730d733444c4fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMjoxMzoyOVrOICr5fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMjoxMzoyOVrOICr5fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4NzI5Mw==", "bodyText": "Nit, unless there's supposed to be a comment here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int pageSize = 1000; //\n          \n          \n            \n                    int pageSize = 1000;", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539687293", "createdAt": "2020-12-09T22:13:29Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +303,92 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Check whether address book migration should be run based on if flag has been set and if table is empty\n+     *\n+     * @return Whether to run address book migration\n+     */\n+    private boolean shouldMigrate() {\n+        if (hasAddressBooks) {\n+            return false;\n+        }\n+\n+        hasAddressBooks = addressBookRepository.count() > 0;\n+        return !hasAddressBooks;\n+    }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private synchronized FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table\n+     */\n+    private void parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000; //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d89285c4a28e536483b7ea21b730d733444c4fb"}, "originalPosition": 202}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9576a37b9742dde55d5d70f8775320d011b4317f", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9576a37b9742dde55d5d70f8775320d011b4317f", "committedDate": "2020-12-09T22:21:07Z", "message": "Removed V1_28_1__Address_Book migration and tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "committedDate": "2020-12-09T22:39:59Z", "message": "Cleaned up a bit\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4ODgxODU5", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#pullrequestreview-548881859", "createdAt": "2020-12-10T06:14:29Z", "commit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNjoxNDoyOVrOIC3iwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNjoxNDoyOVrOIC3iwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg3ODA4MA==", "bodyText": "Is there any risk here of migrate() returning null?  I just see that findLatestAddressBook() is a more granular search than the one migrate() does.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539878080", "createdAt": "2020-12-10T06:14:29Z", "author": {"login": "ijungmann"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -95,9 +116,14 @@ public void update(FileData fileData) {\n     public AddressBook getCurrent() {\n         Instant now = Instant.now();\n         long consensusTimestamp = Utility.convertToNanosMax(now.getEpochSecond(), now.getNano());\n+\n+        // retrieve latest address book. If address_book is empty parse initial and historic address book files\n         return addressBookRepository\n                 .findLatestAddressBook(consensusTimestamp, ADDRESS_BOOK_102_ENTITY_ID.getId())\n-                .orElseThrow(() -> new IllegalStateException(\"No valid address book found in DB\"));\n+                .orElseGet(() -> {\n+                    log.debug(\"No address book found in db\");\n+                    return migrate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NDE3MjYw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#pullrequestreview-549417260", "createdAt": "2020-12-10T17:07:49Z", "commit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNzowNzo1MFrOIDT-Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNzoyODowMVrOIDU2Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM0MzgyNw==", "bodyText": "Log can be moved into migrate to produce a more accurate log for race condition and so you can shorten this to .orElseGet(this::migrate). It should also be changed to info log level. In fact, all logs inside migrate can be info (besides the skipping migration log) since it should only occur once and is very important we understand what is going on.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540343827", "createdAt": "2020-12-10T17:07:50Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -95,9 +116,14 @@ public void update(FileData fileData) {\n     public AddressBook getCurrent() {\n         Instant now = Instant.now();\n         long consensusTimestamp = Utility.convertToNanosMax(now.getEpochSecond(), now.getNano());\n+\n+        // retrieve latest address book. If address_book is empty parse initial and historic address book files\n         return addressBookRepository\n                 .findLatestAddressBook(consensusTimestamp, ADDRESS_BOOK_102_ENTITY_ID.getId())\n-                .orElseThrow(() -> new IllegalStateException(\"No valid address book found in DB\"));\n+                .orElseGet(() -> {\n+                    log.debug(\"No address book found in db\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM0ODA1OA==", "bodyText": "We should never return null. It will NPE during the race condition scenario. Instead of count(), can just call addressBookRepository.findLatestAddressBook(102) again like in getCurrent() and return it if not null. This is effectively double checked locking, so the same check should be done twice.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540348058", "createdAt": "2020-12-10T17:13:50Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,13 +137,39 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    /**\n+     * Migrates address book data by searching file_data table for applicable 101 and 102 files. These files are\n+     * converted to AddressBook objects and used to populate address_book and address_book_entry tables\n+     *\n+     * @return Latest AddressBook from historical files\n+     */\n+    private synchronized AddressBook migrate() {\n+        if (addressBookRepository.count() > 0) {\n+            if (log.isTraceEnabled()) {\n+                log.trace(\"Valid address books exist in db, skipping migration\");\n+            }\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MDIyNQ==", "bodyText": "This will log as MirrorBaseJavaMigration instead of the concrete class. Should remove @Log4j2 and use protected final Logger log = LogManager.getLogger(getClass()) instead. You can also remove the annotation from children classes.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540350225", "createdAt": "2020-12-10T17:16:49Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+@Log4j2\n+public abstract class MirrorBaseJavaMigration extends BaseJavaMigration {\n+\n+    public abstract void doMigrate() throws Exception;\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        MigrationVersion current = getVersion();\n+        if (skipMigrationVersion(current, context.getConfiguration())) {\n+            log.trace(\"Migration {} will be skipped as it precedes baseline version {}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MTM5OQ==", "bodyText": "protected", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540351399", "createdAt": "2020-12-10T17:18:27Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+@Log4j2\n+public abstract class MirrorBaseJavaMigration extends BaseJavaMigration {\n+\n+    public abstract void doMigrate() throws Exception;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1NTA2NQ==", "bodyText": "nit: If you just used a normal for loop you could avoid all the atomics. ForEach is useful to be concise, but due to the atomics it actually makes things more verbose in my opinion.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540355065", "createdAt": "2020-12-10T17:23:32Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +321,68 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table. Uses page size and\n+     * timestamp counters to batch query file data entries\n+     */\n+    private AddressBook parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+        AtomicReference<AddressBook> lastAddressBook = new AtomicReference<>();\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000;\n+        List<FileData> fileDataList = fileDataRepository\n+                .findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        while (!CollectionUtils.isEmpty(fileDataList)) {\n+            log.info(\"Retrieved {} file_data rows for address book processing\", fileDataList.size());\n+            fileDataList.forEach(fileData -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1NTcyMw==", "bodyText": "Codecov says Added lines #L374 - L375 were not covered by tests. Is that true? These seem like pretty important lines to test if so.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540355723", "createdAt": "2020-12-10T17:24:27Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +321,68 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table. Uses page size and\n+     * timestamp counters to batch query file data entries\n+     */\n+    private AddressBook parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+        AtomicReference<AddressBook> lastAddressBook = new AtomicReference<>();\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000;\n+        List<FileData> fileDataList = fileDataRepository\n+                .findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        while (!CollectionUtils.isEmpty(fileDataList)) {\n+            log.info(\"Retrieved {} file_data rows for address book processing\", fileDataList.size());\n+            fileDataList.forEach(fileData -> {\n+                if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                    // convert and ingest address book fileData contents\n+                    lastAddressBook.set(parse(fileData));\n+                    fileDataEntries.incrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1Njc1OA==", "bodyText": "Is it possible to get coverage for this? Even if it's a test of just the base class.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540356758", "createdAt": "2020-12-10T17:25:58Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+@Log4j2\n+public abstract class MirrorBaseJavaMigration extends BaseJavaMigration {\n+\n+    public abstract void doMigrate() throws Exception;\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        MigrationVersion current = getVersion();\n+        if (skipMigrationVersion(current, context.getConfiguration())) {\n+            log.trace(\"Migration {} will be skipped as it precedes baseline version {}\",\n+                    current,\n+                    context.getConfiguration().getBaselineVersion());\n+            return;\n+        }\n+\n+        doMigrate();\n+    }\n+\n+    /**\n+     * Determine whether a java migration should be skipped based on version and isIgnoreMissingMigrations setting\n+     *\n+     * @param current                The current java migration version\n+     * @param migrationConfiguration flyway Configuration\n+     * @return\n+     */\n+    private boolean skipMigrationVersion(MigrationVersion current, Configuration migrationConfiguration) {\n+        MigrationVersion baselineVersion = migrationConfiguration.getBaselineVersion();\n+        if (baselineVersion.isNewerThan(current.getVersion()) && migrationConfiguration.isIgnoreMissingMigrations()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODIzOQ==", "bodyText": "Why do we care about ignoreMissingMigrations here? Missing migrations is for files that have been deleted since they've been ran. I don't think that applies here. If you're baselining you're moving up the min version without regard for the presence of the migrations before that.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540358239", "createdAt": "2020-12-10T17:28:01Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+@Log4j2\n+public abstract class MirrorBaseJavaMigration extends BaseJavaMigration {\n+\n+    public abstract void doMigrate() throws Exception;\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        MigrationVersion current = getVersion();\n+        if (skipMigrationVersion(current, context.getConfiguration())) {\n+            log.trace(\"Migration {} will be skipped as it precedes baseline version {}\",\n+                    current,\n+                    context.getConfiguration().getBaselineVersion());\n+            return;\n+        }\n+\n+        doMigrate();\n+    }\n+\n+    /**\n+     * Determine whether a java migration should be skipped based on version and isIgnoreMissingMigrations setting\n+     *\n+     * @param current                The current java migration version\n+     * @param migrationConfiguration flyway Configuration\n+     * @return\n+     */\n+    private boolean skipMigrationVersion(MigrationVersion current, Configuration migrationConfiguration) {\n+        MigrationVersion baselineVersion = migrationConfiguration.getBaselineVersion();\n+        if (baselineVersion.isNewerThan(current.getVersion()) && migrationConfiguration.isIgnoreMissingMigrations()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9965c481e72057b18cc607c97d891cbb2db30e4", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f9965c481e72057b18cc607c97d891cbb2db30e4", "committedDate": "2020-12-10T21:25:25Z", "message": "Added and cleaned up tests and migration logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dc975a49211f7f0ea5a59bfc0404e7d245e332b", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5dc975a49211f7f0ea5a59bfc0404e7d245e332b", "committedDate": "2020-12-10T21:44:44Z", "message": "Removed code smell from MirrorBaseJavaMigration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b379797f31134382713f3a99fb5a2dcbf464795a", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/b379797f31134382713f3a99fb5a2dcbf464795a", "committedDate": "2020-12-10T22:42:04Z", "message": "Fixed fixable code smells\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07adc3c6377bb5dcfde1577b49e0423c67703838", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/07adc3c6377bb5dcfde1577b49e0423c67703838", "committedDate": "2020-12-10T22:43:59Z", "message": "Added SchemaMigrationException\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NjgwNzg3", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#pullrequestreview-549680787", "createdAt": "2020-12-10T23:01:40Z", "commit": {"oid": "07adc3c6377bb5dcfde1577b49e0423c67703838"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzowMTo0MVrOIDhXIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoxNDo0NlrOIDhz3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2MzIzNQ==", "bodyText": "This should test migrate's invocation of skipMigrationVersion both to ensure it's correctly invoked and provide coverage to that method.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540563235", "createdAt": "2020-12-10T23:01:41Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V0_0_1__MirrorBaseJavaMigrationTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.ClassicConfiguration;\n+import org.junit.jupiter.api.Test;\n+\n+// flyway requires class name conforms with naming convention\n+class V0_0_1__MirrorBaseJavaMigrationTest extends MirrorBaseJavaMigration {\n+    @Override\n+    public void doMigrate() {\n+        // do nothing\n+    }\n+\n+    @Test\n+    void verifySkipMigrationVersionCurrentEmpty() {\n+        assertThat(skipMigrationVersion(MigrationVersion.EMPTY, getConfiguration(\"1\", \"2\"))).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07adc3c6377bb5dcfde1577b49e0423c67703838"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2Mzg0Ng==", "bodyText": "Should just be named MirrorBaseJavaMigrationTest and not extend anything. You should create a custom private nested class to do the actual testing against.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540563846", "createdAt": "2020-12-10T23:02:20Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V0_0_1__MirrorBaseJavaMigrationTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.ClassicConfiguration;\n+import org.junit.jupiter.api.Test;\n+\n+// flyway requires class name conforms with naming convention\n+class V0_0_1__MirrorBaseJavaMigrationTest extends MirrorBaseJavaMigration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07adc3c6377bb5dcfde1577b49e0423c67703838"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2ODc0NA==", "bodyText": "You don't need to declare runtime exceptions (as Sonar also attests).", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540568744", "createdAt": "2020-12-10T23:10:41Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_11_6__Missing_Entities.java", "diffHunk": "@@ -54,14 +53,14 @@\n     // break it.\n     // Correct way is to not use repositories and construct manually: new JdbcTemplate(context.getConnection())\n     public V1_11_6__Missing_Entities(MirrorProperties mirrorProperties, @Lazy EntityRepository entityRepository,\n-            @Lazy JdbcOperations jdbcOperations) {\n+                                     @Lazy JdbcOperations jdbcOperations) {\n         this.mirrorProperties = mirrorProperties;\n         this.entityRepository = entityRepository;\n         this.jdbcOperations = jdbcOperations;\n     }\n \n     @Override\n-    public void migrate(Context context) throws Exception {\n+    public void doMigrate() throws SchemaMigrationException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07adc3c6377bb5dcfde1577b49e0423c67703838"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MDU5MA==", "bodyText": "These two debugs should be info since this is ran once per lifetime.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540570590", "createdAt": "2020-12-10T23:14:46Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,13 +132,50 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    /**\n+     * Migrates address book data by searching file_data table for applicable 101 and 102 files. These files are\n+     * converted to AddressBook objects and used to populate address_book and address_book_entry tables\n+     *\n+     * @return Latest AddressBook from historical files\n+     */\n+    private synchronized AddressBook migrate() {\n+        Instant now = Instant.now();\n+        long consensusTimestamp = Utility.convertToNanosMax(now.getEpochSecond(), now.getNano());\n+        AddressBook currentAddressBook = addressBookRepository\n+                .findLatestAddressBook(consensusTimestamp, ADDRESS_BOOK_102_ENTITY_ID.getId())\n+                .orElse(null);\n+\n+        if (currentAddressBook != null) {\n+            if (log.isTraceEnabled()) {\n+                log.trace(\"Valid address books exist in db, skipping migration\");\n+            }\n+            return currentAddressBook;\n+        }\n+\n+        log.debug(\"No address book found in db, proceeding with migration\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07adc3c6377bb5dcfde1577b49e0423c67703838"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f67c7b7e589287179e9fa162ee151b2b19219fda", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f67c7b7e589287179e9fa162ee151b2b19219fda", "committedDate": "2020-12-11T01:07:25Z", "message": "Improved MirrorBaseJavaMigrationTest coverage\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "570ca3d8677a020d91db156de89cb29ade5517cd", "author": {"user": {"login": "Nana-EC", "name": null}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/570ca3d8677a020d91db156de89cb29ade5517cd", "committedDate": "2020-12-11T01:33:48Z", "message": "Added migration caused by update call\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5Nzg2Mjg2", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#pullrequestreview-549786286", "createdAt": "2020-12-11T04:01:40Z", "commit": {"oid": "570ca3d8677a020d91db156de89cb29ade5517cd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3410, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}