{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MjIxNDgy", "number": 645, "title": "Add getEntityId() to Transaction Handler", "bodyText": "Detailed description:\n\nAddress followups from #638 and #639\nMoved transaction filtering to starting of RecordItemParser.onItem().\nMakes it easier to enforce the invariant - \"No state changes (db writes) if transaction is ignored\"\n\ngetEntityId() was violating it by writing entities before filtering. Corrected it.\n\n\nentity.proxyAccountId: If present, id is looked up using big cache.\nentity.autoRenewAccount: Changed to Long to follow same pattern\nas proxyAccountId i.e. look up id in big cache or create new one.\n\nUpdated affected tests in RecordItemParserTopicTest\n\n\nAdapt logic updating entities for easy cut-paste into TransacionHandlers in followup PRs\nAdded code comments to explain lot of non-obvious existing logic which was easy to\ntrip on and took decent amount of time to decipher\nReplaced 'createEntity(geEntity(xyz))' => 'lookupOrCreateId(EntityId.of(xyz))'.\nLatter has same caching advantage as above.\n\nSigned-off-by: Apekshit Sharma apekshit.sharma@hedera.com\nWhich issue(s) this PR fixes:\nPart of #571 . Needed to do #560 in right way, hence P1.\nSpecial notes for your reviewer:\nTests for Transaction Handlers will be in PR right after this.\nAfter that, there will be followup PRs for moving entity update logic to TransactionHandlers.\nChecklist\n\n Documentation added\n Tests updated", "createdAt": "2020-04-01T20:40:45Z", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645", "merged": true, "mergeCommit": {"oid": "e083768465fa433e0ebafaa0f27d5be0a51ca293"}, "closed": true, "closedAt": "2020-04-03T20:50:51Z", "author": {"login": "apeksharma"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTkIbhAH2gAyMzk3MjIxNDgyOmM0YmEyMDBiMDFmZGIxNTVlZTFkMmE4OWVjMWI4NjUxYzJiODQwNTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUHIxWgFqTM4NzU2ODE0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "committedDate": "2020-04-02T03:56:26Z", "message": "Add getEntityId() and getProxyAccountId() to Transaction Handler\n\n- Address followups from #638 and #639\n- In RecordItemParser, one invariant that should be followed is:\n  No repo writes before txn filter is run (reads okay).\n  - getEntityId() was violating it by writing entities before filtering. Corrected it.\n- getProxyAccountId() is called only after filtering\n- Adapt logic updating entities for easy cut-paste into TransacionHandlers in followup PRs\n- Added code comments to explain lot of non-obvious existing logic which was easy to\n  trip on and took decent amount of time to decipher\n- Changed entity.autoRenewAccount() logic from:\n    During entity update: Lookup/create new\n    If persisiting (after filtering): persist if new entity\n  To:\n    During entity update: create new\n    If persisting: lookup id/persist if new entity.\n  Benefits:\n  1. Essentially, entity id are not needed anywhere except when persisting,\n     so lookup can be delayed.\n  2. Earlier, EXPIRE_AFTER_30M cache was used for lookups. Its max size is 10k\n     (has to be lower since it contains full Entities objects).Now, the lookup\n    uses BIG_LRU_CACHE, max size of which is 100k (can be so big since it contains\n    EntityId objects)\n  There are tests in RecordItemParserTopicTest setting/updating autoRenewAccount\n  in various scenarios.\n- Replaced 'createEntity(geEntity(xyz))' => 'lookupOrCreateId(EntityId.of(xyz))'.\n  Latter has same caching advantage as above.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0e7b77390bce4f6c34d544f8fe33ddadc51cae94", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0e7b77390bce4f6c34d544f8fe33ddadc51cae94", "committedDate": "2020-04-01T20:37:26Z", "message": "Add getEntityId() and getProxyAccountId() to Transaction Handler\n\n- Address followups from #638 and #639\n- In RecordItemParser, one invariant that should be followed is:\n  No repo writes before txn filter is run (reads okay).\n  - getEntityId() was violating it by writing entities before filtering. Corrected it.\n- getProxyAccountId() is called only after filtering\n- Adapt logic updating entities for easy cut-paste into TransacionHandlers in followup PRs\n- Added code comments to explain lot of non-obvious existing logic which was easy to\n  trip on and took decent amount of time to decipher\n- Changed entity.autoRenewAccount() logic from:\n    During entity update: Lookup/create new\n    If persisiting (after filtering): persist if new entity\n  To:\n    During entity update: create new\n    If persisting: lookup id/persist if new entity.\n  Benefits:\n  1. Essentially, entity id are not needed anywhere except when persisting,\n     so lookup can be delayed.\n  2. Earlier, EXPIRE_AFTER_30M cache was used for lookups. Its max size is 10k\n     (has to be lower since it contains full Entities objects).Now, the lookup\n    uses BIG_LRU_CACHE, max size of which is 100k (can be so big since it contains\n    EntityId objects)\n  There are tests in RecordItemParserTopicTest setting/updating autoRenewAccount\n  in various scenarios.\n- Replaced 'createEntity(geEntity(xyz))' => 'lookupOrCreateId(EntityId.of(xyz))'.\n  Latter has same caching advantage as above.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}, "afterCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c4ba200b01fdb155ee1d2a89ec1b8651c2b84054", "committedDate": "2020-04-02T03:56:26Z", "message": "Add getEntityId() and getProxyAccountId() to Transaction Handler\n\n- Address followups from #638 and #639\n- In RecordItemParser, one invariant that should be followed is:\n  No repo writes before txn filter is run (reads okay).\n  - getEntityId() was violating it by writing entities before filtering. Corrected it.\n- getProxyAccountId() is called only after filtering\n- Adapt logic updating entities for easy cut-paste into TransacionHandlers in followup PRs\n- Added code comments to explain lot of non-obvious existing logic which was easy to\n  trip on and took decent amount of time to decipher\n- Changed entity.autoRenewAccount() logic from:\n    During entity update: Lookup/create new\n    If persisiting (after filtering): persist if new entity\n  To:\n    During entity update: create new\n    If persisting: lookup id/persist if new entity.\n  Benefits:\n  1. Essentially, entity id are not needed anywhere except when persisting,\n     so lookup can be delayed.\n  2. Earlier, EXPIRE_AFTER_30M cache was used for lookups. Its max size is 10k\n     (has to be lower since it contains full Entities objects).Now, the lookup\n    uses BIG_LRU_CACHE, max size of which is 100k (can be so big since it contains\n    EntityId objects)\n  There are tests in RecordItemParserTopicTest setting/updating autoRenewAccount\n  in various scenarios.\n- Replaced 'createEntity(geEntity(xyz))' => 'lookupOrCreateId(EntityId.of(xyz))'.\n  Latter has same caching advantage as above.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NjE5NTMw", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#pullrequestreview-386619530", "createdAt": "2020-04-02T16:59:08Z", "commit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjo1OTowOFrOF_0orA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxODoyOToxNVrOF_4LGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2Njk4OA==", "bodyText": "Should use type.getId() instead. Ordinal starts at 0, which is wrong. Not sure how your tests are passing.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402466988", "createdAt": "2020-04-02T16:59:08Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityId.java", "diffHunk": "@@ -20,13 +20,58 @@\n  * \u200d\n  */\n \n+import com.hederahashgraph.api.proto.java.AccountID;\n+import com.hederahashgraph.api.proto.java.ContractID;\n+import com.hederahashgraph.api.proto.java.FileID;\n+import com.hederahashgraph.api.proto.java.TopicID;\n import lombok.Value;\n \n+/**\n+ * Common encapsulation for accountID, fileID, contractID, and topicID.\n+ *\n+ * There is no valid entity in Hedera network with an id '0.0.0'. When AccountID/FileID/ContractID/TopicID are not set,\n+ * their values default to '0.0.0'. If such an unset (default) instance is used to create EntityId using one of the\n+ * of(..) functions, null is returned.\n+ */\n @Value\n public class EntityId {\n     private Long id;\n     private Long entityShard;\n     private Long entityRealm;\n     private Long entityNum;\n     private Integer entityTypeId;\n+\n+    public Entities toEntity() {\n+        Entities entity = new Entities();\n+        entity.setId(id);\n+        entity.setEntityShard(entityShard);\n+        entity.setEntityRealm(entityRealm);\n+        entity.setEntityNum(entityNum);\n+        entity.setEntityTypeId(entityTypeId);\n+        return entity;\n+    }\n+\n+    public static EntityId of(AccountID accountID) {\n+        return of(accountID.getShardNum(), accountID.getRealmNum(), accountID.getAccountNum(), EntityTypeEnum.ACCOUNT);\n+    }\n+\n+    public static EntityId of(ContractID contractID) {\n+        return of(contractID.getShardNum(), contractID.getRealmNum(), contractID.getContractNum(),\n+                EntityTypeEnum.CONTRACT);\n+    }\n+\n+    public static EntityId of(FileID fileID) {\n+        return of(fileID.getShardNum(), fileID.getRealmNum(), fileID.getFileNum(), EntityTypeEnum.FILE);\n+    }\n+\n+    public static EntityId of(TopicID topicID) {\n+        return of(topicID.getShardNum(), topicID.getRealmNum(), topicID.getTopicNum(), EntityTypeEnum.TOPIC);\n+    }\n+\n+    private static EntityId of(long entityShard, long entityRealm, long entityNum, EntityTypeEnum type) {\n+        if (entityNum == 0 && entityRealm == 0 && entityShard == 0) {\n+            return null;\n+        }\n+        return new EntityId(null, entityShard, entityRealm, entityNum, type.ordinal());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNjkwMw==", "bodyText": "I don't think this will work since EntityId will have a null id. JPA won't know to lookup by shard/realm/num. Also, this won't go through cache so will be slow.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402506903", "createdAt": "2020-04-02T17:58:17Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -455,28 +411,23 @@ private void addNonFeeTransferInserts(long consensusTimestamp, long realm, long\n     /**\n      * Store ConsensusCreateTopic transaction in the database.\n      *\n-     * @param body\n-     * @param transactionRecord\n-     * @return Entity ID of the newly created topic, or 0 if no topic was created\n-     * @throws SQLException\n      * @throws IllegalArgumentException\n      */\n-    private Entities storeConsensusCreateTopic(TransactionBody body,\n-                                               TransactionRecord transactionRecord) {\n+    private void consensusCreateTopicUpdateEntity(\n+            Entities entity, TransactionBody body, TransactionRecord transactionRecord) {\n         if (!body.hasConsensusCreateTopic()) {\n             throw new IllegalArgumentException(\"transaction is not a ConsensusCreateTopic\");\n         }\n \n         if (!transactionRecord.getReceipt().hasTopicID()) {\n-            return null;\n+            return;\n         }\n \n-        Entities entity = getEntity(transactionRecord.getReceipt().getTopicID());\n         var transactionBody = body.getConsensusCreateTopic();\n \n         if (transactionBody.hasAutoRenewAccount()) {\n-            Entities autoRenewAccount = getEntity(transactionBody.getAutoRenewAccount());\n-            entity.setAutoRenewAccount(autoRenewAccount);\n+            // Entity's id will be looked up/created lazily when its needed for persisting.\n+            entity.setAutoRenewAccount(EntityId.of(transactionBody.getAutoRenewAccount()).toEntity());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwNzY1OA==", "bodyText": "EntityId.id can be null as well since it's a primitive wrapper Long.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402507658", "createdAt": "2020-04-02T17:59:29Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -749,76 +659,28 @@ private void insertContractResults(\n                 new ContractResult(consensusTimestamp, functionParams, gasSupplied, callResult, gasUsed));\n     }\n \n-    public Entities getEntity(AccountID accountID) {\n-        return getEntity(accountID.getShardNum(), accountID.getRealmNum(), accountID.getAccountNum(), \"account\");\n-    }\n-\n-    public Entities getEntity(ContractID cid) {\n-        return getEntity(cid.getShardNum(), cid.getRealmNum(), cid.getContractNum(), \"contract\");\n-    }\n-\n-    public Entities getEntity(FileID fileId) {\n-        return getEntity(fileId.getShardNum(), fileId.getRealmNum(), fileId.getFileNum(), \"file\");\n-    }\n-\n-    public Entities getEntity(TopicID topicId) {\n-        return getEntity(topicId.getShardNum(), topicId.getRealmNum(), topicId.getTopicNum(), \"topic\");\n-    }\n-\n-    private Entities getEntity(long shardNum, long realmNum, long entityNum, String type) {\n-        return entityRepository.findByPrimaryKey(shardNum, realmNum, entityNum).orElseGet(() -> {\n-            Entities entity = new Entities();\n-            entity.setEntityNum(entityNum);\n-            entity.setEntityRealm(realmNum);\n-            entity.setEntityShard(shardNum);\n-            entity.setEntityTypeId(entityTypeRepository.findByName(type).map(EntityType::getId).get());\n-            return entity;\n-        });\n-    }\n-\n-    public EntityId getEntityId(AccountID accountID) {\n-        return getEntityId(accountID.getShardNum(), accountID.getRealmNum(), accountID.getAccountNum(), \"account\");\n-    }\n-\n-    public EntityId getEntityId(ContractID cid) {\n-        return getEntityId(cid.getShardNum(), cid.getRealmNum(), cid.getContractNum(), \"contract\");\n-    }\n-\n-    public EntityId getEntityId(FileID fileId) {\n-        return getEntityId(fileId.getShardNum(), fileId.getRealmNum(), fileId.getFileNum(), \"file\");\n-    }\n-\n-    public EntityId getEntityId(TopicID topicId) {\n-        return getEntityId(topicId.getShardNum(), topicId.getRealmNum(), topicId.getTopicNum(), \"topic\");\n-    }\n-\n-    private EntityId getEntityId(long shardNum, long realmNum, long entityNum, String type) {\n-        if (0 == entityNum) {\n+    private Entities getEntity(EntityId entityId) {\n+        if (entityId == null) {\n             return null;\n         }\n-        return entityRepository.findEntityIdByNativeIds(shardNum, realmNum, entityNum).orElseGet(() -> {\n-            Entities entityId = new Entities();\n-            entityId.setEntityShard(shardNum);\n-            entityId.setEntityRealm(realmNum);\n-            entityId.setEntityNum(entityNum);\n-            entityId.setEntityTypeId(entityTypeRepository.findByName(type).map(EntityType::getId).get());\n-            return entityRepository.saveAndCacheEntityId(entityId);\n-        });\n+        return entityRepository.findByPrimaryKey(\n+                entityId.getEntityShard(), entityId.getEntityRealm(), entityId.getEntityNum())\n+                .orElseGet(entityId::toEntity);\n     }\n \n-    private Entities createEntity(Entities entity) {\n-        if (entity != null && entity.getId() == null) {\n-            log.debug(\"Creating entity: {}\", () -> entity.getDisplayId());\n-            var result = entityRepository.save(entity);\n-            var entityId = new EntityId(result.getId(), result.getEntityShard(), result.getEntityRealm(),\n-                    result.getEntityNum(), result.getEntityTypeId());\n-            entityRepository.cache(entityId);\n-            return result;\n-        }\n-        return entity;\n-    }\n-\n-    public enum INIT_RESULT {\n-        OK, FAIL, SKIP\n+    /**\n+     * @param entityId containing shard, realm, num, and type for which the id needs to be looked up (from cache/repo).\n+     *                 If no id is found, the the entity is inserted into the repo and the newly minted id is returned.\n+     * @return looked up/newly minted id of the given entityId.\n+     */\n+    public long lookupOrCreateId(EntityId entityId) {\n+        log.debug(\"lookupOrCreateId for {}\", entityId);\n+        if (entityId.getId() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 580}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxNjgwMQ==", "bodyText": "This seems to be an oversight with the old code. Should we be extracting the payer account ID from the TransactionID?", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402516801", "createdAt": "2020-04-02T18:15:10Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoTransferTransactionHandler.java", "diffHunk": "@@ -20,10 +20,18 @@\n  * \u200d\n  */\n \n-import lombok.AllArgsConstructor;\n import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n \n @Named\n @AllArgsConstructor\n public class CryptoTransferTransactionHandler implements TransactionHandler {\n+\n+    @Override\n+    public EntityId getEntityId(RecordItem recordItem) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNDk1NQ==", "bodyText": "I think the id is actually always null based upon EntityId.of(), not 0. As a result, this won't work. It will always try to insert the entity thinking it's new but it may or may not exist. You need to lookup or create entity", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r402524955", "createdAt": "2020-04-02T18:29:15Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -335,12 +288,7 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n         tx.setChargedTxFee(txRecord.getTransactionFee());\n         tx.setConsensusNs(consensusNs);\n         if (entityId != null) {\n-            var tempEntity = new Entities();\n-            tempEntity.setId(entityId.getId());\n-            tempEntity.setEntityShard(entityId.getEntityShard());\n-            tempEntity.setEntityRealm(entityId.getEntityRealm());\n-            tempEntity.setEntityNum(entityId.getEntityNum());\n-            tx.setEntity(tempEntity);\n+            tx.setEntity(entityId.toEntity()); // entityId.id is always 0 here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4ba200b01fdb155ee1d2a89ec1b8651c2b84054"}, "originalPosition": 270}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c270e0d7508e4d95d46d8db5a2420dddd117fac6", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c270e0d7508e4d95d46d8db5a2420dddd117fac6", "committedDate": "2020-04-02T18:54:53Z", "message": "fix tests\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e3f1b804f351a291edb08b269fdecb19ef22a8a4", "committedDate": "2020-04-03T11:15:14Z", "message": "- Moved transaction filtering to starting of onItem().\n  Makes it easier to enforce the invariant -\n  \"No state changes (db writes) if transaction is ignored\"\n- entity.proxyAccountId: if present, looks up id using big cache.\n  Removed TransactionHandler.getProxyAccountId()\n- entity.autoRenewAccount: Changed to Long to follow same\n  pattern as proxyAccountId i.e. look up id in big cache or create\n  new one.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd4c3cbcf69a0e03d951d912e60d934a4365c790", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fd4c3cbcf69a0e03d951d912e60d934a4365c790", "committedDate": "2020-04-03T10:54:49Z", "message": "- Moved transaction filtering to starting of onItem().\n  Makes it easier to enforce the invariant -\n  \"No state changes (db writes) if transaction is ignored\"\n- entity.proxyAccountId: if present, looks up id using big cache.\n  Removed TransactionHandler.getProxyAccountId()\n- entity.autoRenewAccount: Changed to Long to follow same\n  pattern as proxyAccountId i.e. look up id in big cache or create\n  new one.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}, "afterCommit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e3f1b804f351a291edb08b269fdecb19ef22a8a4", "committedDate": "2020-04-03T11:15:14Z", "message": "- Moved transaction filtering to starting of onItem().\n  Makes it easier to enforce the invariant -\n  \"No state changes (db writes) if transaction is ignored\"\n- entity.proxyAccountId: if present, looks up id using big cache.\n  Removed TransactionHandler.getProxyAccountId()\n- entity.autoRenewAccount: Changed to Long to follow same\n  pattern as proxyAccountId i.e. look up id in big cache or create\n  new one.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDMzMzU4", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#pullrequestreview-387433358", "createdAt": "2020-04-03T17:07:13Z", "commit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDAzMDU4", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#pullrequestreview-387403058", "createdAt": "2020-04-03T16:23:45Z", "commit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNjoyMzo0NVrOGAczLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzoyNjo1N1rOGAfoAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyNTAzNw==", "bodyText": "This is a breaking change to people using the configuration property. Would prefer to keep it as before unless there's a need to change now.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403125037", "createdAt": "2020-04-03T16:23:45Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/CommonParserProperties.java", "diffHunk": "@@ -78,21 +81,21 @@\n         private Collection<String> entity = new LinkedHashSet<>();\n \n         @NotNull\n-        private Collection<TransactionTypeEnum> transaction = new LinkedHashSet<>();\n+        private Collection<TransactionTypeEnum> transactionType = new LinkedHashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE3MTMyOQ==", "bodyText": "Calling toString() on a protobuf produces some ugly output, which is why we have helper methods in Utility. However, I think just printing transactionType, entityId and consensusTimestamp would be enough here.", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#discussion_r403171329", "createdAt": "2020-04-03T17:26:57Z", "author": {"login": "steven-sheehy"}, "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -129,37 +126,53 @@ private static int getTransactionType(TransactionBody body) {\n     public void onItem(RecordItem recordItem) throws ImporterException {\n         TransactionRecord txRecord = recordItem.getRecord();\n         TransactionBody body = recordItem.getTransactionBody();\n-\n+        TransactionHandler transactionHandler = transactionHandlerFactory.create(body);\n         log.trace(\"Storing transaction body: {}\", () -> Utility.printProtoMessage(body));\n-        long initialBalance = 0;\n \n+        int transactionType = getTransactionType(body);\n+        EntityId entityId = transactionHandler.getEntityId(recordItem);\n+\n+        TransactionFilterFields transactionFilterFields =\n+                new TransactionFilterFields(entityId, TransactionTypeEnum.of(transactionType));\n+        if (!transactionFilter.test(transactionFilterFields)) {\n+            log.debug(\"Ignoring recordItem {}\", txRecord);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3f1b804f351a291edb08b269fdecb19ef22a8a4"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a35b507d3b68a3e4534fff28911df8ea2d9a8b21", "author": {"user": {"login": "apeksharma", "name": "Apekshit Sharma"}}, "url": "https://github.com/hashgraph/hedera-mirror-node/commit/a35b507d3b68a3e4534fff28911df8ea2d9a8b21", "committedDate": "2020-04-03T18:45:57Z", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTIyMDU5", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#pullrequestreview-387522059", "createdAt": "2020-04-03T19:23:41Z", "commit": {"oid": "a35b507d3b68a3e4534fff28911df8ea2d9a8b21"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTY4MTQz", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/645#pullrequestreview-387568143", "createdAt": "2020-04-03T20:43:29Z", "commit": {"oid": "a35b507d3b68a3e4534fff28911df8ea2d9a8b21"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3373, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}